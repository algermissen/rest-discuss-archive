{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":121832671,"authorName":"inthedarkplace","from":"&quot;inthedarkplace&quot; &lt;inthedarkplace@...&gt;","profile":"inthedarkplace","replyTo":"SENDER","senderId":"UTrIU1lb2JPoQcHfe_gQVIrJX1LOeMwmbrPbASNUowaIqpPoXFEZ5R-bexz6xvZgY87otAE555gSeSM7EEKRYOL1iBql43WRywBKR-8zxQ22hg","spamInfo":{"isSpam":false,"reason":"0"},"subject":"ROP vs RPC vs OOP pt 1","postDate":"1031025680","msgId":2330,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGFsMWM2Zytzb280QGVHcm91cHMuY29tPg==","inReplyToHeader":"PDAwMGIwMWMyNTJlOSQ5OGEyNWJmMCQ1MzM3YTg0MEBkZXV0c2NoODEwMD4="},"prevInTopic":2328,"nextInTopic":0,"prevInTime":2329,"nextInTime":2331,"topicId":2205,"numMessagesInTopic":64,"msgSnippet":"Toivo, I m sorry Toivo, I understand your confusion I think. It stems from the way the words state and stateful have been so hopelessly overloaded. In REST","rawEmail":"Return-Path: &lt;inthedarkplace@...&gt;\r\nX-Sender: inthedarkplace@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_1_0_1); 3 Sep 2002 04:01:22 -0000\r\nReceived: (qmail 69286 invoked from network); 3 Sep 2002 04:01:22 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m7.grp.scd.yahoo.com with QMQP; 3 Sep 2002 04:01:22 -0000\r\nReceived: from unknown (HELO n8.grp.scd.yahoo.com) (66.218.66.92)\n  by mta1.grp.scd.yahoo.com with SMTP; 3 Sep 2002 04:01:22 -0000\r\nReceived: from [66.218.67.187] by n8.grp.scd.yahoo.com with NNFMP; 03 Sep 2002 04:01:22 -0000\r\nDate: Tue, 03 Sep 2002 04:01:20 -0000\r\nTo: rest-discuss@yahoogroups.com\r\nSubject: ROP vs RPC vs OOP pt 1\r\nMessage-ID: &lt;al1c6g+soo4@...&gt;\r\nIn-Reply-To: &lt;000b01c252e9$98a25bf0$5337a840@deutsch8100&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 12426\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;inthedarkplace&quot; &lt;inthedarkplace@...&gt;\r\nX-Yahoo-Group-Post: member; u=121832671\r\nX-Yahoo-Profile: inthedarkplace\r\n\r\nToivo,\n\nI&#39;m sorry Toivo, I understand your confusion I think. It stems from \nthe way the words &#39;state&#39; and &#39;stateful&#39; have been so hopelessly \noverloaded.\n\nIn REST it is very clear what state means. You have resources located \nat URIs and performing a GET on these resources retrieves a \nrepresentation of their state. There is no analogy to SOAP. \n\nAs Paul hinted earlier, a SOAP service is nothing but a bunch of \nstatic methods being called through XML over HTTP. There is no \nfundamental notion of state. SOAP can maintain state through cookies \nand similar mechanisms but this is a poor substitute.\n\nWhy is this important?\n\nThis debate was originally about which methodology was more object \noriented. I was trying to demonstrate that REST is far more object \noriented than SOAP ever will be.\n\nHere are my thoughts on REST and Resource Oriented Programming. This \nemail is very long so don&#39;t read it if you&#39;re in a hurry :)\n\n1) Resources are objects. They expose methods (DoGet, DoPut, \nDoDelete, DoPost, DoOptions, and DoTrace) which define a behavior and \nthey possess a well-defined and meaningful state.\n\n2) Because all resources expose the same five methods polymorphism is \nimplicit. If you define a type of user and I want to retrieve \ninformation about your type of user I call GET url($User). If I want \nto update the representation of that user I call PUT url($User). If \nlater, Idecide to take your user resource type and extend it by \nadding fields then the API does not change. To read the new user \nsubclass you call GET. To update it, you call PUT.\n\n3) The five methods (discounting HEAD) exposed by HTTP can \ncollectively describe any given set of traditional OO methods. The \ntransformation from OO methods to HTTP methods can be automated to a \nlarge extent. Here is the general algorithm I use:\n    3.1) Retrieve all accessor methods from the object which are of \nthe form &#39;getXXX()&#39;. The set of all accessor methods can be described \nby the single HTTP GET method.\n    3.2) Retrieve all mutator methods from the object which are of \nthe form &#39;setXXX()&#39;. The set of all mutator methods can be described \nby the single HTTP PUT method.\n    3.3) If the object is a collection, search for all methods of the \nform &#39;Add(Object o)&#39;. Based on the result of 3.1 wrt to &#39;o&#39; for each \nadd method, then each method of the form Add(Object) can be described \nby the single HTTP POST method.\n    3.4) Repeat step 3.3, but instead searching for Remove(Object) \nmethods which will be mapped to corresponding HTTP DELETE methods.\n    3.5) All methods which ask a question about the state of the \nobject can be safely ignored. Eg methods of the form IsXXX. Instead, \nclients can simply retrieve the state of the object and perform \nqueries directly. Similarly, all methods which perform calculations \nbased on the state of the object (eg Circle.CalculateArea()) can be \nsafely ignored. Let the client perform calculations directly against \nthe state representation.\n    3.6) Examine all remaining methods. Any method which expresses \nbehavior must be decomposed into a resource transfer problem. The \nclassic example (that I continually encounter in my adventures in \nREST) is the ShoppingCart. In OOP-land, it is common to have a \nShoppingCart class which exposes a CheckOut method. In ROP-land, you \ncannot expose such a method. (You could using HTTP POST but you \nshouldn&#39;t). Instead, the behavior of the CheckOut method must be \nexpressed by creating a new Order resource and referring to the \nexisting ShoppingCart resource. Thus the ShoppingCart.CheckOut method \nis replaced by POSTing an OrderCollection resource to create a new \nOrderResource. This is just an example.\n\nThis last step, step 3.6, cannot be automated and it&#39;s what makes \ndesigning RESTful services so difficult IMO. Many developers do not \nwish to take the time to perform the decompisition of behavioral \nmethods so they simply expose them directly. This often leads to many \nproblems. But this is the crux of REST: decomposing an API into a \nresource manipulation problem and while I can&#39;t prove it, it&#39;s my \nbelief that all APIs can be completely decomposed into a resource \nmanipulation problem.\n\n(BTW, consider the SOAP equivalent to checking out a shopping cart. \nBecause there is no real object model, the client usually ends up \ncalling a method CheckOut and passing a UUID of some sort or a simple \nstruct. This is hardly OOP--at best it is akin to &quot;object-based&quot; C \nprogramming).\n\nYou wrote: &#39;With REST you can&#39;t just take any Java/C++/C# Object and \nturn it into an easily used network accessible &quot;thing&quot;.&#39;\n\nIn fact, this is exactly what I do. Given a User class I can generate \na UserResource class. Given a UserCollection class I can generate a \nUserCollectionResource. Eg...\n\nUser extends BusinessObject  ---&gt; UserResource extends HttpResource\n get/set Username                  void DoGet()\n get/set Email                     void DoPut()\n get/set Realname                  void DoDelete()\n                                   void DoOptions()\n\nThe tools exist if you&#39;re willing to write them.\n\n4) When constructing a restful webservice it is necessary to clearly \ndefine what types of resources will exist and what operations may be \nperformed upon these resources. This is done by examining the nouns \nin your problem domain and constructing resources that correspond to \nyour nouns. This is the process of object discovery--it is the same \nprocess performed when constructing traditional object oriented \nsolutions. This suggests there is indeed a strong relationship \nbetween resource oriented programming and object oriented \nprogramming. \n\n5) Now this is just a theory of mine and I need to explore it more, \nbut I suspect that what you call Resource Oriented Programming is \nakin to the logical completion of what has been traditionally called \nObject Oriented Programming. The &quot;goal&quot; of OOP is to encapsulate data \nand behavior into a single logical component. Components then \ninteract by passing messages back and forth. Encapsulation works \nbecause it allows complexity to be hidden (encapsulation is also \nknown as information hiding) and so clients only need to know about \nthe messages that go into and come out of a component and the state \nof that component. So this is the ***fundamental value proposition of \nencapsulation and OOP**: the amount of information a component A \nneeds to know about a component B is reduced to the set of B&#39;s \noperations (the verb&#39;s that can be carried out against B) and B&#39;s \nstate. \n\nNow let&#39;s return to ROP.\n\nThe &quot;essence&quot; of Resource Oriented Programming is to reduce the \nnumber of verbs in a system to a constant N (where N = 5 for HTTP) by \nintroducing many nouns. Agents in an ROP system interact by applying \nthese N verbs to this matrix of nouns. This is the **fundamental \nvalue propisition of REST**: the amount of information a component A \nneeds to know about a component A has been reduced to B&#39;s state (and \nthe XML vocabulary used to describe that state).\n\nIt is a well known fact that loose coupling is the holy grail of \nextremely complex (distributed) apps. The less two components know \nabout one another the better. Therefore I&#39;d like to say that ROP \nsupercedes OOP because it has significantly reduced the amount of \ninformation two components must know about one another by placing a \nlimit on the verbs a components can expose and requiring all \ncomponents to expose the same verbs. Therefore ROP-systems \n**increase** loose-coupling and encapsulation. I&#39;d even go so far as \nto say that a well-defined ROP-system can be more &quot;object-oriented&quot; \nthan the analagous OOP-system.\n\nAnybody who&#39;s ever built a large distributed app based on RPC and RMI \nshould be able to immediately appeaciate the super-encapsulation \nachieved by ROP. Remember the three most common problems with RPC/RMI:\n\n     1) Interface Fragility. Component A needs to add or remove a \nparameter to a method. When this happens, all components which depend \non Component A&#39;s interface must be updated to obtain its new \ninterface.\n\n     2) Inconsistency. (Unbounded Complexity). In RPC/RMI systems the \nsame logical operation can go by many different names. For example, \nComponent A might expose a Destroy() operation, Component B might \nexpose a Finalize() operation, and Component C might expose a Delete\n() operation. This makes it very difficult for these components to be \ntied together into a coherent solution by a virgin third party \nbecause the virgin third party must take time to understand and \nhandle the slightly different interfaces of each. This should be \npretty clear: as the number of components grow the number of verbs in \nthe system approach infinity and so it becomes impossible for \nnewcomers to understand all the verbs exposed by the system and \ntherefore understand what the system can do. This completely destroys \nwhat Sam Ruby calls &quot;Manufactured Serendipity.&quot;\n \n    (I really can&#39;t stress the phenomenon of Manufactured Serendipity \nenough. This is, I believe, the --point-- of the web. When you hide \ninformation behind SOAP endpoints that information might as well not \nbe there. When you assign URLs to information it becomes possible for \nvirgin thirdparties to use the system in ways you never dreamed of \nfor example Google can now index that information (since it has URL) \nand others can use tools like XInclude, XSLT, etc to manipulate that \ninformation).\n\n    3) Dynamic discovery. No matter what Microsoft et. al. may tell \nyou, true dynamic discovery is impossible with  RPC because every RPC \nservice exposes its own set of methods and it is impossible to know \nwhat these methods mean. There&#39;s no way a machine can look \nat &#39;RetrievePurchaseOrder(Long poID)&#39; and havy any clue what that --\nmeans--.\n\n    That&#39;s just off the top of my head but those are three main flaws \nI can think of when it comes to RPC/RMI system. Now look at each one \nand apply ROP. 1 and 2 disappears because you no longer have \nspecialized interfaces -- all components expose the same verbs. 3 \nkind of disappears because these universal verbs have a well-defined \nmeaning. If a machine knows that the resource located at \nhttp://host/purchase-orders/3424242 is a type of purchase order then \nit can infer that executing the GET method against that URL will \nretrieve a representation of that purchase order. In this case it&#39;s \nclear that the data backup problem becomes trivial to solve in \nRESTful services.\n\nToivo, hopefully at this point I&#39;ve convinced you somewhat why I \nthink ROP is far more object oriented than RPC and in fact may be \nmore object oriented than OOP (as if that makes any sense). Also I \ncan honestly say that it&#39;s been my experience that, given a well-\ndefined object model to a business app, it&#39;s easier for me to devise \na RESTful webservice than a SOAP webservice which exposes that object \nmodel.\n\n(continued in ROP vs RPC vs OOP pt 2)\n- itdp\n\n--- In rest-discuss@y..., &quot;Toivo &#92;&quot;Deutsch&#92;&quot; Lainevool&quot; \n&lt;tlainevool@n...&gt; wrote:\n&gt; Where do you get the idea that SOAP services are stateless?  I don&#39;t\n&gt; think there is any mention of state or statelessness in the SOAP \nspec.\n&gt; I think a SOAP service can be just as statefull as a REST \nresource.  Am\n&gt; I missing something here?\n&gt; \n&gt; I&#39;m also not sure what you mean by &quot;By definition [SOAP Services] \nare no\n&gt; objects&quot;.  I don&#39;t want to get argument about what an object is or\n&gt; isn&#39;t, but SOAP services are something you can use for doing object\n&gt; oriented decomposition of a problem, whether or not its stateless.\n&gt; \n&gt; Toivo\n&gt; \n&gt; &gt; -----Original Message-----\n&gt; &gt; From: inthedarkplace [mailto:inthedarkplace@y...]\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; With REST you can&#39;t just take any Java/C++/C# Object and turn \nit\n&gt; &gt; into an\n&gt; &gt; &gt; &gt; easily used network accessible &quot;thing&quot;.\n&gt; &gt; \n&gt; &gt; Actually you can and I do it all the time. I have automated tools\n&gt; &gt; which can automagically generate the REST code given an object&#39;s\n&gt; &gt; class. Also note that SOAP services are stateless. By definition \nthey\n&gt; &gt; are not objects. Resources have states and they expose methods\n&gt; &gt; (DoGet, DoPut, DoDelete, DoPost, DoTrace, DoOptions) which \nconstitute\n&gt; &gt; behavior. After having done a lot of SOAP and REST hacking it&#39;s\n&gt; &gt; evident to me and my team that REST is far more object oriented \nthan\n&gt; &gt; SOAP. In REST you work with real objects, in SOAP you&#39;re \nessentially\n&gt; &gt; working with a class that defines arbitrary static methods.\n\n\n"}}