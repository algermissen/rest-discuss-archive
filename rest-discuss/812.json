{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":22604463,"authorName":"Allan Doyle","from":"Allan Doyle &lt;adoyle@...&gt;","profile":"mit80eecs","replyTo":"SENDER","senderId":"KbPLz6UuLhZ6DRzsaoQBMmDZHAsxBXSjPWllmcah--BxLCFVbEbFdbBJG7fWlxjBxtXR1_6L6Wk8X2dRM9gkG7_soSr9JuNAVK6uOKI_uQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"PUT vs. POST","postDate":"1014845828","msgId":812,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDE1NDg1LjIwODY4LjYxMDAwMC42MDYzNDBAaW50bC1pbnRlcmZhY2VzLmNvbT4="},"prevInTopic":0,"nextInTopic":813,"prevInTime":811,"nextInTime":813,"topicId":812,"numMessagesInTopic":11,"msgSnippet":"This message concerns itself with the issue of PUT vs. POST for creating/updating resources. I m trying to get a handle on some rules of thumb for the time I","rawEmail":"Return-Path: &lt;adoyle@...&gt;\r\nX-Sender: adoyle@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: unknown); 27 Feb 2002 21:35:45 -0000\r\nReceived: (qmail 18414 invoked from network); 27 Feb 2002 21:35:44 -0000\r\nReceived: from unknown (216.115.97.171)\n  by m6.grp.snv.yahoo.com with QMQP; 27 Feb 2002 21:35:44 -0000\r\nReceived: from unknown (HELO mail.intl-interfaces.net) (66.92.76.203)\n  by mta3.grp.snv.yahoo.com with SMTP; 27 Feb 2002 21:35:44 -0000\r\nReceived: from next.intl-interfaces.net (ns.intl-interfaces.net [66.92.76.202])\n\tby mail.intl-interfaces.net (Postfix) with ESMTP id 3EA62100A1\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Wed, 27 Feb 2002 16:35:43 -0500 (EST)\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nMessage-ID: &lt;15485.20868.610000.606340@...&gt;\r\nDate: Wed, 27 Feb 2002 16:37:08 -0500\r\nTo: rest-discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nSubject: PUT vs. POST\r\nX-Mailer: VM 7.00 under Emacs 21.1.1\r\nFrom: Allan Doyle &lt;adoyle@...&gt;\r\nX-Yahoo-Group-Post: member; u=22604463\r\nX-Yahoo-Profile: mit80eecs\r\n\r\nThis message concerns itself with the issue of PUT vs. POST for\ncreating/updating resources. I&#39;m trying to get a handle on some rules\nof thumb for the time I want to actually apply REST...\n\nImage the resource identified as http://foo.org/bar\n\nCase 1. There is only a text/html representation and it&#39;s\n        static. There are no other representations. It&#39;s ok to PUT an\n        update to it. In fact you SHOULD or even MUST use PUT.\n\nCase 2. There are 3 representations that can be retrieved using\n        conneg: text/html, image/jpeg, or text/xml, and you somehow\n        know that the html and jpeg representations are actually\n        mapped from the xml representation. Let&#39;s call this the\n        &quot;ur-representation&quot;. Then you could conceivably PUT the xml\n        representation. But it would not be sufficient to PUT the\n        image or html representation since the underlying resource\n        would be unable to generate the other representations from\n        either the image or the html.\n\nCase 3. The client knows nothing about the resource&#39;s static nature nor about\n        its ur-representation. You can&#39;t PUT to it. You MUST use\n        POST. In fact, this kind of resource can&#39;t be created without\n        a &quot;Processing Block&quot; [1] which implies an already existing\n        resource.\n\nSo perhaps the rules or thumb (ROT) are:\n\nROT 1. &quot;To update/create a resource having only a single exposed\n        representation, your design MUST allow for PUT of the\n        ur-representation.&quot;\n\nROT 2. &quot;To update/create a resource having multiple exposed\n        representations, your design SHOULD allow for PUT of the\n        ur-representation&quot;\n\nHowever in case 2/rule 2 aren&#39;t we violating the implicit contract of\nPUT which is that there is no significant transformational process\ninvolved? RFC 2616 Section 9.6 [2] says\n\n  &quot;The PUT method requests that the enclosed entity be stored under\n  the supplied Request-URI.&quot;\n\nSo perhaps the conclusion really is that you can only PUT to a static\nresource that exposes only a single representation.\n\nInterestingly, 2616 leaves a back door open: \n\n  &quot;A single resource MAY be identified by many different URIs. For\n   example, an article might have a URI for identifying &quot;the current\n   version&quot; which is separate from the URI identifying each particular\n   version. In this case, a PUT request on a general URI might result\n   in several other URIs being defined by the origin server.&quot;\n\nI.e. the PUT could cause a &quot;shift&quot; of resource identifiers like\n&quot;http://foo.org/bar-current&quot; and/or the creation of identifiers like\n&quot;http://foo.org/bar-previous&quot;.  Then that implies that it&#39;s OK to have\na higher-order process do stuff in response to a PUT. That leaves me\nback at the stage where use of PUT or POST are equally defensible in\nCase 2.\n\nSome other material that might help with this conclusion seems only to\nkeep things as muddy:\n\nLet&#39;s look at something most people are probably familiar with by now,\nthe REST Wiki [3]. There have been discussions about how it would be\ngood to be able to apply REST to maintaing a Wiki [4].\n\nI read the arguments on that page about PUT vs. POST but am still left\nwith some vague uneasiness. It seems to me that the debate hinges on\nthe definition of resource and representation and on what I believe is\nambiguous treatment of the topic in Fielding&#39;s dissertation [5]. The\ncrux of the debate seems to be based on the fact that GET returns\nrepresentations and PUT was originally designed to create/replace\nrepresentations; but things like Wikis require a processing block\n(c.f. [1] - Section 3.) to stitch the new/changed page back into the\nWiki. Someone (it&#39;s a bit hard to follow attribution) on [4] states\n\n  &quot;The entity in the PUT request may be the response to a later GET\n  request, but if not, it is an alternate representation of the same\n  resource, which is the important thing from a REST POV&quot;\n\nBut that seems to me to sidestep the issue. Can updating/creating an\nalternate representation of a resource cause all other representations\nof that resource to change? Wishful thinking says &quot;yes&quot; because we\nwant the beneficial side-effect of PUTting a representation to a\nresource to include the cache invalidation of previous GETs from that\nresource.\n\nLets see what Fielding has to say. Fielding defines the term resource\nin [6]\n\n  &quot;More precisely, a resource R is a temporally varying membership\n  function MR(t), which for time t maps to a set of entities, or\n  values, which are equivalent. The values in the set may be resource\n  representations and/or resource identifiers.&quot;\n\nHe goes on to say\n\n  &quot;REST components perform actions on a resource by using a\n  representation to capture the current or intended state of that\n  resource and transferring that representation between components.&quot;\n\nThat sure does sound like PUTting &quot;intended state&quot; should affect the\nresource itself. Next he says\n\n  &quot;For example, remote authoring of a resource requires that the\n  author send a representation to the server, thus establishing a\n  value for that resource that can be retrieved by later requests. If\n  the value set of a resource at a given time consists of multiple\n  representations, content negotiation may be used to select the best\n  representation for inclusion in a given message.&quot;\n\nThis is all tantalizingly vague. He does not connect the dots between\nthe two sentences. I.e. what happens to the representation to affect\nthe resource and its subsequent exposed representations. And is\nfurther complicated by some statements near the end of section 5.4.\n\n  &quot;The interaction method of sending representations of resources to\n  consuming components has some parallels with event-based integration\n  (EBI) styles. The key difference is that EBI styles are push-based.&quot;\n\nThen he goes on to talk about how C2 &quot;could operate in REST&#39;s pull\nstyle&quot;. Is not a PUT of a representation a push? If so, then we&#39;re\nstill left wondering.\n\nMoving along to Section 6 [7] we find out that all the representations\nyou can GET from a web server do not suffice to recreate a\nresource. (He certainly does not talk about ur-resources.)\n\n  &quot;attempts to mirror the content of a Web server as files will fail\n  because the resource interface does not always match the semantics\n  of a file system, and because both data and metadata are included\n  within, and significant to, the semantics of a representation. Web\n  server content can be replicated at remote sites, but only by\n  replicating the entire server mechanism and configuration, or by\n  selectively replicating only those resources with representations\n  known to be static&quot;\n\nWhen he talks about caching in Section 6.3.3.2, we find out that maybe\nsomething can be PUT, but that representation cannot simply be picked\nup by an intermediary cache. The implication is that the cache should\nflag its content as invalid because\n\n &quot;An HTTP cache cannot assume that what gets written through it is the\n  same as what would be retrievable from a subsequent request for that\n  resource, and thus it cannot cache a PUT request body and reuse it\n  for a later GET response. There are two reasons for this rule: 1)\n  metadata might be generated behind-the-scenes, and 2) access control\n  on later GET requests cannot be determined from the PUT request.&quot;\n\nHe does not mention that alternate representations may be generated by\nthe PUT.\n\nI&#39;m also a bit curious about all the emphasis on cacheability. I\nunderstand the need for caching. I understand why GET should be\nidempotent. But given that we know nothing about the actual cache\ntopologies being deployed, it&#39;s a little hard to figure out how\neffectively a single PUT from a single client to a resource can\ninvalidate more than a fraction of the cached representations of that\nresource. It would seem more logical to me that caching services would\nhave to develop some additional handshaking to ensure timely cache\ncoherence. And I suspect that there are often caches from competing\ncache service providers in play. It&#39;s unlikely they will talk to each\nother as they see random &quot;PUT&quot;s flying by.\n\nSo the bottom line is that I&#39;m still at odds with when to PUT and when\nto POST, but I&#39;m leaning towards my rules of thumb above.\n\nThanks for listening...\n\n====\n[1] http://www.ietf.org/internet-drafts/draft-baker-http-resource-state-model-01.txt \n[2] http://www.ietf.org/rfc/rfc2616.txt?number=2616\n[3] http://internet.conveyor.com/RESTwiki/moin.cgi\n[4] http://internet.conveyor.com/RESTwiki/moin.cgi/HowWikiComparesToRest\n[5] http://www.ebuilt.com/fielding/pubs/dissertation/abstract.htm\n[6] http://www.ebuilt.com/fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2\n[7] http://www.ebuilt.com/fielding/pubs/dissertation/evaluation.htm\n\n-- \n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAllan Doyle                         http://www.intl-interfaces.com\nadoyle@...\n\n                                                   \n\n\n"}}