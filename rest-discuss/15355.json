{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":69164307,"authorName":"mike amundsen","from":"mike amundsen &lt;mamund@...&gt;","profile":"mamund","replyTo":"SENDER","senderId":"k1L4bnIA4IoWRnG9Cf1sVY9JCi7wM9_Yhr_h6rrdhhNYkNgtm6ttmkBAxnZWCHqRlS2X59ld0Lo41HErCPo0pAB74IJB3-I","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] RDF as IDL for M2M","postDate":"1273765589","msgId":15355,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEFBTkxrVGlud3VPM2JhTS13bnNJQWpVV2dkTjhQR0gwbUcxNEk2VXZPUDFDYUBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PDIwMTAwNTExMTEyNzExLmNjNTY4NGUxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PDIwMTAwNTExMTEyNzExLmNjNTY4NGUxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":15346,"nextInTopic":15440,"prevInTime":15353,"nextInTime":15356,"topicId":15346,"numMessagesInTopic":3,"msgSnippet":"Eric: 1) i like the idea of using link relations this way. 2) i m curious about your use of RDF here. are you using an existing vocab as your main RDF","rawEmail":"Return-Path: &lt;mca@...&gt;\r\nX-Sender: mca@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 30064 invoked from network); 13 May 2010 15:46:40 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m14.grp.re1.yahoo.com with QMQP; 13 May 2010 15:46:40 -0000\r\nX-Received: from unknown (HELO mail-ww0-f52.google.com) (74.125.82.52)\n  by mta1.grp.sp2.yahoo.com with SMTP; 13 May 2010 15:46:30 -0000\r\nX-Received: by wwb24 with SMTP id 24so986720wwb.25\n        for &lt;rest-discuss@yahoogroups.com&gt;; Thu, 13 May 2010 08:46:29 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.227.134.197 with SMTP id k5mr10741wbt.95.1273765589346; Thu, \n\t13 May 2010 08:46:29 -0700 (PDT)\r\nX-Received: by 10.216.29.72 with HTTP; Thu, 13 May 2010 08:46:29 -0700 (PDT)\r\nIn-Reply-To: &lt;20100511112711.cc5684e1.eric@...&gt;\r\nReferences: &lt;20100511112711.cc5684e1.eric@...&gt;\r\nDate: Thu, 13 May 2010 11:46:29 -0400\r\nX-Google-Sender-Auth: CSNUpQMb6JNsEr8M7vWQYhvBf88\r\nMessage-ID: &lt;AANLkTinwuO3baM-wnsIAjUWgdN8PGH0mG14I6UvOP1Ca@...&gt;\r\nTo: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: mike amundsen &lt;mamund@...&gt;\r\nSubject: Re: [rest-discuss] RDF as IDL for M2M\r\nX-Yahoo-Group-Post: member; u=69164307; y=72E11XifWUmsMcV-FiDXPUjoFwaHN1e8JHg-ZTUfNzJe\r\nX-Yahoo-Profile: mamund\r\n\r\nEric:\n\n1) i like the idea of using link relations this way.\n2) i&#39;m curious =\r\nabout your use of RDF here. are you using an existing\nvocab as your main RD=\r\nF serialization? have you defined a vocabulary\nexplicitly? using adhoc rdf:=\r\nDescription elements?\n3) are you using RDF as the &quot;base&quot; medium and transfo=\r\nrming that based\non conneg (XHTML, XFORMS, etc.)?\n\nIs any part of your work=\r\n available via open source? code? docs? etc.\n\nmca\nhttp://amundsen.com/blog/=\r\n\n\n\n\n\nOn Tue, May 11, 2010 at 13:27, Eric J. Bowman &lt;eric@...&gt; =\r\nwrote:\n&gt; Recent m2m discussions on rest-discuss have had me thinking quite\n=\r\n&gt; deeply about the problem. =A0For any given XHTML application steady-\n&gt; st=\r\nate on my REST system, regardless of the form language I am using,\n&gt; an XSL=\r\nT template may be developed which outputs the metadata as RDF\n&gt; (GRDDL). =\r\n=A0It occurs to me that, because my domain-specific vocabulary\n&gt; remains st=\r\natic across variant representations (generated on the user\n&gt; agent using Xf=\r\norms and/or XSLT), so does the XSLT pattern for GRDDL-\n&gt; generating RDF fro=\r\nm these variants.\n&gt;\n&gt; (You&#39;ll notice that my RESTful take on Semweb doesn&#39;t=\r\n assign URIs to\n&gt; RDF representations. =A0A limited number of XSLT GRDDL tr=\r\nansformations\n&gt; are assigned URIs and linked to from the application steady=\r\n-states.\n&gt; The idea is that RDF can describe an m2m starting point for any\n=\r\n&gt; function provided by a REST application, by linking to its machine-\n&gt; rea=\r\ndable hypertext interface using link relations. =A0This approach falls\n&gt; a =\r\nfew link relations shy of standardization, though.)\n&gt;\n&gt; I was surprised to =\r\ndiscover this. =A0I have lots of example/test files\n&gt; for my system, one is=\r\n a static-page WIP for the Xforms interface, with\n&gt; RDFa matching my demo (=\r\nexcept without syntax errors like @instance-of).\n&gt; Regardless of the specif=\r\nic markup, the metadata stays constant (well,\n&gt; not exactly, but it will wh=\r\nen I&#39;ve refactored a bit as a result of this\n&gt; research). =A0In fact, the R=\r\nDF pattern (the XSLT generating it) for my\n&gt; weblog, or for some other webl=\r\nog using my domain-specific vocabulary,\n&gt; regardless of its URI allocation =\r\nscheme, stays constant. =A0Here&#39;s that\n&gt; pattern again (I posted this sever=\r\nal weeks ago), somewhat:\n&gt;\n&gt; &lt;rdf:Description about=3D&quot;#{//*[@instanceof=3D=\r\n&#39;wiski:weblog-entry&#39;]/@id}&quot;&gt;\n&gt; &lt;link rel=3D&#39;self&#39; href=3D&#39;{./@about}.atom&#39;\n=\r\n&gt; &lt;link rel=3D&#39;edit&#39; href=3D\n&gt; &quot;{document(concat(./@about,&#39;.atom&#39;))//*[@rel=\r\n=3D&#39;edit&#39;]/@href}&quot;/&gt;\n&gt; &lt;link rel=3D&#39;replies&#39; href=3D\n&gt; &quot;{document(concat(./=\r\n@about,&#39;.atom&#39;))//*[@rel=3D&#39;replies&#39;]/@href}&quot;/&gt;\n&gt; &lt;link rel=3D&#39;alternate&#39; h=\r\nref=3D&#39;{./@about}&#39;/&gt;\n&gt; &lt;link rel=3D&#39;etc&#39; href=3D&#39;{etc.}&#39;/&gt;\n&gt; &lt;/rdf:Descript=\r\nion&gt;\n&gt;\n&gt; The post-new-entry form, if present, is always:\n&gt; //*[@instanceof=\r\n=3D&#39;wiski:weblog-entry&#39;][1]\n&gt; While a post-new-comment form, if present, is=\r\n always:\n&gt; //*[@instanceof=3D&#39;wiski:weblog-comment&#39;][1]\n&gt;\n&gt; So, having an u=\r\nnderstanding of the domain-specific vocabulary expressed\n&gt; as RDFa metadata=\r\n on my weblog, allows a spambot to be programmed to\n&gt; follow the API from s=\r\ntarting points in the RDF, i.e. the spambot needs\n&gt; to know how to post a r=\r\neply to a collection, so it looks in the RDF for\n&gt; rel=3D&#39;replies&#39;, which i=\r\nnforms the bot where to look in the steady-state\n&gt; it generated, to find th=\r\ne interface for posting a reply to any entry or\n&gt; comment it encounters.\n&gt;\n=\r\n&gt; So it makes sense to provide m2m capability using Semweb (kinda the\n&gt; who=\r\nle point) technology, based on standard link relations to make it\n&gt; RESTful=\r\n. =A0Given the m2m purpose of Semweb, it makes sense to use\n&gt; fragments, an=\r\nd link explicitly to form controls in the generated RDF.\n&gt;\n&gt; This requires =\r\na worldview that allows link relation semantics to vary\n&gt; based on context =\r\n-- if the intent is to view a comment thread, rel=3D\n&gt; &#39;replies&#39; points to =\r\nthe comment thread, whereas if the intent is to\n&gt; post a comment (via RDF i=\r\nntrospection) then rel=3D&#39;replies&#39; points to a\n&gt; form control.\n&gt;\n&gt; Taking a=\r\nn OO perspective, link relations may identify properties or\n&gt; methods, depe=\r\nnding on the context in which they appear -- if a user\n&gt; agent wants the re=\r\nl=3D&#39;replies&#39; method, it looks in the RDF, if it wants\n&gt; the rel=3D&#39;replies=\r\n&#39; property it looks in the steady-state. =A0Like so:\n&gt;\n&gt; &lt;rdf:Description a=\r\nbout=3D&#39;#post-1&#39;&gt;&lt;!--object in steady state--&gt;\n&gt; &lt;link rel=3D&#39;source&#39; href=\r\n=3D&#39;/2006/aug/09/11.atom&#39;/&gt;&lt;!--property--&gt;\n&gt; &lt;link rel=3D&#39;edit&#39; href=3D&#39;#po=\r\nst-1.edit&#39;/&gt;&lt;!--method--&gt;\n&gt; &lt;link rel=3D&#39;replies&#39; href=3D&#39;/2006/aug/09/11#c=\r\nomment-0.edit&#39;/&gt;&lt;!--method--&gt;\n&gt; &lt;link rel=3D&#39;self&#39; href=3D&#39;/2006/aug/09/11&#39;=\r\n/&gt;&lt;!--property--&gt;\n&gt; &lt;!--nonexistent link relation would be a property in th=\r\ne steady state--&gt;\n&gt; &lt;link rel=3D&#39;tags&#39; href=3D&#39;#tags-1.edit&#39;/&gt;&lt;!--method--&gt;=\r\n\n&gt; &lt;/rdf:Description&gt;\n&gt;\n&gt; In a threaded-comment architecture, each comment =\r\nhas its own unique\n&gt; rel=3D&#39;replies&#39; URI, whereas in my flat-comment archit=\r\necture, each comment\n&gt; shares the same rel=3D&#39;replies&#39; URI. =A0If the m2m g=\r\noal is to reply to\n&gt; a comment instead of an entry, the RDF link for rel=3D=\r\n&#39;replies&#39; for the\n&gt; //*[@instanceof=3D&#39;wiski:weblog-comment&#39;] of interest i=\r\ns followed, not\n&gt; the rel=3D&#39;replies&#39; link in the steady-state (which doesn=\r\n&#39;t point to the\n&gt; form control).\n&gt;\n&gt; When my architecture is extended to su=\r\npport threaded comments, it isn&#39;t\n&gt; the m2m intent that will change -- only=\r\n the target URI will change. The\n&gt; XSLT pattern doesn&#39;t change, it&#39;s still =\r\nreading in the same &lt;form&gt;\n&gt; field with the same method with the same media=\r\n type, but the RDF output\n&gt; from GRDDL reflects the new, unique target URIs=\r\n for each comment&#39;s rel=3D\n&gt; &#39;replies&#39;. =A0Until a comment is made, there i=\r\ns no rel=3D&#39;replies&#39; in the\n&gt; steady-state, only in the RDF.\n&gt;\n&gt; Spambots c=\r\noded against my GRDDL output automatically follow the new API,\n&gt; because th=\r\ne RDF is defining a... &gt;gasp&lt; ...contract to follow for\n&gt; introspecting the=\r\n rel=3D&#39;replies&#39; interface, regardless of how the markup\n&gt; (or even method,=\r\n say I change to PUT instead of tunneling over POST\n&gt; when a firewall rule =\r\nis relaxed) evolves over time. =A0I&#39;m guaranteeing a\n&gt; metadata vocabulary =\r\nwhich describes my interfaces, not any particular\n&gt; interface description.\n=\r\n&gt;\n&gt; In other words, the Semantic Web provides a Framework for Describing\n&gt; =\r\nResources (duh). =A0In the case of my weblog, the manipulable resources\n&gt; a=\r\nre all represented as Atom, but *how* to manipulate resource state is\n&gt; con=\r\ntained within XHTML application steady-states. =A0An RDF view of a\n&gt; steady=\r\n-state is just a framework for exposing the resources of interest\n&gt; making =\r\nup that steady-state, and their interfaces -- in the OO view of\n&gt; it, each =\r\nrdf:Description element identifies an object of interest in the\n&gt; markup, w=\r\nhile the child elements describe its properties and methods.\n&gt;\n&gt; This is wh=\r\nere RDF differs from an Interface Definition Language. =A0The\n&gt; properties =\r\nand methods I&#39;m referring to aren&#39;t HTTP methods as in IDLs,\n&gt; rather stand=\r\nard link relations and specific application functions. =A0The\n&gt; XSLT GRDDL =\r\npattern above merely *points to* a given object&#39;s hypertext-\n&gt; embedded pro=\r\nperty and method definitions. =A0It&#39;s a framework, and a nice\n&gt; m2m entry p=\r\noint... this is about the first time the terms &quot;Semweb&quot; and\n&gt; &quot;RDF&quot; haven&#39;t=\r\n elicited shoulder-shrugs from me as regards my own\n&gt; system. =A0I&#39;d only b=\r\neen halfheartedly using RDFa without really grokking\n&gt; the point of it.\n&gt;\n&gt;=\r\n So the form control for commenting on #post-1 is located at its rel=3Dself=\r\n\n&gt; URI&#39;s #comment-0.edit, which will contain method, target and media type\n=\r\n&gt; instructions... very useful knowledge for a spambot to glean, once it\n&gt; k=\r\nnows where to look, provided by a rel=3D&#39;replies&#39; that&#39;s only present in\n&gt; =\r\nthe RDF -- the steady-state would just give a link to the comment\n&gt; thread,=\r\n if it even has rel=3D&#39;replies&#39;, whereas the RDF links to the\n&gt; comment thr=\r\nead&#39;s post-reply control.\n&gt;\n&gt; My application&#39;s &quot;edit method&quot; points at eith=\r\ner an HTML &lt;fieldset&gt; or an\n&gt; Xforms &lt;group&gt; containing form fields for tit=\r\nle, slug header, content,\n&gt; draft, tags and submission. =A0My Xforms interf=\r\nace looks somewhat like:\n&gt; &lt;xfm:group id=3D&#39;post-1.edit&gt;...&lt;xfm:send submis=\r\nsion=3D&#39;post-1.save&#39;/&gt;\n&gt; &lt;/xfm:trigger&gt;&lt;/xfm:group&gt;. =A0The xfm:send is ref=\r\nerencing the Xforms\n&gt; model in the &lt;head&gt;, or perhaps the RDFa could link t=\r\no #post-1.save...\n&gt;\n&gt; Here&#39;s the very incomplete gist of it (I&#39;ve worked ou=\r\nt the document\n&gt; structure, now I&#39;m working on the submissions so I can cod=\r\ne the system\n&gt; to handle them):\n&gt;\n&gt; &lt;xfm:model&gt;\n&gt; ...\n&gt; &lt;xfm:submission id=\r\n=3D&#39;post-1.save&#39; ref=3D&quot;instance(&#39;post-1.src&#39;)&quot; method=3D\n&gt; &#39;put&#39; validate=\r\n=3D&#39;false&#39; serialization=3D&#39;application/atom+xml; type=3Dentry&#39;&gt;\n&gt; &lt;!-- xfm=\r\n:repeat logic may be used instead of static values --&gt;\n&gt; &lt;xfm:resource&gt;/200=\r\n6/aug/09/11.atom.draft&lt;/xfm:resource&gt;\n&gt; &lt;!-- if app:draft (in the xfm:model=\r\n) =3D true() then previous line, else\n&gt; &lt;xfm:resource&gt;/2006/aug/09/11.atom&lt;=\r\n/xfm:resource&gt;\n&gt; &lt;xfm:header&gt;&lt;!-- todo: make this header optional --&gt;\n&gt; =A0=\r\n&lt;xfm:name&gt;slug&lt;/xfm:name&gt;\n&gt; =A0&lt;xfm:value&gt;&lt;!-- $post-1-slug --&gt;&lt;/xfm:value&gt;=\r\n\n&gt; &lt;/xfm:header&gt;\n&gt; &lt;xfm:header&gt;\n&gt; =A0&lt;xfm:name&gt;If-Match&lt;/xfm:name&gt;\n&gt; =A0&lt;xf=\r\nm:value&gt;&lt;!-- $post-1-etag --&gt;&lt;/xfm:value&gt;\n&gt; &lt;/xfm:header&gt;\n&gt; &lt;/xfm:submissio=\r\nn&gt;\n&gt; ...\n&gt; &lt;/xfm:model&gt;\n&gt;\n&gt; See why I like Xforms? =A0The model instructs t=\r\nhe user agent *how* to\n&gt; conditionally submit entries, comments and edits b=\r\ny following its nose.\n&gt; Now, that&#39;s what I call a self-documenting API. =A0=\r\nThe target URI can&#39;t be\n&gt; known until the parameters of the request for the=\r\n &quot;edit post&quot; state\n&gt; transition are known (due to whether or not it&#39;s a dra=\r\nft, *.draft is not\n&gt; world-readable on my system), which is why rel=3D&#39;edit=\r\n&#39; in the RDF points\n&gt; to a self-documenting interface instead of a source d=\r\nocument -- it&#39;s a\n&gt; method, not a property, in OO-speak (and in terms of m2=\r\nm intent).\n&gt;\n&gt; The referenced form fields for editing tags has buttons for =\r\napply,\n&gt; remove, reset and commit. =A0Following the commit button (or when =\r\ndraft\n&gt; is toggled to false) leads to the xfm:model for the application\n&gt; f=\r\nunction, which gives instructions for target URI, method (PATCH) and\n&gt; medi=\r\na type (application/atomcat+xml).\n&gt;\n&gt; If &#39;tags&#39; were an understood link rel=\r\nation, pointing it to a &lt;ul&gt; would\n&gt; indicate non-editable, whereas pointin=\r\ng it to an element within a form\n&gt; would indicate otherwise. =A0This way, u=\r\nser agents are instructed where\n&gt; to look for the interface for a task, all=\r\nowing that interface to evolve.\n&gt; Initially, I&#39;ll implement tags as part of=\r\n the POST or PUT for creating\n&gt; or editing, only later will it be a standal=\r\none PATCH function.\n&gt;\n&gt; The link in the RDF stays the same (points to the t=\r\nag-editing control),\n&gt; but the hypertext will indicate a different method o=\r\nver time. =A0So the\n&gt; contract specifies where to look for the URI, method =\r\nand media type.\n&gt; Not what the URI, method or media type should be.\n&gt;\n&gt; Use=\r\nrs who lack privilege to do a certain operation will get different\n&gt; target=\r\n URIs in the RDF GRDDL output. =A0For example, if you can&#39;t change\n&gt; a post=\r\n&#39;s tags, then the link points to #post-1.tags not #tags-1.edit.\n&gt; I suppose=\r\n it&#39;s a drawback that the RDF isn&#39;t explicit about editability,\n&gt; but it is=\r\nn&#39;t difficult to check the self-or-parent axis for form\n&gt; elements, either.=\r\n =A0Or look for an Accept response header.\n&gt;\n&gt; Anyway, just thought I&#39;d sha=\r\nre the idea of using link relations to\n&gt; identify m2m goals inside RDF docu=\r\nments, linking directly to API\n&gt; controls using fragments, instead of linki=\r\nng to source documents.\n&gt;\n&gt; -Eric\n&gt;\n&gt;\n&gt; -----------------------------------=\r\n-\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n\n"}}