{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":221173245,"authorName":"Andrew Wahbe","from":"Andrew Wahbe &lt;andrew.wahbe@...&gt;","profile":"wahbedahbe","replyTo":"SENDER","senderId":"hdcVpVzk8qCnUsK61AuvGwhe5f9Bpo1nrCa9ngnoEF4rK5bmRQNz67SY4peJ6K3MEWq1tvJ4hWNJJBoHqsEQ_RxRje8PCdC6N5gFiA","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: about rel and HATEOAS (theoretical question)","postDate":"1263441947","msgId":14544,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGIwZWJhZmQxMTAwMTEzMjAwNW40NTVjMTVlN3ljYjcwNGE4YzBjYWI3Nzg1QG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PEZBMThCNTUwLTdFNEUtNDZFMi04ODBDLTgwQ0ZDNzkxRDFFOUBtYWMuY29tPg==","referencesHeader":"PGhpbGNwdCt1MnJrQGVHcm91cHMuY29tPgkgPEZBMThCNTUwLTdFNEUtNDZFMi04ODBDLTgwQ0ZDNzkxRDFFOUBtYWMuY29tPg=="},"prevInTopic":14543,"nextInTopic":14545,"prevInTime":14543,"nextInTime":14545,"topicId":14499,"numMessagesInTopic":68,"msgSnippet":"... argue that the domain protocol supported by the service is the media type and rel definitions. Is that your view? ... That way doesn t seem to match the","rawEmail":"Return-Path: &lt;andrew.wahbe@...&gt;\r\nX-Sender: andrew.wahbe@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 50140 invoked from network); 14 Jan 2010 04:05:49 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m2.grp.sp2.yahoo.com with QMQP; 14 Jan 2010 04:05:49 -0000\r\nX-Received: from unknown (HELO mail-ew0-f219.google.com) (209.85.219.219)\n  by mta1.grp.sp2.yahoo.com with SMTP; 14 Jan 2010 04:05:48 -0000\r\nX-Received: by ewy19 with SMTP id 19so17727759ewy.1\n        for &lt;rest-discuss@yahoogroups.com&gt;; Wed, 13 Jan 2010 20:05:47 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.216.91.84 with SMTP id g62mr77700wef.216.1263441947449; Wed, \n\t13 Jan 2010 20:05:47 -0800 (PST)\r\nIn-Reply-To: &lt;FA18B550-7E4E-46E2-880C-80CFC791D1E9@...&gt;\r\nReferences: &lt;hilcpt+u2rk@...&gt;\n\t &lt;FA18B550-7E4E-46E2-880C-80CFC791D1E9@...&gt;\r\nDate: Wed, 13 Jan 2010 23:05:47 -0500\r\nMessage-ID: &lt;b0ebafd11001132005n455c15e7ycb704a8c0cab7785@...&gt;\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nContent-Type: multipart/alternative; boundary=0016e6d7849178db98047d180032\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Andrew Wahbe &lt;andrew.wahbe@...&gt;\r\nSubject: Re: [rest-discuss] Re: about rel and HATEOAS (theoretical question)\r\nX-Yahoo-Group-Post: member; u=221173245; y=SAGv1yaB1MuJ02uKx6LcJOvoqk0GQDtM31FhTl388Hi34VySfw\r\nX-Yahoo-Profile: wahbedahbe\r\n\r\n\r\n--0016e6d7849178db98047d180032\r\nContent-Type: text/plain; charset=ISO-8859-1\r\n\r\nOn Wed, Jan 13, 2010 at 5:16 PM, Jan Algermissen &lt;algermissen1971@...&gt;wrote:\n\n&gt;\n&gt; On Jan 13, 2010, at 10:09 PM, wahbedahbe wrote:\n&gt;\n&gt;\n&gt;&gt; Is the media type a part of the service&#39;s contract or the client&#39;s?\n&gt;&gt;\n&gt;&gt; It seems to me that a key distinction between REST and RPC is that in RPC\n&gt;&gt; the service provides the contract while in REST, the client provides the\n&gt;&gt; contract (via the media type).\n&gt;&gt;\n&gt;&gt; A client, in the Accept header, constrains the set of acceptable media\n&gt;&gt; types -- isn&#39;t this essentially run-time contract negotiation?\n&gt;&gt; The server agrees to the contract at run time by returning an appropriate\n&gt;&gt; representation of the requested resource (or rejects the contract by\n&gt;&gt; returning &quot;Not Acceptable&quot;).\n&gt;&gt;\n&gt;\n&gt; When you build a client that understands media type A, you need to hard\n&gt; wire (or configure) two things into your client code:\n&gt;\n&gt; 1. knowledge about which hypermedia elements are traversal options\n&gt;   (links, forms)\n&gt; 2. knowledge about which media types to put into the Accept header\n&gt;   when the user (human or machine) of the client chooses to follow\n&gt;   a certain transition. (You do *not* code the client to simply list\n&gt;   all the media types it understands)\n&gt;\n&gt; During the request handling, there happens runtime negotiation of the\n&gt; content but there is a piece of contract that is a design time artifact (2.\n&gt; above). The question really is: On the basis of what information does the\n&gt; client choose what types to put in the Accept header. It is not an arbitrary\n&gt; decision but a decision that essentially reflects the client&#39;s design-time\n&gt; knowledge of the domain protocol supported by the service.\n&gt;\n&gt; Agreed (I followed your recent thread on the matter closely! ;-). I would\nargue that the &quot;domain protocol supported by the service&quot; is the media type\nand rel definitions. Is that your view?\n\n&gt;\n&gt;\n&gt;&gt; *Typically*, services can easily extend their &quot;reach&quot; by supporting as\n&gt;&gt; many media types as they like while clients support a fixed set of media\n&gt;&gt; types. So in order to give a client reach, it is best to support media types\n&gt;&gt; that are able to be used by a broad range of services.\n&gt;&gt;\n&gt;\n&gt; I think it is the other way round: Services expect the clients to\n&gt; understand a set of media types. This set constitutes the service&#39;s type.\n\n\nThat way doesn&#39;t seem to match the way it works on the web though. What are\nthe &quot;types of services&quot; on the web? Social media applications, customer\nservice applications, auction applications, banking applications, etc. Each\nservice type doesn&#39;t have it&#39;s own set of media types. They all use HTML\nbecause, well that&#39;s what browsers support. If you want to expand your\nservice&#39;s reach beyond browsers you&#39;d have to support the media type of the\nclient you are trying to reach.\n\n&gt;\n&gt;\n&gt;\n&gt;&gt; For example, HTML can obviously be used to express an incredible range of\n&gt;&gt; services.\n&gt;&gt;\n&gt;\n&gt; Hmm - I&#39;d argue that HTML oly expresses the semantics needed by a browser\n&gt; to turn human targetted hypermedia into an interactive GUI. The &#39;incredible\n&gt; range&#39; is a by-product of humans controlling the browser.\n\n\nYa I&#39;m familiar with the &quot;human driven&quot; vs. &quot;machine driven&quot; argument. I\ndon&#39;t agree with this line of thinking at all -- the problem is that the\n&quot;machine driven&quot; media types in use are just plain bad -- one of their big\nproblem&#39;s is the fact they are service specific!\n\n\n&gt;\n&gt;\n&gt;  VoiceXML (used by automated phone systems) can also be used to express a\n&gt;&gt; broad range of services. Supporting one of these media types would give a\n&gt;&gt; client a broad reach as it could interact with many services. But a service\n&gt;&gt; could address both HTML and VoiceXML clients via conneg (or simply two\n&gt;&gt; disjoint sets of URIs).\n&gt;&gt;\n&gt;\n&gt; Hmm, not sure I understand that. Can you illustrate?\n&gt;\n&gt;\nVoice Browsers are used to deliver voice applications over the phone that\nare authored using the VoiceXML markup language.\nRather that explain VoiceXML here, I&#39;ll point you do a short tutorial by\nDave Ragett: http://www.w3.org/Voice/Guide/\n\nNow, say you have a customer service application and you want to let\ncustomers interact with it over the web via an HTML browser and over the\nphone using an automated voice response system. The core application\nresources would likely be the same (user account resources, product\nresources, support ticket resources, etc.) for both the HTML and VoiceXML\napplications. You could use the same set of URIs for both and use conneg to\nserve HTML to web browsers and VoiceXML to voice browsers or use separate\nURI&#39;s to serve HTML and VoiceXML.\n\n\n\n&gt;\n&gt;\n&gt;&gt; Isn&#39;t this the root of the client-server decoupling provided by REST?\n&gt;&gt;\n&gt;\n&gt; The decoupling is achieved by removing *any* assumption on the client side\n&gt; about what the server may do next. (Except for, for example, returning\n&gt; images for requests to &lt;img href=&quot;&quot;&gt; target URIs. The server must not\n&gt; contradict itself.\n&gt;\n&gt; In my posting regarding testing a couple of days ago I tried to\n&gt; &#39;investigate&#39; the point by saying: &quot;A server can never send a wrong\n&gt; response&quot; client&#39;s must expect anything. (See Jim&#39;s excellent point about\n&gt; &#39;anything&#39; being constrained by the used media types).\n&gt;\n&gt; Sure, but you are basically saying that the media type forms the contract\nright? And I what I&#39;m trying to get at here is that the media type is the\nclient&#39;s contract not the service&#39;s. In the customer support example above,\nboth VoiceXML and HTML are mandated by the respective clients. The service\nis conforming to those media types in order to be able to interact with\nthose clients. The client is not coupled to the service at all -- just the\nmedia type, URI and HTTP. The service has the freedom to support whatever\nrepresentations it chooses -- it is not coupled to any one client&#39;s media\ntype.\n\n\n&gt;\n&gt;&gt; If so -- then the question I keep coming back to is if a service that uses\n&gt;&gt; a &quot;service-specific&quot; media type is really an instance of REST. By\n&gt;&gt; service-specific, I don&#39;t mean &quot;not standardized&quot; or vendor-specific -- this\n&gt;&gt; has nothing to do with the nature of the media type itself, just whether or\n&gt;&gt; not it&#39;s been approved by a standards body. I mean that the media type\n&gt;&gt; represents a contract set by the service because the media type is not\n&gt;&gt; designed to represent a set of services. This is because the semantics of\n&gt;&gt; the media type map exactly to the semantics of the service. You see this in\n&gt;&gt; most &quot;REST APIs&quot; that are simply serializing service data structures as JSON\n&gt;&gt; or XML.\n&gt;&gt;\n&gt;\n&gt; JSON or XML media types can never &#39;transport&#39; the semantics of a certain\n&gt; service or domain. They are so generic that they are useless from a media\n&gt; type discussion POV. Maybe you are criticising the use of such generic types\n&gt; and not really the issue of media types designed for a certain application?\n&gt;\n\nWell, even if properly you &quot;named&quot; the XML format (e.g. used\napplication/vnd.whatever+xml instead of application/xml) I think you still\nhave the same problem. The issue goes beyond the media type name -- I&#39;m\ntalking about the format itself.\n\n\n&gt; Also, I think it is very important to diferentiate between service types\n&gt; and service instances. This is sometimes hard to do when you look at the Web\n&gt; because there are mostly services that are unique (are instances of their\n&gt; own type). But services that implement AtomPub are *instances* of the kind\n&gt; of service defined by RFC5023. This is why you can implement AtomPub clients\n&gt; without looking at a service instance.\n&gt;\n\nRight... the clients conform to the spec. If my customer service example\nabove wanted to make a subset of its resources accessible to Atom+AtomPub\nclients, say the customer support tickets, it could do so by supporting\nthose media types. Well, almost -- there&#39;s the whole can of worms of how to\nrepresent the &quot;content&quot; or in this case, the support ticket data. Do you use\na foreign XML namespace in the &lt;entry&gt; or do you put it in &lt;content&gt; (the\nextension vs. envelope question)? I&#39;ll avoid getting into that here, so\nlet&#39;s just say that the formats that compose the contract consist of AtomPub\nplus the content format.\n\nBut again, I see the format as the client&#39;s contract. The service in my\nexample is chosing to support the Atom client type by adding Atom to its\nsupported media types. It&#39;s hard to see it that way with Atom because of the\nwhole mess caused by the embedded content format. The problem is that most\nAtom services use a service-specific content format which makes the whole\nthing service-specific in the end despite the use of Atom.\n\n\n&gt;\n&gt; I do think that certain problem domains (or service types) need their own\n&gt; media types (maybe mixed with existing types). But, yes, I agree that a\n&gt; media type should be designed for a set of services (aka type?) and not for\n&gt; a single one.\n&gt;\n&gt; OTH, when Google provides a set of quasi-standardized extensions when\n&gt; publishing a service - that is fine. How&#39;s that different from Google\n&gt; minting a few types for the job?\n&gt;\n&gt; I think some of Google&#39;s services would be way more RESTful if they&#39;d used\nestablished media types for the content. i.e. Atom feeds of vCards would\nhave been way better than what they implemented IMO.\n\n&gt;\n&gt;\n&gt;\n&gt;&gt; To me a RESTful service &quot;translates&quot; it&#39;s own internal semantics into the\n&gt;&gt; media type(s) of the client(s) it is trying to address --\n&gt;&gt;\n&gt;\n&gt; I would rather say: A service expects clients to understand certain types.\n&gt; If known-to-be-supported types do not do the job, then mint new types or\n&gt; extensions and publish them and hope clients implement them.\n\n\nNope. Can&#39;t agree here. As already discussed, I just don&#39;t see REST that\nway. For me, media types start with the client.\n\n&gt;\n&gt;\n&gt;  the specific translation used being negotiated at runtime. This, to me is\n&gt;&gt; the point of having a distinction between resources and representations in\n&gt;&gt; REST. The translation doesn&#39;t just allow the service to &quot;reach&quot; a broader\n&gt;&gt; set of clients, but it also allows the client to &quot;reach&quot; a broader set of\n&gt;&gt; services. This is because the representation format captures information\n&gt;&gt; using semantics that are specific to the client. By designing the client&#39;s\n&gt;&gt; format around the information processing capabilities of the client, the\n&gt;&gt; client can interact with as many services as possible.\n&gt;&gt;\n&gt;\n&gt; But you cannot magically make a client understand a semantic needed to\n&gt; express your (the server&#39;s) state machine.\n&gt;\n&gt; Ok.... challenge accepted -- give me an example problem and I&#39;ll try to\nshow you how to solve it. One rule: you&#39;ll need to be able to answer\ndetailed questions about the example client as well as the service.\n\n&gt;\n&gt;&gt; For example, HTML represents information in terms of common structures of\n&gt;&gt; visually displayed, interactive text -- it&#39;s designed around visual\n&gt;&gt; browsers. VoiceXML is designed around voice browsers. Yes, you can write a\n&gt;&gt; spider to consume HTML (and VoiceXML). And yes, you can use a screen reader\n&gt;&gt; to process HTML, but VoiceXML is a much more natural way to represent\n&gt;&gt; information for speech-based consumption and interaction (it won a standards\n&gt;&gt; war with SALT -- a set of extensions to HTML for speech). So there are other\n&gt;&gt; ways to consume the information (something afforded by the Principle of\n&gt;&gt; Least Power), but that doesn&#39;t diminish the fact that the media type is\n&gt;&gt; designed to cater to a specific flavor of client.\n&gt;&gt;\n&gt;&gt; So when a media type is designed around a service rather than a type of\n&gt;&gt; client, I question if the result can be called REST. For example, a banking\n&gt;&gt; service that spits out a JSON format that simply serializes the account and\n&gt;&gt; transaction data structures used internally to represent the service&#39;s\n&gt;&gt; resources. i.e. if you aren&#39;t targeting a specific &quot;type&quot; of client by\n&gt;&gt; translating to that client&#39;s media type are you violating the constraints of\n&gt;&gt; REST?\n&gt;&gt;\n&gt;\n&gt; Hmm - are you trying to say that media types should be design for a kind of\n&gt; application (online purchasing, online bank account management etc.)? If so\n&gt; - yes, of course!\n&gt;\n&gt; Nope. I am saying that media types should be designed for kinds of clients.\nThis is the precedent set by HTML, VoiceXML, etc.\n\n\n&gt;\n&gt;\n&gt;&gt; What specific constraints are being violated is a hard question and the\n&gt;&gt; reason I have a hard time explaining this\n&gt;&gt;\n&gt;\n&gt; Sounds like you are talking about visibility in a sense. At least putting\n&gt; application specific stuff into generoc formats and relying on out-of-band\n&gt; contracts to fill the void violates the visibility constraint.\n&gt;\n&gt;\n&gt;  -- I would point to &quot;Self-descriptive messages&quot; and its requirement for\n&gt;&gt; standard media types but the meaning of &quot;standard&quot; in the context of REST is\n&gt;&gt; so hard to pin down. Or maybe this is just inherent in the distinction\n&gt;&gt; between representations and resources.\n&gt;&gt;\n&gt;\n&gt;  &quot;Self-descriptive messages&quot; are another form of saying &#39;visibility&#39;.\n&gt;&gt;\n&gt;\n&gt; Maybe... visibility is a part of it, but I think this goes beyond\nvisibility. This also affects (and is perhaps more central to)\nsubstitutability, modifiability, evolvability, reusability, etc.\n\n&gt;\n&gt;&gt; Or maybe this isn&#39;t part of REST&#39;s constraints at all... I don&#39;t know --\n&gt;&gt; that&#39;s why I keep asking (but based on the answers I get, I don&#39;t think I\n&gt;&gt; ever get the question across properly). Anyways, I&#39;m interested in all of\n&gt;&gt; your thoughts.\n&gt;&gt;\n&gt;\n&gt; Hope they help.\n&gt;\n&gt; Jan\n&gt;\n&gt; Thanks... this is a good conversation, even if we don&#39;t see things the same\nway (yet!) ;-)\n\nRegards,\n\nAndrew\n\r\n--0016e6d7849178db98047d180032\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nOn Wed, Jan 13, 2010 at 5:16 PM, Jan Algermissen &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a h=\r\nref=3D&quot;mailto:algermissen1971@...&quot; target=3D&quot;_blank&quot;&gt;algermissen1971@ma=\r\nc.com&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;div class=3D&quot;gmail_quote&quot;&gt;&lt;blockquote class=\r\n=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin=\r\n: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;\n\n&lt;div&gt;&lt;br&gt;\nOn Jan 13, 2010, at 10=\r\n:09 PM, wahbedahbe wrote:&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=\r\n=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; p=\r\nadding-left: 1ex;&quot;&gt;\n&lt;br&gt;\nIs the media type a part of the service&#39;s cont=\r\nract or the client&#39;s?&lt;br&gt;\n&lt;br&gt;\nIt seems to me that a key distinction be=\r\ntween REST and RPC is that in RPC the service provides the contract while i=\r\nn REST, the client provides the contract (via the media type).&lt;br&gt;\n&lt;br&gt;\nA c=\r\nlient, in the Accept header, constrains the set of acceptable media types -=\r\n- isn&#39;t this essentially run-time contract negotiation?&lt;br&gt;\nThe server =\r\nagrees to the contract at run time by returning an appropriate representati=\r\non of the requested resource (or rejects the contract by returning &quot;No=\r\nt Acceptable&quot;).&lt;br&gt;\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nWhen you build a client t=\r\nhat understands media type A, you need to hard wire (or configure) two thin=\r\ngs into your client code:&lt;br&gt;\n&lt;br&gt;\n1. knowledge about which hypermedia elem=\r\nents are traversal options&lt;br&gt;\n =A0 (links, forms)&lt;br&gt;\n2. knowledge about w=\r\nhich media types to put into the Accept header&lt;br&gt;\n =A0 when the user (huma=\r\nn or machine) of the client chooses to follow&lt;br&gt;\n =A0 a certain transition=\r\n. (You do *not* code the client to simply list&lt;br&gt;\n =A0 all the media types=\r\n it understands)&lt;br&gt;\n&lt;br&gt;\nDuring the request handling, there happens runtim=\r\ne negotiation of the content but there is a piece of contract that is a des=\r\nign time artifact (2. above). The question really is: On the basis of what =\r\ninformation does the client choose what types to put in the Accept header. =\r\nIt is not an arbitrary decision but a decision that essentially reflects th=\r\ne client&#39;s design-time knowledge of the domain protocol supported by th=\r\ne service.&lt;div&gt;\n\n&lt;br&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div&gt;Agreed (I followed your recent=\r\n thread on the matter closely! ;-). I would argue that the &quot;domain pro=\r\ntocol supported by the service&quot; is the media type and rel definitions.=\r\n Is that your view?&lt;br&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;bo=\r\nrder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding=\r\n-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-l=\r\neft: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left:=\r\n 1ex;&quot;&gt;\n&lt;br&gt;\n*Typically*, services can easily extend their &quot;reach&quot=\r\n; by supporting as many media types as they like while clients support a fi=\r\nxed set of media types. So in order to give a client reach, it is best to s=\r\nupport media types that are able to be used by a broad range of services.&lt;b=\r\nr&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nI think it is the other way round: Services e=\r\nxpect the clients to understand a set of media types. This set constitutes =\r\nthe service&#39;s type.&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;That way doesn&#39;t seem to m=\r\natch the way it works on the web though. What are the &quot;types of servic=\r\nes&quot; on the web? Social media applications, customer service applicatio=\r\nns, auction applications, banking applications, etc. Each service type does=\r\nn&#39;t have it&#39;s own set of media types. They all use HTML because, we=\r\nll that&#39;s what browsers support. If you want to expand your service&#39=\r\n;s reach beyond browsers you&#39;d have to support the media type of the cl=\r\nient you are trying to reach. &lt;br&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; =\r\nstyle=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8=\r\nex; padding-left: 1ex;&quot;&gt;&lt;div&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; st=\r\nyle=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex=\r\n; padding-left: 1ex;&quot;&gt;\n&lt;br&gt;\nFor example, HTML can obviously be used to expr=\r\ness an incredible range of services.&lt;br&gt;\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nHmm - I&#=\r\n39;d argue that HTML oly expresses the semantics needed by a browser to tur=\r\nn human targetted hypermedia into an interactive GUI. The &#39;incredible r=\r\nange&#39; is a by-product of humans controlling the browser.&lt;/blockquote&gt;\n&lt;=\r\ndiv&gt;&lt;br&gt;Ya I&#39;m familiar with the &quot;human driven&quot; vs. &quot;mac=\r\nhine driven&quot; argument. I don&#39;t agree with this line of thinking at=\r\n all -- the problem is that the &quot;machine driven&quot; media types in u=\r\nse are just plain bad -- one of their big problem&#39;s is the fact they ar=\r\ne service specific!&lt;br&gt;\n=A0&lt;br&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; styl=\r\ne=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; =\r\npadding-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=\r\n=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; p=\r\nadding-left: 1ex;&quot;&gt;\nVoiceXML (used by automated phone systems) can also be =\r\nused to express a broad range of services. Supporting one of these media ty=\r\npes would give a client a broad reach as it could interact with many servic=\r\nes. But a service could address both HTML and VoiceXML clients via conneg (=\r\nor simply two disjoint sets of URIs).&lt;br&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nHmm, n=\r\not sure I understand that. Can you illustrate?&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;=\r\ndiv&gt;&lt;br&gt;Voice Browsers are used to deliver voice applications over the phon=\r\ne that are authored using the VoiceXML markup language. &lt;br&gt;\nRather that ex=\r\nplain VoiceXML here, I&#39;ll point you do a short tutorial by Dave Ragett:=\r\n &lt;a href=3D&quot;http://www.w3.org/Voice/Guide/&quot;&gt;http://www.w3.org/Voice/Guide/&lt;=\r\n/a&gt;&lt;br&gt;&lt;br&gt;Now, say you have a customer service application and you want to=\r\n let customers interact with it over the web via an HTML browser and over t=\r\nhe phone using an automated voice response system. The core application res=\r\nources would likely be the same (user account resources, product resources,=\r\n support ticket resources, etc.) for both the HTML and VoiceXML application=\r\ns. You could use the same set of URIs for both and use conneg to serve HTML=\r\n to web browsers and VoiceXML to voice browsers or use separate URI&#39;s t=\r\no serve HTML and VoiceXML.&lt;br&gt;\n&lt;br&gt;=A0&lt;br&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_=\r\nquote&quot; style=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt =\r\n0pt 0.8ex; padding-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot;=\r\n style=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.=\r\n8ex; padding-left: 1ex;&quot;&gt;\n&lt;br&gt;\nIsn&#39;t this the root of the client-server=\r\n decoupling provided by REST?&lt;br&gt;\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nThe decoupling i=\r\ns achieved by removing *any* assumption on the client side about what the s=\r\nerver may do next. (Except for, for example, returning images for requests =\r\nto &lt;img href=3D&quot;&quot;&gt; target URIs. The server must not contrad=\r\nict itself.&lt;br&gt;\n\n\n&lt;br&gt;\nIn my posting regarding testing a couple of days ago=\r\n I tried to &#39;investigate&#39; the point by saying: &quot;A server can n=\r\never send a wrong response&quot; client&#39;s must expect anything. (See Ji=\r\nm&#39;s excellent point about &#39;anything&#39; being constrained by the u=\r\nsed media types).&lt;div&gt;\n\n&lt;br&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div&gt;Sure, but you are basic=\r\nally saying that the media type forms the contract right? And I what I&#39;=\r\nm trying to get at here is that the media type is the client&#39;s contract=\r\n not the service&#39;s. In the customer support example above, both VoiceXM=\r\nL and HTML are mandated by the respective clients. The service is conformin=\r\ng to those media types in order to be able to interact with those clients. =\r\nThe client is not coupled to the service at all -- just the media type, URI=\r\n and HTTP. The service has the freedom to support whatever representations =\r\nit chooses -- it is not coupled to any one client&#39;s media type.&lt;br&gt;\n&lt;br=\r\n&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px solid rg=\r\nb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;=\r\n\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px solid rgb(204,=\r\n 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;\n&lt;br&gt;\nIf so -- t=\r\nhen the question I keep coming back to is if a service that uses a &quot;se=\r\nrvice-specific&quot; media type is really an instance of REST. By service-s=\r\npecific, I don&#39;t mean &quot;not standardized&quot; or vendor-specific -=\r\n- this has nothing to do with the nature of the media type itself, just whe=\r\nther or not it&#39;s been approved by a standards body. I mean that the med=\r\nia type represents a contract set by the service because the media type is =\r\nnot designed to represent a set of services. This is because the semantics =\r\nof the media type map exactly to the semantics of the service. You see this=\r\n in most &quot;REST APIs&quot; that are simply serializing service data str=\r\nuctures as JSON or XML.&lt;br&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nJSON or XML media ty=\r\npes can never &#39;transport&#39; the semantics of a certain service or dom=\r\nain. They are so generic that they are useless from a media type discussion=\r\n POV. Maybe you are criticising the use of such generic types and not reall=\r\ny the issue of media types designed for a certain application?&lt;br&gt;\n&lt;/blockq=\r\nuote&gt;&lt;div&gt;&lt;br&gt;Well, even if properly you &quot;named&quot; the XML format (=\r\ne.g. used application/vnd.whatever+xml instead of application/xml) I think =\r\nyou still have the same problem. The issue goes beyond the media type name =\r\n-- I&#39;m talking about the format itself.&lt;br&gt;\n&lt;br&gt;&lt;/div&gt;&lt;blockquote class=\r\n=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin=\r\n: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;\n\n&lt;br&gt;\nAlso, I think it is very im=\r\nportant to diferentiate between service types and service instances. This i=\r\ns sometimes hard to do when you look at the Web because there are mostly se=\r\nrvices that are unique (are instances of their own type). But services that=\r\n implement AtomPub are *instances* of the kind of service defined by RFC502=\r\n3. This is why you can implement AtomPub clients without looking at a servi=\r\nce instance.&lt;br&gt;\n&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;Right... the clients conform to the =\r\nspec. If my customer service example above wanted to make a subset of its r=\r\nesources accessible to Atom+AtomPub clients, say the customer support ticke=\r\nts, it could do so by supporting those media types. Well, almost -- there&#=\r\n39;s the whole can of worms of how to represent the &quot;content&quot; or =\r\nin this case, the support ticket data. Do you use a foreign XML namespace i=\r\nn the &lt;entry&gt; or do you put it in &lt;content&gt; (the extension vs. =\r\nenvelope question)? I&#39;ll avoid getting into that here, so let&#39;s jus=\r\nt say that the formats that compose the contract consist of AtomPub plus th=\r\ne content format.&lt;br&gt;\n&lt;br&gt;But again, I see the format as the client&#39;s c=\r\nontract. The service in my example is chosing to support the Atom client ty=\r\npe by adding Atom to its supported media types. It&#39;s hard to see it tha=\r\nt way with Atom because of the whole mess caused by the embedded content fo=\r\nrmat. The problem is that most Atom services use a service-specific content=\r\n format which makes the whole thing service-specific in the end despite the=\r\n use of Atom.&lt;br&gt;\n=A0&lt;br&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;b=\r\norder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; paddin=\r\ng-left: 1ex;&quot;&gt;\n\n&lt;br&gt;\nI do think that certain problem domains (or service ty=\r\npes) need their own media types (maybe mixed with existing types). But, yes=\r\n, I agree that a media type should be designed for a set of services (aka t=\r\nype?) and not for a single one.&lt;br&gt;\n\n\n&lt;br&gt;\nOTH, when Google provides a set =\r\nof quasi-standardized extensions when publishing a service - that is fine. =\r\nHow&#39;s that different from Google minting a few types for the job?&lt;div&gt;&lt;=\r\nbr&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div&gt;I think some of Google&#39;s services would be w=\r\nay more RESTful if they&#39;d used established media types for the content.=\r\n i.e. Atom feeds of vCards would have been way better than what they implem=\r\nented IMO. &lt;br&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-lef=\r\nt: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1=\r\nex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-left=\r\n: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1e=\r\nx;&quot;&gt;\n&lt;br&gt;\nTo me a RESTful service &quot;translates&quot; it&#39;s own inter=\r\nnal semantics into the media type(s) of the client(s) it is trying to addre=\r\nss --&lt;br&gt;\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nI would rather say: A service expects cl=\r\nients to understand certain types. If known-to-be-supported types do not do=\r\n the job, then mint new types or extensions and publish them and hope clien=\r\nts implement them.&lt;/blockquote&gt;\n&lt;div&gt;&lt;br&gt;Nope. Can&#39;t agree here. As alr=\r\neady discussed, I just don&#39;t see REST that way. For me, media types sta=\r\nrt with the client. &lt;br&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;bo=\r\nrder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding=\r\n-left: 1ex;&quot;&gt;\n&lt;div&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;bo=\r\nrder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding=\r\n-left: 1ex;&quot;&gt;\nthe specific translation used being negotiated at runtime. Th=\r\nis, to me is the point of having a distinction between resources and repres=\r\nentations in REST. The translation doesn&#39;t just allow the service to &q=\r\nuot;reach&quot; a broader set of clients, but it also allows the client to =\r\n&quot;reach&quot; a broader set of services. This is because the representa=\r\ntion format captures information using semantics that are specific to the c=\r\nlient. By designing the client&#39;s format around the information processi=\r\nng capabilities of the client, the client can interact with as many service=\r\ns as possible.&lt;br&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/div&gt;\nBut you cannot magically make=\r\n a client understand a semantic needed to express your (the server&#39;s) s=\r\ntate machine.&lt;br&gt;\n&lt;br&gt;&lt;/blockquote&gt;&lt;div&gt;Ok.... challenge accepted -- give m=\r\ne an example problem and I&#39;ll try to show you how to solve it. One rule=\r\n: you&#39;ll need to be able to answer detailed questions about the example=\r\n client as well as the service.&lt;br&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot;=\r\n style=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.=\r\n8ex; padding-left: 1ex;&quot;&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border=\r\n-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-lef=\r\nt: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\nFor example, HTML represents information in terms of co=\r\nmmon structures of visually displayed, interactive text -- it&#39;s designe=\r\nd around visual browsers. VoiceXML is designed around voice browsers. Yes, =\r\nyou can write a spider to consume HTML (and VoiceXML). And yes, you can use=\r\n a screen reader to process HTML, but VoiceXML is a much more natural way t=\r\no represent information for speech-based consumption and interaction (it wo=\r\nn a standards war with SALT -- a set of extensions to HTML for speech). So =\r\nthere are other ways to consume the information (something afforded by the =\r\nPrinciple of Least Power), but that doesn&#39;t diminish the fact that the =\r\nmedia type is designed to cater to a specific flavor of client.&lt;br&gt;\n\n\n&lt;br&gt;&lt;=\r\n/div&gt;&lt;div&gt;\nSo when a media type is designed around a service rather than a =\r\ntype of client, I question if the result can be called REST. For example, a=\r\n banking service that spits out a JSON format that simply serializes the ac=\r\ncount and transaction data structures used internally to represent the serv=\r\nice&#39;s resources. i.e. if you aren&#39;t targeting a specific &quot;type=\r\n&quot; of client by translating to that client&#39;s media type are you vio=\r\nlating the constraints of REST?&lt;br&gt;\n\n\n&lt;/div&gt;&lt;/blockquote&gt;\n&lt;br&gt;\nHmm - are yo=\r\nu trying to say that media types should be design for a kind of application=\r\n (online purchasing, online bank account management etc.)? If so - yes, of =\r\ncourse!&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div&gt;Nope. I am saying that media types =\r\nshould be designed for kinds of clients. This is the precedent set by HTML,=\r\n VoiceXML, etc. &lt;br&gt;\n&lt;br&gt;&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;b=\r\norder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; paddin=\r\ng-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;bo=\r\nrder-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding=\r\n-left: 1ex;&quot;&gt;\n&lt;br&gt;\nWhat specific constraints are being violated is a hard q=\r\nuestion and the reason I have a hard time explaining this&lt;br&gt;\n&lt;/blockquote&gt;=\r\n\n&lt;br&gt;&lt;/div&gt;\nSounds like you are talking about visibility in a sense. At lea=\r\nst putting application specific stuff into generoc formats and relying on o=\r\nut-of-band contracts to fill the void violates the visibility constraint.&lt;d=\r\niv&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px s=\r\nolid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;\n--=\r\n I would point to &quot;Self-descriptive messages&quot; and its requirement=\r\n for standard media types but the meaning of &quot;standard&quot; in the co=\r\nntext of REST is so hard to pin down. Or maybe this is just inherent in the=\r\n distinction between representations and resources.&lt;br&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br=\r\n&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-left: 1px solid r=\r\ngb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;&quot;&gt;\n&quot;Se=\r\nlf-descriptive messages&quot; are another form of saying &#39;visibility&#3=\r\n9;.&lt;br&gt;\n&lt;/blockquote&gt;&lt;div&gt;\n&lt;br&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div&gt;Maybe... visibility =\r\nis a part of it, but I think this goes beyond visibility. This also affects=\r\n (and is perhaps more central to) substitutability, modifiability, evolvabi=\r\nlity, reusability, etc.&lt;br&gt;\n&lt;/div&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=\r\n=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; p=\r\nadding-left: 1ex;&quot;&gt;&lt;div&gt;\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;border-=\r\nleft: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left=\r\n: 1ex;&quot;&gt;\n&lt;br&gt;\nOr maybe this isn&#39;t part of REST&#39;s constraints at all=\r\n... I don&#39;t know -- that&#39;s why I keep asking (but based on the answ=\r\ners I get, I don&#39;t think I ever get the question across properly). Anyw=\r\nays, I&#39;m interested in all of your thoughts.&lt;br&gt;\n\n\n&lt;/blockquote&gt;\n&lt;br&gt;&lt;/=\r\ndiv&gt;\nHope they help.&lt;br&gt;\n&lt;br&gt;\nJan&lt;br clear=3D&quot;all&quot;&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;/div&gt;T=\r\nhanks... this is a good conversation, even if we don&#39;t see things the s=\r\name way (yet!) ;-)&lt;br&gt;&lt;br&gt;Regards,&lt;br&gt;&lt;br&gt;Andrew&lt;br&gt;\n\r\n--0016e6d7849178db98047d180032--\r\n\n"}}