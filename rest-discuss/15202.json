{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"8ZT4uPHUm9Bn6VBdQB3pXCJCXBrHj65ENxCG3S9KxAkezz91SBTUoSn8PAlCxTAlFkgN_cqQRRwh-iptTl_41sVivHljT-cCU1vsTlK7nw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the sense of  Roy&#39;s dissertation?","postDate":"1270909683","msgId":15202,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNDEwMDgyODAzLjQzMzQxMDFhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PGhwa21oNitpdDJmQGVHcm91cHMuY29tPg==","referencesHeader":"PDIwMTAwNDA3MTQzNDA4Ljk5YzAwYjUzLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPGhwa21oNitpdDJmQGVHcm91cHMuY29tPg=="},"prevInTopic":15199,"nextInTopic":15203,"prevInTime":15201,"nextInTime":15203,"topicId":15152,"numMessagesInTopic":30,"msgSnippet":"To clarify what I mean by an incalculable number of REST applications for any given REST system, an analogy is that the 26 letters of the alphabet lead to an","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 56107 invoked from network); 10 Apr 2010 14:28:42 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m10.grp.re1.yahoo.com with QMQP; 10 Apr 2010 14:28:42 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 10 Apr 2010 14:28:42 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 5F3F8509DA;\n\tSat, 10 Apr 2010 10:28:38 -0400 (EDT)\r\nDate: Sat, 10 Apr 2010 08:28:03 -0600\r\nTo: &quot;William Martinez Pomares&quot; &lt;wmartinez@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100410082803.4334101a.eric@...&gt;\r\nIn-Reply-To: &lt;hpkmh6+it2f@...&gt;\r\nReferences: &lt;20100407143408.99c00b53.eric@...&gt;\n\t&lt;hpkmh6+it2f@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the\n sense of  Roy&#39;s dissertation?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nTo clarify what I mean by an &quot;incalculable number&quot; of REST applications\nfor any given REST system, an analogy is that the 26 letters of the\nalphabet lead to an incalculable number of words.  Some words are\nincredibly common -- conjunctions come to mind.  Same with REST\napplications; there will be common usage patterns, of varying length,\nand these may be optimized.\n\n&quot;William Martinez Pomares&quot; wrote:\n&gt;\n&gt; I do differentiate the concepts. A system is that collection of\n&gt; components organized and with particular interactions. Those may\n&gt; support different applications, that are not more than a set of task\n&gt; to produce a goal. A system is my computer, and applications uses\n&gt; some of the components to achieve a goal.\n&gt; \n\nI&#39;m only interested in using the term &quot;system&quot; in the REST sense so\nclearly evident in the thesis.  I may, in other contexts, use the term\n&quot;system&quot; in the sysadmin sense, to refer to a physical system.  I don&#39;t\nlike to talk about system in the sysadmin sense on rest-discuss, even\nas an analogy, to avoid confusion and because hardware setup isn&#39;t\nrelevant to REST.\n\nWe don&#39;t call REST systems &quot;applications&quot; because that takes a whole\nslew of components and connectors for granted, in order for it to\nwork.  So I don&#39;t like the analogy -- a browser application uses other\ncomponents resident on the same physical system, but others are located\nacross the network.  REST applications are distributed.\n\n&gt;\n&gt; So, you may create a system that supports several apps, even some you\n&gt; didn&#39;t think of!\n&gt; \n\nExactly what&#39;s meant by &quot;serendipitous re-use&quot;.  ;-)  This is exactly\nwhat I mean when I say a REST system has an &quot;incalculable number&quot; of\napplications.  The developer can&#39;t possibly imagine the possible use\ncases, more on that in my next response to Jan...\n\n&gt;\n&gt; Now, System is not an API. I actually argue about the term REST API\n&gt; since it comes, I think, from the idea that REST is a Service or RPC\n&gt; replacement.\n&gt; \n\nYou&#39;re right, the system encompasses many components, but these things\nare out of the REST developer&#39;s hands.  Everything that is in the REST\ndeveloper&#39;s hands, is the API for making the overall system do work.\n\nI think the term REST API was derived from the fundamental nature of\nREST itself.  This is the basis for my interchangeable usage of &quot;REST\nsystem&quot; and &quot;REST API&quot;...\n\n&quot;The resource implementation details are hidden behind the interface.&quot;\n\nWhile the connection to and nature of the backend are certainly parts\nof your overall system architecture, they&#39;ve nothing to do with REST\narchitecture.  REST is all about the communication between connectors\nover the wire -- REST applications are distributed.\n\nSo we&#39;re only concerned with the self-documenting interfaces that\ndescribe a REST system to the world, and the response codes a system\ngenerates to various methods invoked on various resources.  You know --\nthe API... ;-).\n\n&gt;\n&gt; An API is a layer between your system and an external client. Of\n&gt; course, that client is not part of your system.\n&gt;\n\nUser agent is a better term than client.  The user agent is absolutely a\npart of the system.  In fact, REST applications are executed within\nuser agents -- the application state isn&#39;t always held entirely within\nthe representation of a resource, it usually must be rendered to obtain\nan application steady-state.  The combination of representation plus\nuser agent *is* the REST application.  If HTML + browser, it&#39;s a browser\napplication (with, of course, a client connector).\n\n&quot;[T]he interaction of a real system usually involves an extensive number\nof components, resulting in an overall view that is obscured by the\ndetails.&quot;\n\nAn API is the layer between your system and external components, like\ncaches.  The user agent may not ever contact the origin server directly,\nand a cache may be able to serve all requests without contacting the\norigin server either.  That cache becomes part of your system -- one of\nthose components that we take for granted -- it&#39;s executing a REST\napplication against the origin server, to determine resource state\nusing conditional requests.\n\nSo a REST API is truly a programming interface for applications,\nwhether they&#39;re executing on the requesting user-agent or on some\nintermediary.  How would a cache know how to service requests on behalf\nof my origin server, if it can&#39;t be programmed to understand my service\nparameters?  I program intermediaries the same way I program user\nagents, with a REST API.\n\n&gt;\n&gt; API may be a facade, or an adapter. If a facade, if the system is\n&gt; REST, the API is a REST constrained simplification of the system. If\n&gt; an adapter, the API is something that will convert, say, RPC\n&gt; interactions into REST interactions. \n&gt; \n\nI don&#39;t see the distinction, and I don&#39;t see how such a distinction can\nbe made.  Give me a bunch of RPC endpoints, and I can code you a REST\nsystem to drive them.  Since the implementation details are hidden\nbehind the interface, the API is something that will transfer\nrepresentations of application state to user agents, and instruct them\nhow to transfer representations of desired application state to the\norigin server.\n\nREST is a layered-system architecture.  I apply REST constraints to the\ncommunication between the connectors of my back-end system, but this is\nnot part of my API since it&#39;s an implementation detail hidden behind\nthe interface to the world.  That interface to the world is my API.\n\n&gt;\n&gt; The most typical is you have non-REST system (SOA maybe, or a plain\n&gt; old OO) and you want to be REST. You create an API, Adapter, that\n&gt; will allow REST like clients to use your OO system as a REST one. The\n&gt; API will accept HTTP operations in one face, and in the other one\n&gt; will invoke object methods. \n&gt;\n\nBear with me...\n\nIn my case, the non-REST system is WordPress.  I create a REST layer to\nencapsulate this legacy system, just like the thesis says.  WP only\ngenerates Atom Entry, Atom Feed and Atom Category documents.  WP creates\nthe URI allocation scheme you see in my demo via a module with a couple\nof support functions for my template, which generates Atom instead of\nHTML.  But, WP is incapable of responding to that URI allocation scheme\ndirectly without extensive modification.\n\nWhich is OK by me, since I don&#39;t want to expose WP to the world; it\nruns on its own IP and rejects requests from any IP that isn&#39;t the\nencapsulation layer&#39;s or mine (initially, I&#39;ll use the WP interface\nuntil development is completed on the Xforms interface, then I&#39;ll cut\nout the CP, and have the main page return a configuration form to the\nadmin user when an OPTIONS request is made with proper credentials).\n\nThe encapsulation layer converts all requests to /index.php?p={x}, and\nacts as a reverse-proxy/cache for the response.  A request to post a\ncomment to a thread is handled by the encapsulation layer; once handled\n(validated and such), the request is passed on to WP using Atom\nProtocol.  The encapsulation layer creates separate Atom Feeds for each\nthread, whereas WP&#39;s Atom Protocol capability considers the entire\nweblog as a single collection.\n\nThe future of my project consists of replacing WP with an Atom Store.\nThe encapsulation layer (REST wrapper) has a modular design, to support\ninterfacing with multiple source generators.  So a new module is needed\nwhich, instead of abstracting out /index.php?p={x} into a hierarchical\nURI allocation scheme, abstracts out the URI allocation scheme of the\nAtom Store (which is the same as that used in my atom:id&#39;s, btw) into my\nsite&#39;s URI allocation scheme.\n\nSo, I can swap out a MySQL-driven WP content generation layer for a\nsimple Atom Store XMLDB-driven content generation layer that&#39;s not in\nany way similar except for its abilities to generate Atom content that\nexactly matches what WP generates, and accept posts via Atom Protocol.\nThe REST wrapper completely isolates this madness from the outside\nworld. Commenters on my weblog won&#39;t notice a thing -- because I\nhaven&#39;t changed the API in the slightest.  (My back-end API changes a\nbit, but it&#39;s using Atom Protocol either way.)\n\nBy sharing the self-documenting interfaces to my system with the world,\nI am providing a stable API which is unaffected by the nature of my\nback-end implementation.  The API is the interface behind which the\nimplementation details are hidden.  REST API &quot;Implementations are\ndecoupled from the services they provide, which encourages independent\nevolvability.&quot;\n\nDo you see how I just described a REST API which evolves from your\n&quot;adapter&quot; into your &quot;facade&quot; over time?  WP isn&#39;t RESTful, but the Atom\nStore certainly will be.  This distinction has no impact whatsoever on\nany application running against my system, because it&#39;s hidden behind\nthe generic connector interface, which is the point of a REST API.\n\n&gt; \n&gt; See how I see it?\n&gt; \n\nNope, sorry.  You&#39;re trying to make a distinction which assumes the API\nis coupled to the back-end implementation, when such coupling doesn&#39;t\nexist in a REST API.\n\n-Eric\n\n"}}