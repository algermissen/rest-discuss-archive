{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":69164307,"authorName":"mike amundsen","from":"mike amundsen &lt;mamund@...&gt;","profile":"mamund","replyTo":"SENDER","senderId":"U34AoV_CmlEUXfn43XbMZRzUPdA3_TV3N_o2b7PD8AHaX5r94F5uKuuPg_-JqKRZ5gPnTtwoL9iF_2LnzCu8SSZb2TuN6-s","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Forward/Backward versioning, media-types, etc","postDate":"1408915664","msgId":19704,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PENBUFdfOG01K1g0SE1pcD1IZ3Vub2dPNmstVzdCR0Y2azUwVEFNYS00Z0dycU5xWTBNQUBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PDE0MDgyNDczMjAuOTAwODIuWWFob29NYWlsTmVvQHdlYjEyMjIwNi5tYWlsLm5lMS55YWhvby5jb20+","referencesHeader":"PDE0MDgyNDczMjAuOTAwODIuWWFob29NYWlsTmVvQHdlYjEyMjIwNi5tYWlsLm5lMS55YWhvby5jb20+"},"prevInTopic":19703,"nextInTopic":0,"prevInTime":19703,"nextInTime":19705,"topicId":19703,"numMessagesInTopic":2,"msgSnippet":"Kevin: Your post covers a topic that comes up quite often in my discussion w/ devs (both server- and client-side). My answer to the questions about how to ","rawEmail":"Return-Path: &lt;mamund@...&gt;\r\nX-Sender: mamund@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 75319 invoked by uid 102); 24 Aug 2014 21:28:10 -0000\r\nX-Received: from unknown (HELO mtaq1.grp.bf1.yahoo.com) (10.193.84.32)\n  by m14.grp.bf1.yahoo.com with SMTP; 24 Aug 2014 21:28:10 -0000\r\nX-Received: (qmail 26575 invoked from network); 24 Aug 2014 21:28:09 -0000\r\nX-Received: from unknown (HELO nm2-vm1.bullet.mail.gq1.yahoo.com) (98.138.100.121)\n  by mtaq1.grp.bf1.yahoo.com with SMTP; 24 Aug 2014 21:28:09 -0000\r\nX-Received: from [98.137.12.174] by nm2.bullet.mail.gq1.yahoo.com with NNFMP; 24 Aug 2014 21:28:08 -0000\r\nX-Received: from [98.136.164.65] by tm13.bullet.mail.gq1.yahoo.com with NNFMP; 24 Aug 2014 21:28:07 -0000\r\nX-Received: from [127.0.0.1] by smtp227.mail.gq1.yahoo.com with NNFMP; 24 Aug 2014 21:28:07 -0000\r\nX-Yahoo-Newman-Id: 701472.93365.bm@...\r\nX-Yahoo-Newman-Property: ymail-3\r\nX-YMail-OSG: 511TBGwVM1kmchwcHiweZIwKwoBHjt4KxOQT5z_kQEtTjFh\n QbfzjhWa35u4JlOfRtD00.xCGVponFsK3aPZ1Dp0Nqv6QVPZoyXlBIjsIzwG\n p2PeVmt7OLVderavb5DrdgjHZrO6DedLHVEr0TX.US6bak7vqJCdecRufzsa\n NK_9nG8hzl8Sih9AwsyWgGkUPxuIKy.5yPKJUxvB4uBEujQpeN.uDfdvTfpK\n fHHL1kaIntbQug0GDMDjZdMelaRTgVg_GglIsgG9T8McSM7aAz3ARxbm5sQb\n p86GUQrLLSWUzMYGgOg8fB1HgtirkQVoBWB5YjJRT0eKZuIi2YF798qdR.Xp\n dzoX3N5_.JLaKzjDqV7DNRBTObzYg0k2XDLEHqaHDyT7dMXcJBfEOSGOf_c4\n lsJlwqAS_Q9GxZ7kPVoUZzEesDbwN_fSM8U1.3SkrDUY_HdcsO5y9xJFVtzD\n eIdKsUNUFeho85E81RXibEhWB1nwceo6mO.EOLyh_oamNLghVxCkeTlCpV73\n 8Sv6vKRb9Ts.kSb.0JleSDvVIol5AUTmwi1BSv5zPek7ygEZkactJUBSFn68\n c3kRjYkYfcdoqKW55FtonvvZNGogqn8eIviABSmqTg2kil_DB1NkYM1C5995\n ZDsMKkaxvtQR5WmR__U0amk6pPgjH1EVeb5LXRWS1_IknLDVcmC1IgOQrLi2\n n9Aewo0Z4SmnVBVKcWbby5EgBVmbzNjeyyuNXln6O1mFm6SsE6dHiYg6qDNa\n btTPih8mxsnAAEEMcmac3cYOXMnOsKXCsCHUmw.lWjOxofNAr2_icWD75YLM\n L1upQiOUT2RJcdd6XiOP2KZPNqhfYY561qn3.ADtvhEyM_AZsvUg0dBz1dBG\n LHuSKOiUYKSq1UhkNhv9WZ.dF6qniq.aejy4qqpQ4H3lESUkr1uN3XHknsVq\n F6wib8Drr7Xoc3WW1BBAzbR8Rgo_wA7X0oU6I6bZ8ZpCvFdFPXal0FFkjAKe\n d7XKPoHmh1cEVVt4JLtOQ5RqwYnjxs4A_xzXLv9VZ6aX7S3laczIiQa5bgBG\n yGVtAAN2t7PquViWP5vgq7Da5cGNKR4cY4tNUMqxz.jrDL8w7Bs..iuKK9An\n dciHgwhIjd1OjObrv4BxGoRs5iDS8jaYC1eYxh6bpoNQyfi3CeAhnc_006Tb\n Pg8VZxd8MnHKzIQsoWB67UCMlMrDW983.1dJ73jmSY9wvlnSBV6M.ipxvWBy\n Jsia5u4OeijvJDbs.cULEFp9nysP7ZNqf3cyDOC3vFRJmnznexxwkOWs0owK\n dPDu1qd3tyTs25vbDvp2xwz8gSL_VsX4icf3rcd6sO7dQFyNnwFnuRmKtXfD\n 23zs3Ir9itbGzl2AfPKIIPqnjBKV6wXjx4z5ZVSRJTLSjOGqDgKmmSEdXPq5\n 5TFE4miV571AAGViECj3daImL8AY3gc9tVk0MDS4BbT2vNxQnmlCXwxg..2D\n Ppz36aRWgyIbRAOb5FPPtTkD9guoXxIzFEL1Ktl06kpp8eC8bKNcWkKAqYnZ\n otxH080ikTPM8nCGUMGkXvySct6Ed.uCTbdk63KR0kui1oaHJufzcpTxhISR\n 2Bc14IpCv39zqLUMob.fOvc9IZzbaRC.H7zNji83wJUje9GYafHjJNPaJtnx\n uqoJHb89eAVDIvg--\r\nX-Yahoo-SMTP: i12ABOmswBAkPG1PnjmsmmFRWA--\r\nX-Received: by mail-we0-f173.google.com with SMTP id q58so12575905wes.18\n        for &lt;rest-discuss@yahoogroups.com&gt;; Sun, 24 Aug 2014 14:28:05 -0700 (PDT)\r\nX-Gm-Message-State: ALoCoQnHPb4/Vwgari8hWdA2SnXhSshHLzQvetqkOvnx5/ufmcZwSqdX1nVHJa4ell8d2fq2jamG\r\nX-Received: by 10.180.20.6 with SMTP id j6mr5788536wie.64.1408915685287; Sun,\n 24 Aug 2014 14:28:05 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.194.16.9 with HTTP; Sun, 24 Aug 2014 14:27:44 -0700 (PDT)\r\nIn-Reply-To: &lt;1408247320.90082.YahooMailNeo@...&gt;\r\nReferences: &lt;1408247320.90082.YahooMailNeo@...&gt;\r\nDate: Sun, 24 Aug 2014 17:27:44 -0400\r\nMessage-ID: &lt;CAPW_8m5+X4HMip=HgunogO6k-W7BGF6k50TAMa-4gGrqNqY0MA@...&gt;\r\nTo: Kevin Duffey &lt;andjarnic@...&gt;\r\nCc: Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Type: multipart/alternative; boundary=bcaec53f3823f0c560050166be1f\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nSubject: Re: [rest-discuss] Forward/Backward versioning, media-types, etc\r\nX-Yahoo-Group-Post: member; u=69164307; y=nKwPKkU-81kCSEiIPMGecygYpe2D3G6MJiiVva0cFJLk\r\nX-Yahoo-Profile: mamund\r\nFrom: mike amundsen &lt;mamund@...&gt;\r\n\r\n\r\n--bcaec53f3823f0c560050166be1f\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nKevin:\n\nYour post covers a topic that comes up quite often in my discussion=\r\n w/ devs\n(both server- and client-side). My answer to the questions about h=\r\now to\nhandle &quot;change over time&quot; may not be quite what you are looking for. =\r\nBut I\ndecided to pass it along anyway as it has helped me quite a bit over =\r\nthe\nlast several years in dealing with the problem.\n\nTL;DNR\n- Always make y=\r\nour service changes backward-compatible\n- Services should promise to never =\r\ntake anything away, never change\nprocessing of inputs, and always make new =\r\nelements optional\n- Services should only promise to return message formats =\r\n(like HTML, HAL,\netc.) using pre-defined terms (e.g. &quot;givenName&quot;, &quot;familyNa=\r\nme&quot;) and not\npromise any functions to execute or objects in return\n- Client=\r\n apps should not use schema to constrain incoming messages, should\ncode def=\r\nensively, and be designed to inspect incoming message for desired\nterms, no=\r\nt designed to deserialize objects or execute remote functions.\n- Essentiall=\r\ny, both client and server should abide by Postel&#39;s Law\n\nDoing this reduces =\r\nthe need to use &quot;versioning&quot; to separate one service\ninstance from another =\r\nand can make services useful to client apps for quite\na long time w/o the n=\r\need to &quot;fork&quot; the service and clients.\n\nHopefully this gives you some ideas=\r\n on how to deal with changes in APIs.\n\nCheers.\n\nHere&#39;s the long version.\n\nB=\r\nACKWARD-COMPATIBLE\nFirst, I start from the POV that all changes will be bac=\r\nkward-compatible.\nIOW, no change in the future will invalidate the past. Th=\r\nis is how both\nHTTP and HTML have been working over the last couple decades=\r\n. HTTP 1.0, 1.1\nand lots of changes in between (PATCH, LINK methods, new he=\r\naders, etc.) are\nimplemented in a way that doesn&#39;t break existing implement=\r\nations.\n\nTHREE PROMISES\nNext, any assurances/promises my service makes to c=\r\nlients is based on this\nFirst Principle of &quot;no breaking changes.&quot; That mean=\r\ns it is important for me\nto be clear about what I promise going forward. My=\r\n promise will shape what\nthe client expects as non-breaking.  And here are =\r\nmy promises to client\napps that implement my service API\n1 - i will never &quot;=\r\ntake anything away&quot; So, any URL I promise will either a)\nstill exists or b)=\r\n be redirected. Any parameters I describe for URL queries\nor request bodies=\r\n will always be accepted. Any parameters described in a\nresponse body will =\r\nalways be there.\n2 - I will never change the processing/meaning of paramete=\r\nrs. So, if i\npromise the parameter &quot;count&quot; represents the number of users i=\r\nn a list, I\nwill not change this at some future point such that &quot;count&quot; rep=\r\nresents the\nnumber of pages in a collection, etc.\n3 - Any new elements I in=\r\ntroduce will be optional. I will not create new\n*required* parameters for p=\r\nreviously promised requests. If i need to create\nnew requirements, I will c=\r\nreate a new promise and that promise will be\noptional for any existing impl=\r\nementations.\n\nPROMISE MESSAGES AND TERMS NOT FUNCTIONS AND OBJECTS\nNext, my=\r\n service almost never promise to return an object like a &quot;user&quot; or\n&quot;custome=\r\nr&quot;, etc. Instead, my service promises to return a message in one or\nmore fo=\r\nrmats -- message formats like HTML, HAL, Collection+JSON, Siren,\netc. Each =\r\nof these formats have their own rules about what is legal, what\nis required=\r\n, etc. and my service will always honor those promises (from the\nformat des=\r\nigners).\n\nMy service publishes a list of valid vocabulary terms that can be=\r\n returned\nwithin messages. Terms like &quot;givenName&quot;, &quot;familyName&quot;, etc. The v=\r\nocabulary\nalso includes action terms such as &quot;update&quot;, &quot;create&quot;, &quot;share&quot;, &quot;=\r\nmove&quot;,\n&quot;copy&quot; or whatever other terms make sense for this service space. Cl=\r\nient\napplications need to be able to recognize and process these terms when=\r\n the\nappear.\n\nThis means client apps need to focus on the message and the t=\r\nerms, not some\nidea of object or function when requesting, accepting, and p=\r\narsing\nresponses. I make no promise that URL X will return object Y. Client=\r\n apps\ntake on the task of parsing the message and then looking at that mess=\r\nage to\nfind the terms (and their associated values) and be prepared to deal=\r\n with\nthem when the appear in a response.\n\nNON-BREAKING CHANGES BASED ON TH=\r\nESE PROMISES\nBecause my service makes promises based on message formats and=\r\n vocabulary\nterms, there are a series of changes that my service can make a=\r\nnd claim as\nnon-breaking:\n- a new optional parameter can now be used to fil=\r\nter requests (e.g.\n&sort=3DfamilyName is now available for an existing sear=\r\nch operation)\n- a new operation exists that returns a summary of existing d=\r\nata (e.g. a\nnew URL w/ new arguments is published)\n- one or more response t=\r\nerms have been moved in the message (e.g. givenName\nis now at the end of th=\r\ne message instead of the top).\n\nClient apps are expected to continue to fun=\r\nction under the above\ncircumstances. That means client apps need to refrain=\r\n from memorizing the\n&quot;shape&quot; of responses or assuming certain values or ter=\r\nms will ALWAYS appear\nin responses in the EXACT SAME PLACE as they did in t=\r\nhe past. That means\nstrong schema-checking for inbound messages doesn&#39;t hel=\r\np -- actually hurts\n-- client apps. It also means client apps need to safel=\r\ny ignore things they\ndon&#39;t recognize in responses. Ultimately, this means c=\r\nlient apps are coded\n&quot;defensively&quot; and must be implemented in a way that ac=\r\ncounts for minor\nchanges like those listed here.\n\nPOSTEL&#39;S LAW, RULE OF ROB=\r\nUSTNESS\nThis is the embodiment of Postel&#39;s Law: &quot;Be conservative in what yo=\r\nu send,\nbe liberal in what you accept.&quot; HTML browsers work this way today. =\r\nI don&#39;t\nsee examples of these kinds of client apps being talked about much =\r\nin the\npublic space. Most of the time web API clients are implemented as sc=\r\nripted,\nstatic consumers of strongly-typed response objects guaranteed agai=\r\nnst\npre-defined URLs. When that happens, even the smallest change in a requ=\r\nest\nor response body and cause the client app fail.\n\n\n\n\n\n\nmamund\n+1.859.757=\r\n.1449\nskype: mca.amundsen\nhttp://amundsen.com/blog/\nhttp://twitter.com/mamu=\r\nnd\nhttps://github.com/mamund\nhttp://linkedin.com/in/mamund\n\n\nOn Sat, Aug 16=\r\n, 2014 at 11:48 PM, Kevin Duffey andjarnic@...\n[rest-discuss] &lt;rest-d=\r\niscuss-noreply@yahoogroups.com&gt; wrote:\n\n&gt;\n&gt;\n&gt;  Hi all,\n&gt;\n&gt; I&#39;ve been readin=\r\ng up quite a bit on versioning, HATEOAS, forward/backward\n&gt; compatibility c=\r\nhanges and versioning, etc with REST APIs. Some recent docs\n&gt; are suggestin=\r\ng that more people are using versioning in the URI but only\n&gt; for major ver=\r\nsion changes of the entire API and update the version very\n&gt; rarely. I fall=\r\n into the camp that the resource URI should not be versioned,\n&gt; instead usi=\r\nng the Accept header and version the media-type (conneg).\n&gt;\n&gt; I do have a c=\r\nouple of questions though around all this.\n&gt;\n&gt; From some stuff I&#39;ve read, i=\r\nt sounded like if I have a version 1 XML\n&gt; document, with say &lt;a&gt;&lt;b&gt;data&lt;/b=\r\n&gt;&lt;/a&gt;, and that was public, and then I\n&gt; wanted to add a new element to tha=\r\nt doc (representation) (e.g.\n&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt; or &lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;), exis=\r\nting clients should not break\n&gt; because they would simply ignore the newly =\r\nadded element. However, I am\n&gt; seeing something somewhat different, in that=\r\n we support JSON and XML, and\n&gt; in some cases, we&#39;re seeing exceptions when=\r\n the new document is trying to\n&gt; be marshaled into a POJO object. I should =\r\nsay that we provide an XSD\n&gt; document that is used by our server side as we=\r\nll as clients to generate\n&gt; POJOs. We do so with Python and Java presently,=\r\n but I assume any language\n&gt; could take our XSD and generate POJOs, then us=\r\ne those when\n&gt; marshaling/un-marshaling representations. So it seems, at le=\r\nast with XML,\n&gt; there may be a way (I don&#39;t know off hand) to &quot;relax&quot; the r=\r\nequirement for\n&gt; newly added elements to match the generated POJO objects, =\r\nsuch that a\n&gt; client with our first version could actually receive the 2nd =\r\nversion\n&gt; document, but would only see the elements that their first versio=\r\nn POJO\n&gt; understood during the marshaling process. Hope that makes sense. A=\r\nnyway, I\n&gt; am confused if this is how it should be, with both XML and JSON,=\r\n or if the\n&gt; exception we&#39;re seeing means that our clients MUST indicate ve=\r\nrsion 2 of\n&gt; the representation?\n&gt;\n&gt; I think the right answer is that ALL o=\r\nf our resources should always\n&gt; require the Accept header to include the ve=\r\nrsion of the document, and from\n&gt; day one, it should be v1, so that when v2=\r\n comes out, existing clients are\n&gt; still using v1 (and we return v1 to them=\r\n), but those clients that know\n&gt; about v2, can update their clients to requ=\r\nest the v2 representation. At\n&gt; least from all that I&#39;ve read, this seems s=\r\nafer than assuming a client\n&gt; using our XSDs to generate POJOs to use in th=\r\neir language, will get a\n&gt; properly marshaled v2 representation within a v1=\r\n POJO.\n&gt;\n&gt; Along similar lines.. when we add new items to an existing doc, =\r\nthen it&#39;s\n&gt; correct to bump the version value to get the new representation=\r\n.. right?\n&gt; That is, we&#39;re currently working through a beta program and we&#39;=\r\nre taking\n&gt; customer feedback to adjust/add/fix/remove/etc various API reso=\r\nurce\n&gt; representations. During this cycle, some of our customers are still =\r\nusing\n&gt; version 1, some moved to version 2, and we&#39;re working on version 3 =\r\nnow. Is\n&gt; it &quot;ok&quot; to keep bumping the version in this case? At some point w=\r\ne&#39;ll\n&gt; release a GA and whatever version that is, stays in GA. However, our=\r\n goal\n&gt; is to move to a more rapid release schedule, such that we may be ad=\r\nding\n&gt; features (new resources) along with updating (extending/adding to) e=\r\nxisting\n&gt; resources (their representations). As we do this, I assume we sho=\r\nuld be\n&gt; bumping the versions of the specific resource representations that=\r\n change\n&gt; (be it add, change or remove elements from the representation).. =\r\ndoes that\n&gt; make sense?\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; \n&gt;\n\r\n--bcaec53f3823f0c560050166be1f\r\nContent-Type: text/html; charset=UTF-8\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;div dir=3D&quot;ltr&quot;&gt;Kevin:&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Your post covers a topic that co=\r\nmes up quite often in my discussion w/ devs (both server- and client-side).=\r\n My answer to the questions about how to handle &quot;change over time&quot=\r\n; may not be quite what you are looking for. But I decided to pass it along=\r\n anyway as it has helped me quite a bit over the last several years in deal=\r\ning with the problem.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;TL;DNR&lt;/div&gt;&lt;div&gt;- Always =\r\nmake your service changes backward-compatible&lt;/div&gt;&lt;div&gt;- Services should p=\r\nromise to never take anything away, never change processing of inputs, and =\r\nalways make new elements optional&lt;/div&gt;\n\n&lt;div&gt;- Services should only promis=\r\ne to return message formats (like HTML, HAL, etc.) using pre-defined terms =\r\n(e.g. &quot;givenName&quot;, &quot;familyName&quot;) and not promise any fu=\r\nnctions to execute or objects in return&lt;/div&gt;\n\n&lt;div&gt;- Client apps should no=\r\nt use schema to constrain incoming messages, should code defensively, and b=\r\ne designed to inspect incoming message for desired terms, not designed to d=\r\neserialize objects or execute remote functions.&lt;/div&gt;\n\n&lt;div&gt;- Essentially, =\r\nboth client and server should abide by Postel&#39;s Law=C2=A0&lt;/div&gt;&lt;div&gt;&lt;br=\r\n&gt;&lt;/div&gt;&lt;div&gt;Doing this reduces the need to use &quot;versioning&quot; to se=\r\nparate one service instance from another and can make services useful to cl=\r\nient apps for quite a long time w/o the need to &quot;fork&quot; the servic=\r\ne and clients.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Hopefully this gives you some ide=\r\nas on how to deal with changes in APIs.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Cheers.&lt;/d=\r\niv&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Here&#39;s the long version.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;di=\r\nv&gt;BACKWARD-COMPATIBLE&lt;/div&gt;\n\n&lt;div&gt;First, I start from the POV that all chan=\r\nges will be backward-compatible. IOW, no change in the future will invalida=\r\nte the past. This is how both HTTP and HTML have been working over the last=\r\n couple decades. HTTP 1.0, 1.1 and lots of changes in between (PATCH, LINK =\r\nmethods, new headers, etc.) are implemented in a way that doesn&#39;t break=\r\n existing implementations.=C2=A0&lt;/div&gt;\n\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;THREE PROMISE=\r\nS&lt;/div&gt;&lt;div&gt;Next, any assurances/promises my service makes to clients is ba=\r\nsed on this First Principle of &quot;no breaking changes.&quot; That means =\r\nit is important for me to be clear about what I promise going forward. My p=\r\nromise will shape what the client expects as non-breaking. =C2=A0And here a=\r\nre my promises to client apps that implement my service API&lt;/div&gt;\n\n\n&lt;div&gt;1 =\r\n- i will never &quot;take anything away&quot; So, any URL I promise will ei=\r\nther a) still exists or b) be redirected. Any parameters I describe for URL=\r\n queries or request bodies will always be accepted. Any parameters describe=\r\nd in a response body will always be there.&lt;/div&gt;\n\n\n\n&lt;div&gt;2 - I will never c=\r\nhange the processing/meaning of parameters. So, if i promise the parameter =\r\n&quot;count&quot; represents the number of users in a list, I will not chan=\r\nge this at some future point such that &quot;count&quot; represents the num=\r\nber of pages in a collection, etc.&lt;/div&gt;\n\n\n\n&lt;div&gt;3 - Any new elements I int=\r\nroduce will be optional. I will not create new *required* parameters for pr=\r\neviously promised requests. If i need to create new requirements, I will cr=\r\neate a new promise and that promise will be optional for any existing imple=\r\nmentations.&lt;/div&gt;\n\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;PROMISE MESSAGES AND TERMS NOT FUN=\r\nCTIONS AND OBJECTS&lt;/div&gt;&lt;div&gt;Next, my service almost never promise to retur=\r\nn an object like a &quot;user&quot; or &quot;customer&quot;, etc. Instead, =\r\nmy service promises to return a message in one or more formats -- message f=\r\normats like HTML, HAL, Collection+JSON, Siren, etc. Each of these formats h=\r\nave their own rules about what is legal, what is required, etc. and my serv=\r\nice will always honor those promises (from the format designers).&lt;/div&gt;\n\n\n&lt;=\r\ndiv&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;My service publishes a list of valid vocabulary terms th=\r\nat can be returned within messages. Terms like &quot;givenName&quot;, &quot=\r\n;familyName&quot;, etc. The vocabulary also includes action terms such as &=\r\nquot;update&quot;, &quot;create&quot;, &quot;share&quot;, &quot;move&quot;,=\r\n &quot;copy&quot; or whatever other terms make sense for this service space=\r\n. Client applications need to be able to recognize and process these terms =\r\nwhen the appear.&lt;/div&gt;\n\n\n&lt;div&gt;=C2=A0&lt;/div&gt;&lt;div&gt;This means client apps need =\r\nto focus on the message and the terms, not some idea of object or function =\r\nwhen requesting, accepting, and parsing responses. I make no promise that U=\r\nRL X will return object Y. Client apps take on the task of parsing the mess=\r\nage and then looking at that message to find the terms (and their associate=\r\nd values) and be prepared to deal with them when the appear in a response.&lt;=\r\nbr&gt;\n\n\n&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;NON-BREAKING CHANGES BASED ON THESE PROMISE=\r\nS&lt;/div&gt;&lt;div&gt;Because my service makes promises based on message formats and =\r\nvocabulary terms, there are a series of changes that my service can make an=\r\nd claim as non-breaking:&lt;/div&gt;\n\n\n&lt;div&gt;- a new optional parameter can now be=\r\n used to filter requests (e.g. &amp;sort=3DfamilyName is now available for =\r\nan existing search operation)&lt;/div&gt;&lt;div&gt;- a new operation exists that retur=\r\nns a summary of existing data (e.g. a new URL w/ new arguments is published=\r\n)&lt;/div&gt;\n\n\n&lt;div&gt;- one or more response terms have been moved in the message =\r\n(e.g. givenName is now at the end of the message instead of the top).&lt;/div&gt;=\r\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Client apps are expected to continue to function under =\r\nthe above circumstances. That means client apps need to refrain from memori=\r\nzing the &quot;shape&quot; of responses or assuming certain values or terms=\r\n will ALWAYS appear in responses in the EXACT SAME PLACE as they did in the=\r\n past. That means strong schema-checking for inbound messages doesn&#39;t h=\r\nelp -- actually hurts -- client apps. It also means client apps need to saf=\r\nely ignore things they don&#39;t recognize in responses. Ultimately, this m=\r\neans client apps are coded &quot;defensively&quot; and must be implemented =\r\nin a way that accounts for minor changes like those listed here.&lt;/div&gt;\n\n&lt;di=\r\nv&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;POSTEL&#39;S LAW, RULE OF ROBUSTNESS&lt;br&gt;This is the embodi=\r\nment of Postel&#39;s Law: &quot;Be conservative in what you send, be libera=\r\nl in what you accept.&quot; HTML browsers work this way today. I don&#39;t =\r\nsee examples of these kinds of client apps being talked about much in the p=\r\nublic space. Most of the time web API clients are implemented as scripted, =\r\nstatic consumers of strongly-typed response objects guaranteed against pre-=\r\ndefined URLs. When that happens, even the smallest change in a request or r=\r\nesponse body and cause the client app fail.&lt;br&gt;\n\n&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;=\r\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n&lt;/div&gt;&lt;div class=3D&quot;gmail_extra&quot;&gt;&lt;=\r\nbr clear=3D&quot;all&quot;&gt;&lt;div&gt;&lt;div dir=3D&quot;ltr&quot;&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;mamund&lt;div&gt;&lt;span&gt;&lt;spa=\r\nn title=3D&quot;Call with Google Voice&quot;&gt;&lt;span title=3D&quot;Call with Google Voice&quot;&gt;+=\r\n1.859.757.1449&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;skype: mca.amundsen&lt;br&gt;\n\n&lt;a href=3D&quot;=\r\nhttp://amundsen.com/blog/&quot; target=3D&quot;_blank&quot;&gt;http://amundsen.com/blog/&lt;/a&gt;&lt;=\r\nbr&gt;&lt;a href=3D&quot;http://twitter.com/mamund&quot; target=3D&quot;_blank&quot;&gt;http://twitter.c=\r\nom/mamund&lt;/a&gt;&lt;br&gt;&lt;a href=3D&quot;https://github.com/mamund&quot; target=3D&quot;_blank&quot;&gt;ht=\r\ntps://github.com/mamund&lt;/a&gt;&lt;br&gt;\n\n&lt;a href=3D&quot;http://linkedin.com/in/mamund&quot; =\r\ntarget=3D&quot;_blank&quot;&gt;http://linkedin.com/in/mamund&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;br&gt;&lt;=\r\nbr&gt;&lt;div class=3D&quot;gmail_quote&quot;&gt;On Sat, Aug 16, 2014 at 11:48 PM, Kevin Duffe=\r\ny &lt;a href=3D&quot;mailto:andjarnic@...&quot;&gt;andjarnic@...&lt;/a&gt; [rest-disc=\r\nuss] &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a href=3D&quot;mailto:rest-discuss-noreply@yahoogrou=\r\nps.com&quot; target=3D&quot;_blank&quot;&gt;rest-discuss-noreply@yahoogroups.com&lt;/a&gt;&gt;&lt;/spa=\r\nn&gt; wrote:&lt;br&gt;\n\n&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;margin:0 0 0 .8ex=\r\n;border-left:1px #ccc solid;padding-left:1ex&quot;&gt;\n\n\n\n\n\n\n        \n&lt;div&gt;\n\n\n\n\n&lt;br=\r\n&gt;&lt;br&gt;\n\n\n\n\n&lt;div style=3D&quot;color:#000;background-color:#fff;font-family:Helvet=\r\nicaNeue,Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-size:1=\r\n2pt&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;div style=3D&quot;color:rgb(0,0,0);font-family:HelveticaNeue,&#3=\r\n9;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;fo=\r\nnt-size:12pt;background-color:rgb(255,255,255)&quot;&gt;\n\n&lt;div&gt;Hi all,&lt;/div&gt;&lt;div&gt;&lt;b=\r\nr&gt;&lt;/div&gt;&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:Helvetica=\r\nNeue,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-=\r\nserif;font-style:normal;background-color:transparent&quot;&gt;\n\nI&#39;ve been readi=\r\nng up quite a bit on versioning, HATEOAS, forward/backward compatibility ch=\r\nanges and versioning, etc with REST APIs. Some recent docs are suggesting t=\r\nhat\n more people are using versioning in the URI but only for major version=\r\n changes of the entire API and update the version very rarely. I fall into =\r\nthe camp that the resource URI should not be versioned, instead using the A=\r\nccept header and version the media-type\n (conneg).=C2=A0&lt;/div&gt;&lt;div style=3D=\r\n&quot;color:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue,&#39;Helvetica N=\r\neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;font-style:norm=\r\nal;background-color:transparent&quot;&gt;&lt;br&gt;&lt;/div&gt;\n\n&lt;div style=3D&quot;color:rgb(0,0,0)=\r\n;font-size:16px;font-family:HelveticaNeue,&#39;Helvetica Neue&#39;,Helvetic=\r\na,Arial,&#39;Lucida Grande&#39;,sans-serif;font-style:normal;background-col=\r\nor:transparent&quot;&gt;I do have a couple of questions though around all this.&lt;/di=\r\nv&gt;\n\n&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue=\r\n,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-seri=\r\nf;font-style:normal;background-color:transparent&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=3D&quot;c=\r\nolor:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue,&#39;Helvetica Neu=\r\ne&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;font-style:normal=\r\n;background-color:transparent&quot;&gt;\n\nFrom some stuff I&#39;ve read, it sounded =\r\nlike if I have a version 1 XML document, with say &lt;a&gt;&lt;b&gt;data&lt=\r\n;/b&gt;&lt;/a&gt;, and that was public, and then I wanted to add a new elem=\r\nent to that doc (representation) (e.g. &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&=\r\ngt; or &lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;), existing clients =\r\nshould not break because they would simply ignore the newly added element. =\r\nHowever, I am seeing something somewhat different, in that we support JSON =\r\nand XML, and in some cases, we&#39;re seeing exceptions when the new docume=\r\nnt is trying to be marshaled into a POJO object. I should say that we provi=\r\nde an XSD document that is used by our server side as well as clients to ge=\r\nnerate POJOs. We do\n so with Python and Java presently, but I assume any la=\r\nnguage could take our XSD and generate POJOs, then\n use those when marshali=\r\nng/un-marshaling representations. So it seems, at least with XML, there may=\r\n be a way (I don&#39;t know off hand) to &quot;relax&quot; the requirement =\r\nfor newly added elements to match the generated POJO objects, such that a c=\r\nlient with our first version could actually receive the 2nd version documen=\r\nt, but would only see the elements that their first version POJO understood=\r\n during the marshaling process. Hope that makes sense. Anyway, I am confuse=\r\nd if this is how it should be, with both XML and JSON, or if the exception =\r\nwe&#39;re seeing means that our clients MUST indicate version 2 of the repr=\r\nesentation?&lt;/div&gt;\n\n&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-famil=\r\ny:HelveticaNeue,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande=\r\n&#39;,sans-serif;font-style:normal;background-color:transparent&quot;&gt;&lt;br&gt;&lt;/div&gt;=\r\n&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue,&#3=\r\n9;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;fo=\r\nnt-style:normal;background-color:transparent&quot;&gt;\n\nI think the right answer is=\r\n that ALL of our resources should always require the Accept header to inclu=\r\nde the version of the document, and from day one, it should be v1, so that =\r\nwhen v2 comes out, existing clients are still using v1 (and we return v1 to=\r\n them), but those clients that know about v2, can update their clients to r=\r\nequest the v2 representation. At least from all that I&#39;ve read, this se=\r\nems safer than assuming a client using our XSDs to generate POJOs to use in=\r\n their language, will get a properly marshaled v2 representation within a v=\r\n1 POJO.&lt;/div&gt;\n\n&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:He=\r\nlveticaNeue,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39=\r\n;,sans-serif;font-style:normal;background-color:transparent&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div=\r\n style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue,&#39;He=\r\nlvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;font-s=\r\ntyle:normal;background-color:transparent&quot;&gt;\n\nAlong similar lines.. when we a=\r\ndd new items to an existing doc, then it&#39;s correct to bump the version =\r\nvalue to get the new representation.. right? That is, we&#39;re currently w=\r\norking through a beta program and we&#39;re taking customer feedback to adj=\r\nust/add/fix/remove/etc various API resource representations. During this cy=\r\ncle, some of our customers are still using version 1, some moved to version=\r\n 2, and we&#39;re working on version 3 now. Is it &quot;ok&quot; to keep bu=\r\nmping the version in this case? At some point we&#39;ll release a GA and wh=\r\natever version that is, stays in GA. However, our goal\n is to move to a mor=\r\ne rapid release schedule, such that we may be adding features (new resource=\r\ns) along with\n updating (extending/adding to) existing resources (their rep=\r\nresentations). As we do this, I assume we should be bumping the versions of=\r\n the specific resource representations that change (be it add, change or re=\r\nmove elements from the representation).. does that make sense?&lt;/div&gt;\n\n&lt;div =\r\nstyle=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:HelveticaNeue,&#39;Hel=\r\nvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;font-st=\r\nyle:normal;background-color:transparent&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=3D&quot;color:rgb(=\r\n0,0,0);font-size:16px;font-family:HelveticaNeue,&#39;Helvetica Neue&#39;,He=\r\nlvetica,Arial,&#39;Lucida Grande&#39;,sans-serif;font-style:normal;backgrou=\r\nnd-color:transparent&quot;&gt;\n\n&lt;br&gt;&lt;/div&gt;&lt;div style=3D&quot;color:rgb(0,0,0);font-size:=\r\n16px;font-family:HelveticaNeue,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#3=\r\n9;Lucida Grande&#39;,sans-serif;font-style:normal;background-color:transpar=\r\nent&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=3D&quot;color:rgb(0,0,0);font-size:16px;font-family:He=\r\nlveticaNeue,&#39;Helvetica Neue&#39;,Helvetica,Arial,&#39;Lucida Grande&#39=\r\n;,sans-serif;font-style:normal;background-color:transparent&quot;&gt;\n\n&lt;br&gt;&lt;/div&gt;&lt;/=\r\ndiv&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n\n\n\n\n\n&lt;br&gt;\n\n\n&lt;br&gt;\n\n\n\n\n&lt;div width=3D&quot;1&quot; style=3D&quot;color=\r\n:white;clear:both&quot;&gt;&lt;/div&gt;\n&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;\n\r\n--bcaec53f3823f0c560050166be1f--\r\n\n"}}