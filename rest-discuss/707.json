{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":87113616,"authorName":"S. Mike Dierken","from":"&quot;S. Mike Dierken&quot; &lt;mdierken@...&gt;","profile":"mdierken","replyTo":"SENDER","senderId":"yp_WTmD7nbkhOET9R7PV49Er4Nc_UB5YMUrIwtDPClZwpXF-4O1akAdjgcuP9GopreAW0GpPhgIBtk7LqXoS7PccYBMrjOTIRSPm41e30w","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] RFC: Part 2","postDate":"1013398950","msgId":707,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PE9FMTVKdldxQk9WekV3dHVjaFEwMDAwNDMxYUBob3RtYWlsLmNvbT4=","referencesHeader":"PDNDNjcyNTc5LjY0Mzc4RDJEQHByZXNjb2QubmV0Pg=="},"prevInTopic":706,"nextInTopic":709,"prevInTime":706,"nextInTime":708,"topicId":706,"numMessagesInTopic":3,"msgSnippet":"... From: Paul Prescod  ... [mike] triumvirate - quite the ten-dollar word, how about trio ... [mike] Similarly to what? ... [mike]","rawEmail":"Return-Path: &lt;mdierken@...&gt;\r\nX-Sender: mdierken@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_2); 11 Feb 2002 03:35:58 -0000\r\nReceived: (qmail 53769 invoked from network); 11 Feb 2002 03:35:58 -0000\r\nReceived: from unknown (216.115.97.167)\n  by m10.grp.snv.yahoo.com with QMQP; 11 Feb 2002 03:35:58 -0000\r\nReceived: from unknown (HELO hotmail.com) (64.4.16.119)\n  by mta1.grp.snv.yahoo.com with SMTP; 11 Feb 2002 03:35:57 -0000\r\nReceived: from mail pickup service by hotmail.com with Microsoft SMTPSVC;\n\t Sun, 10 Feb 2002 19:35:57 -0800\r\nTo: &lt;rest-discuss@yahoogroups.com&gt;,\n\t&quot;Paul Prescod&quot; &lt;paul@...&gt;\r\nReferences: &lt;3C672579.64378D2D@...&gt;\r\nSubject: Re: [rest-discuss] RFC: Part 2\r\nDate: Sun, 10 Feb 2002 19:42:30 -0800\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 5.50.4133.2400\r\nX-MimeOLE: Produced By Microsoft MimeOLE V5.50.4133.2400\r\nMessage-ID: &lt;OE15JvWqBOVzEwtuchQ0000431a@...&gt;\r\nX-OriginalArrivalTime: 11 Feb 2002 03:35:57.0864 (UTC) FILETIME=[37D16280:01C1B2AD]\r\nFrom: &quot;S. Mike Dierken&quot; &lt;mdierken@...&gt;\r\nX-Yahoo-Group-Post: member; u=87113616\r\nX-Yahoo-Profile: mdierken\r\n\r\n\n----- Original Message -----\nFrom: &quot;Paul Prescod&quot; &lt;paul@...&gt;\n\n\n&gt; The first part is at xml.com. I&#39;d like comments on the second part to be\n&gt; published later this week. Thanks in advance!\n&gt; ====\n&gt; REST, Resource Modeling and the Real World\n&gt;\n&gt; In the last article I described a new model for Web Services\n&gt; construction. It is called REpresentational State Transfer and applies\n&gt; the principles of the Web to transaction-oriented services, rather than\n&gt; publishing-oriented sites. When we apply the strategy in the real world,\n&gt; we do so using Web technologies such as URIs, HTTP and XML. Unlike the\n&gt; current generation of Web Services technologies, however, we make those\n&gt; three technologies central rather than peripheral. We rethink our web\n&gt; service interface in terms of URIs, HTTP and XML. It is this rethinking\n&gt; that takes our web services beyond the capabilities of the first\n&gt; generation.\n&gt;\n&gt; In this article I want to discuss the applicability of several industry\n&gt; buzzwords such as reliability, workflow, orchestration, security,\n&gt; asynchrony, auditing and so forth. Intuitively, it seems that the Web\n&gt; technologies are not sophisticated enough to handle the requirements for\n&gt; large-scale inter-business commerce. Those who think of HTTP as a\n&gt; simple, unidirectional GET and POST protocol will be especially\n&gt; surprised to learn how sophisticated it can be.\n&gt;\n&gt; Quick Review\n&gt;\n&gt; REST is a model for distributed computing. It is the one used by the\n&gt; world&#39;s biggest distributed computing application, the Web. When applied\n&gt; to web services technologies, it usually depends on a triumvirate of\n[mike] &#39;triumvirate&#39; - quite the ten-dollar word, how about &#39;trio&#39;\n\n&gt; technologies designed to be extremely extensible: XML, URIs and HTTP.\n&gt; XML&#39;s extensibility should be obvious to this most, but the other two\n&gt; may not be.\n&gt;\n&gt; Similarly there are an infinite possible of possible URIs.\n[mike] Similarly to what?\n\n&gt; But, more\n&gt; important, they can apply to an infinite number of logical entities\n&gt; called &quot;Resources&quot;. URIs are just their addresses.\n[mike] it&#39;d be neat to have a &#39;sidebar&#39; talking about &#39;names .vs. addresses&#39;\n\n&gt; Some REST advocates\n&gt; call the process of bringing your applications into this model Resource\n&gt; Modeling. This process is not yet as formal as object oriented modeling\n&gt; or entity-relation modeling but it is related to those. The strength and\n&gt; flexibility of REST comes from the creative use of URIs.\n[mike] &#39;creative&#39; implies un-designed, how about &#39;consistent&#39; or &#39;strong&#39; or\n&#39;intelligent&#39; or something positive.\n\n&gt;\n&gt; HTTP&#39;s extensibility stems primarily from the ability to distribute any\n&gt; payload with predefined or new headers using predefined or (on occasion)\n&gt; new methods. What makes HTTP really special among all protocols,\n&gt; however, is its implicit understanding of URIs and resources.\n[mike] is it &#39;implicit understanding&#39; or &#39;central focus&#39;/whatever?\n\n&gt; URIs are\n&gt; the defining characteristic of the Web: the glue that makes it work and\n&gt; scale. HTTP as a protocol keeps them front and center by defining all\n&gt; methods as operations on URI-addressed resources.\n&gt;\n&gt; Auditing and Securing REST Web Services\n&gt;\n&gt; The most decisive difference between web services and previous\n&gt; distributed computing problems is that web services must be designed to\n&gt; work across organizational boundaries. Of course, this is also one of\n&gt; the defining characteristics of the Web. This difference has serious\n&gt; implications with respect to security, auditing and performance. At the\n&gt; core of the Web&#39;s solution to these problems is the same construct that\n&gt; is at the core of the Web&#39;s solution to everything: URIs. By modeling\n&gt; the right combination of resources, addressed through URIs, we can build\n&gt; extremely secure systems.\n&gt;\n&gt; In the previous article I discussed how it is possible to use ACLs to\n&gt; secure services which use URIs as their organizational model.\n&gt; Administrators can apply ACLs to the service itself and to every\n&gt; document that passes through the service, because each of them would\n&gt; have a URI. As two business partners work their way through a process,\n&gt; each step would be represented by a new document with an attached ACL.\n&gt; Other partners (or auditors) could be given access to this document\n&gt; later merely by manipulating the ACLs. Another model for security is\n&gt; called capabilities. This less popular model is more flexible than ACLs\n[mike] popular -&gt; prevalent (it isn&#39;t as widely known, so &#39;popularity&#39; isn&#39;t\nquite correct - KragenS might be able to provide more detail on how it ties\nin with ReST)\n\n&gt; and is nevertheless compatible with second-generation Web Services.\n&gt;\n&gt; In the REST model, both business partners would have a shared view of\n&gt; the URI-space representing the process. Rather than sending each other\n&gt; business documents through an email-style pipe, they would put them on\n&gt; mutually visible websites with shared URIs and passwords. These could be\n&gt; easily checked for discrepancies. Third parties can be brought into the\n&gt; process (perhaps for auditing) merely by pointing them at one or both of\n&gt; the URIs. Standard HTTPS and HTTP authentication and authorization would\n&gt; be sufficient to keep intruders from also being able to look at the\n&gt; documents.\n&gt;\n&gt; Of course HTTP-based Web Services can go through firewalls easily. But\n&gt; that is the only point of similarity with RPC tunnels through HTTP such\n[mike] &#39;rpc tunnels through http&#39; -&gt; &#39;rpc tunneling through http&#39; (&#39;tunnel&#39;\nis both verb and noun, would be nice to clarify)\n\n&gt; as XML-RPC or SOAP-RPC over HTTP. When you use HTTP over a firewall, you\n&gt; are being very explicit about what is going on. Your system\n&gt; administrator can look at her logs to determine what services are\n[mike] &#39;her&#39; -&gt; &#39;the&#39; (overly p.c. is distracting for me...)\n\n&gt; running and who is accessing them. She can disable PUT or POST to make\n&gt; certain parts of the service read-only. She can use standard filtering\n&gt; and hacker detection tools. When you use HTTP you and the system\n&gt; administrator are on the same team.\n&gt;\n&gt; Conversely, when you tunnel XML-RPC or SOAP through a firewall, you are\n&gt; deliberately subverting her work and reducing the efficacy of her tools.\n&gt; Because you are hiding your real actions in the XML body, you make it\n&gt; much harder for her to use standard filtering tools. This greatly\n&gt; expands the opportunity for new security holes!\n&gt;\n&gt; Service Context\n&gt;\n&gt; People building web services often complain that the &quot;tricky bit&quot; of web\n&gt; services is maintaining shared context. For instance, context might\n&gt; include:\n&gt;\n&gt; Where are we in this business process?\n&gt; What transactions have we done in the past?\n&gt; Are there any resources that I promise to hold for you?\n&gt; Are there any notifications I promise to deliver to you later?\n&gt; What permissions do you have?\n&gt;\n&gt; There are three main ways that two partners can share context. One is to\n&gt; send the entire context with every message. This is obviously not very\n&gt; scalable. As the relationship deepens the context will grow larger and\n&gt; larger. Another option is to merely require each partner to keep context\n&gt; privately and presume that the other partner has the same idea of\n&gt; context. As you can imagine, this is quite unreliable. A network hiccup\n&gt; or programming bug could make the contexts diverge. The mechanism used\n&gt; on the Web today is to assign URIs to the context. For instance on\n&gt; Expedia there is a &quot;My Itinerary&quot; URI for each individual. Within that,\n&gt; every purchase you have recently made has its own URI. While you are\n&gt; purchasing a new ticket, each step in the process is represented by\n&gt; another URI.\n&gt;\n&gt; The same principle applies to business-to-business processes. Of course\n&gt; there will be some differences. Typically the canonical format for\n&gt; context in a business process with be XML. HTML will be generated as a\n&gt; view on that XML. But do not underestimate the importance of that\n&gt; human-readable view! Business partners will probably be careful to store\n&gt; a copy of the context in case of network outage, programming bug or\n&gt; outright fraud.\n&gt;\n&gt; This is precisely what the HTTP and the REST model were designed to\n&gt; allow. Remember that REST stands for REpresentational State Transfer.\n&gt; The HTTP client transfers the state (the context) from the server to the\n&gt; client using a representation like XML or HTML (depending on its needs).\n&gt; Context information can be linked together with XLink or RDF.\n[mike] A bit esoteric a bit quick for the typical crowd - may need to start\nslow with just mentioning &#39;urls&#39; and &#39;href&#39; attributes, and get into\nXLink/XPointer/etc later (I don&#39;t know how RDF is a linking enabler..)\n\n&gt; Each bit\n&gt; of it can be individually secured using ACLs or capabilities. This\n&gt; mechanism for handling context seems so obvious to me as to be near\n&gt; inevitable.\n&gt;\n&gt; Orchestration\n&gt;\n&gt; Every method that can be invoked on a resource or service is a possible\n&gt; connector between the client and the service. If there are a hundred\n&gt; methods then there are a hundred connectors. If every service has a\n&gt; hundred different methods then your connections become very complex -\n&gt; essentially point-to-point integrations rather than reusable patterns.\n&gt;\n&gt; There are various systems in the computing world that have proven the\n&gt; power of having just a few methods rather than many. For instance, every\n&gt; true Unix hacker knows that the command line is incredibly powerful\n&gt; because it is possible to pipe data from one process to another using\n&gt; the redirection &quot;methods&quot;, &quot;&gt;&quot;, &quot;&gt;&gt;&quot;, &quot;&lt;&quot;. The other Unix command line\n&gt; tools act as standardized filters and transformers connected by these\n&gt; methods.\n&gt;\n&gt; Similarly, if you think of a SQL table as a resource, the methods SQL\n&gt; makes available are only SELECT, UPDATE, INSERT and DELETE. The rest of\n&gt; SQL is a set of transformers and filters that allow you to combine these\n&gt; methods into services. .NET My Services has Query, Insert, Replace,\n&gt; Update and Delete. As I showed in the last article, UDDI has get_*,\n&gt; delete_* and save_*. This pattern is ubiquitous.\n[mike] &#39;this pattern is ...&#39; -&gt; &#39;this pattern of a small number of methods\non a large amount of data is ...&#39; (can&#39;t hurt to re-iterate the point of\nrest)\n\n&gt;\n&gt; HTTP has GET, PUT, POST and DELETE. Anything that can be done with SOAP\n&gt; RPC or any other RPC can be done with those four methods. In fact, it is\n&gt; precisely because HTTP has few methods that HTTP clients and servers can\n&gt; grow and be extended independently without confusing each other. Rather\n&gt; than invent new methods they find ways to represent new concepts in data\n&gt; structures (increasingly XML data structures) and headers.\n&gt;\n&gt; Now that we&#39;ve boiled down our system to these basic methods, it turns\n&gt; out that we have the beginnings of a web service coordination,\n&gt; orchestration and assembly language. I could imagine defining a new web\n&gt; service as easily as:\n&gt;\n&gt; i = GET http://www.stockquotes.com/xmlquotes?IBM\n&gt; m = GET http://www.stockquotes.com/xmlquotes?MSFT\n&gt; if i &gt; m:\n&gt;     WITH AUTHENTICATION $myuserid $mypassword\n&gt;     POST http://www.etrade.com/stocks/IBM\n&gt; else:\n&gt;     POST http://www.etrade.com/stocks/MSFT\n&gt;\n&gt; Or maybe we don&#39;t need a new language. Perhaps we could incorporate\n&gt; these principles into existing scripting languages. The point is that\n&gt; unifying the method vocabulary of the web provides tremendous\n&gt; opportunities for simplifying interactions. Nobody learning a new web\n&gt; service would ever have to learn the semantics of the various methods\n&gt; again. Web services can be combined through simple Unix-style pipes: GET\n&gt; this, GET that, transform, PUT there.\n&gt;\n&gt; Of course there is no free lunch. Using someone else&#39;s web service\n&gt; requires you to understand their data structures (XML vocabulary and\n&gt; links between documents). But this is true whether we use REST or SOAP\n&gt; RPC. RPC APIs merely hide the problem behind an extra layer of\n&gt; non-standardization. First you must figure out the method names\n&gt; available. Then you must still figure out the data structures that may\n&gt; be used as parameters. And then behind those data structures is the\n&gt; implicit data model of the web service. UDDI has an implicit relational\n&gt; data model. .NET My Services has a concept of a &quot;virtual document&quot;.\n[mike] &#39;virtual document&#39;? really? I gotta check that out...\n\n&gt; The\n&gt; whole thing would be simpler if the implicit data model was directly\n&gt; exposed as XML documents available as URI-addressed resources through\n&gt; HTTP. This in no way dictates the underlying implementation but it is\n&gt; based upon a shared, web-wide data model that allows for easy\n&gt; coordination!\n&gt;\n&gt; Once you begin to orchestrate multiple web services, transaction\n&gt; processing becomes much harder. HTTP does not have a magical solution to\n&gt; this problem but neither do specifications such as SOAP or ebXML. The\n&gt; solutions proposed by the OASIS Business Transactions working group are\n&gt; currently protocol agnostic and should work fine with HTTP, once a\n&gt; binding is formalized. A more complete analysis of their integration\n&gt; with REST would be an interesting project, but it has not been done yet.\n&gt;\n&gt; Asynchrony\n&gt;\n&gt; People often complain that HTTP is not asynchronous. Unfortunately they\n&gt; often mean different things by that term. Most often they compare it to\n&gt; SMTP as an example of an asynchronous protocol. But you could make the\n&gt; case that both are synchronous or asynchronous depending on how you\n&gt; define those terms. Both are synchronous in that you cannot send a\n&gt; message without waiting for a reply from the server. If an SMTP server\n&gt; application is badly written, it can hold a connection open for hours,\n&gt; just as a badly written HTTP web service might. Similarly, both can be\n&gt; considered asynchronous in the sense that servers (HTTP or SMTP) never\n&gt; know when they will get a request from a client.\n[mike] &#39;get&#39; -&gt; &#39;receive&#39; (get might imply proactive processing or polling)\n\n&gt;  Requests are not\n&gt; coordinated in advance. If one HTTP server makes a request to another\n&gt; then it is exactly as synchronous or asynchronous as one SMTP server\n&gt; making a request to another.\n&gt;\n&gt; Email is asynchronous not primarily because of SMTP itself, but the\n&gt; collection of software that does store-and-forward, failure notification\n&gt; and replies. In an XML web services world, much of this must be\n&gt; rewritten to deal with URIs so as to manage shared context. For\n&gt; instance, every message that passes through a web service should\n&gt; probably be given a persistent HTTP URI for auditing purposes.\n&gt; Similarly, the reply-to header should refer to an HTTP resource, not an\n&gt; email address. Although early web services will of course build on\n&gt; whatever software is already available, the vast majority of it will be\n&gt; written from scratch. I feel that it would make little sense to spend\n&gt; the effort adapting a non-Web integrated protocol like SMTP to the Web\n&gt; rather than merely using HTTP.\n&gt;\n&gt; Still, it would require extensions to HTTP to offer all of the features\n&gt; of SMTP (in addition to HTTP&#39;s own unique features). Primarily, HTTP\n&gt; needs a concept of &quot;callback&quot; or &quot;notification&quot;. Although this has been\n&gt; done many times in many places, there is no single standardized way to\n&gt; do this. Software dealing with notifications is not as reusable as other\n&gt; HTTP-based software modules. There is work under progress to correct\n&gt; this situation, under the name &quot;HTTPEvents&quot;. Second, HTTP needs concepts\n&gt; of explicit and implicit store and forward relays, transformational\n&gt; intermediaries and return paths. These may be borrowed from SOAP headers\n&gt; and SOAP Routing. In fact, some REST proponents believe that this is the\n&gt; only part of SOAP that is strongly compatible with the Web and HTTP.\n&gt;\n&gt; In summary, various kinds of asynchrony are certainly possible in HTTP.\n&gt; Many commercial applications have been built using HTTP in a\n&gt; peer-to-peer, asynchronous fashion, by companies as large as Microsoft\n&gt; to as small as KnowNow. But there is active effort standardizing the\n&gt; approach taken on the REST list.\n&gt;\n&gt; Reliability\n&gt;\n&gt; Networks are inherently unreliable and the Internet is an extreme case\n&gt; of this. You must build network-based software to cope with failure no\n&gt; matter what protocol you are using. Nevertheless, a combination of\n&gt; software and protocols can make message delivery more reliable than it\n&gt; would otherwise be. What most people ask for is that a message be\n&gt; delivered if at all possible, and be delivered at most once. If it is\n&gt; not possible to deliver then it should be reported to the application.\n&gt;\n&gt; Writing reliable-delivery software with HTTP is relatively easy. Thanks\n&gt; to the guarantees of TCP, you can always know for sure if you received\n&gt; an appropriate response. If you did not, then in many cases it is safe\n&gt; to repeat the message send, due to the principle of idempotency.\n[mike] another sidebar with concrete examples and &#39;idempotency&#39; would be\ngood here...\n\n&gt; In\n&gt; other cases it takes a slight permutation of the service to make it one\n&gt; that builds upon idempotency. Although this is not rocket science, a\n&gt; full description does take more than a couple of paragraphs.\n&gt;\n&gt; The bottom line is that software written on top of HTTP can make all of\n&gt; the same guarantees that expensive message queuing software can. Once\n&gt; you have done that, the only difference is that the message queuing\n&gt; software builds reliability around a proprietary protocol that cannot\n&gt; (typically) be used between business partners! If you would like to use\n&gt; the message queuing software within your single organization then you\n&gt; can easily tunnel HTTP on top of it and get the best of both worlds.\n&gt;\n&gt; Case Studies\n&gt;\n&gt; Despite its advantages, HTTP-based, URI-centric resource modeling is not\n&gt; a common way of thinking about networking issues and REST-based web\n&gt; services are not very common. On the other hand, useful, scalable,\n&gt; public RPC-based web services are also quite difficult to find. The most\n&gt; obvious examples of HTTP-based web services are actual web sites. Any\n&gt; site that presents a purchasing process as a series of web pages can\n&gt; trivially be changed to do the same thing with XML. People who go\n&gt; through this process get all of the benefits of REST web services and\n&gt; none of the expense of re-implementing their business logic around a\n&gt; SOAP-RPC model.\n&gt;\n&gt; Two businesses that have created (admittedly simple) REST web services\n&gt; are Google and O&#39;Reilly. Google offers to its subscribers the ability to\n&gt; have search results published as XML rather than HTML.  This makes it\n&gt; easy to build various sorts of sophisticated programs on top of Google\n&gt; without worrying about shifting HTML formats. Unfortunately the public\n&gt; version of Google no longer supports the XML feature. Presumably there\n&gt; was some danger it would undermine the banner-based business model!\n&gt; Nevertheless, REST was a natural fit for Google. Essentially all they\n&gt; had to do was change their HTML generating code to XML and they had a\n&gt; Web Service instead of a Web Site.\n&gt;\n&gt; The Meerkat Example\n&gt;\n&gt; O&#39;Reilly&#39;s Meerkat is one of a very few useful, public web services.\n&gt; Unlike the majority of the services described on XMethods, Meerkat is\n&gt; used by thousands of sites every single day.\n&gt;\n&gt; Meerkat uses the three foundation technologies of second-generation web\n&gt; services. It uses a standardized XML vocabulary: RSS. Meerkat would\n&gt; never have become as powerful and scalable if it had invented its own\n&gt; vocabulary. It absolutely depends on the fact that it can integrate\n&gt; information from hundreds of sites that use the RSS vocabulary and the\n&gt; HTTP protocol.\n&gt;\n&gt; In addition to using HTTP and RSS, Meerkat uses URIs as its addressing\n&gt; scheme. It has a very sophisticated URI-based &quot;API&quot; described here:\n&gt; http://www.oreillynet.com/pub/a/rss/2000/05/09/meerkat_api.html\n&gt;\n&gt; Meerkat&#39;s content is also available through an XML-RPC API described in\n&gt; http://www.xml.com/pub/a/2001/07/18/excerpt/xml-rpc.html. Before the\n&gt; REST philosophy was popularized it was not clear that Meerkat&#39;s\n&gt; HTTP/XML-based interface was already a complete web service! It would be\n&gt; an interesting project to compare and contrast these two interfaces in a\n&gt; formal essay.\n&gt;\n&gt; One interesting point, however, is that all of Meerkat&#39;s content\n&gt; aggregation is done through HTTP, not XML-RPC or SOAP. It would be\n&gt; ludicrous to suggest that every content publisher in the world should\n&gt; not only support XML-RPC and SOAP but also some particular set of\n&gt; methods. This would be the situation if instead of inventing the RSS\n&gt; vocabulary the world had standardized the &quot;RSS web service interface.&quot;\n&gt;\n&gt; To be fair, HTTP&#39;s advantages would have been less pronounced if\n&gt; Meerkat&#39;s interaction with these sites had required two-way\n&gt; communication instead of a simple one-way information fetch.\n&gt; Nevertheless, there is nothing particularly difficult about using HTTP\n&gt; in a two-way fashion. It is a virtue of HTTP that it is much easier than\n&gt; other models for one-way (&quot;data publishing&quot;) services and not much\n&gt; harder to use for bi-directional, transactional services.\n&gt;\n&gt; Meerkat shows that when many sites share an XML vocabulary, a protocol\n&gt; and a URI namespace, new services arise organically. It is arguably the\n&gt; first equivalent in the Web Services world to a large-scale, distributed\n&gt; service like Yahoo. Meerkat&#39;s success suggests strongly that the most\n&gt; important enabler of large-scale, distributed web services will be\n&gt; common XML vocabularies.\n&gt;\n&gt; REST limitations\n&gt;\n&gt; There is no free lunch. REST is not a panacea. The biggest problem most\n&gt; will have with REST is that it requires you to rethink your problem in\n&gt; terms of manipulations of addressable resources instead of method calls\n&gt; to a component. Of course you may actually implement it on the server\n&gt; side however you want. But the API you communicate to your clients\n&gt; should be in terms of HTTP manipulations on XML documents addressed by\n&gt; URIs, not in terms of method calls with parameters.\n&gt;\n&gt; Your customers may well prefer a component-based interface to a REST\n&gt; interface. Programmers are more used to APIs and APIs are better\n&gt; integrated into existing programming languages. For client-side\n&gt; programmers, REST is somewhat of a departure although for server-side\n&gt; programmers it is not much different than what they have been doing for\n&gt; the last several years.\n&gt;\n&gt; The client side may get easier in the future. It may be possible to use\n&gt; WSDL to map URIs to logical operations that can in turn be mapped to\n&gt; method calls in a programming language. Although this is described in\n&gt; the WSDL specification, implementations of this feature are few and far\n&gt; between. Even so, RPC will likely always be easier than REST. If a\n&gt; particular problem can be solved with RPC and future extensibility is\n&gt; not an issue then you should certainly use the simpler approach.\n[mike] &#39;use&#39; -&gt; &#39;consider&#39; (don&#39;t recommend an approach that is short term\nand non-interoperable)\n\n&gt;\n&gt; HTTP is also not appropriate in some circumstances. Because HTTP runs on\n&gt; top of TCP, it can have high latency.\n[mike] &#39;high&#39; is relative, give some concrete numbers so people don&#39;t make\ndecisions based on the wrong assumptions\n\n&gt; HTTP is designed primarily for the\n&gt; kind of coarse-grained interactions that are used on the public\n&gt; internet, not the kind of fine-grained ones that might be appropriate on\n&gt; a single desktop, within a department or even in certain enterprise\n&gt; situations. Once again, if DCOM or CORBA solves your fine-grained\n&gt; problem then there is no reason to move to REST. In my opinion, REST\n&gt; will dominate primarily in the world of partner-facing, external Web\n&gt; Services.\n&gt;\n&gt; Why REST is the next Generation\n&gt;\n&gt; Let&#39;s say that ACME Inc sets up a major web service (like UDDI) using\n&gt; the SOAP RPC philosophy. BARTEL Inc. sets up a competing web service\n&gt; using the HTTP philosophy. Customers will gravitate to the REST-based\n&gt; one because it will be simpler on almost every measurable axis: message\n&gt; size, message complexity, number of concepts (URI versus a dozen other\n&gt; naming schemes) and compatibility with their existing systems. The\n&gt; service can be automatically and instantly accessible from any device\n&gt; that can do HTTP and XML. The Context Problem will be much more\n&gt; tractable. Management will appreciate the service&#39;s ease of maintenance,\n&gt; testing and security.\n&gt;\n&gt; But REST will really win out over the long term when the two services\n&gt; try to evolve. The REST-based service uses the most flexible naming and\n&gt; addressing scheme ever invented. It can instantly incorporate a\n&gt; peer-to-peer model by allowing references to data on PCs. When they\n&gt; invent a way to make data on cell phones URI-addressable, every cell\n&gt; phone will be able to integrate data with the service.\n&gt;\n&gt; The rhetoric around web services describes them as &quot;like the web, but\n&gt; for machine to machine communications&quot;. They are said to be a mechanism\n&gt; for publishing processes as the Web published data. REST turns the\n&gt; rhetoric into reality. With REST you really do think of Web Services as\n&gt; a means of publishing information, components and processes. And you\n&gt; really do use the technologies and architecture that make the Web so\n&gt; effective.\n&gt;\n&gt;\n&gt; To unsubscribe from this group, send an email to:\n&gt; rest-discuss-unsubscribe@yahoogroups.com\n&gt;\n&gt;\n&gt;\n&gt; Your use of Yahoo! Groups is subject to http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n&gt;\n\n"}}