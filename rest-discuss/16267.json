{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"agpB9Y9B2cD9LCwA793XfYX47mrsFLYG39JTLMCfYw1OWLzyBvEHYVT2VdTcEf29itpgD41hKWRbU-PBWFU3PdItsXYe_TN-JuDNRdTVxg","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Atom feed vs. list of orders","postDate":"1281593999","msgId":16267,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwODEyMDAxOTU5LjM2ZGFhYzk3LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PERDQzA5QjA2LTNDNzMtNDMxOS05NzVDLTNENENDODEzQzc1QkBtYWMuY29tPg==","referencesHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPgk8RjE5NjI2NDZEM0I2NDY0MkI3QzlBMDYwNjhFRTFFNjQwRTE0Mzg1N0BleDEwLmhvc3RlZGV4Y2hhbmdlLmxvY2FsPgk8RUE2MDczMkMtM0IwMC00NUQ0LThGRDgtMDJFQjFCMjE0NEY1QG1hYy5jb20+CTxGMTk2MjY0NkQzQjY0NjQyQjdDOUEwNjA2OEVFMUU2NDBFMTQzQjExQGV4MTAuaG9zdGVkZXhjaGFuZ2UubG9jYWw+CTxCRTNEODY1OS1CNzYyLTQ3NTktQkM4Qy0xM0I0REE5ODVDNUZAbWFjLmNvbT4JPEFBTkxrVGk9K0x6bk9DdFhma0xVek9CLWFCOEVPWkRyYXNiMzdtV0ItUFd2QkBtYWlsLmdtYWlsLmNvbT4JPDAxMzIzQkEzLTIwNzgtNEM3NS1BRTFCLThEMTg4NUU2NUIwOEBtYWMuY29tPgk8QUFOTGtUaW5OTzNqS3Y4Nj1xPWRtOGVtcVEweFJyaGtUOVBQbmNfN1NkXzgyQG1haWwuZ21haWwuY29tPgk8MzE3RjlBMzQtMUI3QS00QTAxLTkwNjYtRjY5QTZBQjU4ODhDQG1hYy5jb20+CTwyMDEwMDgwNzE3MDQzNC40NGI3ZWVmOC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbjlzRldQQ2ItRUxDU1dOZHRyeTl4dnNpVTRpY0hWV1d6Y1pMb0FAbWFpbC5nbWFpbC5jb20+CTwyMDEwMDgwOTE4MjA0Mi5iMzk0NTI1Yy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbTBPWi09VnN2ejU0OWJabS1vY3dvbnVBWWtlaWU4R3N3RjdZVDNAbWFpbC5nbWFpbC5jb20+CTw0RDUxQTBDQi1ENzJDLTRDRkQtQTVBQy04ODdCM0ZCRjYwNzFAbWFjLmNvbT4JPDIwMTAwODEwMDQyMDA2LjI3NjJiNTAxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPERDQzA5QjA2LTNDNzMtNDMxOS05NzVDLTNENENDODEzQzc1QkBtYWMuY29tPg=="},"prevInTopic":16265,"nextInTopic":16268,"prevInTime":16266,"nextInTime":16268,"topicId":16194,"numMessagesInTopic":86,"msgSnippet":"Media type identifers inform clients what codec or engine to use for deciphering the payload.  Nothing more.  Clients are limited by how recent their","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 93045 invoked from network); 12 Aug 2010 06:20:12 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m12.grp.re1.yahoo.com with QMQP; 12 Aug 2010 06:20:12 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.re1.yahoo.com with SMTP; 12 Aug 2010 06:20:12 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 86E79509DA;\n\tThu, 12 Aug 2010 02:20:11 -0400 (EDT)\r\nDate: Thu, 12 Aug 2010 00:19:59 -0600\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nCc: Peter Williams &lt;pezra@...&gt;, Rest List\n &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100812001959.36daac97.eric@...&gt;\r\nIn-Reply-To: &lt;DCC09B06-3C73-4319-975C-3D4CC813C75B@...&gt;\r\nReferences: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143857@...&gt;\n\t&lt;EA60732C-3B00-45D4-8FD8-02EB1B2144F5@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143B11@...&gt;\n\t&lt;BE3D8659-B762-4759-BC8C-13B4DA985C5F@...&gt;\n\t&lt;AANLkTi=+LznOCtXfkLUzOB-aB8EOZDrasb37mWB-PWvB@...&gt;\n\t&lt;01323BA3-2078-4C75-AE1B-8D1885E65B08@...&gt;\n\t&lt;AANLkTinNO3jKv86=q=dm8emqQ0xRrhkT9PPnc_7Sd_82@...&gt;\n\t&lt;317F9A34-1B7A-4A01-9066-F69A6AB5888C@...&gt;\n\t&lt;20100807170434.44b7eef8.eric@...&gt;\n\t&lt;AANLkTin9sFWPCb-ELCSWNdtry9xvsiU4icHVWWzcZLoA@...&gt;\n\t&lt;20100809182042.b394525c.eric@...&gt;\n\t&lt;AANLkTim0OZ-=Vsvz549bZm-ocwonuAYkeie8GswF7YT3@...&gt;\n\t&lt;4D51A0CB-D72C-4CFD-A5AC-887B3FBF6071@...&gt;\n\t&lt;20100810042006.2762b501.eric@...&gt;\n\t&lt;DCC09B06-3C73-4319-975C-3D4CC813C75B@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Atom feed vs. list of orders\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nMedia type identifers inform clients what codec or engine to use for\ndeciphering the payload.  Nothing more.  Clients are limited by how\nrecent their codec/engine is for the given type, or how fully they\nimplement that type.  Media type identifiers are _not_ meant to say\nanything about the nature of the payload.  Doing so would introduce\ncoupling, violating the layered-system constraint, and result in more\nmedia types than anyone could possibly keep up with, defeating the\nwhole purpose of self-descriptive messaging.\n\nImplementation details, like domain-specific vocabularies, are hidden\nbehind REST&#39;s uniform interface.  REST simply does not care about the\nnature of the information flowing between connectors, only that its\nformat (headers making assertions, possibly about payloads) is obvious\nto anyone who cares to look (self-descriptive messaging) at the headers.\n\nExposing the nature of the payload in media type identifiers is an\nobvious coupling of client to server -- such implementation details\nneed not be, and cannot be, understood by intermediaries.  Fracturing\nthe Web by exposing the nature of the payload in media type identifiers\nplaces a burden on intermediaries that would be impossible to bear.\n\nWhich results in coupling of client to server based on media type\nidentifier, which violates the layered system constraint, even if such\nmedia types were to become ubiquitous enough not to violate the self-\ndescriptive messaging constraint.  Caches and proxies simply do not care\nabout item and price information, only the format such metadata is\ncontained in.  The Web would collapse in a non-interoperable heap if it\nwere any other way.\n\nREST explains this, and predicts the evolution of the Web to continue\nalong the very path it is taking, which is interoperable ubiquitous\nmedia type identifiers, not media type identifers which expose the\nnature of the payload.  Implementation details, like domain-specific\nvocabularies, remain hidden behind the uniform interface -- unless you\nviolate the uniform interface by exposing such details in media type\nidentifiers.\n\nThe best example I can give of proper media type design, and proper\nassignation of media type identifiers, is image types.  You younger\nfolks here really are spoiled nowadays -- what browser doesn&#39;t grok\nprogressive rendering, transparency or animation?  This was not always\nso, these things came about incrementally, _without_ creating new media\ntype identifiers every step of the way.  I&#39;m sure that a search of the\nrelevant archives will show that this is so in large part due to\nconsistent prodding from Roy.\n\nWhen I first went online, the only media types I had to choose from to\ninline an image were GIF 87a and JPEG.  Eventually the Web moved to\nfull support of GIF 89a, and more advanced JPEG capabilities like\nprogressive rendering.  Patent controversy led to PNG.  We have now\nreached a place where it just isn&#39;t necessary to define new media type\nidentifiers for images (esp. w/ SVG), especially for the purpose of\ncommunicating the *nature* of the payload, which is a REST antipattern.\n\n(Of course, there&#39;s still room for new image media types to evolve, for\nexample some new breakthrough in image compression would require a new\ncodec would require a new media type identifier.)\n\nThese different media types (GIF 87a and 89a are different media types\nwhich share an identifier) are backwards-compatible.  Thus, serving an\nanimated GIF 89a to a GIF 87a browser used to result in the display of\nonly the first frame of the animation.  Transparency would show up as\nwhatever masking color was used.  The image would need to transfer\ncompletely before display, instead of rendering incrementally.\n\nMedia types evolve.  Ideally, their identifiers do not.  Only new media\ntypes require new media type identifiers, extensions to existing media\ntypes do not.\n\nAll the media type identifier does is inform the user agent to use its\nlatest knowledge of GIF, not the nature of the payload as dogs vs.\nporn, or as having transparency, animation or whatnot.  To the user\nagent, the media type identifer just says &quot;use your latest GIF codec to\ndecipher this payload as best you can.&quot;  There is nothing more the\nserver needs to assert about the payload at the protocol layer.\n\nAll else is implementation detail, hidden behind the uniform interface,\nnot sent over the wire as part of the protocol.\n\nIt would be silly to require content negotiation in order to provide a\nsingle frame to GIF 87a browsers, vs. animation for GIF 89a browsers.\nSuch coupling does not allow client and server to independently evolve.\n\nThe differences between the image media types which share identifiers\nhave nothing to do with the format of the image, i.e. the codec used for\nrendering is the same.  The differences come down to metadata support.\nAdding support for defining a given color bit as transparent, or having\nprogressive rendering, or being a collection of sequential images, is\nnot really any different than adding RDFa to existing HTML or XML media\ntypes.\n\nProperly designed media types don&#39;t need versioning, or the conneg that\nwould encourage.  Had the Web evolved that way, chaos would have ensued.\nOr not -- in which case we&#39;d have falsification of what I&#39;m saying about\nREST.  As it is, we have corroboration of what I&#39;m saying about REST --\nevolving media types doesn&#39;t begin to mean creating new media type\nidentifers every time an existing media type is extended, or used in a\nnew way (like using a GIF as a sparse-bit array) -- this just won&#39;t\nscale.\n\n&gt; \n&gt; &gt;\n&gt; &gt;&gt; \n&gt; &gt;&gt;&gt; My point is that is that html+gd is a much an application specific\n&gt; &gt;&gt;&gt; media type as a custom xml format.  Not giving it a name does not\n&gt; &gt;&gt;&gt; change that fact.  Once the server adds gd annotations, and\n&gt; &gt;&gt;&gt; clients started depending on them, the representations become\n&gt; &gt;&gt;&gt; application specific.\n&gt; &gt;&gt; \n&gt; &gt;&gt; Even worse: they become service specific and the client\n&gt; &gt;&gt; implementation couples itself to an (un-guarantee) particularity of\n&gt; &gt;&gt; that service. This is not different than having a service specific\n&gt; &gt;&gt; API in the first place.\n&gt; &gt;&gt; \n&gt; &gt; \n&gt; &gt; What do you mean by service-specific?  \n&gt; \n&gt; Specific to a service. Not orthogonal to the service. HTML is\n&gt; orthogonal to Amazon. Amazon&#39;s HTML style attributes are specifc to\n&gt; Amazon.\n&gt; \n\nI&#39;m not holding Amazon up as a shining example of anything other than\nthe use of domain-specific vocabulary within a ubiquitous media type,\nto prove that such a design pattern works even without a defined\nontology or RDFa (it&#39;s basically a microformat).  Let&#39;s get off of\nAmazon please, and back to the original example of BestBuy, which is\nusing RDFa to implement the GoodRelations ontology instead of winging\nit.\n\nAlthough, the difference between the two approaches lies outside the\nscope of REST, because implementation details like domain-specific\nvocabularies using RDFa vs. microformats are hidden behind the uniform\ninterface.  Implementing GR in RDFa is not service-specific.  It is\ndomain-specific and in no way couples clients to servers.\n\nChanging the GIFs on my websites back in the day, from GIF 87a to 89a\nwith progressive rendering (Using &lt;img @lores/&gt; to load a highly-\ncompressed JPEG first -- anyone else remember those dialup days of\nyore?) degraded gracefully, due to the loose coupling of client to\nserver.\n\nHad I been required to implement a new media type identifier, I\nwouldn&#39;t have moved to 89a until all browsers supported it, because it\nwould have required coupling client to server, which would have meant\nimplementing conneg and continuing to serve the 87a images to older\nclients.  Why wouldn&#39;t I apply this experience to my knowledge of REST,\nwhich was both derived from, and motivated the continuation of, the\nmedia type vs. identifier design pattern of images?\n\nCoupling clients to servers by exposing the nature of the payload in a\nmedia type identifier, is exactly the opposite of the proven-successful\ndesign pattern REST is based on, which is why I say it can&#39;t be REST to\ngo that way.\n\n&gt; \n&gt; &gt; Domain-sepcific vocabulary\n&gt; &gt; embedded in metadata is not some sort of design flaw.  Google and\n&gt; &gt; others understand GoodRelations.\n&gt; \n&gt; How would the server know that a user agent depends on it to fullfil\n&gt; its implemented goal?\n&gt; \n\nWhy would the server care?  The goal in REST is graceful degradation,\nas opposed to tight coupling.  The user agent doesn&#39;t depend on domain-\nspecific vocabulary.  That understanding is between the server owner\nand the user, not the server and the user agent, which only care about\nagreeing on a container format for domain-specific vocabulary.  RDFa\nand GoodRelations are tools for communicating the meaning of the server\nowner such that it may be understood by machine users.\n\nContracts exist between the stakeholders in a system, not its REST\nconnectors.  Enforcing contracts between connectors instead of\nstakeholders is a violation of the layered system constraint.  The\nuser, human or machine, is a stakeholder with no knowledge of the\nprotocol layer -- only the application state provided by the user agent.\nThe protocol layer could likewise care less about user goals or the\nnature of the payload, only its format.\n\nThis understanding of intent between server owner and human or machine\nuser, lies neatly outside the scope of REST.  Communicating this\nunderstanding from server to user agent via application-specific media\ntype identifier, breaks right through the layered system constraint.\nHaving the user agent communicate this understanding to the user via\ndomain-specific vocabulary does not violate any constraints.\n\n&gt;\n&gt; If the user agent does not *depend* on GoodRelations then Acept:\n&gt; text/html is just fine. But if it *needs* the embedded stuff to work\n&gt; properly, Accept text/html is not. .. and there is a hidden contract\n&gt; that will eventualy break.\n&gt; \n\nOf course that contract is hidden, and of course being a contract, it&#39;s\nsubject to change.  It&#39;s hidden because it&#39;s an implementation detail\nthat has no business being part of REST&#39;s uniform interface.  RDFa can\nembed GR inside a variety of host languages in a variety of ways, the\nonly contractual agreement in REST between the user agent and the\nserver is to agree on the format, *not* the nature, of the payload.\n\nThe goal in REST is graceful degradation, which means allowing the\nclient and server to evolve independently due to loose coupling based\non shared understanding of evolving media types.  If some client won&#39;t\nwork with RDFa + GR via HTML, then it needs its understanding of HTML\nupgraded to participate in communications on such a system.  Until\nthen, it understands as much of the text/html as it understands, and\nignores the rest -- the REST style is not based on &quot;mustUnderstand.&quot;\n\nThe client may be upgraded by recoding the client, or by the server\ninvoking some code-on-demand via some client-side mechanism which\ndetects the user agent&#39;s capabilities within the media type (like XSLT\nor Xforms capabilities in browsers may be detected using js).  Or the\nserver can account for other clients entirely, for example by GRDDL-\ntransforming RDFa into RDF, or rather linking to such a transformation.\n\nOr perhaps the client understood RDFa + GR via HTML long before the\nserver implemented it.  Instead of constantly asking the server &quot;Are we\nthere yet?&quot; and failing, such a client simply updates automatically\nwhen the server starts sending payloads of that nature.  Except for\ncompression, I like to avoid conneg wherever possible.\n\nAn architecture which requires conneg based on version or payload\nnature for every resource that&#39;s ever been changed over time, is\nfundamentally opposed to REST.  If that&#39;s the price of implementing\napplication-specific contracts at the protocol layer, then I say it&#39;s\nfar too steep to pay, especially when the same goals may be achieved\nusing standardized domain-specific vocabularies and RDFa via HTML.\n\n&gt;\n&gt; &gt;  Any service implementing GR has\n&gt; &gt; provided a machine-readable API that Google interacts with.  These\n&gt; &gt; services are in no way required to resemble one another.  So what do\n&gt; &gt; you mean by coupling?  Agreeing to a domain-specific vocabulary\n&gt; &gt; implemented using standard media types, is exactly what is meant by\n&gt; &gt; decoupling.\n&gt; \n&gt; Right. And HTML + GoodRelations is not such a standardized media\n&gt; type, eh?\n&gt; \n\nNo, HTML is a media type.  RDFa extends the HTML media type (regardless\nof which media type identifier is used).  GoodRelations is a domain-\nspecific vocabulary communicated from server owner to m2m user via RDFa\nmetadata that&#39;s part of the HTML media type by extension.  If a client\n(component or connector) is concerned with the difference between GIF\n87a and 89a, then it may introspect the payload to determine which it\nis, just as a client may introspect a payload to determine the presence\nof RDFa attributes, or perhaps read a composite DTD.\n\nWhen RDFa or Xforms are used as guest languages within HTML host\nlanguages, they do not change the underlying nature of the host\nlanguage, its semantics, its root node or nodes, or anything else about\nit.  It&#39;s merely an extension, no different than adding animation to\nimage/gif.  The nature of the payload, i.e. what the animated GIF shows\nor what ontology RDFa exposes or what forms language is used or what\nURIs are in @profile, has no bearing on its media type.\n\nExtending existing media types with metadata allows graceful\ndegradation.  Assigning new media type identifiers every time this\nhappens couples clients to servers, such that they must evolve at the\nsame time instead of independently.\n\n&gt; \n&gt; &gt; Why should the server owner care?  If BestBuy changes from GR to\n&gt; &gt; something else, then Google can no longer identify items and prices,\n&gt; &gt; until Google implements the new ontology,\n&gt; \n&gt; So then, why do we need HTM in the fisrt place? If this works so\n&gt; smoothly, why not just have Amazon send application/xml? Amazon would\n&gt; send a certain kind of XML, ya now: &lt;html&gt;&lt;title&gt;...&lt;/title&gt; ...\n&gt; &lt;/html&gt; and Google and browser implementors would just implement\n&gt; that.\n&gt;\n\nBecause that would violate the self-descriptive messaging constraint.\nHTML isn&#39;t just some random XML with a schema, it&#39;s a specific format\nwhich, as you describe, has a root element of &lt;html&gt;, a &lt;head&gt; which\ncontains the &lt;title&gt; of the document (i.e. well-known semantics) and\nother metadata, plus a &lt;body&gt; for content, with well-known rendering\nrules as a container for scripts, styling, transformations, forms\nlanguages and whatnot; which, after processing, provides the user with\nan application steady-state consisting of hypertext controls for\nwhatever API the server owner is attempting to communicate to human or\nmachine users using natural or machine (RDFa) language.\n\nSending text/html or application/xhtml+xml describes everything in that\nlast paragraph; which means that these media types come with whatever\nsecurity implications arise from allowing transformation, scripting or\nforms languages to execute, and that these are clearly defined in well-\nknown markup patterns.  Nothing about form semantics or script bindings\nshould be implied, let alone assumed as explicit, when application/xml\nis used, because application/xml doesn&#39;t define any such things,\nalthough it does allow for styling and transformation via XML\nProcessing Instructions and linking via Xlink or rdf:about.\n\nThe same goes for application/custom+xml.  Pick a media type capable of\nconveying your hypertext API to me, then tag it with a ubiquitous media\ntype identifier that explicitly states things like root element, title\nand security profile.  Hypertext APIs are document-driven, so define\nyour APIs using one or more known formats for conveying hypertext\ncontrol documents.  Instead of re-inventing things like &lt;title&gt; or\nforms or script bindings or image inlining or accessibility and whatnot.\n\nJust because browsers sniff content and implement javascript for media\ntype identifiers js doesn&#39;t have bindings for (application/xml, or\ntext/plain in IE&#39;s case) doesn&#39;t mean they&#39;re right to do so, and\ncertainly doesn&#39;t mean that doing so is proper REST architecture.  In\nfact, doing so is a direct violation of what little security features\nexist in REST or Web architectures.\n\nUnless you see no danger from having text/plain treated like text/html\nby allowing transformations, forms and scripts to execute *despite* the\nfact that none of those behaviors are defined for text/plain.\n\nThe risks of HTML media types are well known.  Reinventing new\nhypertext control document languages for every new service results in\nan SOA-like disaster where the security considerations vary from\nservice to service, and are unknowns, of the &quot;known unknown&quot; variety.\n\nGive SVG a try as your hypertext control document media type.  As XML,\nit allows CSS styling, plus it defines linking semantics and javascript\nbindings, and can serve as an Xforms and RDFa host language, thereby\nimplementing GoodRelations.  These are all &quot;known knowns&quot; and as such,\nthe security implications of the payload are bright and clear when\ntagged with the application/svg+xml media type identifier.\n\n&gt;\n&gt; Then, if Amazon changes from that syntax to some other one, Google\n&gt; and our browsers can no longer work with the XML.\n&gt;\n\nAmazon changing from some ad-hoc microformat to RDFa + GR won&#39;t break\nGoogle at all.  Instead, Google would be able to highlight item + price\ninformation for Amazon just like they do for BestBuy.  If Amazon had\nbeaten BestBuy to the punch here, then BestBuy most likely wouldn&#39;t have\nrealized a 30% increase in sales.  Domain-specific vocabulary has no\neffect on browsers, which are there to render the media type, not\ninterpret the m2m metadata any more than they interpret the human-\nreadable metadata.\n\nThe fact that Google is able to glean item/price information from HTML\ncode annotated with RDFa + GR really has nothing to do with REST.  It&#39;s\njust implementation details, the sort which are hidden behind the\nuniform interface.  Which is why I keep talking about it here -- making\nthis agreement a protocol-layer concern is NOT REST.\n\n&gt;\n&gt; Your train of thought implies that that is also just fine because\n&gt; once Google and the browsers follow the new stuff, everyone is happy\n&gt; again.\n&gt; \n\nNo, REST implies that clients and servers evolve independently, this\nisn&#39;t something I came up with.  There is no need for Amazon or BestBuy\nto wait until they have some contractual agreement with Google before\nsending GR, just as there is no need for Google to wait until anyone is\nactually sending GR before they decide to understand it.  This is loose\ncoupling.  The tight coupling which results from requiring a contract,\nsuch that clients and servers must have some a priori arrangement before\neither may evolve, certainly has nothing to do with REST architecture.\n\n&gt;\n&gt; So - why do we need text/html as a media type?\n&gt; \n\nI never said we did.  I have no idea why, when I say hypertext, people\nassume I only mean HTML.  I likewise have no idea why, when I say HTML\nmedia types, people assume I only mean text/html.  I&#39;d much prefer it\nif one major browser vendor didn&#39;t have their head shoved so far up...\nerm, ummm... anyway, there&#39;s no valid reason why application/xhtml+xml\nshouldn&#39;t be the de facto media type for the Web in this day and age.\n\n&gt;\n&gt; (Hint: because browsers (and Google) depend on it\n&gt; implementation-wise. They do not work with any application/xml.\n&gt;\n\nI have no idea what you&#39;re talking about.  Google will read anything it\npossibly can, it won&#39;t refuse to read anything that isn&#39;t text/html.\nCheck out my demo, give application/xml a try under IE.  IE will also\nprocess my text/xml and text/plain variants.  No browser with XSLT\nwon&#39;t work with application/xml, while all XSLT browsers except IE grok\napplication/xhtml+xml.  So my plan is to use conneg to send exactly the\nsame polyglot document as application/xhtml+xml to XSLT browsers except\nIE, application/xml to IE, and transform the document on the server to\nsend text/html to the rest, including Google.\n\nI&#39;m not sending application/xhtml+xml to Google, because Google won&#39;t\nexecute my XSLT transformation (last I checked).  I suppose I could\nsend the server-side transformation to Google as application/xhtml+xml,\nbut I&#39;m using text/html because this is my default variant I want to\nhave work with anything, including obsolete browsers, so it&#39;s just\neasier to have the conneg default to text/html, and detect XSLT\nbrowsers.  If I just didn&#39;t care about older user agents, I&#39;d not be\nusing text/html, it&#39;s certainly not a Google or browser requirement\n(except for IE).\n\n&gt;\n&gt; That is why they say: I &#39;Accept: text/html, application/xhtml+xml&#39;\n&gt; and as long as you send me something that conforms to one of those\n&gt; types I *can* carry out the implemented goal for the response to\n&gt; *this* request.)\n&gt; \n\nNo, Google and browsers all include &#39;*/*&#39; in their Accept headers, to\nindicate their willingness to receive any format.  I don&#39;t actually\ncare what a user agent prefers; if it specifically says it Accepts\napplication/xhtml+xml, that&#39;s what I send it, because that media type\nuses less bandwidth and has better user-perceived performance than\ntext/html.  The client isn&#39;t instructing the server what media type to\nsend, making things work in such fashion is not the result of following\nREST.\n\nReceiving a response of a certain media type says absolutely nothing\nabout whether a user agent can accomplish the goals of the user; that&#39;s\na function of domain-specific vocabulary processed at a different layer\nfrom the protocol interaction between connectors.\n\n&gt;\n&gt; To stress the point again: if the user agent&#39;s implementation of a\n&gt; certain user goal *depends* on a certain format of representation\n&gt; that must be expressed in the Accept header.\n&gt;\n\nSure.  An Atom user agent is going to have one hell of a time trying to\ninterpret my demo system if I only send it HTML media types.  But\nthat&#39;s just one variant; by using RDFa I can incorporate the same\ndomain-specific vocabulary into my HTML and Atom media types, such that\nall variants describe the same API.\n\nIf a user agent depends on that domain-specific vocabulary, then it\nwill have to introspect the payload to determine compatibility -- there\nis absolutely no REST constraint stating that this must be exposed in\nthe media type identifier, in fact to do so violates REST, as I&#39;ve\nexplained.\n\n&gt;\n&gt; If a user agent is implemented to wake up every hour and check the\n&gt; prices of items on various shoppping sites it has far more specific\n&gt; needs than a generic agent that displays a [Next] button if it\n&gt; encounters a next link or displays an [edit] button if it encounters\n&gt; an AtomPub edit link.\n&gt; \n\nOf course its needs are more specific.  That&#39;s what domain-specific\nvocabulary is for.  If I&#39;m a human user, domain-specific vocabulary is\nwhat tells me which link to click to order which item, and what the\nprice is, in natural language.  If I&#39;m a machine user, I&#39;m looking at\nthe metadata to determine the same thing.  Either way, the hypertext is\ndriving application state.\n\nIt wouldn&#39;t be a user agent that&#39;s implemented to do any specific task.\nIf a machine user has a goal of price-checking items on some schedule,\nthen the machine user is coded to have the user agent request the\nproper-format (regardless of the nature of the payload) representation\nand render it into an application steady-state; the machine user\nchooses from the available state transitions; the user agent makes it\nso.\n\nThe options for which state transition to take must be contained in the\npayload (since we don&#39;t have standard link relations for this, the Link:\nheader is not relevant).  All RDFa does, is allows that state transition\nto be annotated in machine-readable fashion.  Otherwise, a machine user\nwould not be able to decipher the state transition choices, let alone\nchoose between them.\n\nThe smart agent you describe can be easily implemented using HTML, js\nand libcurl.  I see no advantage to describing such a service API using\nany other hypertext language.  There is absolutely no REST constraint\nadmonishing against the use of HTML to make this work.  REST is nowhere\nnear as complicated as you&#39;re trying to make it by insisting that media\ntype identifiers must constitute some inviolable, binding agreement\nbetween stakeholders, or indicate the nature of the payload, when they\nonly say what the format of the payload is.\n\nRequiring media type identifiers to mean anything more than that,\nviolates REST, plain and simple.\n\n-Eric\n\n"}}