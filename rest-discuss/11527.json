{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"0CBU6y4RqNqD6HFCafBejfVTv8oegmYhZ1353jAJ9xfJLnufKE9VvFbS_leprtj35fgHCNzYoRf01bLJDdtleYL9w8poaCNPxTZMFgtsGA","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: [rest-discuss] HTML5 and RESTful HTTP in browsers","postDate":"1227021216","msgId":11527,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDgxMTE4MDgxMzM2LmYxNTY5ZTg1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDQ5MjJCMzZBLjMwOTA4MDRAbXlrYW5qby5jby51az4=","referencesHeader":"PDIwMTUxMDEwLjIzNjg3MTIyNjkxOTk1NDUzMi5KYXZhTWFpbC5zZXJ2bGV0QGt1bmRlbnNlcnZlcj4JPDIwMDgxMTE4MDA1OTQ5LmFiNzQ0YmVkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDQ5MjJCMzZBLjMwOTA4MDRAbXlrYW5qby5jby51az4="},"prevInTopic":11526,"nextInTopic":11528,"prevInTime":11526,"nextInTime":11528,"topicId":11508,"numMessagesInTopic":82,"msgSnippet":"On Tue, 18 Nov 2008 12:22:02 +0000 ... I don t know what a JavaScript virtual machine is.  Since scripting makes use of the capabilities a browser already has,","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 33072 invoked from network); 18 Nov 2008 15:13:37 -0000\r\nX-Received: from unknown (66.218.67.94)\n  by m53.grp.scd.yahoo.com with QMQP; 18 Nov 2008 15:13:37 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta15.grp.scd.yahoo.com with SMTP; 18 Nov 2008 15:13:37 -0000\r\nX-Received: from BigBison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTP id DED29D05A6;\n\tTue, 18 Nov 2008 10:13:35 -0500 (EST)\r\nDate: Tue, 18 Nov 2008 08:13:36 -0700\r\nTo: Mike &lt;mike@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20081118081336.f1569e85.eric@...&gt;\r\nIn-Reply-To: &lt;4922B36A.3090804@...&gt;\r\nReferences: &lt;20151010.236871226919954532.JavaMail.servlet@kundenserver&gt;\n\t&lt;20081118005949.ab744bed.eric@...&gt;\n\t&lt;4922B36A.3090804@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.4.5 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] HTML5 and RESTful HTTP in browsers\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nOn Tue, 18 Nov 2008 12:22:02 +0000\nMike wrote:\n&gt;\n&gt; If the solution uses JavaScript for Accept headers and PUT/DELETE \n&gt; requests, is that browser support or JavaScript virtual machine\n&gt; support?\n&gt; \n\nI don&#39;t know what a JavaScript virtual machine is.  Since scripting\nmakes use of the capabilities a browser already has, the script isn&#39;t\nan HTTP client, the browser is.  If a browser implements PUT, then it\ncan be scripted to PUT; but if a browser doesn&#39;t implement PUT, no\namount of scripting will make it PUT.\n\n&gt;\n&gt; Maybe someone can correct me here, but as I understand it; content\n&gt; types served at a given URI are effectively that given resource&#39;s\n&gt; representations.\n&gt; \n\nErrr, uhhh, a Content-Type is not a representation.  A URI may serve\nmultiple representations, but there&#39;s no requirement for a 1:1\nrelationship with MIME type.  A URI may serve HTML 4.01 to some clients\nand XHTML 1.0 to others, both as text/html, with content negotiation\nbased on User-Agent rather than Accept, even.  Or, a URI may serve two\ndifferent representations of an HTML 4.01 page, both served as\ntext/html, one zipped and the other raw, with content negotiation based\non Accept-Encoding.\n\nCompressing content is an example of conneg in everyday use.  When you\nimplement GZIP on your server&#39;s output, you double the number of\nrepresentations for each resource. If the compression is done\nbeforehand rather than on-the-fly, the response headers should include a\nContent-Location with the URI of either the raw or the compressed\nrepresentation.  I would want to directly reference any stored file,\nbut could care less about directly referencing different output streams.\n\nBecause there&#39;s no need to directly reference either the raw or the\ncompressed representation as streams, there&#39;s no need to make them\nseparate resources with different URIs.  There&#39;s no need to implement\nthis negotiation in markup, nor would it make sense to do so. If I want\nto dereference the compressed representation as a stream, I just need to\nmake sure the request includes Accept-Encoding: gzip, but since this\nrepresentation has no URI it can&#39;t be directly referenced (bookmarked).\n\n&gt;\n&gt; A URI should be used to indicate a resource, but (even though it is \n&gt; possible) is it good practice for a resource to indicate a \n&gt; representation? Clearly, this is common practice now, whether it is a \n&gt; query parameter or a &#39;file extension&#39; - but it seems to me that this \n&gt; violates the principal of what a resource is (at least according to\n&gt; my interpretation of  the definition in Roy&#39;s dissertation). I would\n&gt; argue that the reason for this is because HTML has not provided\n&gt; browsers with a hypertext mechanism for protocol conneg. I think\n&gt; developers should at least be given the option, personally.\n&gt; \n\nA resource is anything identified by a URI.  In the case of a\nnegotiated URI with multiple representations, each representation may\nbe a resource in its own right, you just have to assign it a URI.  It\nis not bad practice to do this, it&#39;s how content negotiation is\nproperly done (in most cases, the prominent exception being\ncompression).  There&#39;s no violation of Roy&#39;s definitions of resource or\nrepresentation here.\n\nContent negotiation has nothing to do with HTML, really.  XForms or\nJavaScript allows a document author or generator to override request\nheaders, overriding conneg is a different problem than implementing it.\nSince conneg is handled at the protocol level, it would be silly to\nimplement it in markup, IMO.  HTML doesn&#39;t need its own content\nnegotiation mechanism, just a way to override the client&#39;s request\nheaders without using JavaScript.\n\n&gt;\n&gt; Isn&#39;t one of the benefits of statelessness that any state can be\n&gt; stored by a user (i.e. bookmarked)? If browsers aren&#39;t currently\n&gt; providing this functionality in a way which leverages these benefits\n&gt; - I agree entirely that it is not feasible to completely discount\n&gt; conneg over URIs, but if no movement is made to have HTML encourage\n&gt; browsers to be better HTTP clients, it is likely that nothing will be\n&gt; done about it.\n&gt; \n\nA negotiated URI is easily bookmarked.  All variants represent the same\nstate, though.  The property of being compressed or not, is wholly\nseparate from application state.  Receiving a JPEG instead of a PNG\ndoesn&#39;t change the application state.  Subsequent requests for a\nbookmark will return the same response, unless the server&#39;s algorithm\nhas changed, or the client is upgraded and its request headers have\nchanged.  This may change the format of the response, but not the\napplication state represented by the response.\n\nThere&#39;s no valid reason for a client to store request headers\nas part of the bookmark, this would defeat the entire purpose of\ncontent negotiation, not to mention evolvability. If there&#39;s some reason\nto bookmark a specific representation, then use the URI which identifies\nthat representation as its own resource (if available), don&#39;t try\nstoring the request headers and re-sending them -- that is not the Web\narchitecture.\n\nHTTP headers are client specific, not request specific -- headers don&#39;t\n(shouldn&#39;t) change from one request to the next unless the client is\nupgraded. For example, an upgrade from Safari 2 to Safari 3 changes the\nAccept header to include &#39;application/xhtml+xml&#39;.  If a resource is\nnegotiated based on Accept header, it may well give a different\nresponse to the upgraded browser -- it would be horrible practice if,\nwhen selecting a bookmark link, the browser sent the same stored Accept\nheader it previously had, instead of the new one which more accurately\nreflects the client&#39;s capabilities, and letting the server do its\nconneg thing.\n\nThat&#39;s tight coupling, not to mention needless complexity, and doesn&#39;t\nreally solve any real-world problems, while precluding any benefit to\nusing content negotiation in the first place, if all bookmarks must be\naltered when a browser is upgraded or stay locked in to a lower-quality\nrepresentation.  The simple solution which has been proven to work, is\nto give each representation its own URI, instead of trying to invent\nuber-bookmarks for negotiated resources, or trying to implement content\nnegotiation in markup.\n\nIn REST, any resource of interest is given a URI, such that application\nstate may be bookmarked.  But, that application state is not a function\nof the Content-Type.  A compressed representation doesn&#39;t need its own\nURI.  The argument for using separate URIs for image.jpg/image.png has\nmore to do with proper caching, than being able to bookmark them\nseparately, since they represent the same application state.\n\nI&#39;ve tried to elaborate here, rather than simplify, hope this helps.\n\n-Eric\n\n"}}