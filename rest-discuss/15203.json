{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"rFQ85d1AOS5Sn9GMamT9VY9YLVrs6w4J3TOpEaiWu9rI_1KAvnHq2mB5dGpHOnh5h3N7xfWQQ398m9zQiaVrH9li2_SnLRdY4sk_p2BILw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the sense of Roy&#39;s dissertation?","postDate":"1270931243","msgId":15203,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNDEwMTQyNzIzLjg0NjU3NGJkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDNDQjk4NTUyLTk4NkYtNDIxNS1BNzUyLUE0QkQ4NTZGRDE1N0BtYWMuY29tPg==","referencesHeader":"PGhwa21oNitpdDJmQGVHcm91cHMuY29tPgk8M0NCOTg1NTItOTg2Ri00MjE1LUE3NTItQTRCRDg1NkZEMTU3QG1hYy5jb20+"},"prevInTopic":15202,"nextInTopic":15204,"prevInTime":15202,"nextInTime":15204,"topicId":15152,"numMessagesInTopic":30,"msgSnippet":"... I think trying to fit the notion of contract into REST is hindering RESTful thinking.  ;-)  What is a client developer?  Someone building a user agent?","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 15938 invoked from network); 10 Apr 2010 20:28:00 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m11.grp.re1.yahoo.com with QMQP; 10 Apr 2010 20:28:00 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 10 Apr 2010 20:28:00 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 4B814509B4;\n\tSat, 10 Apr 2010 16:27:59 -0400 (EDT)\r\nDate: Sat, 10 Apr 2010 14:27:23 -0600\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nCc: REST Discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100410142723.846574bd.eric@...&gt;\r\nIn-Reply-To: &lt;3CB98552-986F-4215-A752-A4BD856FD157@...&gt;\r\nReferences: &lt;hpkmh6+it2f@...&gt;\n\t&lt;3CB98552-986F-4215-A752-A4BD856FD157@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the\n sense of Roy&#39;s dissertation?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nJan Algermissen wrote:\n&gt; \n&gt; William Martinez Pomares wrote:\n&gt; \n&gt; &gt; Now, System is not an API. I actually argue about the term REST API\n&gt; &gt; since it comes, I think, from the idea that REST is a Service or\n&gt; &gt; RPC replacement.\n&gt; \n&gt; \n&gt; I think the whole notion of &#39;API&#39; is hindering RESTful thinking. The\n&gt; notions of &#39;service&#39;, &#39;interface&#39; and &#39;API&#39; suggest that the contract\n&gt; that informs and guides client side development is located at the\n&gt; server, that the client developer is coding against the interface\n&gt; provided by the server.\n&gt; \n\nI think trying to fit the notion of &quot;contract&quot; into REST is hindering\nRESTful thinking.  ;-)  What is a client developer?  Someone building a\nuser agent?  Or a third party writing their own REST application against\nmy REST (API | system | service)?  &quot;Client-side development&quot; makes no\nsense -- when I do client-side development I&#39;m not building user agents,\nI&#39;m explicitly writing a self-documenting API of the interfaces\nprovided by the server.  Building user agents is client-side\ndevelopment of a different sort.\n\nThe only contract in REST, is that REST constrains me to use standard\nmethods, media types and link relations to describe this API to user\nagents.  If you want a contract for yor API it needs to be contained\nwithin representations of standard media types.  To me a contract would\nbe declared in domain-specific vocabulary beyond the scope of REST.\n\n&gt;\n&gt; I think it is helpful to view server side development as exposing\n&gt; server-component managed (business-) state...\n&gt;\n\nDo you mean resource state?  I expose resource state through\nrepresentations of requested resources.  Resource state is independent\nof application state.  If an image is dereferenced, the representation\nof resource state is returned, but that isn&#39;t an application state if\nthe image was dereferenced as part of the process of rendering some\nother representation into an application steady-state.\n\nIf by server-side development, you mean figuring out what resources\ncombine into what application steady-states in what media types and\nnaming them, then the goal of server-side development goes beyond\nexposing resource state and carries into developing application steady-\nstates for the native hypertext, i.e. explicitly writing a self-\ndocumenting API of the interfaces provided by the server.  Even though\nthey execute on the client, you can&#39;t develop on the server without a\nknowledge of your intended application steady-states.\n\n&quot;An origin server uses a server connector to govern the namespace for a\nrequested resource. It is the definitive source for representations of\nits resources and must be the ultimate recipient of any request that\nintends to modify the value of its resources. Each origin server\nprovides a generic interface to its services as a resource hierarchy.\nThe resource implementation details are hidden behind the interface.&quot;\n\nOn my demo, application steady-state requires XSLT processing which in\nturn requires /date service translation.  So /date is both part of my\nweblog API and an API in its own right.  As an API in its own right,\nit&#39;s pretty useless, but it&#39;s still (mostly, atm) RESTful.  Another\nservice is the Atom-Protocol-based API, also part of my weblog API and\na (mostly) REST API in its own right.  The weblog API described by my\nhypertext (my &quot;REST API&quot;) instructs user agents how to combine these\ntwo services into an incalculable number of REST applications.\n\nSo my origin server provides a generic connector interface to a\nresource hierarchy of RESTful services.  This resource hierarchy, what\nREST applications are programmed against, is the API.  This REST API\nuses self-descriptive messaging and self-documenting representations\n(i.e. a generic connector interface) to instruct user agents how to\nmanipulate resource state.  Application steady-state isn&#39;t the same\nthing as the state of any given resource it&#39;s composed of.\n\nThe steady-states are what allow for serendipitous re-use.  The API\ndescribed by these steady-states can be referenced by other user agents\nthan the ones the API developer intended.  The more resources and the\nmore metadata exposed by these steady-states, the greater the\nopportunities for serendipitous re-use.\n\n&gt;\n&gt; With REST, however, the contract is provided by the media types (and\n&gt; link rels) only. The client developer cannot even anticipate to what\n&gt; servers and services the interaction will lead the application.\n&gt; \n\nBy client developer, do you mean someone writing a client connector for\nan intermediary component?  Someone writing the API to a REST system?\nA third-party REST application developer?  While it&#39;s true that a\nthird-party REST application can&#39;t anticipate what targets and methods\nwill be used, the developer can know (by looking at my API) where to\n*look* for this information.\n\nThere is plenty of metadata to choose from in the steady-states of my\nREST API, which may be used for any purpose a third-party developer\nsees fit, based on whatever their assumptions may be (constrained by\nthe actual responses of my origin server).  I make no promises about\nhow stable any of it is, unless it&#39;s part of the API described by the\nsum of the actual responses of my origin server and my hypertext.\n\nIf a third-party REST application is based on the API I&#39;ve described in\nmy hypertext through an understanding of its domain-specific vocabulary,\nthen that domain-specific vocabulary is probably the &quot;contract&quot; you&#39;re\nlooking for.  Any deviation from the API I&#39;ve described is unsupported,\neven if it does work for now, whereas I&#39;ll be supporting the contract.\n\n&gt;\n&gt; A nice side effect of this view is that it immediately becomes\n&gt; evident that there cannot be any client side coding before specific\n&gt; media types have been decided upon.\n&gt; \n\nNot really, no.  In many cases, the data may be represented as Atom and\ninteracted with using Atom Protocol, as a prototyping exercise.  Thus\nthe cost-benefit analysis vs. Just Use Atom/AtomPub can be done, and a\nbaseline exists for performance analysis of further system development.\n\nConsider this case, not only as an example of design following the\nabove paragraph, but a result machine users can contractually follow to\nexecute tasks.  (It&#39;s similar to my demo and the process I went\nthrough, but not exactly so, and I&#39;m riffing on that to boot).\n\nLet&#39;s say I&#39;m at the blank-sheet phase of designing the system my demo\nrepresents.  I have some idea how I want to present my weblog, i.e.\nfollowing a link to an original post contains a link to that post with\nits comment thread contains links to those comments as standalone\ndocuments.  On the homepage, I want to present only a summary of the\ncontent, with a &quot;more&quot; link which when clicked updates the page in-\nplace with the content from the standalone source.\n\nFrom this vague idea, I can create the &quot;outline&quot; of a single document\ncontaining the entire content of the weblog API I&#39;m creating.  I can now\ncreate a filesystem hierarchy with folders titled as per the outline,\ni.e. Roman numeral &#39;I&#39; is a folder name, containing folders named\ncapital &#39;A, B etc.&#39;, containing folders &#39;1, 2 etc.&#39; containing folders\n&#39;a, b etc.&#39; and so on and so forth.\n\nInto these folders I can place numbered text files containing random\ngibberish.  I&#39;ve now modeled my main resources and their relationships\nto one another.  I can now create Atom representations for each snippet\nof gibberish, still as text, and start naming directories and files and\nassigning them titles, then tie them together with standard link\nrelations.  I can now set up eXist and manipulate things with Atom\nProtocol -- there&#39;s my initial prototype, based on text/plain with no\ndomain specific vocabulary.\n\nNow I can proceed to think about what my media types are.  Atom works\nfor me, to some extent, so I&#39;m going to build onto this core using\nXHTML and Xforms.  That I&#39;m using HTML and forms is kind of a foregone\nconclusion, but even if it weren&#39;t, what follows would be the same, and\nit doesn&#39;t really lock you into anything, only fleshes out the\narchitectural model you&#39;re developing.\n\nWhat I need now are RDF tuples to describe the interfaces in terms of\nmapping my domain-specific vocabulary to standard link relations.  For\nexample, the root-level resource has an index.rdf file which follows the\nfollowing pattern to *locate* interfaces:\n\n&lt;!-- I&#39;m uncertain about RDF syntax but think I&#39;m on the right track --&gt;\n&lt;rdf:Description about=&quot;{//*[@instanceof=&#39;wiski:weblog-entry&#39;]}&quot;&gt;\n&lt;!-- in my demo the particular element is li but this isn&#39;t required --&gt;\n&lt;link rel=&#39;edit&#39; href=\n&quot;{document(./@about)//*[@rel=&#39;edit&#39;]/@href}&quot;/&gt;\n&lt;!-- in my demo the particular element is a but doesn&#39;t have @rel --&gt;\n&lt;link rel=&#39;replies&#39; href=\n&quot;{document(./@about)//*[@rel=&#39;replies&#39;]/@href}&quot;/&gt;\n&lt;/rdf:Description&gt;\n\nMy documentation states that //*[@instanceof=&#39;wiski:weblog-entry&#39; and \n@id=&#39;post-0&#39;] identifies the interface for me to make a new entry on my\nweblog, if it&#39;s at root level, otherwise it identifies the interface to\nmake a new comment somewhere deeper in my hierarchy (even if I use CSS\nto make it appear at the bottom of the Web page, but HTML/CSS is\ngetting ahead of myself here).  And, collections don&#39;t have rel=&#39;edit&#39;,\ncomments don&#39;t have rel=&#39;replies&#39;, but weblog entries have both.\n\nOtherwise, without documentation, my RDF describes the interfaces to \nexisting resources located at {./@about}, which is also where to find\nthe locations for editing and replying (based on link relation).  I\nsuppose this does require using XML, but the media type is up in the\nair still -- I can choose anything from which I can point rel=\n&#39;transform&#39; to an XSLT file which outputs index.rdf (GRDDL) in the\nabove pattern.\n\nOf course, at this point I can swap eXist for CouchDB if I want, using\ndifferent URIs to define Views.  But the RDF pattern would still hold\nequally true.  The rel=&#39;replies&#39; target may change, and so may its media\ntype, and so may the representation from which the RDF is derived (and\nits media type).  What wouldn&#39;t change is my API, i.e. the pattern the\nRDF describes, if my Atom &lt;link/&gt;s are redone as HTTP Links seeing as\nhow the JSON media type CouchDB uses doesn&#39;t define links.\n\nThe RDF is generated from the steady-states using a domain-specific\nmachine-targeted vocabulary.  So the RDF always tells a user agent\ncapable of GRDDL, where to look in the source document in terms of\nXpath, to find URIs of interest.  The user agent follows its nose to\nfigure out *how* to post a new entry, post a new comment or edit an\nentry or comment, from the representations its receives.\n\nA third-party spambot developer can script together some standard\nlibraries, to crawl my site and report back the @href for every rel=\n&#39;replies&#39; by deducing the RDF pattern above from the XSLT GRDDL\ntransformation (if not just running the XSLT transformation) and\nPOSTing some Atom-wrapped spam to each one.\n\nSince each rel=&#39;replies&#39; responds that it will Accept POSTs made in\napplication/atom+xml, unless some mechanism gets in the way the spambot\nwill be incredibly successful on my weblog.  If I change eXist to\nCouchDB the spambot breaks because the developer didn&#39;t write it to\nfollow its nose through any REST application, so the spambot tries to\nPOST Atom to a resource that now only Accepts application/json.\n\nIf, instead of a spambot, we consider my XHTML representations being\nused to drive the application, the user agent is following its nose and\nall it requires to display JSON as text/plain inside a &lt;textarea&gt;\ninstead of HTML as text/plain inside a &lt;textarea&gt; is how to render a\n&lt;textarea&gt;.  The API is no different, really, only a media type has\nbeen changed or added.  What method to use on what URI and what media\ntype to send may have changed, but any user agent following hypertext\ninstead of third-party developer assumptions will be automatically\nupdated when my representations change.\n\nThe contract in REST is that the API be spelled out using standard\nmethods, media types and link relations.  Any contract you want beyond\nthat, has to do with domain-specific vocabulary.  My RDF guarantees\nthat the steady-state from which it was derived will instruct the user\nagent where and how to make and edit posts, while deliberately saying\nnothing about media types or methods or URI patterns (only metadata).\n\nIf your spambot GRDDL-crawls my site and learns where and how to post a\nnew comment to a thread by following my RDF and RDFa, then I change my\nsite all around but still base it on the same RDF and RDFa vocabulary,\nyour spambot won&#39;t break over time because it&#39;s sticking to the third-\nparty developer contract elucidated through domain-specific metadata\nresiding in application steady-states (with a smidgen of documentation,\ni.e. wiski:weblog-entry is a nodeset corresponding to an entry that\nisn&#39;t a comment -- wiski:weblog-comment does that -- to explain the API\nin terms of domain-specific vocabulary exposed in steady-states).\n\nIOW, if your spambot groks RDF and the media types I&#39;m using to\ndescribe the API, it can spam me with text sent as any media type.  No\nservice document needed.  But, I can also write a killbot which knows\nhow to crawl my site, detect and remove spam using the same API.\n\n-Eric\n\n"}}