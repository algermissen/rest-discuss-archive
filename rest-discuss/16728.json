{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"77vy7MxUsB8NdlJ1mQMHLjwGRbWIclV79wiImbtOzViniarCRrY8qLtlZtXQYKXSbnH6MhqMzqW5opbIjupCGTmhA_NgdIdOf0OksB91Rg","spamInfo":{"isSpam":false,"reason":"0"},"subject":"It&#39;s the architecture, stupid.","postDate":"1287126151","msgId":16728,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAxMDE1MDEwMjMxLjkxY2Y2YzI5LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":0,"nextInTopic":16729,"prevInTime":16727,"nextInTime":16729,"topicId":16728,"numMessagesInTopic":15,"msgSnippet":"This is a shot across the bow of Web Sockets Protocol (or, as I call it, Google Wave Protocol), followed by some RESTful alternatives.  Roy, of course, has the","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 99633 invoked from network); 15 Oct 2010 07:02:35 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m17.grp.re1.yahoo.com with QMQP; 15 Oct 2010 07:02:35 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 15 Oct 2010 07:02:35 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id B3849509DC\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Fri, 15 Oct 2010 03:02:34 -0400 (EDT)\r\nDate: Fri, 15 Oct 2010 01:02:31 -0600\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20101015010231.91cf6c29.eric@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: It&#39;s the architecture, stupid.\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nThis is a shot across the bow of Web Sockets Protocol (or, as I call it,\nGoogle Wave Protocol), followed by some RESTful alternatives.  Roy, of\ncourse, has the money quote:\n\n&quot;Generally speaking, REST is designed to avoid tying a server&#39;s\nconnection-level resources to a single client using an opaque protocol\nthat is indistinguishable from a denial of service attack.  Go figure.&quot;\n\nhttp://tech.groups.yahoo.com/group/rest-discuss/message/15818\n\nI don&#39;t think it&#39;s possible for any protocol to constrain its\nimplementations to be RESTful.  All I really require from any extension\nof the Web is that I *can* implement it RESTfully, if I so choose.  Web\nSockets precludes REST, which should be an architectural red flag where\nthe Web is concerned.  If you know where to look, the rationale behind\nthe dissertation&#39;s development of an idealized model for the Web, is\nsteeped in the fundamentals of the Internet.  You can disagree with\nREST, but it&#39;s hard to dismiss the logic of 2.3 (which says nothing\nabout improving application performance by stripping out protocol\nheaders, particularly at the expense of caching, btw):\n\n&quot;\nThe performance of a network-based application is bound first by the\napplication requirements, then by the chosen interaction style,\nfollowed by the realized architecture, and finally by the\nimplementation of each component.  In other words, software cannot\navoid the basic cost of achieving the application needs; e.g., if the\napplication requires that data be located on system A and processed on\nsystem B, then the software cannot avoid moving that data from A to B.\nLikewise, an architecture cannot be any more efficient than its\ninteraction style allows; e.g., the cost of multiple interactions to\nmove the data from A to B cannot be any less than that of a single\ninteraction from A to B. Finally, regardless of the quality of an\narchitecture, no interaction can take place faster than a component\nimplementation can produce data and its recipient can consume data.\n\n...\n\nAn interesting observation about network-based applications is that\nthe best application performance is obtained by not using the network.\nThis essentially means that the most efficient architectural styles for\na network-based application are those that can effectively minimize use\nof the network when it is possible to do so, through reuse of prior\ninteractions (caching), reduction of the frequency of network\ninteractions in relation to user actions (replicated data and\ndisconnected operation), or by removing the need for some interactions\nby moving the processing of data closer to the source of the data\n(mobile code).\n&quot;\n\nThis issue goes beyond REST, to the architecture of the Web and of the\nInternet itself.  Apparently HTTP is incapable of supporting modern Web\nsystems which desire to use push.  Apparently, push requires all aspects\nof good protocol design to be chucked out the window.  Late binding?\nUseless -- who needs compression anyway?  These are the assumptions\nseemingly underlying Web Sockets.  But where&#39;s the rationale behind\nthose assumptions?  What architectural precepts are guiding the design,\nhow does the protocol meet those precepts, and do the results solve the\nproblems as rationalized?  Why is HTTP being treated as obsolete?\n\nIt appears to me, that Web Sockets is not only being made up as it goes\nalong (heh, just like SOA), but represents an outright rejection of\narchitecture itself (heh, also just like SOA).  REST and Web\narchitecture are based on an object model -- each object (resource) has\nproperties and methods.  In OOP, messaging between objects is part of\nthe language; on the Web, this messaging is HTTP.  In Web Sockets,\npayloads have no relation to objects -- no properties or methods are\nexposed.  I realize that stripped-down packets of data are the goal,\nbut *why* is that remotely a good idea when it goes against every peer-\nreviewed and ubiquitous protocol design to ever succeed on the Internet,\nwillfully disregarding features that allowed the Web to thrive -- like\ncaching, or filtering/negotiating on data type?\n\nUnlike Web architecture, there is no way to restrict a browser from\nrendering a PDF, except by blocking Web Sockets communication outright.\nUnlike Web architecture, content is sent without indicating length or\nchunked, or even delimiting one message from another by adhering to a\n1:1 request/response ratio?  Unlike Web architecture, caching is\nimpossible because the protocol is stateful.  Unlike Web architecture,\nthe user has no control (via browser settings) over what content should\nbe handled in what way.  All of these features of the Web evolved\nthrough consensus and working code, guided by solid architectural\nrationale (even before REST), and were essential in the success of the\nWeb -- apparently all this is completely irrelevant if we want to do\npush!\n\nHogwash.  If Web Sockets were to be accepted as an RFC, Jon Postel\nwould roll over in his grave.  Jon thought it was important that any\napplication protocol be a well-behaved citizen of the Net.  His\ninfluence is why RFCs are written the way they&#39;re written, to this day,\nexcept for Web Sockets (which recently introduced three SHOULDs, but\neverything else is MUST/MUST NOT, resting on an assumption that all\nimplementations will be fully compliant good Net citizens and therefore\ngraceful degradation isn&#39;t needed, presumably).\n\nhttp://www.ics.uci.edu/~rohit/IEEE-L7-Jon-NNTP.html\nhttp://tools.ietf.org/html/rfc2468\n\nDr. Postel&#39;s leadership is responsible for the Internet architecture\nbeing what it is.  Aside from ICMP, every protocol he wrote or\ninfluenced, push or pull, shares the request/response idiom.  IRC, FTP,\nSMTP, NNTP, HTTP and every other client-server application protocol I\ncan think of (except Gopher) sends a _response code_ after receiving a\nrequest.  Web Sockets is off in its own little world of completely\nuntried and untested architecture astronuttery which goes against the\nvery nature of Internet messaging -- once a connection is established\nwith a single request, multiple responses are sent until the connection\nis closed. This is not the tried-and-true architecture of the Internet,\nit&#39;s a greenfield experiment with no foundation in what&#39;s known to work.\n\nIf you&#39;re going to propose an extension to the Web architecture that\ndefies the Internet itself, I&#39;m gonna need to see your rationale as to\nexactly what problem it is you&#39;re trying to solve, why it can&#39;t be\nsolved in a Web-native or even Internet-native fashion, and what design\nconstraints you expect will result in a protocol meeting those needs.\nLacking that, I just can&#39;t be expected to approve of winging it on a\nblank sheet of paper and making up a spec as it moves along.  Like SOA,\nWeb Sockets is an example of the null architecture, i.e. no constraints.\n\nWhile there are smart folks involved, doing their best to make sure\nthere are no obvious security holes in the protocol, I can&#39;t help but\nthink that hackers will be having a field day with it -- any new,\nuntried and untested pattern can&#39;t be considered to have the same\nsecurity considerations as request/response messaging, meaning it&#39;s all\njust guesswork.  You can secure against known attack vectors, but you\ncan&#39;t secure against attack vectors you don&#39;t know you&#39;re creating,\nwhich you&#39;re likely doing by ignoring all that has come before.\n\nDespite the efforts of a minority, the WG doesn&#39;t seem to think it&#39;s\nall that big a deal that their protocol as currently written won&#39;t\ninteroperate with the deployed infrastructure, or that it isn&#39;t really\na problem to require that such infrastructure be updated to avoid\ndeadlock conditions between existing load balancers and the servers\nthey farm, when encountering Web Sockets.  If that&#39;s the case, then why\nnot add a push method to HTTP?  I&#39;ll get to that...\n\nFirst, though, how to do RESTful push given the current reality.  Is\nthere some requirement that long polling results in a 200 response?\nBetter to assign a sub-resource to handle long polling, and have it\nsend a redirect to the updated resource.  Instead of sending a new\nrepresentation to every client polling, just a URI is sent, allowing\nall those clients to take advantage of caching of the main resource.\nNot an ideal solution, but an improvement on common practice.  The\nproblem is how to make one resource capable of both pull and push...\n\nhttp://tools.ietf.org/html/rfc2177\n\nSo why not define HTTP IDLE, if the solution is going to require all\nintermediaries be upgraded in order to work, anyway?  IDLE would be\nalmost exactly like GET, except that instead of a 304 the connection\nstays open.  Caches could pool IDLE requests from multiple clients,\nreducing load on origin servers.  The advantage of caching solves the\nproblem of reducing the bandwidth required to service push requests, by\nseveral orders of magnitude at Internet scale as compared to using a\nprotocol that&#39;s essentially an uncacheable, raw TCP connection based on\nthe provably false assumption that network or user-perceived performance\nare somehow impaired by the overhead of HTTP headers (OK, they are a\nlittle, but it&#39;s a tradeoff worth making -- an un-protocol isn&#39;t the\nsolution).\n\nWouldn&#39;t it be better, in the commonly-cited use case of a stock ticker,\nif that exactly-the-same data could be shared instead of having to be\ndelivered separately to every browser interested in the resource -- at\nthe same time, no less?  The Web Sockets solution, i.e. reducing\nprotocol overhead by eliminating headers entirely, throws this baby out\nwith the bathwater.  Surely a better solution is warranted?\n\nUnless Web Sockets is committed to being compatible with HTTP&#39;s\nUpgrade facility (instead of requiring an upgrade of the deployed\ninfrastructure), just what problem is it solving that wouldn&#39;t be\nbetter, more easily and more securely addressed by extending HTTP\nrather than declaring it obsolete?  Even if this problem is recognized\nand solved, is this protocol really an HTTP &quot;upgrade&quot; or rather, a\ncompletely fundamentally opposed protocol violating basic Web security\nby using HTTP to tunnel through any firewalls, even as a temporary\nstopgap until ws:// and wss:// are approved?  Using Upgrade to launch\nHTTP 1.2, rHTTP or Waka makes sense; Web Sockets, not so much.\n\nSurely *any* solution that&#39;s compatible with RESTful implementation, is\nby default aligned with both Web and Internet architecture?  I fail to\nunderstand why REST is a toxic concept to the browser vendors.  It\nseems to me like it&#39;s in their best interests, unless of course you&#39;re\nGoogle and your goal is not to improve the Web, but to try to corrupt\nit into being a replacement for an OS for the purpose of taking market\nshare away from Apple and Microsoft...  Without any technical basis for\nWeb Sockets, I&#39;m left to ponder the political considerations of those\npushing hardest against using HTTP for Web messaging (as if it were\nobsolete).\n\nSo I&#39;m calling &quot;ITAS&quot; (see post title) on Web Sockets -- this isn&#39;t\nREST, Web or Internet architecture; in fact, it isn&#39;t architecture at\nall.  As such, it ought to be killed in favor of an architecture-\noriented solution.  Apologies to those working on it, I have no issues\nwith y&#39;all trying to make the best of a situation being foisted on us\nby the runaway HTML 5 project.  But my opinion is that it&#39;s DOA, and\ngiven that, I&#39;d just as soon it not see the light of day so I won&#39;t be\nforced to deal with it for the rest of my career even if I choose _not_\nto implement it in my own projects.  Kinda like Flash.\n\n-Eric\n\n"}}