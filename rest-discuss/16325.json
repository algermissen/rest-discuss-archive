{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":289191104,"authorName":"Jan Algermissen","from":"Jan Algermissen &lt;algermissen1971@...&gt;","profile":"algermissen1971","replyTo":"SENDER","senderId":"Uujch75HknuKk6WiXy0ABNvW081oxrD2KJWehxRD2uvYjs01I7V5SohDo6Mg55VTixl1C2WUzPjhE4Fmd-HKbY8v84Qhtk4Fey8ttFZsvdo","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Processing semantics vs. declaring capabilities. Was: Atom feed vs. list of orders","postDate":"1281695729","msgId":16325,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAwQzFBOEQ4LTc5MjEtNERBOS04MjQ4LTExMjZBMTBFMzMxRUBtYWMuY29tPg==","inReplyToHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPg==","referencesHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPg=="},"prevInTopic":16319,"nextInTopic":16329,"prevInTime":16324,"nextInTime":16326,"topicId":16194,"numMessagesInTopic":86,"msgSnippet":"Here is a different angle how one might look at this: The two headers Content-Type and Accept serve two entirely different purposes: Content-Type: tells the","rawEmail":"Return-Path: &lt;algermissen1971@...&gt;\r\nX-Sender: algermissen1971@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 92030 invoked from network); 13 Aug 2010 10:36:16 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m11.grp.re1.yahoo.com with QMQP; 13 Aug 2010 10:36:16 -0000\r\nX-Received: from unknown (HELO asmtpout026.mac.com) (17.148.16.101)\n  by mta3.grp.re1.yahoo.com with SMTP; 13 Aug 2010 10:36:16 -0000\r\nMIME-version: 1.0\r\nContent-transfer-encoding: 7BIT\r\nContent-type: text/plain; charset=us-ascii\r\nX-Received: from [192.168.2.102] ([84.143.188.11])\n by asmtp026.mac.com (Sun Java(tm) System Messaging Server 6.3-8.01 (built Dec\n 16 2008; 32bit)) with ESMTPSA id &lt;0L73006Q56R5CW00@...&gt; for\n rest-discuss@yahoogroups.com; Fri, 13 Aug 2010 03:35:34 -0700 (PDT)\r\nX-Proofpoint-Spam-Details: rule=notspam policy=default score=0 spamscore=0\n ipscore=0 phishscore=0 bulkscore=0 adultscore=0 classifier=spam adjust=0\n reason=mlx engine=6.0.2-1004200000 definitions=main-1008130045\r\nX-Proofpoint-Virus-Version: vendor=fsecure\n engine=2.50.10432:5.0.10011,1.0.148,0.0.0000\n definitions=2010-08-13_03:2010-08-13,2010-08-13,1970-01-01 signatures=0\r\nIn-reply-to: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\r\nDate: Fri, 13 Aug 2010 12:35:29 +0200\r\nCc: REST Discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-id: &lt;00C1A8D8-7921-4DA9-8248-1126A10E331E@...&gt;\r\nReferences: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nX-Mailer: Apple Mail (2.1081)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jan Algermissen &lt;algermissen1971@...&gt;\r\nSubject: Re: [rest-discuss] Processing semantics vs. declaring capabilities.\n Was: Atom feed vs. list of orders\r\nX-Yahoo-Group-Post: member; u=289191104; y=dM8iFoHN0ehmTNLwzspfsemX4X20YWqE4a2pbS0kUsRKGuCb0P9MpYpQ\r\nX-Yahoo-Profile: algermissen1971\r\n\r\nHere is a different angle how one might look at this:\n\nThe two headers Content-Type and Accept serve two entirely different purposes:\n\nContent-Type: tells the recipient which processing model to apply to the message body. Roughly, the meaning is &quot;I am sending you this. Please understand it to be of this type and process accordingly&quot;.\n\nAccept: tells the server which types of representations the user agent can handle to achieve whatever it wants to achieve with the response to the current query. Roughly: &quot;I am about to do something with what you send me back. I can do that something as long as you send me one of the accepted types.&quot;\n\n[The following is contradicting my previous statement below, don&#39;t get confused]\n\nMedia types primarily serve the purpose of expressing processing models. Only when new processing models emerge should we mint new media types. IOW: as long as the media types you have available make correct candidates for the Content-Type header values we do not need new media types.\n\napplication/atom+xml is in that sense necessary because it defines a very different processing model than text/html. While you could provide the same information as application/atom+xml does with text/html and microformats you could not express a processing model beyond that of text/html.\n\nThink of it this way: when you say Content-Type: text/html the recipient will fire up the browser, never the feed reader.\n\n\n\nThe issues I have had with declaring capabilities or expectations in the Accept header are better solved by the principle of designing for re-use, IMO.\n\nMy major concern is how the server developer would know about any additional expectation of the client beyond the declared Accept values. I am (was) worried that the server developer would not have a clue that would keep him form doing simply *anything* as long as the response comes in e.g. application/atom+xml.\n\nNow, in my thinking, the developers &#39;in&#39; a system (say: an enterprise, or *the* Web, or an enterprise and it&#39;s suppliers) know[1] the set of media types used. Regarding the example below, a server side developer of the new-orders resource would know that orders can be represented as application/order. When it comes to implementing the handler for application/atom+xml designing for maximised re-usability would mean to either include the application/order XML directly in the feed or at least provide alternate links from where the client can access the application/order version.\n\nSimply serving an HTML (or even scaned image) based feed and not providing application/order somehow would just be bad design.\n\nOn this basis, having the newly-ordered-items-summary-building client just send Accept: applicaton/atom+xml would do the job for me. Then, if you want to fortify your system a bit more, you can use profile parameters to help conneg (but it now appears to me as typical enterprisey overkill).\n\nJan\n\n\n[1] &#39;know&#39; of course being an evolving state\n\nOn Aug 6, 2010, at 1:05 PM, Jan Algermissen wrote:\n\n&gt; Something I have been trying to wrap my head around:\n&gt; \n&gt; Suppose we are dealing with the procurement domain. Also suppose we plan on dealing with lists of orders (e.g. maybe there is a system that manages orders and exposes the new ones, processsed ones or the ones being shipped. There will be clients that do something with these order lists such as compiling a report.\n&gt; \n&gt; Also suppose we have defined a link semantic that allows a server to point a client to, for example, the list of new orders.\n&gt; \n&gt; It is not important how that link semantic looks, but it could be &lt;newOrders href=&quot;/foo/bar&quot; /&gt; or &lt;link rel=&quot;new-orders&quot; href=&quot;/foo/bar&quot;/&gt; or an AtomPub collection with a special category: &lt;collection href=&quot;/foo/bar&quot;&gt;&lt;category term=&quot;new-orders&quot; scheme=&quot;..&quot;/&gt;&lt;/collection&gt;.\n&gt; \n&gt; I personally &#39;call&#39; any of those &#39;link semantics&#39; and for the purpose of my question it only matters that the useragent ends up knowing that\n&gt; \n&gt; \n&gt;   /foo/bar  is the URI of a resource that represents the list of new orders.\n&gt; \n&gt; An equivalent from the HTML world would be that &lt;img src=&quot;/baz.gif&quot;/&gt; tells the client that\n&gt; \n&gt;  /baz.gif is a resource that is &#39;an image&#39;[1]\n&gt; \n&gt; \n&gt; The issue I am dealing with is this: What is the appropriate degree of specificity of the media type for lists of orders. Especially I am wondering whether it is enough for the user agent to say\n&gt; \n&gt;  Accept: application/atom+xml;type=feed\n&gt; \n&gt; \n&gt; or whether the Accept header should include the user agent capabilities regarding the individual order entries, e.g.\n&gt; \n&gt;  Accept: application/orderlist\n&gt; \n&gt; \n&gt; Take a step back and lets think about what is happening here. At one level, the server informs that client about the nature of a resource and at another (lower) level the client informs the server about its technical capabilities that allow it to process responses for a request to the given resource.\n&gt; \n&gt; I think it is important to distinuish these levels because the actual request the client makes does not express any assumptions about the nature of the resource, only about the technical capability.\n&gt; \n&gt; The assumption (e.g. that the requested resource is &#39;an image&#39;) happens before that.\n&gt; \n&gt; Browsers are implemented to follow &lt;img src=&quot;&quot;/&gt; links and process the response by inlining the received images into the rendered page. Other HTML-aware clients might be implemented to produce a fine-printed book of all images found via &lt;img src=&quot;&quot;/&gt; links.\n&gt; \n&gt; The actual request will (usually) contain an Accept header of the form:\n&gt; \n&gt; Accept: image/gif,image/jpeg,image/png,image/*\n&gt; \n&gt; What this accept header is saying is *not*\n&gt; \n&gt;    &quot;I expect that the requested resource is &#39;an image&#39;&quot;\n&gt; \n&gt; but\n&gt; \n&gt;       &quot;I can process a response to this request if you give me any of the accepted formts&quot;\n&gt;   IOW:&quot;I can do whatever I want to do if the response comes in any of these formats&quot;\n&gt; \n&gt; \n&gt; Before this gets boring, lets shift to the example of the list of new orders. Suppose I am implementing a user agent that compiles a list of all items ordered in the list of new orders.\n&gt; \n&gt; Such a user agent would be implemented to find (or just be given or have bookmarked) the URI of the resource that represents the list of new orders (in the same sense as browsers get hold of the URI of &#39;an image&#39;).\n&gt; \n&gt; How do I have to implement the user agent&#39;s construction of the GET request to /foo/bar?\n&gt; \n&gt; Suppose we are using a media type application/order for order representations and have also decided to build upon Atom for dealing with lists of stuff in our domain. We might construct the request as:\n&gt; \n&gt; GET /foo/bar\n&gt; Accept: application/atom+xml;type=feed\n&gt; \n&gt; and the server might send something like (excuse flaws in the XML, pls)\n&gt; \n&gt; \n&gt; 200 Ok\n&gt; Content-Type: application/atom+xml[1]       \n&gt; \n&gt; &lt;feed&gt;\n&gt;  &lt;entry&gt;\n&gt;    &lt;content type=&quot;application/order&gt;\n&gt;      &lt;order&gt;....&lt;/order&gt;\n&gt;    &lt;/content&gt;\n&gt;  &lt;/entry&gt;\n&gt;  &lt;entry&gt;\n&gt;    &lt;content type=&quot;application/order&gt;\n&gt;      &lt;order&gt;....&lt;/order&gt;\n&gt;    &lt;/content&gt;\n&gt;  &lt;/entry&gt;\n&gt; &lt;/feed&gt;\n&gt; \n&gt; Is that sufficient? Does the acept header sufficiently express the processing capabilities in the Accept header? Can the server know that the user agent wants to receive the entries as application/order? Is it ok to just program the user agent to ignore the entries of which it does not understand the type?\n&gt; \n&gt; Would we end up with the correct list of ordered items if all entries come back as HTML and the user agent ignores them?\n&gt; \n&gt; \n&gt; \n&gt; \n&gt; I think that there is a great danger of creating a nightmare of hidden coupling because in my opinion the user agent simply can *not* fullfil its processing goal given simply &#39;an atom feed&#39;. An Atom feed reader *can* do that (because it has a different goal) but a newly-ordered-items-list compiling user agent can not do that it it must express that in the Accept header.\n&gt; \n&gt; I&#39;d rather define a media type application/orderlist (defined as an Atom feed containing entries of application/order) and have the user agent be explicit:\n&gt; \n&gt; GET /foo/bar\n&gt; Accept: application/orderlist\n&gt; \n&gt; \n&gt; 200 Ok\n&gt; Content-Type: application/orderlist       \n&gt; \n&gt; &lt;feed&gt;\n&gt;  &lt;entry&gt;\n&gt;    &lt;content type=&quot;application/order&gt;\n&gt;      &lt;order&gt;....&lt;/order&gt;\n&gt;    &lt;/content&gt;\n&gt;  &lt;/entry&gt;\n&gt;  &lt;entry&gt;\n&gt;    &lt;content type=&quot;application/order&gt;\n&gt;      &lt;order&gt;....&lt;/order&gt;\n&gt;    &lt;/content&gt;\n&gt;  &lt;/entry&gt;\n&gt; &lt;/feed&gt;\n&gt; \n&gt; \n&gt; What do others think?\n&gt; \n&gt; (See also [3])\n&gt; \n&gt; Jan\n&gt; \n&gt; [1] &#39;An image&#39; is as good as it gets in terms of definitions, BTW.\n&gt;    &lt;http://www.w3.org/TR/html401/struct/objects.html#edef-IMG&gt; \n&gt;    Note that the HTML spec also provides some sort of hint what media types are involved when dealing with images.\n&gt; \n&gt; [2] conneged on the type param already, so no need to repeat it in the Content-Type header\n&gt; \n&gt; [3] There is also the issue of returning a feed that consists of references to entries that the user agent can then GET as Accept: application/order individually. Certainly we aould not want to define a list format that constrains the references to only references application;order resource. The user agent would basically have to report an error if the referenced order is not available as application/order (that is upon a 406 on a GET subrequest)\n&gt; \n&gt; An alternative would be to have the user agent Accept: application/atom+xml;type=feed but report an error if an entry in the feed is not provided as application/order (be it inline or via a sub-request).\n&gt; \n&gt; \n&gt; -----------------------------------\n&gt; Jan Algermissen, Consultant\n&gt; NORD Software Consulting\n&gt; \n&gt; Mail: algermissen@...\n&gt; Blog: http://www.nordsc.com/blog/\n&gt; Work: http://www.nordsc.com/\n&gt; -----------------------------------\n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n&gt; ------------------------------------\n&gt; \n&gt; Yahoo! Groups Links\n&gt; \n&gt; \n&gt; \n\n-----------------------------------\n Jan Algermissen, Consultant\n NORD Software Consulting\n\n Mail: algermissen@...\n Blog: http://www.nordsc.com/blog/\n Work: http://www.nordsc.com/\n-----------------------------------\n\n\n\n\n\n"}}