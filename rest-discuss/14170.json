{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":401876259,"authorName":"Will Hartung","from":"Will Hartung &lt;willh@...&gt;","profile":"gaminginparis","replyTo":"SENDER","senderId":"CY6T4Xoi28NL59QX1vCn3uOaxVwGnPSfJdnWXBc_MaP7Ml1pYdIMkygnn0WHPJ3aHH27yZEJQg3JasDWVwGr7N-qRgptHeo8TQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] RESTful M2M Systems and Resource Typing","postDate":"1261004773","msgId":14170,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDM5MTVjNjlkMDkxMjE2MTUwNnUxNTIwZTYzNmw2ZGE2NDI5ZmZlMWVlMDZAbWFpbC5nbWFpbC5jb20+","inReplyToHeader":"PDkxNkFENTIxLTVGRjEtNEU5Mi1BMUJELTVDNTJCREE5RDIzMUBtYWMuY29tPg==","referencesHeader":"PENCNEU1MkVDLTQ2RTktNDhFNC05QkY2LTVFNUVFMjg1NDM4OEBtYWMuY29tPgkgPGI1NDhkZjY1MDkxMjE2MDc1OHE0NjQzMDgwOHY4ODk4MzY5NDI4ZjVkOTE1QG1haWwuZ21haWwuY29tPgkgPDM0MkYwNEE0LUFCNzYtNEY5Qy04Mjg1LTU2QUFBMDE2Q0I0MEBtYWMuY29tPgkgPGI1NDhkZjY1MDkxMjE2MDkxMWoxYWEwN2Q2ZHFhOGQxMjU5ZmE3Mjc0ODcwQG1haWwuZ21haWwuY29tPgkgPDM5MTVjNjlkMDkxMjE2MTAzOXA3NWRkMzcxZGtmY2QyYmViODBjY2E4ZTk4QG1haWwuZ21haWwuY29tPgkgPDkxNkFENTIxLTVGRjEtNEU5Mi1BMUJELTVDNTJCREE5RDIzMUBtYWMuY29tPg=="},"prevInTopic":14169,"nextInTopic":14171,"prevInTime":14169,"nextInTime":14171,"topicId":14156,"numMessagesInTopic":134,"msgSnippet":"On Wed, Dec 16, 2009 at 12:27 PM, Jan Algermissen ... Part of the problem here is simply atom+xml. The problem is that it s too generic, and describes mostly a","rawEmail":"Return-Path: &lt;willh@...&gt;\r\nX-Sender: willh@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 76692 invoked from network); 16 Dec 2009 23:06:16 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m14.grp.re1.yahoo.com with QMQP; 16 Dec 2009 23:06:16 -0000\r\nX-Received: from unknown (HELO mail-vw0-f177.google.com) (209.85.212.177)\n  by mta3.grp.re1.yahoo.com with SMTP; 16 Dec 2009 23:06:16 -0000\r\nX-Received: by vws7 with SMTP id 7so432512vws.22\n        for &lt;rest-discuss@yahoogroups.com&gt;; Wed, 16 Dec 2009 15:06:13 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.220.124.6 with SMTP id s6mr327051vcr.3.1261004773136; Wed, 16 \n\tDec 2009 15:06:13 -0800 (PST)\r\nIn-Reply-To: &lt;916AD521-5FF1-4E92-A1BD-5C52BDA9D231@...&gt;\r\nReferences: &lt;CB4E52EC-46E9-48E4-9BF6-5E5EE2854388@...&gt;\n\t &lt;b548df650912160758q46430808v8898369428f5d915@...&gt;\n\t &lt;342F04A4-AB76-4F9C-8285-56AAA016CB40@...&gt;\n\t &lt;b548df650912160911j1aa07d6dqa8d1259fa7274870@...&gt;\n\t &lt;3915c69d0912161039p75dd371dkfcd2beb80cca8e98@...&gt;\n\t &lt;916AD521-5FF1-4E92-A1BD-5C52BDA9D231@...&gt;\r\nDate: Wed, 16 Dec 2009 15:06:13 -0800\r\nMessage-ID: &lt;3915c69d0912161506u1520e636l6da6429ffe1ee06@...&gt;\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nCc: mike amundsen &lt;mamund@...&gt;, REST Discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Will Hartung &lt;willh@...&gt;\r\nSubject: Re: [rest-discuss] RESTful M2M Systems and Resource Typing\r\nX-Yahoo-Group-Post: member; u=401876259; y=QIELMJApbI3mO9tzw87xZm2eCfoUofjWsMqHq1xdNTNZYO85D3JznQ\r\nX-Yahoo-Profile: gaminginparis\r\n\r\nOn Wed, Dec 16, 2009 at 12:27 PM, Jan Algermissen\n&lt;algermissen1971@...&gt; wrote:\n&gt;\n&gt; On Dec 16, 2009, at 7:39 PM, Will Hartung wrote:\n&gt;\n&gt;&gt; The media-type would have informed me what\n&gt;&gt; the &quot;rel=&#39;next&#39;&quot; link means.\n&gt;\n&gt; Sure. But how did you know that it makes sense to write code that looks for\n&gt; the rel=&quot;next&quot; in the first place? Or: how did you know it makes sense to\n&gt; expect that the response would be available in application/atom+xml?\n\nPart of the problem here is simply atom+xml. The problem is that it&#39;s\ntoo generic, and describes mostly a payload rather than strict\nsemantics. That&#39;s what you&#39;re bumping in to here. Link relationships\nin atom are just that, relationships,\n\nBut, in theory, when the media type is documented, the semantics of\nthe rels will be defined. Deciding to look for a particular link type\non your machine varies. For example, if you have a media-type that has\nlinks for paging, then it&#39;s not untoward to have a client coded to\ncheck for links tagged with  &#39;next&#39; rels if it wants more of the\nresource being served. But you can see how this is an optional link --\nthere may well not be any more available.\n\nAs for how I know to expect a response to be available in response to\nthe link, the link can/should have a type associated with it telling\nme that&#39;s what to expect.\n\n&gt; As a human, you do the GET, see what is returned and if you understand it.\n&gt; Then, if you do, you know what you can do next. All fine.\n&gt;\n&gt; When coding a client, however, you need to know at design time that it makes\n&gt; sense to expect application/atom+xml to be returned. There might be other\n&gt; possible media types available, too, but you need some source of information\n&gt; that is the source for this expectation.\n\nThe entry points of the service need to be externally documented, part\nof that documentation is the media type being returned, or available.\n\nIf you want alternate forms, then in theory you should be able to fall\nback on content negotiation.\n\nAnd if you end up at an impasse where the server supplies one type but\nthe client only accepts another, then that&#39;s what you have -- impasse.\nThe client gets to explode spectacularly and start paging operators,\nor whatever it&#39;s failure mode is.\n\nIn this sense, yea, clients are tightly coupled to their\ninterpretations of the media types. If it&#39;s an extensible media type,\nthen ideally you have an extensible client in the sense that the\nclient won&#39;t lost functionality in the long term, but it won&#39;t\nnecessarily be able to leverage any new capability as manifested by\nnew entries in an updated media type.\n\nIf the underlying media type changes dramatically, then the media type\nshould change, and the client should end up at an impasse (what it can\nprocess vs what the server can provide are incompatible).\n\nYou can not eliminate this coupling. All you can do is make the\ncoupling less painful by using extensible media types that accept\nchange more readily and ensure backward compatibility and by\nimplementing friendly services that don&#39;t simply &quot;go dark&quot; without\nsolid warning, announcements, etc. and themselves maintaining some\nmodicum of backward compatibility (i.e. still accepting the old\nprotocols during some transition period).\n\nIn the end, the server can send a 406 Does not accept with a nice\ndescription of &quot;Yea, we changed this 2 years ago, here&#39;s a link to the\nnew documentation&quot;.\n\nSo, how does REST then differ from some other mechanism? Where&#39;s the promise?\n\nThe promise comes from the fact that the media types are the details\nof the system, but those details are actually pretty high level.\n\nThe hard details, the links, the host names, etc. those are gone.\nThose can change however and whenever you want, and compliant clients\nwill continue to function.\n\nIf you add a new media type to your system, then once the clients\nactually understand that media type, then it&#39;s back in the game. For\nexample, you can have a new media type, application/yourapp+xml, and\nit changed to application/yournewapp+xml. If a client understands both\nof those, then as you roll out this new media type throughout your\ninfrastructure, the clients will work with both.\n\nYou could have a new payload link to a service that provides the old\npayload, and the client will say &quot;okey dokey&quot; because it understands\nthem both. And when you finally upgrade that older service to the new\ntype, the client doesn&#39;t change -- it already knows the new payload,\nall you did was change the new part to instead of pointing to an older\nserver, it points to a modern service.\n\nThe client doesn&#39;t know anything about what host or app or whatever is\nbeing called, it know opaque URIs and media types, so this contract\nholds.\n\nCombining uniform interface with &quot;well known&quot; media types lets the\nunderlying infrastructure remain nimble.\n\nBut it also highlights how you should go about selecting and designing\nthe media types for your application.\n\nRegards,\n\nWill Hartung\n(willh@...)\n\n"}}