{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"R03W1LTtSkrLlYRbQSg3r6dr5UDuBlSQXP8FopH-ESDF2zaZ0lTTDLDZBtWSS6z8Nh63vuhzYPdY54S0QNcZlv1FQmVWO6YRi788DddfJQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: Good way to report types of a resource?","postDate":"1289001820","msgId":16803,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAxMTA1MTgwMzQwLjI2YzlkM2IwLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlrekV4bXA5ejRMSlhEK3NNTk5GVGlDQlBSVmhkMjN4Y0ErckRid0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PDIwMTAxMTAzMTgyNjUxLmY2ZjQyNzQ1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPGlhdGNnYStodms0QGVHcm91cHMuY29tPgk8MjAxMDExMDMyMzEzNTEuMjBjNDViZjAuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWt6RXhtcDl6NExKWEQrc01OTkZUaUNCUFJWaGQyM3hjQStyRGJ3QG1haWwuZ21haWwuY29tPg=="},"prevInTopic":16802,"nextInTopic":16804,"prevInTime":16802,"nextInTime":16804,"topicId":16793,"numMessagesInTopic":10,"msgSnippet":"... Close.  The negotiated representation may be application/xhtml+xml, application/xml, text/html, text/xml, text/plain or application/atom+ xml (sometimes ;","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 55627 invoked from network); 6 Nov 2010 00:03:30 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m1.grp.sp2.yahoo.com with QMQP; 6 Nov 2010 00:03:30 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.sp2.yahoo.com with SMTP; 6 Nov 2010 00:03:29 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id AB877509D9;\n\tFri,  5 Nov 2010 20:03:28 -0400 (EDT)\r\nDate: Fri, 5 Nov 2010 18:03:40 -0600\r\nTo: Erik Mogensen &lt;erik@...&gt;\r\nCc: Ray &lt;ray.polk@...&gt;, rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20101105180340.26c9d3b0.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTikzExmp9z4LJXD+sMNNFTiCBPRVhd23xcA+rDbw@...&gt;\r\nReferences: &lt;20101103182651.f6f42745.eric@...&gt;\n\t&lt;iatcga+hvk4@...&gt;\n\t&lt;20101103231351.20c45bf0.eric@...&gt;\n\t&lt;AANLkTikzExmp9z4LJXD+sMNNFTiCBPRVhd23xcA+rDbw@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: Good way to report types of a resource?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nErik Mogensen wrote:\n&gt;\n&gt; &gt;\n&gt; &gt; When I talk about resource type, I&#39;m talking about an abstraction\n&gt; &gt; which manifests itself in various ways in my system (hypertext,\n&gt; &gt; configuration files), but never in a header or any other field. I\n&gt; &gt; have over a dozen resource types on the system I&#39;m developing, all\n&gt; &gt; of which negotiate between the same handful of ubiquitous media\n&gt; &gt; types. Media types identify generic processing models for families\n&gt; &gt; of forwards-backwards compatible data types.\n&gt; &gt;\n&gt; \n&gt; You have a dozen or so resource types (e.g. person, order or\n&gt; whatever; I don&#39;t know your domain) and they all typically have an\n&gt; XHTML representation, and perhaps a url encoded form representation\n&gt; (and some of the other 11 ubiquitous media types) of some sort.\n&gt; \n&gt; Is that a correct assumption?\n&gt; \n\nClose.  The negotiated representation may be application/xhtml+xml,\napplication/xml, text/html, text/xml, text/plain or application/atom+\nxml (sometimes ; type=feed).  My resource types are related to the\nintegration of wiki, weblog and forum; all of which are represented as\neither Atom Entry or Atom Feed documents.  Atom (etc.) is encapsulated\nby HTML to provide a hypertext user interface.  The HTML user interface\nis negotiated based on client capability (read on), and it&#39;s this user\ninterface which communicates the difference in resource types to the\nuser (read on).\n\n&gt;\n&gt; If it is, then I assume that your resources work perfectly in Firefox\n&gt; or any other generic user agent, and can be cached and transmogrified\n&gt; using Google&#39;s mobile proxy and so on.  Nice.\n&gt; \n\nAlmost.  I&#39;m using client-side XSLT, initiated via XML PI.  Most user-\nagents grok application/xhtml+xml, but IE needs application/xml while\nAtom-only clients are redirected to application/atom+xml.  Other user-\nagents need a text/html represenation, generated server-side; text/xml\nand text/plain are really just there to demonstrate how certain browsers\nfail to respect sender intent.  In a perfect world, I wouldn&#39;t need\nconneg, if all user-agents (bots, browsers etc.) would only agree to\nsupport XSLT via XML PI using application/xhtml+xml, because that media\ntype best describes sender intent (so does text/html for my server-side\nXSLT, but in my case application/xml and text/xml do not because current\nbrowsers don&#39;t respect that intent, and text/plain only does for user-\nagents which respect my display-rather-than-render intent).\n\nIOW, my resources *should* work perfectly as you say, without conneg.\nThe fact that conneg exists, is what allows interoperability of new\napproaches, i.e. browser-resident XSLT, and compensates for the fact\nthat in the real world not every participant in the communication is\nwell-behaved.  Minting new data/media types for every resource type\nmeans your resources fail hard, instead of degrading gracefully.  What\nconneg does for me, is enable graceful degradation and forwards\ncompatibility which is only possible when resource type is decoupled\nfrom media type.\n\n&gt; \n&gt; &gt; \n&gt; &gt; The application logic is in the interpretation of the payloads,\n&gt; &gt; after following the designated processing models. The application\n&gt; &gt; code has knowledge of the resource type, the user-agent requires\n&gt; &gt; none, i.e. this is not a concern at the protocol layer.\n&gt; &gt;\n&gt;\n&gt; Here&#39;s where I&#39;m not 100% clear on your terminology.  Normally, I&#39;d\n&gt; interpret &quot;application logic&quot; as the server component, but here I&#39;m\n&gt; inclined to understand it as a rich client component, since it does\n&gt; most of the &quot;interpretation of the payloads&quot;.\n&gt; \n&gt; If I&#39;m right to interpret &quot;application logic&quot; as a client connector,\n&gt;\n\nIn REST, the application logic is what executes in client components.\nTypically, application logic also resides in the server code generating\nthe code executing in client components, however, I&#39;ve used client-side\nXSLT to place it entirely within the browser.  So my terminology was\nconfusing, as I was thinking in terms of my system.  What I meant was,\nthe API is in the interpretation of payloads.  This is the notion of a\nself-documenting API, which my HTML served as text/plain should never\nbe, but which IE transforms anyway, by treating it as application/xml,\nwhich isn&#39;t my intent either; or what IE does, which ultimately amounts\nto treating it as text/html, which is a privilege escalation.\n\nWhat media type to send shouldn&#39;t be considered part of the application\nlogic; it&#39;s system logic on the origin server.  My application logic is\nexpressed by the combination of HTML, XSLT, Javascript, CSS, images,\nAtom Entry/Feed/Category, and XBEL documents which together comprise the\nsteady-states which users interact with; processed according to the\nmedia types and encodings I&#39;ve assigned to them per-request on the basis\nof capabilities and realities.  Resource type is key to the rendering\nand interpretation of the API, yet bears no relation to the processing\nrules used to decode that API into, say, a DOM.\n\n&gt;\n&gt; then that more specific client (e.g. yours) would recognize the\n&gt; &quot;person HTML&quot; as a person resource type and (perhaps?) present that\n&gt; differently... Or...? You mention that the application logic knows\n&gt; about resource types, so I&#39;m curious to understand how it recognizes\n&gt; them.\n&gt; \n\nThe system I&#39;m working on uses Atom Feeds to represent many resource\ntypes -- one is wiki page, another is weblog archive.  The HTML\ninterface of a wiki page is different than that of a weblog archive.\nNeither the application logic nor the user-agent cares about this\ndistinction -- the interface is uniform -- they just need to call the\nproper transformation.\n\nSo the distinction between resource types on my system, manifests\nitself in the @href of the xml-stylesheet PI.  It&#39;s incidental, and not\na thing to standardize as separate media types or present as custom link\nrelations.  The user sees either what looks and functions like a wiki\npage, or what looks and functions like a weblog archive (regardless of\nwhether by user I mean human or machine).\n\nThe users know what their goals are, the hypertext explains how to\naccomplish those goals; user-agents provide a mechanism which translates\nthese goals into actions.  This mechanism (hypertext over HTTP) simply\ndoesn&#39;t need to care about resource types.  This decoupling is what\nallows my representations to be negotiated between media types.  If the\nmechanism needs to know about resource type, it&#39;s coupling client to\nserver.\n\nWho cares about resource type, are resource owners and end users.\n&quot;Wiki page&quot; and &quot;weblog archive&quot; are abstract notions the resource\nowner needs to communicate to the end user.  This understanding has no\nbearing on the semantics of the messaging between connectors, where\neverything is an Atom Feed or Entry, and roughly follows Atom Protocol.\nThe application logic, client-side or server-side, makes sure that the\nright markup goes to the right place, without caring about resource\ntype -- media types aren&#39;t contracts, just a shared understanding of\ncommon processing models.\n\n&gt;\n&gt; And lastly, just a word of praise :-)  I greatly appreciate your\n&gt; efforts in this list, and although I&#39;ve been learning REST for 7\n&gt; years, I still think there&#39;s more to it:\n&gt; \n&gt; http://stackoverflow.com/questions/3543075/what-is-a-concise-way-of-understanding-restful-and-its-implications/3543326#3543326\n&gt;\n\nOr, a lot less to it.  Thanks, btw, and sorry you&#39;re having difficulties\nwith rest-discuss (happens).  The most concise explanation of REST I\ncan give, uses OOP terminology.  Resources are objects with IDs.  Each\nobject may have one or more methods from a set, which remains uniform\nfrom one object to the next, and from one system to the next.  If you\nneed more methods, REST says try using more objects, first.  Messaging\nbetween objects is HTTP.\n\nProperties vary depending on the nature of the request (method,\nselection headers, cache-control), organized by response code.  For any\nresponse code, each object may have one or more associated data types\nfrom a standardized set, the processing of which is determined by a\nregistered set of media types; both of which remain uniform from one\nobject to the next, and from one system to the next.  If you need more\ndata/media types, REST says try less coupling, first.  The API is\ndescribed using standardized hypermedia data types and link relations.\nHyperlinks are used within properties, to reference other objects for\nencapsulation, inheritance or extension.\n\nFamiliar approaches to networked software development (DCOM, CORBA, SOA,\nmany unRESTful HTTP APIs, etc.) attempt to distribute the object over\nthe wire, ignoring the constraints imposed by the network (see REST 2.1,\n2.3.1).  REST deviates radically from these unproven approaches, by\nproviding a uniform object interface which compensates for the reality\nof these network constraints by becoming part of the network itself.\n\nYou aren&#39;t distributing your objects, you&#39;re attaching them as nodes on\na network-based, distributed object messaging bus.  Instead of the\nlimited scale of ESB, think GSB -- Global Service Bus, or distributed\nESB.  You&#39;re extending your object *interface* across organizational\nboundaries, in a proven, standardized fashion described as a set of\ndesign constraints named REST (or CREST, or ARRESTED, or whatever set\nof constraints is appropriate to both the characteristics of the global\nInternet and the needs of your system).  If your object interfaces are\napplication-specific, you&#39;re distributing your objects instead of\ndistributing your uniform object interfaces, even with HTTP + URI.\n\n-Eric\n\n"}}