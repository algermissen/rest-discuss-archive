{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":4849001,"authorName":"Alex Jacobson","from":"Alex Jacobson &lt;alex@...&gt;","profile":"shop2it","replyTo":"SENDER","senderId":"Ms4G2C9WwgQe7Th2HtQy40jx3ooXsmEolriF9eMdc7IDabRfFEmvLqXhuTBeZBfQymXw6o0fxTAcF8GLg9EADBP-","spamInfo":{"isSpam":false,"reason":"0"},"subject":"MoST - Model State Transfer (was Pure-REST Wiki experiment)","postDate":"1059520405","msgId":3803,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDE3MzU5MTgzMzguMTA1OTUwNjAwNUBsb2NhbGhvc3Q+","inReplyToHeader":"PDBFQUE1MDY3ODdEMTJCNEI5OUQzQ0EwODYyMzBBMkI0REE5RkEyQG1haWwtMDEuc3Bva2Vzb2Z0d2FyZS5jb20+","referencesHeader":"IDwwRUFBNTA2Nzg3RDEyQjRCOTlEM0NBMDg2MjMwQTJCNERBOUZBMkBtYWlsLTAxLnNwb2tlc29mdHdhcmUuY28gbT4="},"prevInTopic":3801,"nextInTopic":3804,"prevInTime":3802,"nextInTime":3804,"topicId":3793,"numMessagesInTopic":23,"msgSnippet":"Note: Draft musings.  Please be gentle. Model State Transfer is an emerging web architecture style in which agents transfer application data models themselves","rawEmail":"Return-Path: &lt;alex@...&gt;\r\nX-Sender: alex@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 90011 invoked from network); 29 Jul 2003 23:14:09 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m19.grp.scd.yahoo.com with QMQP; 29 Jul 2003 23:14:09 -0000\r\nReceived: from unknown (HELO mailgate.vo.com) (208.45.6.97)\n  by mta2.grp.scd.yahoo.com with SMTP; 29 Jul 2003 23:14:09 -0000\r\nReceived: from [10.255.218.171] (m6a8d36d0.tmodns.net [208.54.141.106])\n\t(using TLSv1 with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits))\n\t(No client certificate requested)\n\tby mailgate.vo.com (Postfix) with ESMTP\n\tid 2D6F389685; Tue, 29 Jul 2003 19:14:08 -0400 (EDT)\r\nDate: Tue, 29 Jul 2003 19:13:25 -0400\r\nTo: Justin Sampson &lt;justin.sampson@...&gt;,\n\trest-discuss@yahoogroups.com\r\nSubject: MoST - Model State Transfer (was Pure-REST Wiki experiment)\r\nMessage-ID: &lt;1735918338.1059506005@localhost&gt;\r\nIn-Reply-To: &lt;0EAA506787D12B4B99D3CA086230A2B4DA9FA2@...&gt;\r\nReferences:  &lt;0EAA506787D12B4B99D3CA086230A2B4DA9FA2@...\n m&gt;\r\nX-Mailer: Mulberry/3.0.3 (Win32)\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=us-ascii; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nX-eGroups-From: Alex Jacobson &lt;alex@...&gt;\r\nFrom: Alex Jacobson &lt;alex@...&gt;\r\nX-Yahoo-Group-Post: member; u=4849001\r\nX-Yahoo-Profile: shop2it\r\n\r\nNote: Draft musings.  Please be gentle.\n\nModel State Transfer is an emerging web architecture style in which agents \ntransfer application data models themselves occasionally packaged with \nmetadata describing how the model should be viewed and constraining how it \nmay be altered (e.g. HTML/XML with css/xsl stylesheets and schemas).  In \ncontrast Representational State Transfer, is an older style in which agents \ntransfer representations of application referents (e.g. HTTP with conneg \nand content-type).\n\nREST pretends that we can talk about transferring representations without \ntalking about being able to talk unambiguously about what is represented. \nThis pretense is surprisingly effective in publishing information hidden in \ndatabases.  It runs into serious trouble however when we want to shift from \npublishing apps to two-way apps.  Examples include the difficulty in \ndescribing how to implement a Wiki, the meaninglessness of &quot;index&quot; and HTTP \ncontainers, the failure of conneg, the uselessness of PUT (and WebDAV \nalmost everywhere), and the lack of a coherent story about POST.\n\nNo ReSTful general Wikis or web editting (or the uselessness of PUT)\nReSTful clients lack a model for the data they receive and therefore can do \nlittle other than render it.  The uselessness of PUT is an obvious \nconsequence of this failure.   PUT only works in the small set of apps \nwhere the returned data happens to correspond to the underlying model or \nwhen changes in the representation are invertible.  Those apps are actually \nrelatively rare.  Wiki and database apps both fall outside that category. \nOf course, one CAN design apps to make sure that this constraint is \nfollowed, but then you are no longer passing around representations, you \nare passing around data models themselves.\nThe upshot of ReSTs failure here is that we are actually spending any time \nat all implementing Wikis as opposed to WebDAV and that none of this work \nis useful for editing user-friendly directories.  In contrast, MoST \narchitectural style would give the client the underlying data so that \nFile|Edit would have the browser open an editor appropriate to the data \ncontent-type.  For example, in a addressbook application, the server would \nsend XML V-Cards with a stylesheet URL in the XML header that transforms \nthose v-cards into user-friendly SVG.  The client would apply the \ntransformation and render the SVG using an SVG viewer.   If the user chose \nFile|Edit from the browser menu, the browser would open up an editor \ndesigned to handle v-cards (outlook? if installed) or perhaps simply an XML \neditor.  And when the user &quot;saves&quot; the changes, they are simply PUT back to \nthe server.\n\n\nContainers\nAnother example of the failure of the ReST model is uselessness of the \ncontainer metaphor.  The most obvious operation to perform on a container \nis to obtain an enumeration of its contents.  ReST provides no standard way \nto do that.  Instead servers are intended to return a &quot;respresentation&quot; of \nthe container. In practice this representation is so far from representing \nthe container that a foo/ URL is really just a URL like any other with no \nparticularly interesting special properties.  Under MoST GETting a foo/ URL \nwould actually result in a model of the container.  This model may be \npackaged with a view URL/transformation, but containership would actually \nhave real meaning.\n\nContent-Negotiation\nContent-negotiation exacerbates the problem above.  It is particularly \nincompatible with PUT/POST because the server has no way to tell the client \nwhat types may be PUT/POST and REST provides no way to understand what was \nmeant when a client does so.  MoST applications  give each URL a specific \ncontent-type/data-model.  MoST clients and servers know that they are \ncommunicating about that data model.  Under MoST it is meaningful to update \ncontent from a PUT.  In real life, conneg is used much less often than \nsimply proliferating URLs.  MoST endorses that approach, viewing e.g. \nlanguage translations as different objects and not simply different \nrepresentations.\n\nWhat is a POST?\nIn theory a POST is intended to update the server about some refferent.  In \npractice usage of POST also ends up being application specific.  There is \nno way to know what one may POST to a particular URL without having access \nto some special purpose meta-data located at some arbitrarily different URL \n(the location of e.g. an HTTP form).  ReST also provides no way of knowing \nwhat the consequence of a POST is, other than, abstractly, some state \nchange, perhaps.  In contrast, a MoST POST has some semantic coherence.  It \nis an append to a container (because we now have containers) or it is an \nupdate to particular data model based on the semantics of updates to models \nof that type.  Note: Unlike ReST POSTs, MoST POSTs are NOT database queries \nunless they create new resources that are result-sets.\n\nQueries\nReST has no interpretation of query strings either.  They are opaque and \ninvisible.  MoST constrains query strings to be filters on the set of \nobjects returns by a container (because it actually has access to models it \ncan do this).  Query-strings on non-container objects are not-meaninful.\n\nContainer Creation\nMKDIR is a silly semantic.  Simply PUT a container data model at a URL \nwhere you want the container to be.  Then you have a container.  If the \nserver doesn&#39;t understand the semantics of the container data model the \nclient puts, it gives an error.\n\nHTTP support for MoST architectural style is relatively weak.  Content-type \nends up being used both to constrain viewing and editing.  XML with schemas \nand stylesheets better supports MoST.   It would be nice to be able to do \nMoST with other content-types.  Perhaps HTTP will eventually have a \ncontent-view or model-location header.\n\nNote: MoST isn&#39;t a PhD thesis.  It is just my description of a different \ndesign philosophy\nthat I see around.  Hoping for useful comments.\n\nJustin is effectively describing a MoST wiki implementation rather than a \nReST implementation below.\n\n-Alex-\n\n___________________________________________________________________\nS. Alexander Jacobson                   i2x Media\n1-212-787-1914 voice                    1-603-288-1280 fax\n\n\n\n\n\n\n--On Monday, July 28, 2003 10:54 PM -0700 Justin Sampson \n&lt;justin.sampson@...&gt; wrote:\n\n&gt; Vincent Murphy wrote:\n&gt;\n&gt;&gt; &gt; The user interface is implemented completely on the client\n&gt;&gt; &gt; side using HTML and JavaScript.\n&gt;&gt;\n&gt;&gt; at first i wondered why not use conneg (perhaps based on the\n&gt;&gt; user agent (UA)) rather than a &#39;browser-within-a-browser&#39;\n&gt;&gt; approach. as in, the editor GETs wiki-text, and everything else\n&gt;&gt; GETs HTML.\n&gt;\n&gt; I have a feeling what I really want is to convince the browser\n&gt; that my client.html is actually a plugin appropriate for\n&gt; text/x-wiki content. So, whenever the user types in a URI that\n&gt; dereferences to a representation of type text/x-wiki, the\n&gt; response would simply be passed off to this JavaScript client.\n&gt; The client would still have its own buttons for Edit and Delete,\n&gt; sending PUT and DELETE requests, respectively; but links to other\n&gt; Wiki topics or to non-Wiki URIs would be handed back to the\n&gt; browser.\n&gt;\n&gt; Justin\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; To unsubscribe from this group, send an email to:\n&gt; rest-discuss-unsubscribe@yahoogroups.com\n&gt;\n&gt;\n&gt;\n&gt; Your use of Yahoo! Groups is subject to http://docs.yahoo.com/info/terms/\n&gt;\n&gt;\n\n\n\n\n"}}