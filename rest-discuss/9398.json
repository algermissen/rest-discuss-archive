{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"oPW0XQcADagKNfzu3ToAUKma6uEnZ7j4naOZemd3hbM9RYu67BfWauNogEzRMvhJItdPyNSno_sMNfLIKUWiEUQO6wa7xHf5-xmGJ5XIug","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Fun with DELETE","postDate":"1184021686","msgId":9398,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PFcxNDUyMzMyMzExMTkzMTkxMTg0MDIxNjg2QG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":9397,"nextInTopic":9399,"prevInTime":9397,"nextInTime":9399,"topicId":8604,"numMessagesInTopic":107,"msgSnippet":"... In order for this to work, the client must somehow know that the URL being sent back in  is the same resource that the user just requested be","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 1161 invoked from network); 9 Jul 2007 22:55:20 -0000\r\nReceived: from unknown (66.218.66.68)\n  by m37.grp.scd.yahoo.com with QMQP; 9 Jul 2007 22:55:20 -0000\r\nReceived: from unknown (HELO mail.mailsnare.net) (209.236.228.78)\n  by mta11.grp.scd.yahoo.com with SMTP; 9 Jul 2007 22:55:20 -0000\r\nX-Virus-Scanned: by ClamAV at mailsnare.net\r\nX-Message-ID: 749f92e98ac7daa1b40c7093adeba4681e7bd0d5869d272e49d9ebde58f8da29\r\nReceived: from mail.mailsnare.net (unknown [209.236.228.74])\n\tby mail.mailsnare.net (Postfix) with ESMTP id E77E0792DB;\n\tMon,  9 Jul 2007 22:54:47 +0000 (UTC)\r\nTo: &quot;A. Pagaltzis&quot; &lt;pagaltzis@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nImportance: Normal\r\nSensitivity: Normal\r\nMessage-ID: &lt;W1452332311193191184021686@...&gt;\r\nX-Mailer: Mintersoft EdgeDesk, Build 4.03.0105\r\nDate: Mon, 09 Jul 2007 22:54:46 +0000\r\nOrganization: Bison Systems Corporation\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;utf-8&quot;\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nReply-To: eric@...\r\nSubject: Re: Fun with DELETE\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\n&gt;\n&gt;to put things in context, all of my following points below apply\n&gt;to the following protocol:\n&gt;\n&gt;    &gt; DELETE /foo/bar\n&gt;    &lt; 200 OK\n&gt;    &lt; Content-Type: application/vnd.exampleorg.tombstone+xml\n&gt;    &lt;\n&gt;    &lt; &lt;tombstone&gt;\n&gt;    &lt;   &lt;dead    href=&quot;/foo/bar&quot; /&gt;\n&gt;    &lt;   &lt;epitaph href=&quot;/deleted/foo/bar&quot; /&gt;\n&gt;    &lt; &lt;/tombstone&gt;\n&gt;\n&gt;    &gt; GET /foo/bar\n&gt;    &lt; 410 Gone\n&gt;\n&gt;    &gt; DELETE /deleted/foo/bar\n&gt;    &lt; 204 No Content\n&gt;\n&gt;    &gt; GET /foo/bar\n&gt;    &lt; 404 Not Found\n&gt;\n\nIn order for this to work, the client must somehow know that the URL \nbeing sent back in &lt;epitaph&gt; is the same resource that the user just \nrequested be DELETEd.  In other words, your DELETE semantic is &quot;move&quot;.  \nIf you want to assign a new URL to the resource, then you PUT the \nresource to the new /deleted/ URL followed by a DELETE to the no-\nlonger-desired URL.\n\nBut even that isn&#39;t right, because the old URL is still identifying a \nconcept that has not been DELETEd from the server, so you&#39;ve only \naccomplished changing the semantics of the mapping, which is the one \nthing REST doesn&#39;t allow you to change about your resource identifiers.  \nSee, if you then GET /foo/bar and receive a 410 response, the \nserver is lying, because it should really respond with a 307 redirect \nto /deleted/foo/bar since the resource isn&#39;t really gone, just moved, \n*and the server knows it* so it should tell the client.\n\n&gt;\n&gt;So does your design. It requires clients to know that 410 Gone\n&gt;means something in other than 410 Gone in addition to 410 Gone.\n&gt;\n\nNo, it most certainly does not.  Some people here assume that a client \nMUST NOT ever repeat a request which results in a 410 Gone.  If there \nwere any support for such a view in the standards, then the comments \nsuggesting that my 410 Gone is somehow &quot;overloaded&quot; might have a \npoint, but under the current standards, I&#39;m sorry but you do not.\n\nYour premise is that by sending a DELETE to an URL which is known to \nrespond to GET requests with 410 Gone my client has violated the \nrestriction that says once an URL responds 410 Gone to a GET request, \nall other request methods are disallowed and the condition is \npermanent for ever and ever.  But, this premise is not supported by \nthe standards, therefore you can&#39;t use this premise to critique my \nstandards-compliant use of the 410 response.\n\n&gt;\n&gt;&gt; In my setup, the response to a DELETE request is\n&gt;&gt; straightforward -- the status of the resource changes to\n&gt;&gt; reflect the request, no matter what client is making the\n&gt;&gt; DELETE.\n&gt;\n&gt;So it does in mine.\n&gt;\n\nExcept your status code is wrong.  The server knows for a fact that \nthe resource still exists in a new location, and that as long as the \nresource is in /delete/ it may be restored to its original location.  \nSo I would suggest that the server is lying, in sending a 410 Gone \nresponse instead of a 404 -- or a 307 to to the new location.  The \nclient requested a DELETE and got a MOVE instead.\n\n&gt;\n&gt;So it does in mine. However, my design requires the client to\n&gt;understand a specific media type. This is in line with the REST\n&gt;constraints.\n&gt;\n\nSorry, but no.  Your specific media type instructs the client to \ninterpret the response to a DELETE request as a MOVE.  But I still \nsay that a media type cannot be used to change the semantics of an \nHTTP request.  A media type is a data format, not an API, if the \nsemantics of a DELETE are MOVE for one media type but not for \nanother, then there is no generic interface present in your app \nas clients must not only know how to render that media type for \ndisplay, but also how to change their connector behavior in order \nto re-interpret HTTP for that media type.\n\nA generic-interface-based client will GET /deleted/foo/bar and receive \na 200 OK status code.  This does not reflect any sort of &quot;deleted&quot; \nstate for the resource, only &quot;present and accounted for&quot;.\n\n&gt;\n&gt;It does not require the client to have knowledge of the\n&gt;overloading of a status code, like yours does, which breaks\n&gt;interface uniformity.\n&gt;\n\nI&#39;m sorry, but you have not explained how I am &quot;overloading&quot; the \n410 Gone response.  A DELETE request is received, the server then \nresponds 410 Gone and the resource is no longer available at that \nURL, nor has it been moved to some other URL.  So I fail to see \nhow the results of my interaction are anything other than what \nany HTTP client would expect, as no subsequent request to that or \nany other URL will respond with a 200 OK with the entity that was \njust DELETEd.\n\nIt may change to 404 at some point, or it may return to a 200 OK \nstatus at some point, but only if some other action is taken first \n-- clients cannot infer permanence from any response.\n\n&gt;\n&gt;In other words, all of your objections/support claims apply\n&gt;equally to both of protocols, except that mine uses hypermedia\n&gt;where yours does not, and yours breaks uniformity where mine does\n&gt;not.\n&gt;\n\nSorry, but no.  While you show an understanding of HEAS, you take it \ntoo far if you claim that a client sending a DELETE and receiving a \n204 No Content response breaks with HEAS because no link was clicked \nand no URL was received in the response.  My DELETE actually deletes, \nyour DELETE moves (by assigning a new URI) without deleting anything.\n\n&gt;\n&gt;REST is not CRUD. Can we get away from that please?\n&gt;\n\nThat&#39;s a strawman argument.  I don&#39;t see how anyone reading my posts \nwould get the impression that I treat REST as CRUD.  Claiming that&#39;s \nwhat I&#39;m saying then refuting that claim is disingenuous.\n\n&gt;\n&gt;The design I proposed *is* RESTful. I told you which constraints\n&gt;*your* design violates, so if you want to claim otherwise about\n&gt;mine, please return the favour.\n&gt;\n\nI&#39;ve been trying, really I have.  If you are imparting MOVE semantics \nto a DELETE request then you are directly violating the Uniform \nInterface constraint, because you are overloading DELETE when two \nseparate HTTP actions gets the job done without needing a media \ntype to define special interaction semantics.  If you want to \nimplement a trashcan for some reason, then be my guest.  I do not \nwant to implement a trashcan.  But if you do, then you should first \nPUT the resource to the new URL, then DELETE the resource at the old \nURL and respond 404, not 410, because you are implying that the \nresource may be un-deleted at some point.  Or better yet, use a 307.\n\nMy 410 Gone is not a trashcan and has no mechanism to un-delete \nanything from a trashcan.  So I don&#39;t understand why you keep \ninsisting that I must somehow implement a trashcan in order to be \nRESTful.  I DELETE a resource, subsequently it responds 410 Gone \nand really is gone, not available at some new URL -- what is the \nproblem with that?\n\n&gt;\n&gt;No, you’re not. The interpretation of that URI comes from the\n&gt;hypermedia which the server returns upon DELETE, not from a\n&gt;substring inside the URI.\n&gt;\n\nYou&#39;re using media type to describe interaction semantics, which is not \ntheir purpose.  The purpose of a media type is to provide hints on \nrendering the entity for display, not to dictate nonstandard client \nbehavior.  You can&#39;t use a media type to give DELETE the semantics of \nMOVE, because a media type does not describe a networking API.  A \nmedia type can tell a client how to interpret an URL found in the \nmarkup, but it can&#39;t tell the client anything about the interaction \nwhich led to that response.  My question remains.  How are you \ninstructing the client that the DELETE it just sent was handled as a \nMOVE?  If the client must *infer* this from the media type then the \ninterface is hardly generic -- in a generic interface media type does \nnot affect method implementation.\n\n&gt;\n&gt;What matters is that the URI is found in the `epitaph` element of\n&gt;the response, not that it is rooted at `/deleted/`. You could\n&gt;just as well return\n&gt;\n&gt;    &lt;tombstone&gt;\n&gt;      &lt;dead    href=&quot;/foo/bar&quot; /&gt;\n&gt;      &lt;epitaph href=&quot;/xyzzy/frobnitz/veeblefitzer&quot; /&gt;\n&gt;    &lt;/tombstone&gt;\n&gt;\n&gt;and the protocol would work just the same.\n&gt;\n&gt;Hypermedia as the engine of application state.\n&gt;\n\nOf course, to any client which doesn&#39;t understand your media type, my \nobjections stand in that there is no way to know that the DELETE was \nreally a MOVE.  You can&#39;t use a media type to redefine HTTP interaction \nsemantics like that, because that non-generic behavior can&#39;t be \nrepeated except by a client with knowledge of the media type.  Internet \nExplorer has no clue about the application/xhtml+xml media type, but \nit can still GET such a representation and ask the user to save it.  \nOnly the rendering is affected, not the interaction semantics.\n\nIn your system, a client without knowledge of your media type cannot \ninteract with the system because the interface is not generic.  How \ndoes a client without specific knowledge of your system infer that \na DELETE has been treated as a MOVE?  It could, if you were using a \n307 redirect instead of telling the app that the resource was \nremoved entirely by sending 410 Gone.  But that wouldn&#39;t make it REST, \nbecause the server&#39;s response to the DELETE method is to rename the \nresource -- imposing a &quot;move&quot; semantic on DELETE has nothing to do \nwith a generic interface.\n\n&gt;\n&gt;It doesn’t tunnel anything. Nothing is getting moved.\n&gt;\n\nYou are moving the resource for which a DELETE was requested, to another \nlocation, instead of following the client request to DELETE the resource.  \nWorse, you&#39;re telling clients that the DELETE request was successful and \nusing 4xx on subsequent responses when the resource still exists at a \nnew location, instead of redirecting.\n\n&gt;\n&gt;No, I have a new identifier for a new resource.\n&gt;\n\nUgh.  A resource is a concept, a URI identifies that concept.  You can \nhave two URIs identify the same concept, yes.  But what you are doing \nis assigning two different meanings to two different URIs which both \nidentify the same resource.  The concept of the resource identified \ndoes not include its state -- &quot;resource&quot; and &quot;deleted resource&quot; identify \nthe same resource.  You do not have a &quot;new, deleted resource&quot;.  You \nhave a new status for the existing resource, if you are using REST.\n\nIf you interpret a DELETE as a MOVE, then you are creating a new \nidentifier for the same resource, except now one of the URLs gives a \n4xx error while the other indicates 200 OK -- the semantics of your \nmapping are not static in such a case.  You have a new identifier for \nthe same resource, but it is out of sync with the old identifier for \nthe same resource.  Which is why I suggest using a 307 redirect if you \nwant to implement such a trashcan setup, which is still not what I&#39;m \ndoing anyway.\n\n&gt;\n&gt;The status of that resource should itself be exposed as a\n&gt;resource if you want clients to be able to manipulate it. If you\n&gt;want clients to be able to manipulate any aspect of server state,\n&gt;then that state must be exposed as a resource if you want to\n&gt;comply with the REST constraints.\n&gt;\n\nNo, this is not REST.  In REST, a resource has an identifier and a \nstatus.  If the status needs changing, in REST a representation of the \nresource is manipulated in order to change the status of that resource.  \nThe identifier of the resource remains unchanged when a representation \nis altered to reflect a new state of that resource.  I am really at a \nloss as to how you have come up with this &quot;state must be exposed as \na resource&quot; bit, it has nothing at all whatsoever to do with REST.\n\n&gt;\n&gt;It’s not the second DELETE where you break the uniformity\n&gt;constraint, it’s the _first_.\n&gt;\n\nNo, I&#39;m sorry.  I have a resource, I DELETE the resource, the resource \nresponds 410 Gone afterwards.  Any client using any RESTful protocol \nwould expect this to happen -- changing a resource from responding \n&quot;success&quot; to responding &quot;failure&quot; is the expected behavior of the \nDELETE method.  You break from this by giving the resource a new \nname, so that requests for that resource respond &quot;success&quot; if the new \nname is known.  But the request was for the resource to be deleted, \nnot remapped to a new identifier.\n\n&gt;\n&gt;Exactly!! That is how your design breaks the constraint. You\n&gt;spell it out in detail and then fail to realise the consequences\n&gt;of what you said: the client cannot assume that 410 Gone means\n&gt;anything but 410 Gone! But you expect the client to make such an\n&gt;assumption. Your protocol breaks uniformity at that point.\n&gt;\n\nNo, I&#39;m sorry, but you are imposing a constraint which does not exist \nin the spec.  There is nothing about receiving a 410 Gone response to \na GET request which precludes the client from sending a request to the \nsame URL using a different (or even the same) method.  You are \nexpecting a client to assume permanence from a 4xx response, and \nclaiming that by not refusing to send any more requests to that address \nall existing clients are in violation of RFC 2616.\n\nIf my browser encounters a 410 response, and I click &quot;reload&quot; the request \nis repeated.  Why?  Because the client cannot assume permanency of a \n4xx response.  Nowhere does RFC 2616 state that the client MUST NOT \nrepeat such a request -- if it did, my app behavior would indeed be \nnonstandard by expecting a client to assume that it can repeat such a \nrequest.  If I can repeat a GET request, why can&#39;t I make a request of \nthat URL using a different method?  I&#39;ve responded to a DELETE request \nby making the resource unavailable, what&#39;s wrong with that?\n\n&gt;\n&gt;How is that not a file-centric world view? You are fixated on how\n&gt;your URIs map to your filesystem, which is what I was saying: you\n&gt;don’t want to make up resources not backed by your filesystem,\n&gt;which is a WebDAV-ish worldview.\n&gt;\n\nHuh?  We&#39;re talking about a specific implementation which uses a file, \nyou are the one claiming that you can look into some crystal ball and \ninfer that I believe one way or another based on that.  In this \nexample I use a file, in my real-world application no HTML is ever \nwritten to disk, everything is generated on the fly by transforming \ndatabase output.  There are no &quot;files&quot; to delete.  But if a DELETE \nrequest is received, the resource will respond 410 Gone instead of \ngenerating a response on the fly be transforming database output.\n\nMuch easier to talk in terms of &quot;a file&quot;, except for all the people \naround here who then make nutty statements about how what I say must \nthen only apply to WebDAV.\n\nBut let&#39;s get back to talking about this particular implementation, \nand not making assumptions about how my use of a file in this case \nproves that I don&#39;t know what the hell I&#39;m talking about, because \nif you&#39;re only interested in a pissing match I will ignore you.  If \nyou need help implementing a RESTful trashcan, then please start a \nthread on it because it&#39;s off-topic here and only causing confusion \nfor others.\n\n-Eric\n\n\n\n\n"}}