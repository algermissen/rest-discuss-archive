{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":147780944,"authorName":"A. Pagaltzis","from":"&quot;A. Pagaltzis&quot; &lt;pagaltzis@...&gt;","profile":"a22pag","replyTo":"SENDER","senderId":"KfkHw3VyoQLYAOrD6I4YGmdw_nkB3101BJjnOvHToNzNgCWId1JKWhIb-crWxqVgdfZ9L-JwLZ5DRx9_bI-HW7FHXbdaZ67Q","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Fun with DELETE","postDate":"1184001746","msgId":9394,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDcwNzA5MTcyMjI2LkdWMTI3NzdAa2xhbmdyYXVtPg==","inReplyToHeader":"PFc2NjQ5MDExOTM3MTc0NTcxMTgzNzY5NjA1QG1haWwubWFpbHNuYXJlLm5ldD4gPFc3ODA0MzMxNjE0NDQ0MTE4Mzc3ODc4M0BtYWlsLm1haWxzbmFyZS5uZXQ+IDxXNjQ0ODE2Nzc3MTE3NzcxMTgzNzY2NDI1QG1haWwubWFpbHNuYXJlLm5ldD4=","referencesHeader":"PDIwMDcwNzA2MjI0MzE3LkdJMTI3NzdAa2xhbmdyYXVtPiA8VzY2NDkwMTE5MzcxNzQ1NzExODM3Njk2MDVAbWFpbC5tYWlsc25hcmUubmV0PiA8MjAwNzA3MDcwMjA2NDIuR0wxMjc3N0BrbGFuZ3JhdW0+IDxXNzgwNDMzMTYxNDQ0NDExODM3Nzg3ODNAbWFpbC5tYWlsc25hcmUubmV0PiA8MjAwNzA3MDYyMjE5MjQuR0gxMjc3N0BrbGFuZ3JhdW0+IDxXNjQ0ODE2Nzc3MTE3NzcxMTgzNzY2NDI1QG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":9393,"nextInTopic":9395,"prevInTime":9393,"nextInTime":9395,"topicId":8604,"numMessagesInTopic":107,"msgSnippet":"Hi Eric, to put things in context, all of my following points below apply ... ","rawEmail":"Return-Path: &lt;pagaltzis@...&gt;\r\nX-Sender: pagaltzis@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 56358 invoked from network); 9 Jul 2007 17:23:29 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m56.grp.scd.yahoo.com with QMQP; 9 Jul 2007 17:23:29 -0000\r\nReceived: from unknown (HELO mail.gmx.net) (213.165.64.20)\n  by mta9.grp.scd.yahoo.com with SMTP; 9 Jul 2007 17:23:29 -0000\r\nReceived: (qmail invoked by alias); 09 Jul 2007 17:22:26 -0000\r\nReceived: from static-87-79-236-202.netcologne.de (EHLO klangraum) [87.79.236.202]\n  by mail.gmx.net (mp052) with SMTP; 09 Jul 2007 19:22:26 +0200\r\nX-Authenticated: #163624\r\nX-Provags-ID: V01U2FsdGVkX1945pUoWbp4MqRbOYxh5aTqYhlzjrRptHDrhh4DGF\n\tB7eMgH0Lf4zlSp\r\nDate: Mon, 9 Jul 2007 19:22:26 +0200\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-ID: &lt;20070709172226.GV12777@klangraum&gt;\r\nMail-Followup-To: rest-discuss@yahoogroups.com\r\nReferences: &lt;20070706224317.GI12777@klangraum&gt; &lt;W6649011937174571183769605@...&gt; &lt;20070707020642.GL12777@klangraum&gt; &lt;W78043316144441183778783@...&gt; &lt;20070706221924.GH12777@klangraum&gt; &lt;W644816777117771183766425@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=utf-8\r\nContent-Disposition: inline\r\nContent-Transfer-Encoding: 8bit\r\nIn-Reply-To: &lt;W6649011937174571183769605@...&gt; &lt;W78043316144441183778783@...&gt; &lt;W644816777117771183766425@...&gt;\r\nUser-Agent: Mutt/1.4.2.1i\r\nX-Y-GMX-Trusted: 0\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;A. Pagaltzis&quot; &lt;pagaltzis@...&gt;\r\nSubject: Re: Fun with DELETE\r\nX-Yahoo-Group-Post: member; u=147780944; y=NiWsVuiFgnj5K_quawKKQJ6pnhUuu41lhVML-B9K7dMn\r\nX-Yahoo-Profile: a22pag\r\n\r\nHi Eric,\n\nto put things in context, all of my following points below apply\nto the following protocol:\n\n    &gt; DELETE /foo/bar\n    &lt; 200 OK\n    &lt; Content-Type: application/vnd.exampleorg.tombstone+xml\n    &lt;\n    &lt; &lt;tombstone&gt;\n    &lt;   &lt;dead    href=&quot;/foo/bar&quot; /&gt;\n    &lt;   &lt;epitaph href=&quot;/deleted/foo/bar&quot; /&gt;\n    &lt; &lt;/tombstone&gt;\n\n    &gt; GET /foo/bar\n    &lt; 410 Gone\n\n    &gt; DELETE /deleted/foo/bar\n    &lt; 204 No Content\n\n    &gt; GET /foo/bar\n    &lt; 404 Not Found\n\nAll other suggestions I made were misguided.\n\nWith that in place, onward…\n\n\n* Eric J. Bowman &lt;eric@...&gt; [2007-07-07 02:05]:\n&gt; &gt;The fact remains that this design does not have problems with\n&gt; &gt;idempotency nor does it require as much hardwired knowledge\n&gt; &gt;about the specific semantics of your protocol from clients\n&gt; &gt;(aka REST-RPC hybrid).\n&gt; \n&gt; But it does require the server connector to understand the\n&gt; semantics of DELETE to mean something other than &quot;remove&quot; in\n&gt; addition to meaning &quot;remove&quot; depending on the URL the DELETE\n&gt; request is sent to, or some other shared knowledge between\n&gt; client and server.\n\nSo does your design. It requires clients to know that 410 Gone\nmeans something in other than 410 Gone in addition to 410 Gone.\n\n&gt; In my setup, the response to a DELETE request is\n&gt; straightforward -- the status of the resource changes to\n&gt; reflect the request, no matter what client is making the\n&gt; DELETE.\n\nSo it does in mine.\n\n&gt; The optional, sysadmin-only second DELETE does require\n&gt; knowledge of the specific protocol in that it must have an\n&gt; If-Match header, but the semantics of making such a DELETE\n&gt; request are still &quot;remove&quot;, which doesn&#39;t break the Uniform\n&gt; Interface constraint.\n\nSo it does in mine. However, my design requires the client to\nunderstand a specific media type. This is in line with the REST\nconstraints.\n\nIt does not require the client to have knowledge of the\noverloading of a status code, like yours does, which breaks\ninterface uniformity.\n\nIn other words, all of your objections/support claims apply\nequally to both of protocols, except that mine uses hypermedia\nwhere yours does not, and yours breaks uniformity where mine does\nnot.\n\n\n* Eric J. Bowman &lt;eric@...&gt; [2007-07-07 05:30]:\n&gt; &gt;&gt; Or, to phrase that better. I can do whatever I want with the\n&gt; &gt;&gt; origin server, but REST constrains the behavior of the\n&gt; &gt;&gt; _connector_ that origin server uses to communicate with the\n&gt; &gt;&gt; outside world.\n&gt; &gt;\n&gt; &gt;Citation please. I disagree that there is any part of REST\n&gt; &gt;which imposes any particular behaviour on the server.\n&gt; \n&gt; &quot;Server&quot; means both the origin server component, and the server\n&gt; connector.  REST dictates that the server connector meets the\n&gt; generic interface constraint, meaning the server connector must\n&gt; behave in a very specific way that may be generically\n&gt; understood by clients as well as intermediary caches.  REST\n&gt; also dictates that the origin server manage the namespace in\n&gt; such a way that the semantics of the mappings are static.\n\nWhat? No. A RESTful server is not a filesystem. It is perfectly\nfine for a successful PUT to create 15 new resources in addition\nto the one that was stored at the request URI, if the server uses\nthe content of the entity body to expose derived resources.\nLikewise it is perfectly fine for a DELETE that changes the\nserver state in more ways than just unbinding a resource from a\nURI to result in the creation of resource that expose this other\nstate.\n\nREST is not CRUD. Can we get away from that please?\n\n&gt; &quot;An origin server uses a server connector to govern the\n&gt; namespace for a requested resource. It is the definitive source\n&gt; for representations of its resources and must be the ultimate\n&gt; recipient of any request that intends to modify the value of\n&gt; its resources. Each origin server provides a generic interface\n&gt; to its services as a resource hierarchy. The resource\n&gt; implementation details are hidden behind the interface.&quot;\n\nThis in no way contradicts what I said.\n\n\n* Eric J. Bowman &lt;eric@...&gt; [2007-07-07 02:55]:\n&gt; &gt;Why do you keep thinking in terms of files? Files are\n&gt; &gt;irrelevant. What does moving a file to a URI even mean?\n&gt; \n&gt; Sorry, I meant to use the word &quot;source&quot;, which could be a file,\n&gt; or it could be a database cell, or a combination of both, or\n&gt; something else entirely.  But if you are changing the\n&gt; identifier of that source, you are making it a new resource,\n&gt; which is either a MOVE or a COPY.  All I am doing is flagging\n&gt; the source as having been removed, no new URL required.\n\nWhere did I say to change the identifier?\n\nI said that the server responds by exposing a different resource\nat a different URI.\n\nYou’re putting words in my mouth that never came out of it. (Or\nmy keyboard, as the case were.)\n\n\n&gt; &gt;You&#39;re exposing your knowledge of the previous existence of a\n&gt; &gt;resource as a separate resource.\n&gt; \n&gt; I suppose you could do it that way if you wanted and could make it \n&gt; RESTful,\n\nThe design I proposed *is* RESTful. I told you which constraints\n*your* design violates, so if you want to claim otherwise about\nmine, please return the favour.\n\n&gt; but I am merely representing the resource as having been\n&gt; removed, not assigning it a new identifier that must be\n&gt; interpreted as having the same meaning as a 4xx response even\n&gt; though it&#39;s giving a 200 OK response.  How, by dereferencing\n&gt; the URL which includes &quot;/trash/&quot; in its path, does the server\n&gt; convey to me that the file has been removed?  If I must infer\n&gt; this from the URL then I&#39;m forgetting that URLs are opaque.\n\nNo, you’re not. The interpretation of that URI comes from the\nhypermedia which the server returns upon DELETE, not from a\nsubstring inside the URI.\n\nWhat matters is that the URI is found in the `epitaph` element of\nthe response, not that it is rooted at `/deleted/`. You could\njust as well return\n\n    &lt;tombstone&gt;\n      &lt;dead    href=&quot;/foo/bar&quot; /&gt;\n      &lt;epitaph href=&quot;/xyzzy/frobnitz/veeblefitzer&quot; /&gt;\n    &lt;/tombstone&gt;\n\nand the protocol would work just the same.\n\nHypermedia as the engine of application state.\n\n&gt; &gt;I admit that responding with a redirect is the wrong answer.\n&gt; &gt;It took me a few iterations to get to a 200 response to a\n&gt; &gt;DELETE with a link in the entity-body, but that is the right\n&gt; &gt;approach.\n&gt; \n&gt; I agree that a link in a 200 or 204 response is better than a\n&gt; redirect, but I still believe such a response breaks the\n&gt; Universal Interface constraint by tunneling &quot;move&quot; through\n&gt; &quot;remove&quot; and that a PUT followed by a DELETE is a RESTful, RFC\n&gt; 2616-based solution.\n\nIt doesn’t tunnel anything. Nothing is getting moved.\n\nState that means “I remember something about that one resource”\ngets exposed with a new URI.\n\n&gt; &gt;The server responds to the DELETE by saying “OK, it’s gone;\n&gt; &gt;here’s a description of how you can also delete my memory of\n&gt; &gt;its previous existence by deleting the following resource.”\n&gt; \n&gt; You&#39;re saying that sending the client a different URL that also \n&gt; needs deletion to fully remove the resource, is superior than \n&gt; sending two DELETE requests to the same URL to achieve the same \n&gt; thing. I&#39;m still not seeing the need for the added complexity \n&gt; of executing a MOVE as part of a DELETE request, and I still \n&gt; don&#39;t understand how changing an URL to reflect state in the \n&gt; path segment is understandable by intermediaries who only \n&gt; interpret 410 Gone as meaning &quot;removed&quot;, not a 200 OK response \n&gt; from a different URL that includes &quot;/trash/&quot; in the path.\n\nThere is no moving. There is no interpretation of URI paths.\n\n&gt; Once you&#39;ve assigned a &quot;deleted&quot; URL to the resource, you now \n&gt; have two identifiers for the same resource.\n\nNo, I have a new identifier for a new resource.\n\n&gt; In and of itself, this is not a problem, except that each URL\n&gt; gives a different representation of resource state (one is 4xx,\n&gt; the other 200). Which one is authoritative about the resource\n&gt; state being &quot;removed&quot;, the 404 or 410 response, or the 200 OK\n&gt; response? Wouldn&#39;t this confuse user-agents, and users?\n\nNo, there are two representations of two resources; while one of\nthe resources is *about* the other resource, it is false to say\nit *is* the other resource. So if you ask the server for the\nresource, it authoritatively states that this resource is gone,\nand if you ask it whether this resource used to exist, it\nauthoritatively responds in the affirmative. There is no\ncontradiction.\n\n&gt; &gt;The resource and the server’s memory of its existence are two\n&gt; &gt;separate Things, and should be exposed separately.\n&gt; \n&gt; I&#39;m sorry, but I see all of this as simply changing the state of \n&gt; one resource.  First, it exists.  Then, it is gone.  Then, as an \n&gt; option, it was never there. But none of this implies that the\n&gt; server has forgotten, or should have forgotten, about the\n&gt; resource.  I am merely altering the response to requests for\n&gt; one resource, to reflect the current state of that resource, by\n&gt; returning a status code.\n\nThe status of that resource should itself be exposed as a\nresource if you want clients to be able to manipulate it. If you\nwant clients to be able to manipulate any aspect of server state,\nthen that state must be exposed as a resource if you want to\ncomply with the REST constraints.\n\n&gt; &gt;Your double-DELETE is a very surprising interpretation of what\n&gt; &gt;RFC 2616 allows. You are effectively overloading the meaning\n&gt; &gt;of 410 in a way that the uniformity constraint reserves for\n&gt; &gt;the entity body.\n&gt; \n&gt; ??? The Uniform Interface constraint pertains to request\n&gt; methods and their corresponding response codes.  Where does RFC\n&gt; 2616 tell me that the server can no longer accept requests once\n&gt; a resource has had its status changed to 410 Gone?  And where\n&gt; does anything say that response codes apply to the entity body?\n&gt; They convey the status of the resource, but the response may\n&gt; contain both resource headers and entity headers.\n\nIt’s not the second DELETE where you break the uniformity\nconstraint, it’s the _first_.\n\n&gt; RFC 2616 clearly allows a DELETE to change the status of a\n&gt; resource to either 404 or 410, this is exactly what the Uniform\n&gt; Interface constraint means.  There is no restriction in either\n&gt; RFC 2616 or REST which states that the resource must respond\n&gt; 200 OK before a DELETE request may be accepted.  In fact, RFC\n&gt; 2616 clearly states that a resource responding 404 or 410 can\n&gt; still exist -- it may just be a matter of privilege level,\n&gt; where authorization is required before a GET will respond 200\n&gt; OK.\n\nExactly!! That is how your design breaks the constraint. You\nspell it out in detail and then fail to realise the consequences\nof what you said: the client cannot assume that 410 Gone means\nanything but 410 Gone! But you expect the client to make such an\nassumption. Your protocol breaks uniformity at that point.\n\n&gt; &gt;You seem to be following the WebDAV school of HTTP which\n&gt; &gt;considers resources somehow equivalent to files on the\n&gt; &gt;server’s disk and prefers to model additional aspects of state\n&gt; &gt;by putting them into the method instead of exposing them as\n&gt; &gt;resources.\n&gt; \n&gt; That characterization couldn&#39;t be further from my view of\n&gt; things.  We are discussing a situation where there is both a\n&gt; resource, and a source, I use the term &quot;source file&quot; because\n&gt; that is exactly what I am discussing in this thread -- my\n&gt; implementation, which in this case is using a file.  I used the\n&gt; example I used because too many people are claiming that the\n&gt; deletion of a resource must result in the deletion of the\n&gt; source.  So it is just a narrative convenience to speak in\n&gt; terms of a DELETE only changing the status of the resource\n&gt; without touching the source &quot;file&quot;, because only the resource\n&gt; mapping gets deleted -- or rather, has its status changed to\n&gt; express a &quot;removed&quot; state to the requesting client.\n&gt; \n&gt; My application uses one URL and content negotiation to serve\n&gt; four different &quot;text/html&quot; representations and three\n&gt; &quot;application/xhtml+xml&quot; representations (plus one Atom and one\n&gt; PDF) depending on client capability, so I would have to say\n&gt; that I am keenly aware of the separation between the HTTP\n&gt; resource/representation model and the file-centric models of\n&gt; FTP and WebDAV.\n\nYes, very fine; except that you then go on a drop a clonker like\nthe following:\n\n&gt; &gt;URI proliferation is about multiple names for the same\n&gt; &gt;resource. I don’t understand how this applies to my proposed\n&gt; &gt;protocol design. From a REST point of view, URI starvation\n&gt; &gt;(where you don’t expose sufficient state as separate resources\n&gt; &gt;and overload aspects of other messages instead) is worse.\n&gt; \n&gt; I have to disagree, there.  If I have one resource which has a\n&gt; variety of possible states, then I want the response to a\n&gt; request for that resource to reflect the current state of the\n&gt; resource, in the retrieved representation -- either as an\n&gt; entity body or as a control code.  I do not want to change the\n&gt; semantics of the mapping of my resource when state changes,\n\nHow is that not a file-centric world view? You are fixated on how\nyour URIs map to your filesystem, which is what I was saying: you\ndon’t want to make up resources not backed by your filesystem,\nwhich is a WebDAV-ish worldview.\n\n/deleted/foo/bar doesn’t have to be a file created in your\nfilesystem by the server upon deletion of whatever file /foo/bar\nmaps to, and in fact probably shouldn’t be.\n\n&gt; i.e. the resource is a conceptual mapping that does not include\n&gt; any information about the resource state, that can only be\n&gt; conveyed in a representation of the resource, not by deducing\n&gt; the meaning of the assigned URL.\n\nNo one said to deduce meaning from any URI.\n\nYou can use /xzyzzy/frobnitz/veeblefitzer in place of\n/deleted/foo/bar and /bender/casino/blackjack in place of\n/deleted/foo/baz as long as the media type you return from a\nsuccessful DELETE has well-defined meaning.\n\n&gt; If I have some other semantic mapping for the same resource, then I \n&gt; assign it a new URL, i.e. sometimes I want to describe the &quot;thing of \n&gt; the day&quot;.  Under your method, that would need to be changed to &quot;the \n&gt; deleted thing of the day&quot; if someone deletes &quot;a thing&quot; at the wrong \n&gt; time.\n\nThere is no other semantic mapping for the same resource. There\nis a mapping for knowledge *about* the resource, which is not the\nsame thing as the resource itself.\n\nRegards,\n-- \nAristotle Pagaltzis // &lt;http://plasmasturm.org/&gt;\n\n"}}