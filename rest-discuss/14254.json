{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"vmVVPqfCxjqn0qSJt_hEjkvnjGehSZqgRtX-WBil0gRUZGz7m2adjidqImgwAsmAyKgKzxOF8XRlo5peS7M0Ev3__GHf18F-e_TTTstSRw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Good examples of REST implementations","postDate":"1261368923","msgId":14254,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkxMjIwMjExNTIzLjA2M2U0NGM2LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDRCMkQ2RjdCLjcwMjAwQGRlaG9yYS5uZXQ+","referencesHeader":"PGhlbXBjaCszbGRuQGVHcm91cHMuY29tPgk8OUI4OTYwM0QtQTI4Mi00ODUwLUFDRkUtRjEyRjNBOTEwMzhEQGJibGZpc2gubmV0Pgk8ZWM4NjEzYTgwOTEyMTEwMjA5cjcwNGMwNjNhazM4MGNmYjQxYzVjZTY3MjNAbWFpbC5nbWFpbC5jb20+CTwyMDA5MTIxNTAxNTcwMS4xOWJjM2IxMy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTw0QjJENkY3Qi43MDIwMEBkZWhvcmEubmV0Pg=="},"prevInTopic":14247,"nextInTopic":14308,"prevInTime":14253,"nextInTime":14255,"topicId":14060,"numMessagesInTopic":20,"msgSnippet":"... Actually, having worked through a REST design for Contentbox, I would call it the most egregious, since it turned out it could be built using off-the-shelf","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 43877 invoked from network); 21 Dec 2009 04:15:30 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m12.grp.re1.yahoo.com with QMQP; 21 Dec 2009 04:15:30 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.re1.yahoo.com with SMTP; 21 Dec 2009 04:15:30 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id A7A27509B4;\n\tSun, 20 Dec 2009 23:15:28 -0500 (EST)\r\nDate: Sun, 20 Dec 2009 21:15:23 -0700\r\nTo: Bill de hOra &lt;bill@...&gt;\r\nCc: Ian Davis &lt;lists@...&gt;, swschilke &lt;steffen.schilke@...&gt;,\n rest-discuss@yahoogroups.com, Story Henry &lt;henry.story@...&gt;\r\nMessage-Id: &lt;20091220211523.063e44c6.eric@...&gt;\r\nIn-Reply-To: &lt;4B2D6F7B.70200@...&gt;\r\nReferences: &lt;hempch+3ldn@...&gt;\n\t&lt;9B89603D-A282-4850-ACFE-F12F3A91038D@...&gt;\n\t&lt;ec8613a80912110209r704c063ak380cfb41c5ce6723@...&gt;\n\t&lt;20091215015701.19bc3b13.eric@...&gt;\n\t&lt;4B2D6F7B.70200@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Good examples of REST implementations\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nBill de hOra wrote:\n&gt; \n&gt; &gt; Particularly egregious are the Changeset Protocol and Store OAI\n&gt; &gt; Service. \n&gt; \n&gt; Why?\n&gt; \n\nActually, having worked through a REST design for Contentbox, I would\ncall it the most egregious, since it turned out it could be built using\noff-the-shelf parts that are widely implemented and understood, and\neasy to understand for those who are new to the particular technologies\nI suggested, for a REST API right out of the box without half-trying.\n\n&gt;\n&gt; The changeset protocol isn&#39;t worth arguing over.\n&gt;\n\nWhy not?  It fails to be a uniform interface, while assigning a delta\nformat to be used with PUT.  Since it can and should be made RESTful, I\nfail to see how that&#39;s nit-picking or otherwise irrelevant criticism.\n\n&gt;\n&gt; The OAI-PMH verbs\n&gt; you can consider an existing protocol that needs to be gatewayed onto\n&gt; the web. The ListRecords operation is associated with a resource and\n&gt; bound to GET. This is a straghtforward basis to associate later one\n&gt; with something like a &quot;rel&quot; attribute value in a format (eg RDF,\n&gt; which is the best working example we have today of an in-band model\n&gt; of data). Worrying about the appearance of the string &quot;verb&quot; in the\n&gt; URL seems like a gensym fallacy.\n&gt;\n\nOAI-PMH is not something I&#39;m familiar with, looking at it on the n2 wiki\nafter looking at the Changeset Protocol, led me to believe that it was\nalso specific to the n2 application.  To avoid confusion, the wiki\nshould link to the actual spec, and should also indicate that this\ninterface isn&#39;t being claimed to be RESTful.  Accusing me of basing my\ncriticism on the word &quot;verb&quot; appearing in a URI isn&#39;t very polite;\nasking me to elaborate would be, before jumping to such conclusions.\n\n&gt; \n&gt; &gt; While it&#39;s good to see Content Negotiation in action, it is\n&gt; &gt; not good to see it made part of a query URL. \n&gt; \n&gt; It&#39;s adequate, as part of a ladder. This list is littered with conneg \n&gt; has failed threads. So why is it not good to see it made part of a\n&gt; query URL when the model as presented in HTTP has more or less failed?\n&gt;\n\nThis list is also littered with me pointing out that we all encounter\ncontent negotiation on a daily basis, thus it is not a failure.\nThreads here about failed conneg almost always come down to failing to\nmake representations resources in their own right, and using their URIs\nin the Content-Location header.  The counter-argument is always that\nthis header is optional.  Well, of course it is, it isn&#39;t needed for\nthe primary use case for conneg, which is compression.\n\nContent Negotiation also works well for having both (X)HTML and Atom\nrepresentations of a resource; the odd client receiving the wrong\nvariant ought to be able to self-correct by either reading the\nAlternates header or introspecting for a &lt;link rel=&#39;alternate&#39;/&gt; with\nthe appropriate @type. \n\nBut Content-Location is needed to make Accept-header-based conneg work\nproperly in the real world.  The solution to this deficiency isn&#39;t to\nmake conneg part of a query URL, even on the off-chance that such a\nsystem is using query URLs in Content-Location headers.  The failure of\nthe conneg model presented in HTTP has everything to do with the poor\nquality of client Accept headers, and nothing to do with using filename\nextensions in the Path.  This failure, plus the failure of a certain\nbrowser to support application/xhtml+xml, has throttled the innovation\nwe would have otherwise seen evolve around content negotiation and XHTML\non the Web.\n\n&gt; \n&gt; &gt; Your supported mime types\n&gt; &gt; each have unique filename extensions, why not use those, plus\n&gt; &gt; Content- Location? \n&gt; \n&gt; What useful properties would that induce?\n&gt; \n\nProper identification of resources and the implementation of self-\ndescriptive messaging would be to apply two of REST&#39;s four uniform\ninterface constraints:\n\n&quot;\nREST is defined by four interface constraints: identification of\nresources; manipulation of resources through representations;\nself-descriptive messages; and, hypermedia as the engine of application\nstate.\n&quot;\n\nThe primary desirable property induced by REST&#39;s uniform interface is\nthe decoupling of client and server, allowing independent\nevolvability.  This is why media types don&#39;t need versioning -- they do\nnot represent a contract (an inherent coupling) between client and\nserver, which is why the goal is to re-use and extend standard media\ntypes.\n\n&quot;\nThe trade-off, though, is that a uniform interface degrades efficiency,\nsince information is transferred in a standardized form rather than one\nwhich is specific to an application&#39;s needs.\n&quot;\n\nThe other desirable property induced is visibility, which allows\nscaling and serendipitous re-use.\n\n&gt; \n&gt; &gt; Or the Alternates header? Or the OPTIONS method? \n&gt; \n&gt; What useful properties would that induce?\n&gt; \n\nVisibility.  If an Atom client receives an XHTML representation, with\nan Alternates header, it can request the proper representation without\nconsulting the user.  A smarter client, in the absence of an Alternates\nheader, could make an OPTIONS request on the resource, and receive\ninformation about other variants.  Depending on the API, some systems\nmay only send Alternates when an OPTIONS request is made.  But, OPTIONS\nis something I view as primarily for human consumption, specifically\ndevelopers wishing to query for an interface definition in order to\ndesign a custom client (serendipitous re-use).\n\n&gt; \n&gt; &gt; Or, if\n&gt; &gt; not a filename extension, why not a URI parameter? \n&gt; \n&gt; What useful properties would that induce?\n&gt; \n\nThe desirable properties of a uniform interface aren&#39;t achieved without\nproper identification of resources, which means following RFC 3986.\nURIs may have parameters and queries.  Properly applying URI means\nthat, if output format matters and isn&#39;t part of the Path, then it must\nbe a parameter -- that&#39;s what it is, a property of the resource, not an\nattribute of the search query.  To include an output format in a query\nwould be to imply that the scope of the search be limited to include\nonly documents of a certain media type.  While URIs are opaque, there\nis a logical semantic separation between hierarchical path, parameter\nand query inherent in the spec that must be followed.\n\nPlacing output type in a query string, instead of a filename extension,\nis not a standard solution, therefore it is not a visible solution.  By\nfailing to apply the resource identification constraint, this solution\ndoes not have a uniform interface, thereby coupling client to server,\nreducing scalability, and avoiding serendipitous re-use.\n\n&gt; \n&gt; &gt; Anything but using\n&gt; &gt; URI queries. In a hypertext-driven API, use &lt;link rel=&#39;alternate&#39;/&gt;.\n&gt; \n&gt; How will the &quot;link&quot; element and the &quot;rel&quot; attribute and the\n&gt; &quot;alternate&quot; value been understood by a client?\n&gt; \n\nBy using standard media types and link relations.  Any client will only\nbe fully-compatible with any REST API if it fully implements the media\ntypes and link relations used.  A simple example would be a weblog --\nI&#39;m viewing an (X)HTML page, but my browser has introspected for &lt;link\nrel=&#39;alternate&#39;/&gt; and read @type.  If it finds a match, it displays an\nicon in the location bar, alerting me to the existence of a feed for\nthe page.\n\nAnother browser may fully support the media type and display the page\njust fine, but not introspect for a feed to display an icon.  REST\nsupports this sort of graceful degradation -- this other browser\nobviously doesn&#39;t implement or care about the standard link relation\nknown as &#39;alternate&#39;.  For a client to be fully compatible with a REST\nsystem that relies on any standard link relation, it must implement\nthat link relation.\n\n&gt; \n&gt; &gt; I could go on. For hours, after spending 30 minutes reviewing your\n&gt; &gt; site. Please don&#39;t promote this as a good example of a REST\n&gt; &gt; implementation.\n&gt; \n&gt; Please don&#39;t play fetch me a rock. Produce an improved design that\n&gt; fits the constraints or explain what properties are lost with the\n&gt; current design.\n&gt; \n\nThere is a fundamental REST mismatch in defining an HTTP interface to\nan obsolete media type that doesn&#39;t define the methods being used. GET\nis inferred; but there exists no standard RSS Publishing Protocol that\nextends the application/rss+xml media type to encompass any other\nmethod.  In a REST API, &quot;what methods to use on what URIs of interest\nshould be entirely defined within the scope of the processing rules for\na media type (and, in most cases, already defined by existing media\ntypes).&quot;  Worse, to edit certain resources, their URI is entered as the\nquery to another resource (definitely an RPC endpoint), another\nfundamental REST mismatch.\n\nThose are examples of the sub-constraint of the uniform interface\nconstraint of &quot;manipulation of resources through representations&quot; being\nviolated.  So, while mostly meeting the client-cache-stateless-server\nand layered-system constraints, this API isn&#39;t applying _any_ of the\nadditional constraints which make up REST&#39;s uniform interface, &quot;The\ncentral feature that distinguishes the REST architectural style from\nother network-based styles.&quot;\n\nThus, the desirable properties lost are all those desirable properties\nassociated with REST.  No biggie...\n\n&gt;\n&gt; I swear, I get tired of REST populists pointing at something, saying \n&gt; that&#39;s not REST, without providing alternatives or explanations, \n&gt; especially when people are making valid attempts to align with the \n&gt; architecture.\n&gt; \n\nThen update the thread, before hitting &quot;send&quot;...\n\nhttp://tech.groups.yahoo.com/group/rest-discuss/message/14240\n\n(Notice I&#39;ve paginated Contentbox-index using URI parameters, while\npaginating Contentbox-search using a query attribute -- to use\n&quot;;page=2&quot; on Contentbox-search would indicate page 2 of the query-\ninterface resource, i.e. the search form, not page 2 of the results.)\n\nI&#39;m not the sort to single something out without an explanation.  I&#39;m\nas self-serving as the next human; I will eventually explain what I\nmean because I&#39;m using it as an example to make some larger point(s).\nLately, I&#39;ve been on about using the standard media types which best\nfit the task at hand, rather than creating proprietary media types as a\nsolution to every problem.  This project is an example of choosing the\nwrong media types, except where a new delta type is properly created\n(yet improperly implemented).\n\nBut I believe the wrong media types were chosen, because the project\nstarted by defining URIs and methods.  That&#39;s something else I&#39;ve been\non about lately, a project must start by defining its resources in\nterms of standard media types and link relations before proceeding with\ndesigning the URI allocation scheme.  How many times has it been said\non this list over the years, that URI allocation scheme has nothing to\ndo with REST?  Yet that&#39;s where people always seem to start, naming\ntheir resources before they&#39;ve been properly identified.\n\n-Eric\n\n"}}