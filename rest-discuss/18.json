{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":23186829,"authorName":"Paul Prescod","from":"Paul Prescod &lt;paul@...&gt;","replyTo":"SENDER","senderId":"vxLBVAczWNN4eLj3YCvdD1fi7YgN5EnpiGVqmki-tpAbP7Y5Z-IxdSBAnKbdTdQoBilxRcSQuRGidt10OK3HonRJqYii1Q","spamInfo":{"isSpam":false,"reason":"0"},"subject":"RFC: Potential XML.com article","postDate":"1011164779","msgId":18,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNDNDUyNjZCLjg0MUI5NDJGQHByZXNjb2QubmV0Pg=="},"prevInTopic":0,"nextInTopic":0,"prevInTime":17,"nextInTime":19,"topicId":18,"numMessagesInTopic":1,"msgSnippet":"Please contribute comments on this article I am working on for xml.com. ============== Second Generation Web Services In the early days of the Internet, it was","rawEmail":"Return-Path: &lt;paul@...&gt;\r\nX-Sender: paul@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_1_3); 16 Jan 2002 07:07:10 -0000\r\nReceived: (qmail 71171 invoked from network); 16 Jan 2002 07:07:09 -0000\r\nReceived: from unknown (216.115.97.171)\n  by m8.grp.snv.yahoo.com with QMQP; 16 Jan 2002 07:07:09 -0000\r\nReceived: from unknown (HELO smtp1.ActiveState.com) (209.17.183.249)\n  by mta3.grp.snv.yahoo.com with SMTP; 16 Jan 2002 07:07:09 -0000\r\nReceived: from smtp3.ActiveState.com (smtp3.ActiveState.com [192.168.3.19])\n\tby smtp1.ActiveState.com (8.11.6/8.11.6) with ESMTP id g0G776717134\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Tue, 15 Jan 2002 23:07:06 -0800\r\nReceived: from prescod.net (ssh1.ActiveState.com [192.168.3.32])\n\tby smtp3.ActiveState.com (8.11.6/8.11.6) with ESMTP id g0G774e07598\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Tue, 15 Jan 2002 23:07:04 -0800\r\nMessage-ID: &lt;3C45266B.841B942F@...&gt;\r\nDate: Tue, 15 Jan 2002 23:06:19 -0800\r\nX-Mailer: Mozilla 4.76 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: &quot;rest-discuss@yahoogroups.com&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nSubject: RFC: Potential XML.com article\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nX-Filtered-By: PerlMx makes it fast and easy.  See http://www.ActiveState.com/Products/PerlMx/Header\r\nFrom: Paul Prescod &lt;paul@...&gt;\r\nX-Yahoo-Group-Post: member; u=23186829\r\n\r\nPlease contribute comments on this article I am working on for xml.com.\n==============\n\tSecond Generation Web Services\n\nIn the early days of the Internet, it was common for enlightened\nbusinesses to connect to the Internet merely by using SMTP, NTTP and FTP\nclients and servers to deliver messages, text files, executables and\nsource code. The Internet became a more fundamental tool when businesses\nstarted to integrate their corporate information (both public and\nprivate) into the emerging Web framework. The Internet became popular\nwhen it shifted from a focus on transactional protocols to a focus on\ndata objects and the links between them. \n\nThe technologies that characterize the early Web framework were\nHTML/GIF/JPEG, HTTP and URLs. This combination of standardized formats,\na single application protocol and a single universal namespace was\nincredibly powerful. Using these technologies, corporations integrated\ntheir diverse online publishing systems into something much more\ncompelling than any one of them could have built.\n\nOnce organizations converged on common formats, the HTTP protocol and a\nsingle addressing scheme, the Web became more than a set of Web sites.\nIt became the world&#39;s most diverse and powerful information system.\nOrganizations built links between their own information and other\npeople&#39;s. Amazing third party applications also weaved the information\ntogether. Examples include Google, Yahoo, Babelfish and Robin Cover&#39;s\nXML citations.\n\nFirst generation Web Services are like first generation Internet\nconnections. They are not integrated with each other and are not\ndesigned so that third parties can easily integrate them in a uniform\nway. I posit that the next generation will be more like the integrated\nWeb that arose for online publishing and human/computer interactions. In\nfact, I believe that second generation web services will actually build\nmuch more heavily on the architecture that made the Web work. Look for\nthe holy trinity: standardized formats (XML vocabularies), a\nstandardized application protocol and a single URI namespace.\n\nThis next generation of Web Services will likely bear the name &quot;REST&quot;\nWeb Services. REST is the underlying architectural model of the current\nWeb. It stands for REpresentational State Transfer. Roy Fielding of\neBuilt invented the name in his PhD dissertation.\nhttp://www.ebuilt.com/fielding/pubs/dissertation/top.htm. Recently, Mark\nBaker of PlanetFred has been a leading advocate of this architecture.\n\nREST details why the Web has URIs, HTTP, HTML, JavaScript and many other\nfeatures. It has many aspects and I would not claim to understand it in\ndetail. I&#39;m going to focus on the aspects that are most interesting to\nXML users and developers.\n\n\tThe Current Generation\n\nSOAP was originally intended to be a cross-Internet form of DCOM or\nCORBA. The name of an early SOAP-like technology was &quot;WebBroker&quot; -\nWeb-based object broker. It made perfect sense to model an\ninter-application protocol on DCOM, CORBA, RMI etc. because they were\nthe current models for solving inter-application interoperability\nproblems.\n\nThese RPC protocols achieved only limited success before they were\nported to the Web. Some believe that the problem was merely that\nMicrosoft and the OMG supporters could not get along. I disagree. There\nis a deeper issue. RPC models are great for closed-world problems. A\nclosed world problem is one where you know all of the users, you can\nshare a data model with them, and you can all communicate directly as to\nyour needs. Evolution is comparatively easy in such an environment: you\njust tell everybody that the RPC API is going to change on such and such\na date and perhaps you have some changeover period to avoid downtime.\nWhen you want to integrate a new system you do so by building a\npoint-to-point integration.\n\nOn the other hand, when your user base is too large to communicate\ncoherently you need a different strategy. You need a pre-arranged\nframework that allows for evolution on both the client and server sides.\nYou need to depend less on a shared, global understanding of the rights\nand responsibilities of a participant. You need to put in hooks where\nyour users can innovate without contacting you. You need to leave in\nexplicit mechanisms for interoperating with systems that do not have the\nsame API. RPC protocols are traditionally poor at this kind of\nevolution. Changing interfaces tends to be extremely difficult. I\nbelieve that this is why no enterprise has ever successfully unified all\nof their systems with an RPC protocol such as DCOM, CORBA or RMI.\n\nNow we come to the crux of the problem: SOAP RPC is DCOM for the\nInternet.\nThere are many problems that can be solved with an RPC methodology. But\nI believe that the biggest, hairiest problems will require a model that\nallows for independent evolution of clients, servers and intermediaries.\nIt is therefore important for us to study the only distributed\napplications in history to ever scale to the size of the Internet.\n\n    The archetypical scalable application\n\nThere two most massively scalable, radically interoperable, distributed\napplications in the world today and they are the Web and email. What\nmakes these two so scalable and interoperable feature? For starters,\nthey both depend on standardized, extensible message formats (HTML and\nMIME). They both depend on standardized, extensible application\nprotocols (HTTP and SMTP). But I believe that the most important thing\nis that each has a global addressing scheme.\n\nIn the real estate world there is a joke that there are three things\nthat make a property valuable: location, location and location. The same\nis true in the world of XML web services. Properly implemented, XML web\nservices allow you assign addresses to data objects so that they may be\nlocated for sharing or modification.\n\nIn particular, the web&#39;s central concept is a single unifying namespace\nof URIs. URIs allow the dense web of links that make the Web worth\nusing. URIs identify resources. Resources are conceptual objects.\nRepresentations of them are delivered across the web in HTTP messages.\nThese ideas are so simple and yet they are profoundly powerful and\ndemonstrably successful. URIs are extremely &quot;loosely coupled&quot;. You can\npass a URI from one &quot;system&quot; to another using a piece of paper and OCR!\nURIs are &quot;late bound&quot;. They do not declare what can or should be done\nwith the information they reference. It is because they are so radically\n&quot;loose&quot; and &quot;late&quot; that they scale to the level of the Web.\n\nUnfortunately, most of us do not think of our web services in these\nterms. Rather we think of them in terms of remote procedure calls\nbetween endpoints that represent software components. This is CORBA/DCOM\nthinking. Web thinking is organized around URIs for resources.\n\nClaim: The next generation of web services will use individual data\nobjects as endpoints. Software component boundaries will be invisible\nand irrelevant.\n\n\tAn Illustrative Example\n\nUDDI is an example of a Web Service that could be made much, much more\nrobust as a second generation Web Service. I&#39;m not discussing the\nphilosophical issues of UDDI&#39;s role in the web services world but the\nvery concrete issue of how to get information into and out of it. These\narguments will apply to most of the Web Services in existence, including\nstock quote services, airplane reservations systems and so forth.\n\nUDDI has a concept of a businessEntity representing a corporation.\nBusinesses are identified by UUIDs. The Web-centric way to do this would\nhave been to identify them by URIs. The simplest way to do this would be\nto make a businessEntity an XML document addressable at a URI\nlike&quot;http://www.uddi.org/businessEntity/ibm.com&quot; or perhaps\n&quot;http://www.uddi.org/getbusinessEntity?ibm.com&quot;. The difference between\nthese two is subtle and does not have many technical implications so\nlet&#39;s not worry about it. \n\nYou can think of &quot;http://www.uddi.org/businessEntity&quot; as a directory\nwith files in it or a web service pulling data from a database. A\nwonderful feature of the Web is that there is no way to tell which is\ntrue just from looking at the URI. That is &quot;loose coupling&quot; in action!\n\nLet&#39;s consider the implications of using HTTP-based URIs instead of\nUUIDs for business entities:\n\n*\tAnybody wanting to inspect that business entity would merely point\ntheir (XML-aware!) browser at that URI and look at the businessEntity\nrecord. \n\n*\tAnybody wanting to reference the businessEntity (in another web\nservice or a document) could just use the URL.\n\n*\tAnybody wanting to incorporate the referenced information into another\nXML document could use an XLink, XPointer or XInclude.\n\n*\tAnybody wanting a permanent copy of the record could use a command\nline tool like &quot;wget&quot; or do a &quot;Save As&quot; from the browser. \n\n*\tAny XSLT stylesheet could fetch the resource dynamically to combine it\nwith others in a transformation.\n\n*\tAccess to the businessEntity could be controlled using standard HTTP\nauthentication and access control mechanisms\n\n*\tMetadata could be associated with the businessEntity using RDF\n\n*\tAny client-side application (whether browser-based or not) could fetch\nthe data without special SOAP libraries.\n\n*\tTwo business entities could represent their merger by using a standard\nHTTP redirect from one businessEntity to another.\n\n*\tEditing and analysis tools like Excel, XmetaL, Word and EMACS could\nimport XML from the URL directly using HTTP. They could write back to it\nusing WebDAV.\n\n*\tUUIDs or other forms of location-independent addresses could still be\nassigned as an extra level of abstraction as demonstrated at purl.org.\n\nThe current UDDI &quot;API&quot; has a method called get_businessDetail. Under an\naddress-centric model, that method would become entirely redundant and\ncould thus be removed from the API. UDDI has several get_ methods that\noperate on data objects such as tModels and business services. These\ndata objects could all be represented by logical XML documents and the\nmethods could be removed. Note how we have substantially simplified the\nuser&#39;s access to UDDI information.\n\nBusiness entities are not the only things in UDDI that should be\nidentified by URI-addressable resources rather than SOAP APIs. In fact\nall of the data in a UDDI database could be represented this way.\n\nSummary: Resources (data objects) are like children. They need to have\nnames if they are to participate in society.\n\n\tExtensibility\n\nNow let&#39;s consider the extensibility  characteristics of the REST model\nversus the original SOAP RPC model. Let&#39;s say that your company has a\nprivate UDDI registry and mine does also. You and I are business\npartners. We agree to share our customer databases. The customer\ndatabases have pointers into our UDDI registries for referring to\nbusinessEntities.\n\nIf our registries have little or no overlap then it makes sense for you\nto maintain yours and for me to maintain mine. Rather than replicating\nbetween them (which has serious security and maintainability\nimplications) I would like to just add you to the access control lists\nfor some records and allow you to refer to them from your customer\ndatabase and I&#39;ll do the opposite from mine.\n\nIf the customer databases use UUIDs then they have no way of knowing\nwhether a particular UUID should be looked up in the local database, the\npartner&#39;s database or even the public UDDI In The Sky. URIs are not just\nglobally unique but also typically embed enough information to allow\nthem to be de-referenced without further context. Using URIs instead of\nUUIDs, new repositories can be integrated whenever we want. In fact, if\nwe use URIs, the customer database could refer just as easily to\nbusinessEntity records sitting on somebody&#39;s hard disk as in a formal\nUDDI registry. The database maintainer could choose whether to allow\nthat or not.\n\nBecause the businessEntity documents are XML, it is relatively easy to\nadd elements, attributes or other namespaces. This makes the document\nformat extensible. It is also easy to extend the protocol by adding\nspecialized HTTP headers or even new HTTP methods.\n\n\tPerformance\n\nPerformance of web services will be an important issue. Any resource\nrepresentation retrieved from a GET-based URI can be cached. It can be\ncached in a cache server in front of the server, in an intermediate\nprovided by an ISP, at a corporate firewall or on the client computer.\nCaching is built-in to HTTP. SOAP get_businessDetail messages are not\ncached by any existing technology.\n\nAs an optimization, the URI &quot;http://www.uddi.org/businessEntity/ibm.com&quot;\nmight be represented as a raw text file on a hard disk of an operating\nsystem optimized towards serving files over HTTP. There is not and will\nlikely never be any server that can invoke SOAP methods as quickly as a\nfast HTTP server can serve files from disk.\n\n\tOther methods\n\nUDDI has other methods for working with businessEntities. One is\ndelete_business. HTTP already has a DELETE method. Therefore this method\nwould be redundant in the REST model. Instead of doing a UDDI\nSOAP-RPC-specific delete you could do an HTTP delete. This would have\nthe benefit of being compatible with tools that know how to do HTTP\ndeletes like the Windows 2000 explorer and MacOS X finder. In theory,\nbusinesses could delete portions of their own records (perhaps obsolete\nbranch plant addresses) by merely hitting the &quot;delete&quot; key.\n\nObviously authentication and access control is key. Microsoft should not\nbe able to delete their competitors (or at least should be forced to\ndelete them in the old fashioned way, by competing with them). HTTP\nalready has the authentication, authorization and encryption features\nthat UDDI&#39;s SOAP RPC protocol lacks. It already works.\n\nUDDI has a save_business method. This is for uploading new businesses.\nThe HTTP equivalent is PUT or POST. A pleasant side effect of using HTTP\nmethods instead of a SOAP method is that you can do a POST from an HTML\nform. So the web service can be used either from other programs or (with\na browser) by a human editor.\n\nUDDI has a find_business method. This is no different in principle than\nthe search features built into every website in the world and search\nengine sites in particular. That would be a form of GET. On the URL\nline, the service would take a series of search parameters and return an\nXML document representing the matching businessEntities (either by\nreference, as URLs, or by value, as XML elements).\n\n\tThe Role of HTTP\n\nYou may notice a recurring theme. Everything that we want to do in this\nWeb Service is already supported in HTTP. The only things that we need\nto innovate on are our URI structure and our XML schemas. Bingo! That\nwas the whole point of XML: to focus on data interchange instead of\nsoftware components!\n\nEverything in UDDI can be represented in terms of HTTP operations on\nresources. So HTTP isn&#39;t accidentally paired with URIs as one of the\ncentral technologies of the Web. It is designed specifically as a major\npart of the location-centric REST architecture.\n\nHere&#39;s the radical idea: no matter what your problem, you can and should\nthink about it as a data resource manipulation problem rather than as an\nAPI design problem. Think of your web server as this big information\nrepository: like a database. You are doing data manipulation operations\non it.\n\nIn UDDI I&#39;ve chosen a web service that is ripe for an easy conversion to\nREST philosophy but we can apply these principles to anything. What\nabout something like a purchase order submission? That seems more\ntransactional. Well purchase orders want to be named also! If you POST\nor PUT a purchase order to a new URI then internal systems all over your\ncompany can instantly refer to it no matter where they are. Using HTTP,\nan arbitrary XSLT stylesheet or Perl script sitting on an employee&#39;s\ndesktop in the Beijing office can massage data from a purchase order\nsitting on the accounting mainframe in Los Angeles. Accessing\nHTTP-addressable resources is no more difficult than accessing files off\nof the local file system, but it requires much less coordination than\nstandard file system sharing technologies.\n\nWhat about a request for quote? RFQs want to be named! Once you give\nthem a name you can pass around the URL to your partners rather than the\ntext. Then your partners can build references to them using hyperlinks\nfrom their documents and databases. Use access controls to keep out your\ncompetitors. You can think about any business problem in this way.\n\nEven web services with complicated work flows can be organized in a\nURI-centric manner. Consider a system that creates airline reservations.\nIn a traditional HTML system there are a variety of pages representing\nthe different stages in the logical transaction. First you look up\nappropriate flights. You get back a URI representing the set of\nappropriate flights. Then you choose a light. You get back a URI\nrepresenting your choice. Then you decide to commit. You get back a web\npage that returns reservation number. Ideally the URL for that page will\npersist for a reasonable amount of time so that you can bookmark it. \n\nAn XML based web service could go through the exact same steps. Rather\nthan returning HTML forms at each step, the service would return XML\ndocuments conforming to a standard airline industry vocabulary. Those\nsame XML documents could be used on a completely different airline\nreservation site to drive exactly the same process.\n\nSummary: Any business problem can be thought of as a data resource\nmanipulation problem and HTTP is a data resource manipulation protocol.\n\n\tMetcalfe&#39;s Law Revisited\n\nMetcalfe&#39;s law is that the value of a network is proportional to the\nsquare of the number of people on the network, because each pair of\npeople can make a connection between them. One telephone is useless. One\nbillion phones cause a major telecommunications revolution - if they can\nall access each other through a single global naming system. \n\nMetcalfe&#39;s law also applies to data objects. Elements in UDDI can only\n(with a few exceptions) refer to each other. They cannot refer to\nobjects elsewhere on the Web (for instance in other UDDI repositories).\nSimilarly, objects on the Web (for instance web pages) cannot refer to\nthe XML elements in the UDDI repository. A URL-centric solution would\nunify these data domains as the phone number system unifies telephones.\n\n\tSecurity\n\nMaking your data universally addressable is not equivalent to making it\nuniversally available! It is easy to hide objects by merely never\npublishing their URIs. It is also easy to apply security policies to\nobjects. In fact, REST simplifies security greatly. \n\nUnder the SOAP RPC model, the objects that you work with are implicit\nand their names are hidden in method parameters. Therefore you need to\ninvent a new security strategy for each and every web service. UDDI is\ncompletely unlike .NET My Service which will likely be completely unlike\nLiberty and so forth. Under REST, you can apply the four basic\npermissions to each data object: GET permission, PUT permission, DELETE\npermission and POST permission. You might also want to allow or disallow\nGET/PUT/DELETE and POST on sub-resources. This model is exactly like the\none used for today&#39;s file systems! It is proven and it works. I know of\nno security model that works in a similarly generic manner for remote\nprocedure call models.\n\n\tMaintenance\n\nIn fact, security is just one form of maintainability that is simplified\nby REST.  Any network administrator will tell you that every level of\nnetworking causes its own headaches. Some days IP works but DNS doesn&#39;t\n(DNS server down or DNS settings misconfigured). Some days IP/DNS works\nbut HTTP doesn&#39;t (firewall or proxy misconfigured). If you run a web\nservice protocol on top of HTTP it will add its own layer of\nconfiguration and software headaches on top of the existing ones. It\ncannot be more reliable than its foundational HTTP layer. It can only\nadd one more layer of unreliability.\n\nOnce you have your service working, it is possible to &quot;test&quot; REST web\nservices just by looking at them in a browser. It is possible to make\nsimple HTML forms to test POSTs. QA departments can easily pretend to be\nmultiple users by changing their HTTP credentials. Standard web tools\ncan monitor availability. In essence, testing REST services is often\neasy if you already know how to test web sites. On the other hand, every\nSOAP RPC service will have its own security model, its own addressing\nmodel, an implicit data model and its own set of methods. Of these four\nthings, only the security model is even currently a candidate for\nstandardization. Testing such a system is much more challenging.\n\n\tThe Rest of the Story\n\nThis brief introduction can only whet your appetite to the theory and\npractice of REST-based web services. In an upcoming article, I will:\n\n*\tdescribe in more detail how any web service can be transformed into a\nURI-centric one. \n\n*\tshow how the REST philosophy and the XML philosophy are highly\ncompatible.\n\n*\tshow an example of a successful, public, widely used web service that\nuses this model today. \n\n*\tdiscuss the role of SOAP in these sorts of web services.\n\n*\tdiscuss reliability, coordination, transactions, encryption, firewalls\netc.\n\nIf you would like to discuss these issue in the meantime, please\nconsider contributing to the rest-wiki\n(http://internet.conveyor.com/RESTwiki/moin.cgi/FrontPage) and the REST\nmailing list (http://groups.yahoo.com/group/rest-discuss/). \n=============\n\n"}}