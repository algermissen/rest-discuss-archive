{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":159732348,"authorName":"Tony Butterfield","from":"Tony Butterfield &lt;tab@...&gt;","profile":"butter1060","replyTo":"SENDER","senderId":"VKLak6tSYnL8SLiQvs4bcSO08rkUC3Bs6uJZ3LPfhhQgosHbyPbMFmVS51c8CHy55Eo-OaSGcbB-15KIinNtM4-ao0mDDg","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] REST toolkits","postDate":"1078133068","msgId":4256,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDEwNzgxMzMwNjcuMjQ0MDYuNDguY2FtZWxAbG9jYWxob3N0LmxvY2FsZG9tYWluPg==","inReplyToHeader":"PDIwMDQwMjI3MTM1MzU1LkdBMjYzNTNAcGhvZW5peC5zb3Zlci5uZXQ+","referencesHeader":"PGJ2dGludCs2bzIwQGVHcm91cHMuY29tPgkgPDIwMDQwMjA2MTUxNTQ2LkdBMjI4OTlAcGhvZW5peC5zb3Zlci5uZXQ+CSA8MTA3NjMyNDk0OS4xNjE1OS4zNC5jYW1lbEBsb2NhbGhvc3Q+CSA8MjAwNDAyMjcxMzUzNTUuR0EyNjM1M0BwaG9lbml4LnNvdmVyLm5ldD4="},"prevInTopic":4254,"nextInTopic":4257,"prevInTime":4255,"nextInTime":4257,"topicId":1078,"numMessagesInTopic":37,"msgSnippet":"There is lots of interesting fragments of this broad discussion. If I could summarise the main threads, in order of importance, from my perspective: 1)","rawEmail":"Return-Path: &lt;tab@...&gt;\r\nX-Sender: tab@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 3632 invoked from network); 1 Mar 2004 09:27:36 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m9.grp.scd.yahoo.com with QMQP; 1 Mar 2004 09:27:36 -0000\r\nReceived: from unknown (HELO ptb-relay03.plus.net) (212.159.14.214)\n  by mta1.grp.scd.yahoo.com with SMTP; 1 Mar 2004 09:27:35 -0000\r\nReceived: from [212.159.120.165] (helo=localhost.localdomain)\n\t by ptb-relay03.plus.net with esmtp (Exim) id 1Axjhv-000OYf-7r; Mon, 01 Mar 2004 09:27:27 +0000\r\nTo: Josh Sled &lt;jsled-yahoogroup@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nIn-Reply-To: &lt;20040227135355.GA26353@...&gt;\r\nReferences: &lt;bvtint+6o20@...&gt;\n\t &lt;20040206151546.GA22899@...&gt;\n\t &lt;1076324949.16159.34.camel@localhost&gt;\n\t &lt;20040227135355.GA26353@...&gt;\r\nContent-Type: text/plain\r\nOrganization: 1060 Research\r\nMessage-Id: &lt;1078133067.24406.48.camel@...&gt;\r\nMime-Version: 1.0\r\nX-Mailer: Ximian Evolution 1.4.4 \r\nDate: Mon, 01 Mar 2004 09:24:28 +0000\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Remote-IP: 212.159.14.214\r\nFrom: Tony Butterfield &lt;tab@...&gt;\r\nSubject: Re: [rest-discuss] REST toolkits\r\nX-Yahoo-Group-Post: member; u=159732348\r\nX-Yahoo-Profile: butter1060\r\n\r\nThere is lots of interesting fragments of this broad discussion. If I\ncould summarise the main threads, in order of importance, from my\nperspective:\n1) Toolkits versus Frameworks (the pro&#39;s and con&#39;s of each)\n2) Service orchestration (declaring, sequencing and pipelining requests)\n3) Meta data (what is needed and why)\n4) REST versus HTTP (HTTP is the definitive REST implementation but\nisn&#39;t the essence)\n\n\nOn Fri, 2004-02-27 at 13:53, Josh Sled wrote: \n&gt; On Mon, Feb 09, 2004 at 11:09:09AM +0000, Tony Butterfield wrote:\n&gt; \n&gt; | Are you thinking of RDF for defining, declaring and documenting the\n&gt; | interfaces?\n&gt; \n&gt; Likely... maybe ... too early to say, though.\nYeah, I agree, certainly at the moment XML suffices for all our\nmeta-data, RDF/XML requires a whole new technology stack to process it\nbut if it has sufficient merit then why not. Ideally it is just another\ndata type. \n&gt; \n&gt; | Looking at the service, there are at least three aspects:\n&gt; | 1) implementing the service\n&gt; | 2) providing a public interface to the service\n&gt; | 3) providing meta-data about the service\n&gt; | \n&gt; | As far as implementing the service goes, I think it would great if the\n&gt; | toolkit would provide all abstractions to implement the service\n&gt; | independent of the public interface, provide implementations of the\n&gt; | common web datatypes and provide tools for the management of the\n&gt; | service.\n&gt; \n&gt; Hmm.  My biggest issue with this is that the developer is likely already\n&gt; going to have a set of idioms and tools [data-structures, libraries, &c.]\n&gt; with which to deal with common web datatypes [be they images or XML].  Hmmm.\n&gt; \n&gt; &quot;Management of the service&quot; I&#39;m going to read as &quot;basic lifecycle and\n&gt; network-connection accepting&quot; ... in that case, I also think that most people\n&gt; already have some tool for dealing with this, as well.  At the same time, a\n&gt; lightweight HTTP client/server might be a good optional provision of the\n&gt; toolkit.\n\nI think our difference of perspective is because I have been thinking\nmore framework than toolkit. You talk about this further down too. To me\nthis is a key aspect to raising the abstraction bar on developing REST\nservices- I don&#39;t want to be hand crafting code to extract fields from\nHTTP headers and parsing XML.\n\nI don&#39;t think of it as a black and white thing though. By using an OS,\nJVM, servlets you are effectively using a framework just a fairly non\ninvasive one. You mention a few problems further down which, to me, hint\nat framework solutions. I understand that a framework is more subsuming\nof the developers world and than a toolkit and makes adoption harder but\nthe tradeoffs are worth considering. From the little I understand about\nAspect Oriented Programming too, it seems that framework-like features\ncan be added in to code in a less invasive manner.\n\nI think that a toolkit encourages a from-the-ground structure, this\nisn&#39;t as bad as having to re-invent the wheel like the lack of toolkits\ncauses. But it doesn&#39;t easily encourage good patterns of usage. I guess\nan attribute of a good framework is that it can be repeatedly &quot;peeled\nback&quot; to reveal more control and flexibility and thus ideally converging\non a toolkit.\n\nFor me the bottom line is that if you mostly like and trust the pattern\nthat a framework is encouraging then a framework can offer more than a\ntoolkit.\n\n&gt; I don&#39;t know what meta data there necessarily is.  In fact, I think that\n&gt; RESTful services should try to minimize the volume of meta-data necessary to\n&gt; function; anything apart from the interface itself is another point of\n&gt; &quot;failure&quot;.\n&gt; \n&gt; \n&gt; | As far as providing the public interface I would good to be able to\n&gt; | declaratively map the service onto some public interface. I.e. lets say\n&gt; | put the ImageTransformService at http://imagetools.org/transform\n&gt; \n&gt; Hmm.  Let&#39;s come to agreement on a sketch of what the RESTful API for this\n&gt; service would look like...\n&gt; \n&gt; C: POST /transform\n&gt; C: &lt;transform&gt;\n&gt;      &lt;image resource=&quot;http://host/path/image.png&quot; /&gt;\n&gt;      &lt;format&gt;image/png&lt;/format&gt;\n&gt;      &lt;transforms&gt;\n&gt;        &lt;scale x=&quot;0.5&quot; y=&quot;0.5&quot; /&gt;\n&gt;        &lt;crop x0=&quot;0&quot; y0=&quot;0&quot; x1=&quot;-20&quot; y1=&quot;-50&quot; /&gt;\n&gt;        &lt;sharpen q=&quot;0.217&quot; /&gt;\n&gt;      &lt;/transforms&gt;\n&gt;    &lt;/transform&gt;\n&gt; S: 201; Location: /transform/1\n&gt; \n&gt; C: GET /transform/1\n&gt; S: 200\n&gt; S: &lt;transform&gt;\n&gt;      &lt;source resource=&quot;http://host/path/image.png&quot; /&gt;\n&gt;      &lt;image resource=&quot;/transform/1/image&quot; /&gt;\n&gt;      &lt;transforms&gt;\n&gt;        &lt;scale x=&quot;0.5&quot; y=&quot;0.5&quot; /&gt;\n&gt;        &lt;crop x0=&quot;0&quot; y0=&quot;0&quot; x1=&quot;-20&quot; y1=&quot;-50&quot; /&gt;\n&gt;        &lt;sharpen q=&quot;0.217&quot; /&gt;\n&gt;      &lt;/transforms&gt;\n&gt;    &lt;/transform&gt;\n&gt; \n&gt; C: GET /transform/1/image\n&gt; S: 200; Content-Type: image/png\n&gt; S: [binary image data]\n&gt; \n&gt; Seem reasonable?\nYes. I see how it would work. What are you motivations for having a two\nstage register a transform, then get result of transform. Is this\nsomething that you have come across as a necessary pattern? \n&gt; \n&gt; | Providing meta-data. I&#39;d like to explore this issue more. To use RDF or\n&gt; | WSDL to describe an interface is nice but useful only for automatically\n&gt; | building static client stubs or providing documentation. \n&gt; \n&gt; Those are pretty useful things, and I think exactly what most people want out\n&gt; of such a toolkit. :)\nSOAP style object bindings are not needed though are they? Providing\nhuman readable definitions of the interfaces I can understand.\n\nDoes anyone have experience of defining REST interfaces in terms of the\nMIME types posted or got, xml schemas (if XML), response codes and verbs\napplicable on URIs? Also is it currently more work than the benefits\nderived?\n\n&gt; There is an elephant in the room, though, of actually modeling a\n&gt; resource-space such that it matches the nouns of the application domain, but\n&gt; with the necessary ... formalism ... to support an REST implementation.\n&gt; Perhaps a &quot;resource-space-builder&quot; [a-la a GUI builder] isn&#39;t out of the\n&gt; question.  This may be REST&#39;s hardest sell ... one needs to do some work not\n&gt; directly related to writing code to get the thing off the ground.\n&gt; \nI like idea! Have you got one?\n\n&gt; | parameters to a request using standard web datatypes- in this example\n&gt; | say and XML specification plus a PNG image stream. Then pass them to the\n&gt; | service. \n&gt; \n&gt; Damn; I&#39;m torn between getting out of the developer&#39;s way and letting her use\n&gt; whatever tools for both XML/data-handling and http-{client,server}age she\n&gt; wants, and the necessities of actually having a toolkit that provides value.\n&gt; I think the right thing is to do the latter, and try to abstract it out\n&gt; toward the former.\n&gt; \n&gt; I think it&#39;s important to focus on a toolkit, rather than a framework.  That\n&gt; is: focus less on subsuming the developer&#39;s world, instead focus on providing\n&gt; a set of small tools to be used and integrated into their world.\n\nSee above.\n\n&gt; &gt;From recent experience building a RESTful [internal] client/server system,\n&gt; these [were] the more useful parts we had spawned:\n&gt; \n&gt; 1/ &#39;http[-test]-client&#39; -- a simple [~300line] command-line wrapper around\n&gt;    the Jakarta HttpClient library, allowing manual execution of all 4 verbs:\n&gt; \n&gt;    e.g.:\n&gt;    # htc [-h localhost] [-p 8180] GET &#39;/transform?created=today&#39;\n&gt;      &lt;xml&gt;\n&gt;    # htc -f new-transform.xml POST /transform\n&gt;      Location: /transform/42\n&gt;    # htc GET /transform/42\n&gt;      &lt;xml&gt;\n&gt;    # htc DELETE /transform/42\n&gt;      200\n&gt; \n&gt;    Basically: wget += [ put, post, delete ];\n&gt; \n&gt; \n&gt; 2/ a resource/service-method mapping dispatcher -- a relatively simple\n&gt;    Servlet dispatcher which was configured by a simple text file of lines of\n&gt;    the form:\n&gt; \n&gt;    --\n&gt;    ###  public void getTransforms( Map m )\n&gt;    GET  /transform?[query-spec] in:null out:TransformList TransformService.getTransforms\n&gt;    ###  public TransformUri postTransform( Transform t )\n&gt;    POST /transform in:Transform out:TransformURI TransformService.postTransform\n&gt;    ###  public Transform getTransform( TransformURI turi )\n&gt;    GET  /transform/1 in:TransformURI out:Transform TransformService.getTransform\n&gt;    --\n&gt; \n&gt;    The Dispatcher had support for:\n&gt;    * URI-pattern matching.\n&gt;    * required query paramaters which modified dispatching.\n&gt;    * input/output data validation/[un]marshaling.\n&gt; \n&gt;    I think the data behind this particular file is better placed in a simple\n&gt;    data structure directly in the code, in the simple case.  One problem we\n&gt;    had was the seperation of the sections of this file from the 20-or-so\n&gt;    services which backed it ... they could then more easily change\n&gt;    independently, which sucks.\n&gt; \n&gt;    In out system, we autogenerated all those in: and out: types ... but it\n&gt;    was more important that they implemented a simple interface which allowed\n&gt;    the retreival of their &quot;xml-delegate&quot;, which was then used to do\n&gt;    [un]marshaling.\n&gt; \n&gt;    This is the trickiest part, for me...\n&gt; \n&gt;    i/    I don&#39;t want a tool that autogenerates data-carrier objects: there&#39;s\n&gt;          already too many of them, and they all suck.\n&gt; \n&gt;    ii/   I personally don&#39;t want to deal with XML-enabled objects anymore.\n\nThese are looking like ways service orchestration/pipelining of requests\nin a declarative way. I think this is a key feature however:\n1) if you use HTTP/network as the only inter-service communication\nmechanism you&#39;ll be reluctant to reduce the granularity of your\nservices. If you create a request abstraction that maps to HTTP and\nanything else you might have you get more flexibility.\n2) these higher-level orchestrations of services will soon want to be\nservices in their own right too. How would you wrap them up? \n&gt;    \n&gt; \n&gt; 3/ A set of defined error-codes, exceptions and consistent handling.  We only\n&gt;    ended up using the &quot;common subset&quot; of HTTP response codes... specifically:\n&gt;    200 [ok], 201 [created], 202 [accepted], 204 [no content]\n&gt;    400 [bad req], 401 [unauthorized], 404, 409 [object conflict]\n&gt;    500 [server error]\n&gt; \n&gt;    We handled these with exceptions in java; there was one in particular that\n&gt;    we all felt sad about throwing the exception, since it wasn&#39;t an\n&gt;    exceptional case. :/  At the same time, you don&#39;t want every function\n&gt;    return value to be &quot;HttpResponse&quot;...\nIt&#39;s a tough one. Most languages only like one return type/value from a\nfunction/service. Exceptions are a let-out but it starts to get messy if\nyou start putting real data into exception subclasses. Putting\nHttpResponse objects thoughout you code bind the whole thing tightly to\nHTTP and the servlet infrastructure.\n\nOur approach has been to in effect eliminate the dichotomy of response\ncode and response representation in HTTP. i.e. consider the response as\njust one value, either the code is the relevant part or the\nrepresentation in the body is.\n\n&gt; 4/ request/response logger -- we did this on the client side, but should have\n&gt;    done it on the server side, too.  It was basically a fixed-size FILO queue\n&gt;    of request objects, which was trivially HTMLized.  It made debugging and\n&gt;    undestanding the system a breeze.\n&gt;    * We also should have extended it to save a replayable log for testing\n&gt;      purposes, which would have been real nice.\nI guess it was because of the servlet framework that you had a clean\nsingle point to add the logging. To me this is one of the key pro points\nfor frameworks; if abstracted well they provide a single points where\nchanges can be made which have global effect. \n\n&gt; 5/ ScriptableHttpXml -- a simple tool which accepted a script file with\n&gt;    directives like:\n&gt;    --\n&gt;    GET /transform/0 expect:404\n&gt;    GET /transform/-1 expect:404\n&gt;    POST /transform file:transform-test0.xml expect:201 location:test0uri\n&gt;    GET  ${test0uri} expect:200 saveIn:test0data compareTo:transform-test0-get.xml\n&gt;    XPATHREPLACE ${test0data} /transform/@about=&quot;/transform/42&quot;\n&gt;    PUT  ${test0uri} ${test0data} expect:409\n&gt;    # ...\n&gt;    --\n&gt; \n&gt;    * It started with the 4 verbs plus a couple of other data-handling\n&gt;      directives, and grew as we got more sophisticated.  I&#39;ll see what I can\n&gt;      do about getting the tool from it&#39;s owner. :)\n&gt; \nMore service orchestration with some simple XML primitives thrown in- I\nreally think this approach works. You have:\n1) request definitions\n2) response assertions\n3) temporary variables\n4) xml comparisons\n5) xml manipulations\n\nI&#39;ve been down this path too. Then I got to the point where I thought\nbut why build all these primitives into the language, make them services\ntoo. Then you boil it down to simple URI request assembly language.\n\n&gt; As well, in would have been really nice to have the following:\n&gt; \n&gt; a/ some auto-population of the resource-space.  I always wanted [GET /]\n&gt;    to return a list of the top-level resources.  The ResourceDispatcher\n&gt;    should have been able to do that.\nI guess there would be a few aspects to this, mapping a listing service\nonto all paths that end with slash. The using of your meta-data about\nyour services to create the listing resource (maybe in XML) \n\n&gt; b/ a standard way to return &quot;4xx, but here&#39;s how you use it...&quot;, in a\n&gt;    developer-understandable form.\nMmm. Can you return a meaningful representation in the body of a\nresponse? \n\n&gt; c/ a useful URI class -- we ended up doing the URI-pattern matching in\n&gt;    multiple places.  It&#39;d sure have been nice to have a consistent mechanism\n&gt;    for it.\nI&#39;ve done lots of regex matching on URIs too. It works well. As for a\nconsistent mechanism; having a framework where you define URI address\nspaces as sets of services that map to them has worked for me. \n\n&gt; d/ etags/timestamps + conditional-GET support -- we solved multiple\n&gt;    performance problems with poor-man&#39;s caching, but it would have been nice\n&gt;    to have had an easy way to plumb etags/timestamps through the server to\n&gt;    the API.\nHaving a non-HTTP request abstraction solves this one too. The\nequivalent of the HTTP header becomes meta-data that travels around with\nthe representation of a resource.\n\n&gt; So what toolkit pieces do I see out of this, at this point?\n&gt; \n&gt; * &quot;httpc&quot;\n&gt; * ScriptableHttpXml\n&gt; * ResourceDispatcher\n&gt; * PatternURI\nhttpc- A good HTTP client yes, I&#39;ve been recommended Apache&#39;s HTTPClient\nScriptableHttpXML- Take a look at our equivalent DPML:\nhttp://1060research-server-1.co.uk/docs/1.1.0/docxter/doc_guide_dpml_quick_reference.html\nResourceDispatcher/PatternURI- take a look at:\nhttp://1060research-server-1.co.uk/docs/1.1.0/docxter/doc_guide_concise.html\n\n-- \nTony Butterfield &lt;tab@...&gt;\n1060 Research\n\n\n"}}