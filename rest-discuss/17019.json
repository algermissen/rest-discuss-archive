{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":69164307,"authorName":"mike amundsen","from":"mike amundsen &lt;mamund@...&gt;","profile":"mamund","replyTo":"SENDER","senderId":"jj3oJf552etC-P2CXDcsjnBym7ldfCqxi1DW9Vp7w2Gug_9uVNb2fksF2pc3W2gKyDNIeauOkIFa7ZKkZhb1o_BwWm1Oh6M","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Link relations [was: A media type for case files, dossiers and documents]","postDate":"1291391254","msgId":17019,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEFBTkxrVGlrN0RfeFFHRGZFbmQyWG9RdUZQaXVoaVY3PWtCdkVpK2twZHBIWEBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PDkyMDI1NC43NDQ2Ni5xbUB3ZWI1NTkwNi5tYWlsLnJlMy55YWhvby5jb20+","referencesHeader":"PEFBTkxrVGltSGZXUVBzVURNLTUtOWt5RzhtRkNXPXM4S3R1Zzk5dnNNMHdhZUBtYWlsLmdtYWlsLmNvbT4JPDkyMDI1NC43NDQ2Ni5xbUB3ZWI1NTkwNi5tYWlsLnJlMy55YWhvby5jb20+"},"prevInTopic":17018,"nextInTopic":17020,"prevInTime":17018,"nextInTime":17020,"topicId":16947,"numMessagesInTopic":88,"msgSnippet":"Kevin: Glad the post helped.  What I am having a hard time swallowing is providing an API that returns data as HTML. I think it s going to be hard to go","rawEmail":"Return-Path: &lt;mca@...&gt;\r\nX-Sender: mca@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 78667 invoked from network); 3 Dec 2010 15:47:36 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m6.grp.sp2.yahoo.com with QMQP; 3 Dec 2010 15:47:36 -0000\r\nX-Received: from unknown (HELO mail-fx0-f53.google.com) (209.85.161.53)\n  by mta1.grp.sp2.yahoo.com with SMTP; 3 Dec 2010 15:47:35 -0000\r\nX-Received: by fxm4 with SMTP id 4so4317692fxm.12\n        for &lt;rest-discuss@yahoogroups.com&gt;; Fri, 03 Dec 2010 07:47:34 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.223.72.14 with SMTP id k14mr2273866faj.45.1291391254347; Fri,\n 03 Dec 2010 07:47:34 -0800 (PST)\r\nX-Received: by 10.223.122.77 with HTTP; Fri, 3 Dec 2010 07:47:34 -0800 (PST)\r\nIn-Reply-To: &lt;920254.74466.qm@...&gt;\r\nReferences: &lt;AANLkTimHfWQPsUDM-5-9kyG8mFCW=s8Ktug99vsM0wae@...&gt;\n\t&lt;920254.74466.qm@...&gt;\r\nDate: Fri, 3 Dec 2010 10:47:34 -0500\r\nX-Google-Sender-Auth: d0xPmfuC9yQBfrL2vCK7p3aJ4fc\r\nMessage-ID: &lt;AANLkTik7D_xQGDfEnd2XoQuFPiuhiV7=kBvEi+kpdpHX@...&gt;\r\nTo: Kevin Duffey &lt;andjarnic@...&gt;\r\nCc: Rest Discussion List &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Type: multipart/alternative; boundary=20cf3054a203fb411a04968374e6\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: mike amundsen &lt;mamund@...&gt;\r\nSubject: Re: [rest-discuss] Link relations [was: A media type for case files,\n dossiers and documents]\r\nX-Yahoo-Group-Post: member; u=69164307; y=MWxltvUIucjHXgbOovd8_Qrkcpq60LIn1krOE0wv5vFw\r\nX-Yahoo-Profile: mamund\r\n\r\n\r\n--20cf3054a203fb411a04968374e6\r\nContent-Type: text/plain; charset=ISO-8859-1\r\n\r\nKevin:\n\nGlad the post helped.\n\n&lt;snip&gt;\nWhat I am having a hard time swallowing is providing an API that returns\ndata as HTML. I think it&#39;s going to be hard to go out there and tell\nconsumers, &quot;here is my api, which returns HTML, but not for visual use.. you\nhave to parse the HTML yourself, even though your not a browser.. you&#39;re\ngoing to become a browser basically, in order to use my api&quot;. This just\nseems hard to get acceptance or by in by potential consumers. I would\nimagine most consumers of apis are expecting xml or json, and to get back\nhtml, and have to actually parse it at least to me I&#39;d be questioning why\nhtml, which as far as I knew was used to display data in a visual manner, is\nbeing sent back for me to parse to use the data in it.\n&lt;/snip&gt;\n\nIf you don&#39;t like [X]HTML, you don&#39;t have to use it. You;ll note in my\nslides (from the previous post), I don&#39;t use XHTML, I use a custom media\ntype built using XML as the format; could have been JSON, or some other\nformat, too.  The value of XHTML is not in DIV, SPAN, etc. it&#39;s in A, FORM,\netc.  Use XForms and XInclude and you get the same basic functionality.\n Don&#39;t like XForms? design your own hypermedia controls to handle navigation\nlinks, query templates, and idempotent & non-idempotent &quot;send&quot; operations\nand you have all the application controls you need.\n\nFielding, himself stated that hypermedia does not require HTML:\n&quot;Hypertext does not need to be HTML on a browser; machines can follow links\nwhen they understand the data format and relationship types&quot;[1]\n\nYou see lots of talk about XHTML here because it is well-known&#92;understood,\nand  has all the &quot;bits&quot; needed in a media type to support hypermedia-driven\napplications in the style Roy calls REST. This is the same reason you see\nlots of talk here about HTTP; because it has all the bits needed in a\napp-level protocol to support the REST style.  Neither are _required_, they\nare very well-suited for Roy&#39;s style.\n\nHope that clears\n\n[1]http://www.slideshare.net/royfielding/a-little-rest-and-relaxation (see\nslide #50)\n\n\nmca\nhttp://amundsen.com/blog/\nhttp://twitter.com@mamund\nhttp://mamund.com/foaf.rdf#me\n\n\n#RESTFest 2010\nhttp://rest-fest.googlecode.com\n\n\n\nOn Fri, Dec 3, 2010 at 10:27, Kevin Duffey &lt;andjarnic@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; Mike, a most excellent response.. very well said, again I have a better\n&gt; understanding of all this thanks to you and Eric.\n&gt;\n&gt; Here I thought I was implementing HATEOAS by providing links back in my\n&gt; response and a single entry point for all consumers to initiate their\n&gt; communication with my api.\n&gt;\n&gt; I totally get the concept of an evolving api breaking clients. Because of\n&gt; that, it was my impression that providing versions of your api prevent that,\n&gt; at least to some degree. Clients using v1, continue to use v1 until they are\n&gt; ready to be written to use v2, or..they just stay on v1. Like most software\n&gt; that adheres to major version changes as major feature changes, a v2 would\n&gt; be something probably quite a bit different.. different response formats,\n&gt; perhaps... but by using links in the responses, I can, from my api, direct\n&gt; clients to new resources if need be. Perhaps the old /orders is no longer\n&gt; valid.. we have a /neworders to handle all kinds of new data. Since all the\n&gt; clients use the links elements to navigate based on the rel=&quot;&quot; value, they\n&gt; shouldn&#39;t break, that I know of. Well.. to be fair, if the response format\n&gt; changes, then yes, they would break.. but if you keep the response format\n&gt; the same but modify the resources called via the links, then the clients\n&gt; will &quot;evolve&quot; with the api automatically.\n&gt;\n&gt; What I am having a hard time swallowing is providing an API that returns\n&gt; data as HTML. I think it&#39;s going to be hard to go out there and tell\n&gt; consumers, &quot;here is my api, which returns HTML, but not for visual use.. you\n&gt; have to parse the HTML yourself, even though your not a browser.. you&#39;re\n&gt; going to become a browser basically, in order to use my api&quot;. This just\n&gt; seems hard to get acceptance or by in by potential consumers. I would\n&gt; imagine most consumers of apis are expecting xml or json, and to get back\n&gt; html, and have to actually parse it at least to me I&#39;d be questioning why\n&gt; html, which as far as I knew was used to display data in a visual manner, is\n&gt; being sent back for me to parse to use the data in it.\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; --- On *Fri, 12/3/10, mike amundsen &lt;mamund@...&gt;* wrote:\n&gt;\n&gt;\n&gt; From: mike amundsen &lt;mamund@...&gt;\n&gt; Subject: Re: [rest-discuss] Link relations [was: A media type for case\n&gt; files, dossiers and documents]\n&gt; To: &quot;Kevin Duffey&quot; &lt;andjarnic@...&gt;\n&gt; Cc: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;, &quot;Rest Discussion List&quot; &lt;\n&gt; rest-discuss@yahoogroups.com&gt;, juergen.brendel@...\n&gt; Date: Friday, December 3, 2010, 2:08 AM\n&gt;\n&gt;\n&gt; Kevin:\n&gt;\n&gt; I&#39;ve been doing quite a bit of work in the area of making decisions on how\n&gt; to code clients for Internet apps. Your comments about how XHTML seems\n&gt; inappropriate remind me of a set of decisions we all make (consciously or\n&gt; not) about implementing solutions for Internet apps. Here&#39;s a peek into one\n&gt; aspect of my current thinking on this. Hopefully it hits some of teh points\n&gt; to raise and provides some ideas on how you can approach your\n&gt; decision-making.\n&gt;\n&gt; NOTE: I cover some of this in a talk and the slides (and C# code) for that\n&gt; talk are here:http://amundsen.com/talks/#beyond-web20\n&gt;\n&gt; CONSIDERATIONS\n&gt; When coding clients for application-level protocols (HTTP) over distributed\n&gt; networks (i.e. the &quot;Web&quot;), these things (among others) must be taken into\n&gt; account:\n&gt; 1 - how does the client know all the addresses (URIs) that will be needed\n&gt; to execute operations?\n&gt; 2 - how does the client know how to properly construct specific requests\n&gt; (searches, filters, etc.) to send to the addresses?\n&gt; 3 - how does the client &quot;understand&quot; the responses returned from those\n&gt; requests?\n&gt; 4 - how does the client know the order in which these actions\n&gt; (requests/responses) must take place (you can&#39;t create a new order until you\n&gt; create a new customer, you can&#39;t register more than ten pending orders per\n&gt; day, etc.).\n&gt;\n&gt; You have two general approaches:\n&gt; - code these details into the client (non-hypermedia) and re-code the\n&gt; client when the details change or;\n&gt; - code these details into the message (hypermedia) and reformat the message\n&gt; when the details change.\n&gt;\n&gt; A NON-HYPERMEDIA APPROACH:\n&gt; 1 - When coding the client application programmers will get a long list of\n&gt; URIs (from documentation) and hard-code them into the client application or\n&gt; encode the URI list in some static config file, etc. and make that available\n&gt; to the client code. It&#39;s possible that some URI construction rules can be\n&gt; used instead of a static list. Then programmers write code that knows how to\n&gt; execute the construction rules at runtime based on the state of the client,\n&gt; etc. The client application will also have some rules in code in order to\n&gt; associate each fixed/constructed URI w/ some &quot;action&quot; (get a user record,\n&gt; search for users added last week, add a new user, etc.) and the client code\n&gt; will select the proper address at runtime based on the state of the client,\n&gt; etc.\n&gt;\n&gt; 2 - When sending requests from the client to the server (the &quot;actions&quot;\n&gt; mentioned in #1 above), programmers will write code that knows the format\n&gt; details of the message (XML, JSON, CSV, etc), the layout details (XML\n&gt; elements named &quot;email&quot;, &quot;hat-size&quot;, etc.), which elements are required,\n&gt; optional, etc. Programmers will write code that, at runtime, associates\n&gt; client state with each of these &quot;fields&quot;, populates the structures and sends\n&gt; them to the proper URI (from #1).\n&gt;\n&gt; 3 - When receiving responses, client applications know, ahead of time, what\n&gt; to format expect (XML, JSON, etc.), the exact layout of each response\n&gt; (elements and attributes, etc.), and how to render them visually for humans\n&gt; (or arrange the data returned in the proper memory &quot;slots&quot; for M2M apps).\n&gt;\n&gt; 4 - The client application will have all the rules for application flow\n&gt; hard coded. It will &quot;know&quot; that customers cannot have more than ten pending\n&gt; orders or that order detail lines can&#39;t be sent to the server before an\n&gt; order document is created, etc.\n&gt;\n&gt; When using the this approach, changing any of those items over time (new\n&gt; addresses for new requests that return new responses in a\n&gt; new application-flow order) will require re-coding the client and\n&gt; re-deploying that new code to replace all the existing &quot;old&quot; client code.\n&gt;\n&gt; A HYPERMEDIA-DRIVEN APPROACH\n&gt; Using Fielding&#39;s REST style as a guide (&quot;hypermedia as the engine of\n&gt; application state&quot;):\n&gt; 1 - The goal is to reduce the number of addresses to the fewest reasonably\n&gt; possible. One pre-established address is a nice goal - the &quot;starting&quot;\n&gt; address. After that, all other addresses are expected to come in the\n&gt; responses. XHTML has a built-in element for this data - the anchor (&lt;a ...\n&gt; /&gt;) tag.\n&gt;\n&gt; 2 - The information about what fields to use when crafting a request are\n&gt; contained in the responses to requests, not hard-coded in the client\n&gt; application. XHTML has built-in elements for this, too. FORMs w/ INPUT,\n&gt; SELECT, and TEXTAREA elements. Clients know ahead of time how to handle each\n&gt; of these elements; they are universal for all types of requests (for users,\n&gt; customers, stores, orders, etc.). Also, the FORM element has the associated\n&gt; URI for this action when the client receives the response so there is no\n&gt; need to hard-code any other URIs in the client, either.\n&gt;\n&gt; 3 - The information about what fields & layouts to expect in responses and\n&gt; how to &quot;render&quot; them is also included in XHTML. Like the FORM elements,\n&gt; response elements are generic and of a limited set. Clients to do not need\n&gt; to know a set of specific data elements (&lt;email /&gt;, &lt;hat-size /&gt;, etc.) and\n&gt; when to expect them and how to render them. Instead, client code is written\n&gt; to know how to render the generic set of elements (DL, DT, DD, DIV, SPAN,\n&gt; TABLE, etc) in a response.\n&gt;\n&gt; 4 - The responses carry the &quot;next possible steps&quot; for the application flow.\n&gt; XHTML elements such as &lt;a /&gt; and &lt;form /&gt; will appear when it&#39;s appropriate\n&gt; (the response to create order will have links/controls to create order\n&gt; lines, once ten pending orders are created for a customer, the response will\n&gt; no longer in include a &quot;create pending order&quot; link, etc.).\n&gt;\n&gt; When using the second approach, new addresses for new requests that return\n&gt; new responses w/ new app-flow details will not require changing the client\n&gt; code. Because all that information is included in the responses; the media\n&gt; type (XHTML) has &quot;affordances&quot; for carrying that application control\n&gt; information (&lt;a /&gt;, &lt;form /&gt;, etc.) within the responses.  XHTML has an\n&gt; advantage due to it&#39;s built-in hypermedia controls. XML and JSON do not have\n&gt; these.\n&gt;\n&gt; CHOOSING WHICH APPROACH TO USE\n&gt; Now, it may turn out that you are creating an application that:\n&gt; 1) has only one address\n&gt; 2) has only one request format\n&gt; 3) has only one response format\n&gt; 4) has only one possible application flow\n&gt;\n&gt; If that&#39;s the case, you don&#39;t need the advantages that a hypermedia-driven\n&gt; implementation affords; all that work may be overkill and waste. Using a\n&gt; non-hypermedia format (e.g. CSV, XML, JSON, etc.) and hard-coding the\n&gt; details in the client will work much better with less overall effort.\n&gt;\n&gt; Or, you may have a small set of addresses, or a small set of request\n&gt; formats, or a small set of response formats, or a small set of app-flows.\n&gt; Now you need to think a bit more on whether your varying set of addresses,\n&gt; request and response formats, and app-flows are numerous enough to make it\n&gt; worth while to adopt a hypermedia-driven implementation or stick to\n&gt; hard-coding clients.\n&gt;\n&gt; Or you may have an application where, even w/ a wide range of address,\n&gt; requests, responses, and app-flows, these values hardly change over the life\n&gt; of the application (days, weeks, years, etc.). Does it make sense to use a\n&gt; hypermedia-driven implementation if the formats never change?\n&gt;\n&gt; Or you may be the only one writing the client. Just like it&#39;s often more\n&gt; effort to document a simple app than build it, using a hypermedia-driven\n&gt; implementation in order to never change the code that you yourself could\n&gt; write more quickly and efficiently anyway may be too much effort for the\n&gt; return.\n&gt;\n&gt; So,,,\n&gt; _When_ you choose one approach over the other is entirely up to you based\n&gt; on your particular constraints (time, money, complexity of the app, variance\n&gt; of the app over time, etc.). But if you _do_ choose a hypermedia-driven\n&gt; approach,you&#39;ll want to use an existing hypermedia type (XHTML) or design\n&gt; and implement your own custom hypermedia type.\n&gt;\n&gt; Hope that ramble helps.\n&gt;\n&gt; mca\n&gt; http://amundsen.com/blog/\n&gt; http://twitter.com@mamund\n&gt; http://mamund.com/foaf.rdf#me\n&gt;\n&gt;\n&gt; #RESTFest 2010\n&gt; http://rest-fest.googlecode.com\n&gt;\n&gt;\n&gt;\n&gt; On Fri, Dec 3, 2010 at 02:54, Kevin Duffey &lt;andjarnic@...&lt;http://mc/compose?to=andjarnic@...&gt;\n&gt; &gt; wrote:\n&gt;\n&gt;\n&gt;\n&gt; I get everything you are saying..finally thanks to a few of you that set me\n&gt; clear on this whole media-type issue.\n&gt;\n&gt; I am however having a hard time thinking about telling clients that they\n&gt; basically need to parse html to use my API. I much rather say &quot;for /orders,\n&gt; you get this chunk of xml back with these potential elements.. parse it to\n&gt; get the data you need&quot;. Or in JSON. As I use Java/JAX-RS with Jersey, it\n&gt; handles automatically turning my objects into either xml or json, whatever\n&gt; the Accept header specifies. Anyway, for my own learning, it is good to know\n&gt; what you said, and it does make sense. However, it seems odd to me to return\n&gt; things in HTML as opposed to xml or json, when it&#39;s just chunks.. that is, a\n&gt; user places 100 orders over 3 months, then comes in and asks to see a\n&gt; history of orders. I return an xml chunk with their 100 orders and related\n&gt; info. That seems perfectly fine to provide in xml or json, allowing any\n&gt; client to parse the response as they see fit. I would obviously have some\n&gt; sort of api doc that would explain the response.\n&gt;\n&gt; I guess what I am grappling with is that for the most part, I would suspect\n&gt; most services like the one I am messing around with to learn, would be used\n&gt; by specific clients, not anyone and everyone out on the web. More so, I\n&gt; don&#39;t see anyone needing to use my particular bits of data I return for\n&gt; their own use.. that is, if I were to register a media type that represents\n&gt; a generic ordering document, that might make sense, but in my case, if I am\n&gt; building up a REST api for my specific little service, it doesn&#39;t seem like\n&gt; returning HTML would make any more sense than returning xml or json. I\n&gt; certainly can see if I was building my own web site, where I have some\n&gt; javascript make ajax requests and I return a chunk of HTML instead of XML or\n&gt; JSON, so that my own site consuming my API can benefit from having HTML\n&gt; directly, rather than xml or json then have to build up the html on the fly\n&gt; in the browser. But for say a mobile app that had a native client that\n&gt; allowed a user to log in and pull up their recent orders, a chunk of XML\n&gt; would fit well. HTML seems more difficult to have to parse and deal with..\n&gt; at least the way I think. Again, if I were going to display it in a\n&gt; browser..maybe it&#39;s fine, but if I wanted to do something with the data\n&gt; before displaying it or maybe it&#39;s not a web browser at all, html seems out\n&gt; of place. That&#39;s just my opinion tho from the bits I&#39;ve learned the past few\n&gt; days.\n&gt;\n&gt;\n&gt;\n&gt; --- On *Thu, 12/2/10, Eric J. Bowman &lt;eric@...&lt;http://mc/compose?to=eric@...&gt;\n&gt; &gt;* wrote:\n&gt;\n&gt;\n&gt; From: Eric J. Bowman &lt;eric@...&lt;http://mc/compose?to=eric@...&gt;\n&gt; &gt;\n&gt; Subject: Re: [rest-discuss] Link relations [was: A media type for case\n&gt; files, dossiers and documents]\n&gt; To: &quot;Kevin Duffey&quot; &lt;andjarnic@...&lt;http://mc/compose?to=andjarnic@...&gt;\n&gt; &gt;\n&gt; Cc: &quot;Rest Discussion List&quot; &lt;rest-discuss@yahoogroups.com&lt;http://mc/compose?to=rest-discuss@yahoogroups.com&gt;&gt;,\n&gt; juergen.brendel@...&lt;http://mc/compose?to=juergen.brendel@...&gt;\n&gt; Date: Thursday, December 2, 2010, 10:32 PM\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; Kevin Duffey wrote:\n&gt; &gt;\n&gt; &gt; Valid point. I am not sure what media type would fit then. I am\n&gt; &gt; trying to follow the HATEOS design, I have an entry point that\n&gt; &gt; returns some links based on credentials, from there a client would\n&gt; &gt; use those to make calls to any of my resources, and each response\n&gt; &gt; would return a relevant chunk of XML or JSON with links for each\n&gt; &gt; resource accessible at that point (for example GET /orders/id would\n&gt; &gt; return a specific order along with one or more links that can be used\n&gt; &gt; to operate on the order).\n&gt; &gt;\n&gt;\n&gt; I&#39;ve never seen an order-processing system that couldn&#39;t be modeled as\n&gt; HTML. In fact, I&#39;ve rarely seen an order-processing system that wasn&#39;t\n&gt; HTML. In OOP terminology, the goal is to distribute not your objects,\n&gt; but your object interfaces. REST says, make those object interfaces\n&gt; uniform. Which means participants have a network-based shared\n&gt; understanding of your state transitions (links, forms), IOW, a self-\n&gt; documenting API.\n&gt;\n&gt; It&#39;s perfectly acceptable to model your data as JSON or as XML (bearing\n&gt; in mind that schemas are an orthogonal concern). The trick is to\n&gt; create an HTML interface for either JSON or XML data, which instructs\n&gt; user-agents how to interact with that data. I&#39;d choose either JSON or\n&gt; XML, instead of trying to do both, depending on whether you&#39;re more\n&gt; comfortable transforming that data into HTML using Javascript or XSLT.\n&gt;\n&gt; &gt;\n&gt; &gt; So if I use application/xml, my API would not be considered truly\n&gt; &gt; RESTful?\n&gt; &gt;\n&gt;\n&gt; No, not if you&#39;re using application/xml as the hypertext engine driving\n&gt; application state. If it&#39;s just a snippet of XML which gets read by,\n&gt; say, an HTML front-end driving application state, then it&#39;s OK because\n&gt; the processing model (parse as XML, handling XInclude/XLink/rdf:about)\n&gt; is adequate to the task. If that XML snippet contains URIs the user is\n&gt; supposed to click on to transition the application to the next steady-\n&gt; state (which aren&#39;t XLinks), well, that&#39;s what &lt;a&gt; and atom:link are\n&gt; for, there&#39;s no corollary in application/xml (besides XLink).\n&gt;\n&gt; Also, most order forms are simply tabular data, the semantics of which\n&gt; don&#39;t exist in application/xml like they do in application/xhtml+xml or\n&gt; text/html with &lt;table&gt;. Same with lists, same with forms.\n&gt;\n&gt; &gt;\n&gt; &gt; So now I&#39;ll ask, what media type I could possibly use with my own\n&gt; &gt; xml/json structure? It almost sounds like you&#39;re saying I shouldn&#39;t\n&gt; &gt; be returning my own made up structure, that I should instead use an\n&gt; &gt; existing media type, like one with xhtml or something. Is there a\n&gt; &gt; media type that allows for any sort of specific format to a domain to\n&gt; &gt; be returned? Or does that now fall into a case where I should create\n&gt; &gt; my own media type and register it with IANA?\n&gt; &gt;\n&gt;\n&gt; It falls into a case where you should refactor. You have tabular data,\n&gt; so you need to choose a data type which expresses such semantics (i.e.\n&gt; HTML, or DocBook). The whole point of media types is that they are\n&gt; _not_ domain-specific, but rather, represent a shared understanding of\n&gt; a processing model at the network (IP) layer. This is the fundamental\n&gt; tradeoff of the style:\n&gt;\n&gt; &quot;[A] uniform interface degrades efficiency, since information is\n&gt; transferred in a standardized form rather than one which is specific to\n&gt; an application&#39;s needs.&quot;\n&gt;\n&gt; An order consists of item numbers, descriptions, quantity, unit price\n&gt; and total price. You *could* re-invent the &lt;table&gt; wheel and register\n&gt; it as a new media type, but it&#39;s more scalable (maintainable, portable)\n&gt; to re-use HTML even if it isn&#39;t a precise fit. If you create a new\n&gt; media type, then you need to distribute a custom user-agent. When you\n&gt; upgrade your API, you must simultaneously update that user-agent.\n&gt;\n&gt; The success of the Web is due to the common user-agent. What I really\n&gt; don&#39;t want, is for any system I interact with to require me to install\n&gt; yet another piece of software, and keep it up-to-date. That&#39;s coupling.\n&gt; So much easier for everyone concerned, to target the browser. That way,\n&gt; I only need to install and maintain one user-agent regardless of how\n&gt; many different systems I interact with. Such decoupling allows clients\n&gt; and servers to evolve independently. So there is a cost associated\n&gt; with the minting of new media types -- coupling -- unless and until the\n&gt; new media type achieves significant uptake.\n&gt;\n&gt; -Eric\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; \n&gt;\n\r\n--20cf3054a203fb411a04968374e6\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nKevin:&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Glad the post helped.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&l=\r\nt;snip&gt;&lt;/div&gt;&lt;meta http-equiv=3D&quot;content-type&quot; content=3D&quot;text/html; cha=\r\nrset=3Dutf-8&quot;&gt;&lt;div&gt;&lt;span class=3D&quot;Apple-style-span&quot; style=3D&quot;font-family: a=\r\nrial, sans-serif; font-size: 13px; &quot;&gt;What I am having a hard time swallowin=\r\ng is providing an API that returns data as HTML. I think it&#39;s going to =\r\nbe hard to go out there and tell consumers, &quot;here is my api, which ret=\r\nurns HTML, but not for visual use.. you have to parse the HTML yourself, ev=\r\nen though your not a browser.. you&#39;re going to become a browser basical=\r\nly, in order to use my api&quot;. This just seems hard to get acceptance or=\r\n by in by potential consumers. I would imagine most consumers of apis are e=\r\nxpecting xml or json, and to get back html, and have to actually parse it a=\r\nt least to me I&#39;d be questioning why html, which as far as I knew was u=\r\nsed to display data in a visual manner, is being sent back for me to parse =\r\nto use the data in it.&lt;/span&gt;=A0&lt;/div&gt;\n&lt;div&gt;&lt;/snip&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/d=\r\niv&gt;&lt;div&gt;If you don&#39;t like [X]HTML, you don&#39;t have to use it. You;ll=\r\n note in my slides (from the previous post), I don&#39;t use XHTML, I use a=\r\n custom media type built using XML as the format; could have been JSON, or =\r\nsome other format, too. =A0The value of XHTML is not in DIV, SPAN, etc. it&=\r\n#39;s in A, FORM, etc. =A0Use XForms and XInclude and you get the same basi=\r\nc functionality. =A0Don&#39;t like XForms? design your own hypermedia contr=\r\nols to handle navigation links, query templates, and idempotent &amp; non-i=\r\ndempotent &quot;send&quot; operations and you have all the application cont=\r\nrols you need.&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Fielding, himself stated that hype=\r\nrmedia does not require HTML:&lt;/div&gt;&lt;div&gt;&lt;font class=3D&quot;Apple-style-span&quot; fa=\r\nce=3D&quot;arial, helvetica, sans-serif&quot;&gt;&quot;Hypertext does not need to be HTM=\r\nL on a browser; machines can follow links when they understand the data for=\r\nmat and relationship types&quot;[1]&lt;/font&gt;&lt;/div&gt;\n&lt;div&gt;&lt;font class=3D&quot;Apple-=\r\nstyle-span&quot; face=3D&quot;arial, helvetica, sans-serif&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;fo=\r\nnt class=3D&quot;Apple-style-span&quot; face=3D&quot;arial, helvetica, sans-serif&quot;&gt;You see=\r\n lots of talk about XHTML here because it is well-known&#92;understood, and =A0=\r\nhas all the &quot;bits&quot; needed in a media type to support hypermedia-d=\r\nriven applications in the style Roy calls REST. This is the same reason you=\r\n see lots of talk here about HTTP;=A0because=A0it has all the bits needed i=\r\nn a app-level protocol to support the REST style. =A0Neither are _required_=\r\n, they are very well-suited for Roy&#39;s style.&lt;/font&gt;&lt;/div&gt;\n&lt;div&gt;&lt;font cl=\r\nass=3D&quot;Apple-style-span&quot; face=3D&quot;arial, helvetica, sans-serif&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;=\r\n/div&gt;&lt;div&gt;&lt;font class=3D&quot;Apple-style-span&quot; face=3D&quot;arial, helvetica, sans-s=\r\nerif&quot;&gt;Hope that clears&lt;/font&gt;&lt;/div&gt;&lt;meta http-equiv=3D&quot;content-type&quot; conten=\r\nt=3D&quot;text/html; charset=3Dutf-8&quot;&gt;&lt;div&gt;\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;[1]&lt;a href=3D&quot;http://=\r\nwww.slideshare.net/royfielding/a-little-rest-and-relaxation&quot;&gt;http://www.sli=\r\ndeshare.net/royfielding/a-little-rest-and-relaxation&lt;/a&gt; (see slide #50)=A0=\r\n&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br clear=3D&quot;all&quot;&gt;\nmca&lt;br&gt;&lt;a href=3D&quot;http://=\r\namundsen.com/blog/&quot; target=3D&quot;_blank&quot;&gt;http://amundsen.com/blog/&lt;/a&gt;&lt;br&gt;&lt;a h=\r\nref=3D&quot;http://twitter.com&quot; target=3D&quot;_blank&quot;&gt;http://twitter.com&lt;/a&gt;@mamund&lt;=\r\nbr&gt;&lt;a href=3D&quot;http://mamund.com/foaf.rdf#me&quot; target=3D&quot;_blank&quot;&gt;http://mamun=\r\nd.com/foaf.rdf#me&lt;/a&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;#RESTFest 2010 &lt;br&gt;&lt;a href=3D&quot;http://rest=\r\n-fest.googlecode.com&quot; target=3D&quot;_blank&quot;&gt;http://rest-fest.googlecode.com&lt;/a&gt;=\r\n&lt;br&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;&lt;div class=3D&quot;gmail_quote&quot;&gt;On Fri, Dec 3, 2010 at 10:27, K=\r\nevin Duffey &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a href=3D&quot;mailto:andjarnic@...&quot;&gt;an=\r\ndjarnic@...&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;blockquote class=3D&quot;gmail_quote=\r\n&quot; style=3D&quot;margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex;&quot;&gt;=\r\n\n\n\n\n\n\n\n\n        \n\n\n\n\n&lt;div&gt;\n\n\n\n\n\n&lt;br&gt;&lt;br&gt;\n\n\n\n\n&lt;table cellspacing=3D&quot;0&quot; cellp=\r\nadding=3D&quot;0&quot; border=3D&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=3D&quot;top&quot; style=3D&quot;font:inher=\r\nit&quot;&gt;Mike, a most excellent response.. very well said, again I have a better=\r\n understanding of all this thanks to you and Eric.&lt;br&gt;\n&lt;br&gt;Here I thought I=\r\n was implementing HATEOAS by providing links back in my response and a sing=\r\nle entry point for all consumers to initiate their communication with my ap=\r\ni. &lt;br&gt;&lt;br&gt;I totally get the concept of an evolving api breaking clients. B=\r\necause of that, it was my impression that providing versions of your api pr=\r\nevent that, at least to some degree. Clients using v1, continue to use v1 u=\r\nntil they are ready to be written to use v2, or..they just stay on v1. Like=\r\n most software that adheres to major version changes as major feature chang=\r\nes, a v2 would be something probably quite a bit different.. different resp=\r\nonse formats, perhaps... but by using links in the responses, I can, from m=\r\ny api, direct clients to new resources if need be.\n Perhaps the old /orders=\r\n is no longer valid.. we have a /neworders to handle all kinds of new data.=\r\n Since all the clients use the links elements to navigate based on the rel=\r\n=3D&quot;&quot; value, they shouldn&#39;t break, that I know of. Well.. to =\r\nbe fair, if the response format changes, then yes, they would break.. but i=\r\nf you keep the response format the same but modify the resources called via=\r\n the links, then the clients will &quot;evolve&quot; with the api automatic=\r\nally. &lt;br&gt;\n&lt;br&gt;What I am having a hard time swallowing is providing an API =\r\nthat returns data as HTML. I think it&#39;s going to be hard to go out ther=\r\ne and tell consumers, &quot;here is my api, which returns HTML, but not for=\r\n visual use.. you have to parse the HTML yourself, even though your not a b=\r\nrowser.. you&#39;re going to become a browser basically, in order to use my=\r\n api&quot;. This just seems hard to get acceptance or by in by potential co=\r\nnsumers. I would imagine most consumers of apis are expecting xml or json, =\r\nand to get back\n html, and have to actually parse it at least to me I&#39;d=\r\n be questioning why html, which as far as I knew was used to display data i=\r\nn a visual manner, is being sent back for me to parse to use the data in it=\r\n.&lt;div class=3D&quot;im&quot;&gt;\n&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;--- On &lt;b&gt;Fri, 12/3/10, mike amundsen &lt;=\r\ni&gt;&lt;&lt;a href=3D&quot;mailto:mamund@...&quot; target=3D&quot;_blank&quot;&gt;mamund@...=\r\nm&lt;/a&gt;&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;br&gt;&lt;/div&gt;&lt;blockquote style=3D&quot;border-left:2px soli=\r\nd rgb(16, 16, 255);margin-left:5px;padding-left:5px&quot;&gt;\n&lt;div class=3D&quot;im&quot;&gt;&lt;br=\r\n&gt;From: mike amundsen &lt;&lt;a href=3D&quot;mailto:mamund@...&quot; target=3D&quot;_bla=\r\nnk&quot;&gt;mamund@...&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;&lt;div class=3D&quot;im&quot;&gt;Subject: Re: [rest-=\r\ndiscuss] Link relations [was: A media type for case files, dossiers and doc=\r\numents]&lt;br&gt;\nTo: &quot;Kevin Duffey&quot; &lt;&lt;a href=3D&quot;mailto:andjarnic@ya=\r\nhoo.com&quot; target=3D&quot;_blank&quot;&gt;andjarnic@...&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;Cc: &quot;E=\r\nric J. Bowman&quot; &lt;&lt;a href=3D&quot;mailto:eric@...&quot; target=3D&quot;=\r\n_blank&quot;&gt;eric@...&lt;/a&gt;&gt;, &quot;Rest Discussion List&quot; &lt=\r\n;&lt;a href=3D&quot;mailto:rest-discuss@yahoogroups.com&quot; target=3D&quot;_blank&quot;&gt;rest-dis=\r\ncuss@yahoogroups.com&lt;/a&gt;&gt;, &lt;a href=3D&quot;mailto:juergen.brendel@...=\r\nm&quot; target=3D&quot;_blank&quot;&gt;juergen.brendel@...&lt;/a&gt;&lt;br&gt;\nDate: Friday, Dec=\r\nember 3, 2010, 2:08 AM&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=3D&quot;h5&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;&lt;div&gt;K=\r\nevin:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I&#39;ve been doing quite a bit of work in t=\r\nhe area of making decisions on how to code clients for Internet\n apps. Your=\r\n comments about how XHTML seems inappropriate remind me of a set of decisio=\r\nns we all make (consciously=A0or not) about implementing solutions for Inte=\r\nrnet apps. Here&#39;s a peek into one aspect of my current thinking on this=\r\n. Hopefully it hits some of teh points to raise and provides some ideas on =\r\nhow you can approach your decision-making.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;NOTE:=\r\n I cover some of this in a talk and the slides (and C# code) for that talk =\r\nare here:&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;http://amundsen.com/talks/#beyond-web2=\r\n0&quot; target=3D&quot;_blank&quot;&gt;http://amundsen.com/talks/#beyond-web20&lt;/a&gt;=A0=A0&lt;/div=\r\n&gt;\n&lt;div&gt;\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;CONSIDERATIONS&lt;/div&gt;&lt;div&gt;When coding clients for app=\r\nlication-level protocols (HTTP) over distributed networks (i.e. the &quot;W=\r\neb&quot;), these things (among others) must be taken into account:&lt;/div&gt;\n&lt;d=\r\niv&gt;1 - how does the client know all the addresses (URIs) that will be neede=\r\nd to execute operations? =A0&lt;/div&gt;&lt;div&gt;2 - how does the client know how to =\r\nproperly construct specific requests (searches, filters, etc.) to send to t=\r\nhe addresses?&lt;/div&gt;\n\n\n&lt;div&gt;3 - how does the client &quot;understand&quot; t=\r\nhe responses returned from those requests?&lt;/div&gt;&lt;div&gt;4 - how does the clien=\r\nt know the order in which these actions (requests/responses) must take plac=\r\ne (you can&#39;t create a new order until you create a new customer, you ca=\r\nn&#39;t register more than ten pending orders per day, etc.).&lt;/div&gt;\n\n\n&lt;div&gt;=\r\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;You have two general approaches:=A0&lt;/div&gt;&lt;div&gt;- code th=\r\nese details into the client (non-hypermedia) and re-code the client when th=\r\ne details change or;&lt;/div&gt;\n&lt;div&gt;- code these details into the message (hype=\r\nrmedia) and reformat the message when the details change.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;=\r\nbr&gt;&lt;/div&gt;&lt;div&gt;A NON-HYPERMEDIA APPROACH:&lt;/div&gt;&lt;div&gt;1 - When coding the clie=\r\nnt application programmers will get a long list of URIs (from documentation=\r\n) and hard-code them into the client application or encode the URI list in =\r\nsome static config file, etc. and make that available to the client code. I=\r\nt&#39;s possible that some URI construction rules can be used instead of a =\r\nstatic list. Then programmers write code that knows how to execute the cons=\r\ntruction rules at runtime based on the state of the client, etc. The client=\r\n application will also have some rules in code in order to associate each f=\r\nixed/constructed URI w/ some &quot;action&quot; (get a user record, search =\r\nfor users added last week, add a new user, etc.) and the client code will s=\r\nelect the proper address at runtime based on the state of the client, etc.&lt;=\r\n/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - When sending requests from the client to th=\r\ne server (the &quot;actions&quot; mentioned in #1 above), programmers will =\r\nwrite code that knows the format details of the message (XML, JSON, CSV, et=\r\nc), the layout details (XML elements named &quot;email&quot;, &quot;hat-siz=\r\ne&quot;, etc.), which elements are required, optional, etc. Programmers wil=\r\nl write code that, at runtime, associates client state with each of these &=\r\nquot;fields&quot;, populates the structures and sends them to the proper UR=\r\nI (from #1).&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3 - When=A0receiving=A0responses, =\r\nclient applications know, ahead of time, what to format expect (XML, JSON, =\r\netc.), the exact layout of each response (elements and attributes, etc.), a=\r\nnd how to render them visually for humans (or arrange the data returned in =\r\nthe proper memory &quot;slots&quot; for M2M apps).=A0&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/di=\r\nv&gt;&lt;div&gt;4 - The client application will have all the rules for application f=\r\nlow hard coded. It will &quot;know&quot; that customers cannot have more th=\r\nan ten pending orders or that order detail lines can&#39;t be sent to the s=\r\nerver before an order document is created, etc.&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div=\r\n&gt;When using the this approach, changing any of those items over time (new a=\r\nddresses for new requests that return new responses in a new=A0application-=\r\nflow order) will require re-coding the client and re-deploying that new cod=\r\ne to replace all the existing &quot;old&quot; client code.&lt;/div&gt;\n\n\n&lt;div&gt;=A0=\r\n&lt;/div&gt;&lt;div&gt;A HYPERMEDIA-DRIVEN APPROACH&lt;/div&gt;&lt;div&gt;Using Fielding&#39;s REST=\r\n style as a guide (&quot;hypermedia as the engine of application state&quot=\r\n;):&lt;/div&gt;&lt;div&gt;1 - The goal is to reduce the number of addresses to the fewe=\r\nst reasonably possible. One pre-established address is a nice goal - the &q=\r\nuot;starting&quot; address. After that, all other addresses are expected to=\r\n come in the responses. XHTML has a built-in element for this data - the an=\r\nchor (&lt;a ... /&gt;) tag.=A0&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - The informat=\r\nion about what fields to use when crafting a request are contained in the r=\r\nesponses to requests, not hard-coded in the client application. XHTML has b=\r\nuilt-in elements for this, too. FORMs w/ INPUT, SELECT, and TEXTAREA elemen=\r\nts. Clients know ahead of time how to handle each of these elements; they a=\r\nre universal for all types of requests (for users, customers, stores, order=\r\ns, etc.). Also, the FORM element has the associated URI for this action whe=\r\nn the client=A0receives=A0the response so there is no need to hard-code any=\r\n other URIs in the client, either.&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3 - The info=\r\nrmation about what fields &amp; layouts to expect in responses and how to &=\r\nquot;render&quot; them is also included in XHTML. Like the FORM elements, r=\r\nesponse elements are generic and of a limited set. Clients to do not need t=\r\no know a set of specific data elements (&lt;email /&gt;, &lt;hat-size /&gt;=\r\n, etc.) and when to expect them and how to render them. Instead, client cod=\r\ne is written to know how to render the generic set of elements (DL, DT, DD,=\r\n DIV, SPAN, TABLE, etc) in a response.&lt;/div&gt;\n\n\n&lt;div&gt;=A0&lt;/div&gt;&lt;div&gt;4 - The r=\r\nesponses carry the &quot;next possible steps&quot; for the application flow=\r\n. XHTML elements such as &lt;a /&gt; and &lt;form /&gt; will appear when it=\r\n&#39;s appropriate (the response to create order will have links/controls t=\r\no create order lines, once ten pending orders are created for a customer, t=\r\nhe response will no longer in include a &quot;create pending order&quot; li=\r\nnk, etc.).&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;When using the second approach, new =\r\naddresses for new requests that return new responses w/ new app-flow=A0deta=\r\nils=A0will not require changing the client code. Because all that informati=\r\non is included in the responses; the media type (XHTML) has &quot;affordanc=\r\nes&quot; for carrying that application control information (&lt;a /&gt;, &l=\r\nt;form /&gt;, etc.) within the responses. =A0XHTML has an advantage due to =\r\nit&#39;s built-in hypermedia controls. XML and JSON do not have these.=A0&lt;/=\r\ndiv&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CHOOSING WHICH APPROACH TO USE&lt;/div&gt;&lt;div&gt;Now, it=\r\n may turn out that you are creating an=A0application=A0that:&lt;/div&gt;&lt;div&gt;1) h=\r\nas only one address&lt;/div&gt;&lt;div&gt;2) has only one request format&lt;/div&gt;&lt;div&gt;3) h=\r\nas only one response format&lt;/div&gt;\n\n&lt;div&gt;4) has only one possible applicatio=\r\nn flow&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If that&#39;s the case, you don&#39;t need=\r\n the advantages that a hypermedia-driven implementation affords; all that w=\r\nork may be overkill and waste. Using a non-hypermedia format (e.g. CSV, XML=\r\n, JSON, etc.) and hard-coding the details in the client will work much bett=\r\ner with less overall effort.&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or, you may have a=\r\n small set of addresses, or a small set of request formats, or a small set =\r\nof response formats, or a small set of app-flows. Now you need to think a b=\r\nit more on whether your varying set of addresses, request and response form=\r\nats, and app-flows are numerous enough to make it worth while to adopt a hy=\r\npermedia-driven implementation or stick to hard-coding clients.&lt;/div&gt;\n\n\n&lt;di=\r\nv&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or you may have an application where, even w/ a wide range=\r\n of address, requests, responses, and app-flows, these values hardly change=\r\n over the life of the application (days, weeks, years, etc.). Does it make =\r\nsense to use a hypermedia-driven implementation if the formats never change=\r\n?&lt;/div&gt;\n\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or you may be the only one writing the client=\r\n. Just like it&#39;s often more effort to document a simple app than build =\r\nit, using a hypermedia-driven implementation in order to never change the c=\r\node that you yourself could write more quickly and efficiently anyway may b=\r\ne too much effort for the return.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;So,,,&lt;/div&gt;&lt;di=\r\nv&gt;_When_ you choose one approach over the other is entirely up to you based=\r\n on your particular constraints (time, money, complexity of the app, varian=\r\nce of the app over time, etc.). But if you _do_ choose a hypermedia-driven =\r\napproach,you&#39;ll want to use an existing hypermedia type (XHTML) or desi=\r\ngn and implement your own custom hypermedia type.&lt;/div&gt;\n\n&lt;div&gt;=A0=A0=A0&lt;/di=\r\nv&gt;&lt;div&gt;Hope that ramble helps.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;\nmca&lt;/div&gt;&lt;div&gt;&lt;a r=\r\nel=3D&quot;nofollow&quot; href=3D&quot;http://amundsen.com/blog/&quot; target=3D&quot;_blank&quot;&gt;http:/=\r\n/amundsen.com/blog/&lt;/a&gt;&lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;http://twitter.com&quot; =\r\ntarget=3D&quot;_blank&quot;&gt;http://twitter.com&lt;/a&gt;@mamund&lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; href=\r\n=3D&quot;http://mamund.com/foaf.rdf#me&quot; target=3D&quot;_blank&quot;&gt;http://mamund.com/foaf=\r\n.rdf#me&lt;/a&gt;&lt;br&gt;\n\n\n&lt;br&gt;&lt;br&gt;#RESTFest 2010 &lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;ht=\r\ntp://rest-fest.googlecode.com&quot; target=3D&quot;_blank&quot;&gt;http://rest-fest.googlecod=\r\ne.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;&lt;div&gt;On Fri, Dec 3, 2010 at 02:54, Kevin Duffey &lt;=\r\nspan dir=3D&quot;ltr&quot;&gt;&lt;&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;http://mc/compose?to=3Dand=\r\njarnic@...&quot; target=3D&quot;_blank&quot;&gt;andjarnic@...&lt;/a&gt;&gt;&lt;/span&gt; wrot=\r\ne:&lt;br&gt;&lt;blockquote style=3D&quot;margin:0pt 0pt 0pt 0.8ex;border-left:1px solid r=\r\ngb(204, 204, 204);padding-left:1ex&quot;&gt;\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n&lt;div&gt;\n\n\n\n\n\n&lt;br&gt;&lt;=\r\nbr&gt;\n\n\n\n\n&lt;table border=3D&quot;0&quot; cellpadding=3D&quot;0&quot; cellspacing=3D&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;=\r\n&lt;td style=3D&quot;font:inherit&quot; valign=3D&quot;top&quot;&gt;I get everything you are saying..=\r\nfinally thanks to a few of you that set me clear on this whole media-type i=\r\nssue. &lt;br&gt;&lt;br&gt;\n\n\nI am however having a hard time thinking about telling cli=\r\nents that they basically need to parse html to use my API. I much rather sa=\r\ny &quot;for /orders, you get this chunk of xml back with these potential el=\r\nements.. parse it to get the data you need&quot;. Or in JSON. As I use Java=\r\n/JAX-RS with Jersey, it handles automatically turning my objects into eithe=\r\nr xml or json, whatever the Accept header specifies. Anyway, for my own lea=\r\nrning, it is good to know what you said, and it does make sense. However, i=\r\nt seems odd to me to return things in HTML as opposed to xml or json, when =\r\nit&#39;s just chunks.. that is, a user places 100 orders over 3 months, the=\r\nn comes in and asks to see a history of orders. I return an xml chunk with =\r\ntheir 100 orders and related\n info. That seems perfectly fine to provide in=\r\n xml or json, allowing any client to parse the response as they see fit. I =\r\nwould obviously have some sort of api doc that would explain the response. =\r\n&lt;br&gt;&lt;br&gt;I guess what I am grappling with is that for the most part, I would=\r\n suspect most services like the one I am messing around with to learn, woul=\r\nd be used by specific clients, not anyone and everyone out on the web. More=\r\n so, I don&#39;t see anyone needing to use my particular bits of data I ret=\r\nurn for their own use.. that is, if I were to register a media type that re=\r\npresents a generic ordering document, that might make sense, but in my case=\r\n, if I am building up a REST api for my specific little service, it doesn&#=\r\n39;t seem like returning HTML would make any more sense than returning xml =\r\nor json. I certainly can see if I was building my own web site, where I hav=\r\ne some javascript make ajax requests and I return a chunk of HTML instead o=\r\nf XML or JSON, so that my own\n site consuming my API can benefit from havin=\r\ng HTML directly, rather than xml or json then have to build up the html on =\r\nthe fly in the browser. But for say a mobile app that had a native client t=\r\nhat allowed a user to log in and pull up their recent orders, a chunk of XM=\r\nL would fit well. HTML seems more difficult to have to parse and deal with.=\r\n. at least the way I think. Again, if I were going to display it in a brows=\r\ner..maybe it&#39;s fine, but if I wanted to do something with the data befo=\r\nre displaying it or maybe it&#39;s not a web browser at all, html seems out=\r\n of place. That&#39;s just my opinion tho from the bits I&#39;ve learned th=\r\ne past few days.&lt;div&gt;\n\n\n&lt;br&gt;&lt;br&gt;&lt;br&gt;--- On &lt;b&gt;Thu, 12/2/10, Eric J. Bowman =\r\n&lt;i&gt;&lt;&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;http://mc/compose?to=3Deric@bisonsystems=\r\n.net&quot; target=3D&quot;_blank&quot;&gt;eric@...&lt;/a&gt;&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;br&gt;&lt;/d=\r\niv&gt;&lt;blockquote style=3D&quot;border-left:2px solid rgb(16, 16, 255);margin-left:=\r\n5px;padding-left:5px&quot;&gt;\n\n\n&lt;div&gt;&lt;br&gt;From: Eric J. Bowman &lt;&lt;a rel=3D&quot;nofoll=\r\now&quot; href=3D&quot;http://mc/compose?to=3Deric@...&quot; target=3D&quot;_blank&quot;=\r\n&gt;eric@...&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Subject: Re: [rest-discuss] Li=\r\nnk relations [was: A media type for\n case files, dossiers and documents]&lt;br=\r\n&gt;&lt;/div&gt;&lt;div&gt;To: &quot;Kevin Duffey&quot; &lt;&lt;a rel=3D&quot;nofollow&quot; href=3D&quot;ht=\r\ntp://mc/compose?to=3Dandjarnic@...&quot; target=3D&quot;_blank&quot;&gt;andjarnic@yahoo=\r\n.com&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;Cc: &quot;Rest Discussion List&quot; &lt;&lt;a rel=3D&quot;no=\r\nfollow&quot; href=3D&quot;http://mc/compose?to=3Drest-discuss@yahoogroups.com&quot; target=\r\n=3D&quot;_blank&quot;&gt;rest-discuss@yahoogroups.com&lt;/a&gt;&gt;, &lt;a rel=3D&quot;nofollow&quot; href=\r\n=3D&quot;http://mc/compose?to=3Djuergen.brendel@...&quot; target=3D&quot;_blank&quot;&gt;=\r\njuergen.brendel@...&lt;/a&gt;&lt;br&gt;\n\n\nDate: Thursday, December 2, 2010, 10=\r\n:32 PM&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;\n\n\n\n\n\n&lt;span&gt;=A0&lt;/span&gt;\n\n\n\n    &lt;div&gt;=\r\n\n      \n      \n      &lt;p&gt;Kevin Duffey wrote:&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Valid point.=\r\n I am not sure what media type would fit then. I am&lt;br&gt;\n&gt; trying to foll=\r\now the HATEOS design, I have an entry point that&lt;br&gt;\n&gt; returns some link=\r\ns based on credentials, from there a client would&lt;br&gt;\n&gt; use those to mak=\r\ne calls to any of my resources, and each response&lt;br&gt;\n&gt; would return a r=\r\nelevant chunk of XML or JSON with links for each&lt;br&gt;\n&gt; resource accessib=\r\nle at that point (for example GET /orders/id would&lt;br&gt;\n&gt; return a specif=\r\nic order along with one or more links that can be used&lt;br&gt;\n&gt; to operate =\r\non the order). &lt;br&gt;\n&gt;&lt;br&gt;\n&lt;br&gt;\nI&#39;ve never seen an order-processing s=\r\nystem that couldn&#39;t be modeled as&lt;br&gt;\nHTML.  In fact, I&#39;ve rarely s=\r\neen an order-processing system that wasn&#39;t&lt;br&gt;\nHTML.  In OOP terminolog=\r\ny, the goal is to distribute not your objects,&lt;br&gt;\nbut your object interfac=\r\nes.  REST says, make those object interfaces&lt;br&gt;\nuniform.  Which means part=\r\nicipants have a network-based shared&lt;br&gt;\nunderstanding of your state transi=\r\ntions (links, forms), IOW, a self-&lt;br&gt;\ndocumenting API.&lt;br&gt;\n&lt;br&gt;\nIt&#39;s p=\r\nerfectly acceptable to model your data as JSON or as XML (bearing&lt;br&gt;\nin mi=\r\nnd that schemas are an orthogonal concern).  The trick is to&lt;br&gt;\ncreate an =\r\nHTML interface for either JSON or XML data, which instructs&lt;br&gt;\nuser-agents=\r\n how to interact with that data.  I&#39;d choose either JSON or&lt;br&gt;\nXML, in=\r\nstead of trying to do both, depending on whether you&#39;re more&lt;br&gt;\ncomfor=\r\ntable transforming that data into HTML using Javascript or XSLT.&lt;br&gt;\n&lt;br&gt;\n&=\r\ngt; &lt;br&gt;\n&gt; So if I use application/xml, my API would not be considered t=\r\nruly&lt;br&gt;\n&gt; RESTful? &lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nNo, not if you&#39;re using appl=\r\nication/xml as the hypertext engine driving&lt;br&gt;\napplication state.  If it&#=\r\n39;s just a snippet of XML which gets read by,&lt;br&gt;\nsay, an HTML front-end d=\r\nriving application state, then it&#39;s OK because&lt;br&gt;\nthe processing model=\r\n (parse as XML, handling XInclude/XLink/rdf:about)&lt;br&gt;\nis adequate to the t=\r\nask.  If that XML snippet contains URIs the user is&lt;br&gt;\nsupposed to click o=\r\nn to transition the application to the next steady-&lt;br&gt;\nstate (which aren&#=\r\n39;t XLinks), well, that&#39;s what &lt;a&gt; and atom:link are&lt;br&gt;\nfor, th=\r\nere&#39;s no corollary in application/xml (besides XLink).&lt;br&gt;\n&lt;br&gt;\nAlso, m=\r\nost order forms are simply tabular data, the semantics of which&lt;br&gt;\ndon&#39=\r\n;t exist in application/xml like they do in application/xhtml+xml or&lt;br&gt;\nte=\r\nxt/html with &lt;table&gt;.  Same with lists, same with forms.&lt;br&gt;\n&lt;br&gt;\n&gt=\r\n;&lt;br&gt;\n&gt; So now I&#39;ll ask, what media type I could possibly use with m=\r\ny own&lt;br&gt;\n&gt; xml/json structure? It almost sounds like you&#39;re saying =\r\nI shouldn&#39;t&lt;br&gt;\n&gt; be returning my own made up structure, that I shou=\r\nld instead use an&lt;br&gt;\n&gt; existing media type, like one with xhtml or some=\r\nthing. Is there a&lt;br&gt;\n&gt; media type that allows for any sort of specific =\r\nformat to a domain to&lt;br&gt;\n&gt; be returned? Or does that now fall into a ca=\r\nse where I should create&lt;br&gt;\n&gt; my own media type and register it with IA=\r\nNA?&lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nIt falls into a case where you should refactor.  You=\r\n have tabular data,&lt;br&gt;\nso you need to choose a data type which expresses s=\r\nuch semantics (i.e.&lt;br&gt;\nHTML, or DocBook).  The whole point of media types =\r\nis that they are&lt;br&gt;\n_not_ domain-specific, but rather, represent a shared =\r\nunderstanding of&lt;br&gt;\na processing model at the network (IP) layer.  This is=\r\n the fundamental&lt;br&gt;\ntradeoff of the style:&lt;br&gt;\n&lt;br&gt;\n&quot;[A] uniform inte=\r\nrface degrades efficiency, since information is&lt;br&gt;\ntransferred in a standa=\r\nrdized form rather than one which is specific to&lt;br&gt;\nan application&#39;s n=\r\needs.&quot;&lt;br&gt;\n&lt;br&gt;\nAn order consists of item numbers, descriptions, quant=\r\nity, unit price&lt;br&gt;\nand total price.  You *could* re-invent the &lt;table&g=\r\nt; wheel and register&lt;br&gt;\nit as a new media type, but it&#39;s more scalabl=\r\ne (maintainable, portable)&lt;br&gt;\nto re-use HTML even if it isn&#39;t a precis=\r\ne fit.  If you create a new&lt;br&gt;\nmedia type, then you need to distribute a c=\r\nustom user-agent.  When you&lt;br&gt;\nupgrade your API, you must simultaneously u=\r\npdate that user-agent.&lt;br&gt;\n&lt;br&gt;\nThe success of the Web is due to the common=\r\n user-agent.  What I really&lt;br&gt;\ndon&#39;t want, is for any system I interac=\r\nt with to require me to install&lt;br&gt;\nyet another piece of software, and keep=\r\n it up-to-date.  That&#39;s coupling.&lt;br&gt;\nSo much easier for everyone conce=\r\nrned, to target the browser.  That way,&lt;br&gt;\nI only need to install and main=\r\ntain one user-agent regardless of how&lt;br&gt;\nmany different systems I interact=\r\n with.  Such decoupling allows clients&lt;br&gt;\nand servers to evolve independen=\r\ntly.  So there is a cost associated&lt;br&gt;\nwith the minting of new media types=\r\n -- coupling -- unless and until the&lt;br&gt;\nnew media type achieves significan=\r\nt uptake.&lt;br&gt;\n&lt;br&gt;\n-Eric&lt;br&gt;\n&lt;/p&gt;\n\n    &lt;/div&gt;\n     \n\n\n\n \n\n\n&lt;/div&gt;&lt;/div&gt;&lt;/di=\r\nv&gt;&lt;/blockquote&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;\n\n\n\n\n\n\n\n      \n\n\n\n\n\n&lt;br&gt;\n\n    =\r\n\n    \n&lt;br&gt;\n\n\n\n\n&lt;div style=3D&quot;color:white;clear:both&quot;&gt;&lt;/div&gt;\n\n\n\n&lt;/div&gt;&lt;/bloc=\r\nkquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;\n&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/=\r\ntable&gt;&lt;br&gt;\n\n\n\n\n\n\n\n      \n\n\n\n\n\n&lt;br&gt;\n\n    \n    \n&lt;br&gt;\n\n\n\n\n&lt;div width=3D&quot;1&quot; sty=\r\nle=3D&quot;color:white;clear:both&quot;&gt;&lt;/div&gt;\n\n\n\n&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;=\r\n&lt;/div&gt;&lt;/div&gt;\n\r\n--20cf3054a203fb411a04968374e6--\r\n\n"}}