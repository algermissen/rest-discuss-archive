{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"tvX_eTYDmLIlIVxSM_rPBzATzW4IzRDy7BkesnNYQL7_N8Mcr0RPF96ZjlPzV31wJlbRVUD1PDwvjS1CusUZfGe7RtkdAG_JDaJCLV1xpg","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Why SPARQL endpoints aren&#39;t even remotely RESTful.","postDate":"1296657629","msgId":17281,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTEwMjAyMDc0MDI5LmZhYzgyMTlhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":0,"nextInTopic":17284,"prevInTime":17280,"nextInTime":17282,"topicId":17281,"numMessagesInTopic":22,"msgSnippet":"... When I go to that page, I see not even a clue about the nature of the interface, other than that I ll need the out-of-band knowledge of some query language","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 53969 invoked from network); 2 Feb 2011 14:40:45 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m1.grp.sp2.yahoo.com with QMQP; 2 Feb 2011 14:40:45 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.sp2.yahoo.com with SMTP; 2 Feb 2011 14:40:44 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 535F9509EB\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Wed,  2 Feb 2011 09:40:44 -0500 (EST)\r\nDate: Wed, 2 Feb 2011 07:40:29 -0700\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20110202074029.fac8219a.eric@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Why SPARQL endpoints aren&#39;t even remotely RESTful.\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nDanny Ayers wrote:\n&gt; \n&gt; For example, if I go to:\n&gt; \n&gt; http://api.talis.com/stores/bbc-backstage/services/sparql\n&gt; \n&gt; and enter the query :\n&gt; \n&gt; select ?s where { ?s ?p ?o } \n&gt; limit 10\n&gt; \n&gt; then click the &quot;Search&quot; button, I get a bunch of results in SPARQL\n&gt; results format.\n&gt; \n\nWhen I go to that page, I see not even a clue about the nature of the\ninterface, other than that I&#39;ll need the out-of-band knowledge of some\nquery language to use it.  Where are the instructions for how to\ntransition to the next application state, given *any* goal?  This is\nindeed an RPC endpoint, not a hypertext API.\n\nThe corollary is to run your weblog by providing a textbox which takes a\nSQL query, instead of encapsulating SQL within a hypertext interface\n(i.e. running WordPress).  This is precisely what Roy is talking about,\nin his final bullet point, here:\n\nhttp://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\n\nAlso, from the comments to that post:\n\n&quot;When I say hypertext, I mean the simultaneous presentation of\ninformation and controls such that the information becomes the\naffordance through which the user (or automaton) obtains choices and\nselects actions...  Machines can follow links when they understand the\ndata format and relationship types...  It is the same basic issue as\nwith human communication:  we will always need a common vocabulary to\nmake sense of it. Exposing that vocabulary in the representations makes\nit easy to learn and be adopted by others.&quot;\n\nThe data format is HTML, which says nothing about SPARQL, and there is\nno link relation.  So the vocabulary isn&#39;t exposed in hypertext at all.\nThe interaction is not based on the information presented in the\nhypertext, therefore it is being driven by out-of-band information.\nGoogle&#39;s search API (though not entirely RESTful) accepts keywords,\nwith a syntax defined here:\n\nhttp://www.google.com/advanced_search\n\nIt should be obvious that there&#39;s a very fundamental difference between\nGoogle&#39;s homepage, and the advanced_search page -- the former relies on\nout-of-band information to add &#39;&num=10&#39;, the latter makes it a RESTful\nhypertext control; SPARQL endpoints don&#39;t even encode number of results\nas a name/value pair, instead making it part of one opaque search\nphrase (limit+10 tacked on at the end) and needlessly complicating the\nissue of input validation on both the client and the server sides.\n\nTaking Google&#39;s advanced_search interface a little further, RDFa could\nbe used to describe the &quot;results per page&quot; control, and type it as an\ninteger.  A more advanced forms language could express the range that\nthe server will accept.  This allows client-side input validation.\nGoogle allows any value; what would make more sense would be to take\ntheir form control literally -- limiting results-per-page to a set\nnumber of values improves cacheability.\n\n&gt; \n&gt; then click the &quot;Search&quot; button, I get a bunch of results in SPARQL\n&gt; results format.\n&gt; \n\nNo, it returns a representation as application/xml, which means I need\nto sniff in order to determine that it&#39;s a SPARQL result.  To meet the\nself-descriptive messaging constraint of REST, the results would\nproperly be sent as application/sparql-results+xml, but making that\nchange alone won&#39;t make the API RESTful.  As the results from an actual\nhypertext API, it makes a fine media type, although I&#39;d personally tack\non an XML PI to call some XSLT to transform it into HTML, assuming my\nhypertext interface was also HTML.\n\n&gt; \n&gt; and enter the query :\n&gt; \n&gt; select ?s where { ?s ?p ?o } \n&gt; limit 10\n&gt; \n\nHow do I know what to enter, when instead of entering keywords for a\nsearch, I have to enter a query formatted in a manner not afforded\nthrough hypertext controls?  A REST API would have one hypertext\ncontrol for select=, providing me with the options the server has\nimplemented.  Instead of making users guess at what namespaces are\nsupported, a REST API would provide that list as a hypertext control.\nThe server tells the user-agent the parameters of the API, such that\nthe user-agent only needs to fill in the search terms (keywords, not\ninstructions, particularly not instructions which amount to tunneling a\ncustom method like CONSTRUCT over POST).\n\n*That&#39;s* what I mean by providing instructions for how to execute a\nstate transition, not urlencoding an opaque query language and letting\nthe server sort it out.  The goal of a REST API is not to encode query\nlanguages as URIs this way, it&#39;s to abstract away such implementation\ndetails behind a generic interface.  No (reasonable) CMS based on SQL\npresents SQL queries as URIs or in hypertext, that implementation\ndetail is abstracted away behind the interface, which is exactly how\nSPARQL can be made RESTful (as opposed to providing non-hypertext-API\nendpoints).  The server converts the request into a SPARQL query for a\nback-end system in REST, as opposed to exposing a SPARQL endpoint -- no\ndifferent from how SQL is handled in REST APIs.\n\nThere is one way I can think of to use SPARQL queries in a REST app,\nwhich is to POST or PUT a representation as application/sparql-query to\nsome URI.  Dereferencing that URI executes the query as a stored\nprocedure, returning application/sparql-results+xml by default, but\ncan also return the original query with Accept: application/sparql-\nquery.  I&#39;ve used the eXist DB this way, creating cells containing\nXQuery, which is a nice way to create a Web app from an XML store.\n\n-Eric\n\n"}}