{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"8ziQsou1etS9oOdd6s8u4NqJ248EB--FJOLnSiJN-MYD0fsA83f-9KWsXMrUKYatVa0Rfk7ekjzy-vmEJOnFse-3Vb5K_lpkfDWNn5NhQQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"RE: [rest-discuss] REST design question","postDate":"1164143143","msgId":7078,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PFc0MjgyNTEzNDMwMTQ4MzQxMTY0MTQzMTQzQG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":7075,"nextInTopic":7079,"prevInTime":7077,"nextInTime":7079,"topicId":6804,"numMessagesInTopic":134,"msgSnippet":"... That s an URL.  You can t tell by looking at an URL what its representation may be.  URLs are opaque.  Look again at the URL I gave as an example, and stop","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 42509 invoked from network); 21 Nov 2006 21:12:19 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m36.grp.scd.yahoo.com with QMQP; 21 Nov 2006 21:12:19 -0000\r\nReceived: from unknown (HELO mail.mailsnare.net) (206.246.200.185)\n  by mta3.grp.scd.yahoo.com with SMTP; 21 Nov 2006 21:12:19 -0000\r\nX-Virus-Scanned: by ClamAV at mailsnare.net\r\nReceived: from mail.mailsnare.net (v167.mailsnare.net [206.246.200.167])\n\tby mail.mailsnare.net (Postfix) with ESMTP id 138F022E04;\n\tTue, 21 Nov 2006 21:05:43 +0000 (UTC)\r\nTo: &quot;Mike Schinkel&quot; &lt;mikeschinkel@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nImportance: Normal\r\nSensitivity: Normal\r\nMessage-ID: &lt;W4282513430148341164143143@...&gt;\r\nX-Mailer: Mintersoft EdgeDesk, Build 4.03.0105\r\nDate: Tue, 21 Nov 2006 21:05:43 +0000\r\nOrganization: Bison Systems Corporation\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nReply-To: eric@...\r\nSubject: RE: [rest-discuss] REST design question\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\n&gt;\n&gt;&gt;&gt; No, there&#39;s nothing inherently un-RESTful about an URL like this:\n&gt;&gt;&gt;\n&gt;&gt;&gt; [1] http://example.com/service?query=www.example.org\n&gt;&gt;&gt;\n&gt;&gt;&gt; That&#39;s sending an identifier, not logic or a representation. I can GET,\n&gt;PUT,\n&gt;&gt;&gt; POST or DELETE the above URL [1]. In REST, the application logic defines\n&gt;\n&gt;&gt;&gt; how /service responds to these methods, not the contents of the message\n&gt;&gt;&gt; body.\n&gt;\n&gt;I&#39;m still confused. I though REST requests me to transfer representations.\n&gt;Since it doesn&#39;t appear that URL is transfering a representation isn&#39;t it\n&gt;non-RESTful? (sorry I&#39;m being so dense.)\n&gt;\n\nThat&#39;s an URL.  You can&#39;t tell by looking at an URL what its representation \nmay be.  URLs are opaque.  Look again at the URL I gave as an example, and \nstop assuming the query string is a query string.  Taken character-for-\ncharacter that URL identifies a resource, and that&#39;s all it does.\n\nIn this case it is a query string.  Let&#39;s make a different example, a State \nCapitol service.  The URL:\n\n[1] http://example.com/capitol\n\nConsists of a form (method=GET) which is a simple drop-down list containing \nthe names of all fifty states.  When I select my State from the list and \nclick &quot;submit&quot; what happens?  A GET is sent to dereference this URL:\n\n[2] http://example.com/capitol?query=CO\n\nWhen this URL is dereferenced it returns a representation which contains the \nword &quot;Denver&quot; in an HTML page.  No representation needs to be sent to that \nURL, it just needs to be dereferenced.  When URL 1 is dereferenced, the \nrepresentation it returns is a form which may be filled out and returned to \nthe server.\n\nWhen interacting with a web application, URLs are dereferenced which transfer \nrepresentations of application state.  When the service URL is dereferenced, \nthat one application state contains a list of fifty other application states, \nwith a submit button.  That is an HTML representation, i.e. hypermedia.\n\n[3] http://example.com/capitol?query={state_abbreviation}\n\nSelecting one item and returning the representation of the form to the server \n(either as a message body, or urlencoded) results in the retrieval of one of \nthe other application states, which are also each individually \ndereferenceable at their own RESTful URLs.\n\nLet&#39;s say I want to move the capitol of Colorado to Oak Creek.  I can design \na service which accepts a PUT at [2] containing the same representation \nreturned by a GET at [2], with &quot;Denver&quot; replaced by &quot;Oak Creek&quot; such that \nsubsequent GET requests at [2] return a representation containing the words \n&quot;Oak Creek.&quot;  Application state has changed as a result of a representational \nstate transfer, i.e. a PUT.\n\n&gt;\n&gt;As a point of note, I find that confusing. I would find this much less\n&gt;confusing for your stated resource:\n&gt;http://technoresti.com/users/{username}/weblogs/\n&gt;\n&gt;&gt;&gt; If you want to put the blog ID in the URL and make &lt;updated&gt;\n&gt;&gt;&gt; a standalone resource, you could do that, I suppose -- but you&#39;d\n&gt;&gt;&gt; better have good reason for it.\n&gt;\n&gt;But who gets to define if my reason is good or not?\n&gt;That&#39;s a rhetorical question, if it&#39;s not obvious. ;-)\n&gt;\n\nMY stated resource is just what I said it was.  YOU expanded the example to \ninclude &quot;profiles&quot; which I hadn&#39;t mentioned.  Now you&#39;re confused because my \nresponse to that doesn&#39;t conform to _your_ stated resource, not _mine_.  You \nare imagining in your head some expanded version of the example I wrote down \nand finding that you would prefer a different URI allocation scheme for that \nexpanded version that I am not privvy to.  Good, more power to you, but again \nwe&#39;re in the realm of preference, where all pragmatic considerations are only \nspecific to the use case at hand.\n\nIt seems to me my examples are confusing you because you keep attempting to \napply them either globally, or to some other use case than that for which \nthey were intended.  Try to understand the examples as they are given, then \nask how to apply the lesson contained to some other use case, instead of \ntrying to understand the examples given in terms of some other use case.\n\nYou can indeed come up with your own reasons and define whether they are good \nones or not, but in the context of the example I gave (and the fact that you \nare here asking for enlightenment), I get to define if your reason is good \nwithin the context of my example.  But you are coming up with a URI pattern \nthat applies to something which is _not_ my example then asking who gets to \ndefine if the reason is good or not.  Well, you do, but only for your own \nexamples -- not mine -- because the use cases may be in the same ballpark but \nthey are evidently dissimilar.\n\n&gt;\n&gt;Okay, then I got the wrong impression regard posting logic from some other\n&gt;discussion on this list. Can you give me a simple but realistic example of\n&gt;posting logic, in this context or any other?\n&gt;\n\nAside from the very simple and definitely realistic Technorati example?  Or \nexplain exactly which part of my explanation of exactly why that amounted to \nposting logic to the server you did not understand.  Is it not clear that \nwhen application logic is posted, that representation which is POSTed does \nnot resemble any representation which may be retrieved with a GET?  In REST, \nthe contents of a PUT are different representations (which may be identical) \nof the same resource each way.\n\nOK, here&#39;s another simple but realistic example, within the context of my \nabove example:\n\nLet&#39;s redefine URL [1] (forget about [2] and [3] for a bit) above as a non-\nRESTful service which returns a different response depending on the contents \nof the request, i.e. if the message body (instead of the URL) contains \n&quot;?query=CO&quot; then a POST to URL [1] returns &quot;Denver.&quot;  There is no GET method \non [1] in such a setup because [1] could be one of fifty options -- making \nthe landing URL uncacheable and not very scalable.  A POST which contains \n&quot;?query=CO&quot; and &quot;&lt;method_call type=&#39;change_capitol&#39;&gt;Oak Creek&lt;/method_call&gt;&quot; \ndoes what&#39;s expected of it.\n\nNow, we have two different use cases, one REST the other not.  Let&#39;s apply a \nchange to the URL format such that we have:\n\n[4] http://example.com/{state_abbreviation}/capitol\n\nHow do we change the RESTful service?  By changing the application logic on \nthe server.  There&#39;s nothing about the old URI allocation scheme which keeps \nthose URLs from being 301-redirected to the new URI allocation scheme.  The \nservice is no longer limited to just the capitol, /state_bird could also be a \nresource.  A PUT to [3] gets silently redirected to [4] using mod_rewrite \n(for example), [4] would also accept the PUT directly, since the message body \nis the same as it was before the only thing different about the PUT request \nis the URL.\n\nTry changing the non-REST service to some other URI format.  The message body \nof each POST request would have to be parsed and analyzed by the application \nto determine where to redirect, it can&#39;t be done with DNS or mod_rewrite \nwhich act on the request URI.  This middleware layer would also need to \nreformat the request so that it can be understood by the new application \nlogic.  In the REST example, there is no logic to interpret embedded within \nthe message body, only a name-value pair expressed as &lt;name&gt;value&lt;/name&gt; like \n&lt;h1 class=&#39;capitol&#39;&gt;Denver&lt;/h1&gt;, so the entire application may be rewritten \nwithout needing a middleware layer to interpret any old application logic \ncontained in the message body.\n\nThis way, changing the URI allocation scheme is separated from changing the \ncontents of the hypermedia.  I can always recode my HTML such that it&#39;s \n&lt;dl&gt;&lt;dt&gt;capitol&lt;/dt&gt;&lt;dd&gt;Denver&lt;/dd&gt;&lt;/dl&gt;.  A PUT with the old HTML style \nusing &lt;h1&gt; can be rejected with a 406 error, while a PUT which contains\n ...&lt;dd&gt;Oak Creek&lt;/dd&gt;... is handled exactly the same way the application \nlogic handled a PUT which changed the contents of the &lt;h1&gt; tag before.  It&#39;s \njust the content of the message body is interpreted a little differently.  \nThe architecture of the site hasn&#39;t changed, only the structure of the \nhypermedia, which is no big deal -- the state change still updates the name/\nvalue pair from capitol=&#39;Denver&#39; to capitol=&#39;Oak Creek&#39; regardless of how \nthat&#39;s expressed, or in what media type.\n\nIf you never put application logic out there for clients to transfer in \nrequests, you never have to account for it later because you haven&#39;t locked \nyourself in to any one approach.  Clients which are built around the previous \nnon-REST logic need to be rewritten to fit the new logic, otherwise the \nlegacy format must continue to be supported by introspecting every request, \nwhereas with REST the volume of requests resulting in a 301-redirect (which \nrequires no introspection of the request body) steadily decreases with time \nsince there is no legacy code residing on any client.\n\nSince making a change as I described doesn&#39;t break anything previously \nimplemented, previously-cached pages which aren&#39;t due to expire don&#39;t need to \nbe expired, so what if the old URLs are still responding without redirection \nfor a couple of weeks.  No worries.  With the other approach, if caching were \nimplemented (it could be, but it would be neither easy nor reliable) any \ncached pages would be broken, so everything would need to expire and such a \nchange to the application logic would have a real impact on server \navailability/performance when implemented.\n\nI disagree that these are considerations which boil down to &quot;personal \nvalues.&quot;  Adhering to proper web architecture is the most pragmatic of \nconcerns for a wide variety of reasons, moral repugnance at the thought of \nunnecessarily wasting bytes may not factor into some peoples&#39; consideration \nof architecture but that is still no argument against REST.  I find REST \nintuitive and easy to grasp because I&#39;ve been maintaining websites since 1993 \nand cleaning up after others&#39; messes.  Sanity, reason, rationale and logic \nare in favor of REST, and are born of lessons learned from years of \nexperience, not values or evangelicalism based on faith -- although every \nbelief system has its fanboys.\n\n&gt;\n&gt;I don&#39;t see why there is any requirement via XML-RPC to chance an existing\n&gt;service and I don&#39;t see why logic needs to be sent. Just create a new\n&gt;service (ver 2.0) and send a list of URLs, not just one.\n&gt;\n\nYou don&#39;t see how any service would ever need to change over time?  Oh, I \nsee, for you it just isn&#39;t a big deal that all the old URLs go 404 when \nscrapping the old version in favor of ver 2.0.  Well, that&#39;s not RESTful at \nall.  In REST, designs don&#39;t need to anticipate every possible contingency \nfor the future, because the architectural style is inherently amenable to \nsane evolution over time.  You may not be arguing for XML-RPC but it sounds \nlike you&#39;re arguing in favor of scrapping an entire architecture and starting \nover from scratch, as being &quot;no big deal&quot; and like avoiding that situation \nisn&#39;t somehow a valid, if not key, point in favor of adhering to the REST \narchitectural style.\n\nREST is a sane alternative to the willy-nilly scrapping of entire \narchitectures every couple of years in light of the latest fad.  I&#39;d much \nrather implement AJAX as an enhancement to a RESTful system than as a hackish \nsolution to the performance problems inherent in an architecturally-borked \nMVC CMS because it&#39;s trendy.  Or, have you noticed how slow live.com is?  All \nflash, no substance.  Microsoft is big enough to get away with this, but for \nmost companies trying to grow on the web slow=death.  Also, look what Dare \nhas to go through to make sure that the non-RESTful AJAX-widget architectural \nstyle works for a smattering of (the most popular desktop-browser) user-\nagents:\n\n[5] http://www.25hoursaday.com/weblog/PermaLink.aspx?guid=e6090fb8-97a3-4607-bbf3-140c3d11d6c4\n\nThere&#39;s another example of entirely too much application logic on the client \nside, particularly when all sorts of hacks must be implemented in the code, \nwhich won&#39;t even begin to work on a handheld... just some of the things I \nnever need to worry about, because starting from a REST standpoint means \nhaving a platform that works as a fallback for *all* user-agents which \nunderstand HTML, URI and HTTP, so a widget failure isn&#39;t nonrecoverable.  If \nmy application logic doesn&#39;t depend on my widgets, I can change my widgets \nfrom JavaScript to OpenLaszlo so my enhancements-on-top-of-REST are in Flash -\n- without worrying about breaking the entire functionality of the site in \ngeneral, or for those without JavaScript _and_ Flash.\n\nhttp://weblogs.asp.net/bleroy/archive/2006/11/06/DOM-events-in-the-Microsoft-AJAX-Library.aspx\n\nThat page makes as good an argument as I&#39;ve seen to avoid coding application \nlogic into the client regardless of implementation, and is a great argument \nin favor of REST without even mentioning the concept.  Making HTML/CSS work \ncross-browser is hard enough without trying to achieve cross-platform \nportability of client-side non-RESTful application logic.\n\n&gt;\n&gt;I don&#39;t see how REST allows not changing the API either. If you originally\n&gt;allowed posting only one website and not you are going to allow posting of\n&gt;multiple, wouldn&#39;t you need to create another URI to PUT to?\n&gt;\n\nWhere did I or anyone else claim that changing the API is not allowed?  No, I \ndon&#39;t need to create another URL to PUT to if I have multiple values, it&#39;s \njust a form and forms, of course, are not limited to a single field.  I never \nlimited my example to one website in the first place, which is why I used a \nlist in the example, and why I pointed out that I had used a list in the \nexample, I&#39;m not sure how you ever got the idea that I was restricting \nanything to one website.  That&#39;s what the XML-RPC Technorati ping example \ndoes, and that is a specific limitation I took pains to say did not apply to \nmy example, and was what made the XML-RPC approach inferior to the example I \nwas giving. So in fact, I&#39;m not even changing the API, I&#39;m defining a \nresource to contain one or more of something.\n\n-Eric\n\n\n\n\n"}}