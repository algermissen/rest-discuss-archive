{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"_GW_Q4dVm-sdOChbTDwDT0cP5wdh0dldESoEZDSQP22y0pXlaJUVgZ7wB7v5vsq34TuUbYsE0cAdcIyzKO8sKj18ATDbp5MvrKD10s4XKw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] An approach to deleting multiple resources use one  DELETE","postDate":"1237431927","msgId":12248,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkwMzE4MjEwNTI3LmZlNDJkYWZlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDUwMzdiNmU0MDkwMzE4MTYzOG41NWFhYzdlMG4zN2QyMmRjM2JjMTRiMTcwQG1haWwuZ21haWwuY29tPg==","referencesHeader":"PGU3OGJkYmMwMDkwMjI0MDczOHY0ODRkNmU5NGg0NDQ5ZWIwYjY3YTI4ZDJlQG1haWwuZ21haWwuY29tPgk8NTAzN2I2ZTQwOTAzMTgwOTU3ZzcwYzI2ZDU4cTZmY2Q4OWVjYmQyMzBjOTdAbWFpbC5nbWFpbC5jb20+CTwyMDA5MDMxODE1MTkzNi40OTMzOWZlNC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTw1MDM3YjZlNDA5MDMxODE0MjVwNjZjYTU3OGV1ZjY1YjM0MDI3Y2RjYjhhZUBtYWlsLmdtYWlsLmNvbT4JPDIwMDkwMzE4MTYzNjAxLjQwNDdkMDZiLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDUwMzdiNmU0MDkwMzE4MTYzOG41NWFhYzdlMG4zN2QyMmRjM2JjMTRiMTcwQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":12247,"nextInTopic":12249,"prevInTime":12247,"nextInTime":12249,"topicId":12154,"numMessagesInTopic":112,"msgSnippet":"... Each request method should map to one and only one action, each action should map to one and only one method, each method should mean the same thing for","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 56962 invoked from network); 19 Mar 2009 03:05:09 -0000\r\nX-Received: from unknown (69.147.108.201)\n  by m5.grp.sp2.yahoo.com with QMQP; 19 Mar 2009 03:05:09 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 19 Mar 2009 03:05:07 -0000\r\nX-Received: from BigBison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id D9841D05A2;\n\tWed, 18 Mar 2009 23:05:06 -0400 (EDT)\r\nDate: Wed, 18 Mar 2009 21:05:27 -0600\r\nTo: Assaf Arkin &lt;assaf@...&gt;\r\nCc: Dong Liu &lt;edongliu@...&gt;, Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20090318210527.fe42dafe.eric@...&gt;\r\nIn-Reply-To: &lt;5037b6e40903181638n55aac7e0n37d22dc3bc14b170@...&gt;\r\nReferences: &lt;e78bdbc00902240738v484d6e94h4449eb0b67a28d2e@...&gt;\n\t&lt;5037b6e40903180957g70c26d58q6fcd89ecbd230c97@...&gt;\n\t&lt;20090318151936.49339fe4.eric@...&gt;\n\t&lt;5037b6e40903181425p66ca578euf65b34027cdcb8ae@...&gt;\n\t&lt;20090318163601.4047d06b.eric@...&gt;\n\t&lt;5037b6e40903181638n55aac7e0n37d22dc3bc14b170@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.4.5 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] An approach to deleting multiple resources use\n one  DELETE\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nAssaf Arkin wrote:\n\n&gt;\n&gt; &gt; If an API doesn&#39;t implement DELETE, and also doesn&#39;t use POST for\n&gt; &gt; anything but deletion (single or batch), and the options are\n&gt; &gt; presented in an HTML form then yes, it&#39;s a uniform interface.\n&gt; &gt; However, once DELETE is also implemented, or if POST is used for\n&gt; &gt; anything else like accepting content uploads, the interface is no\n&gt; &gt; longer uniform, unless and until the previous usage of POST to\n&gt; &gt; delete is deprecated.\n&gt; \n&gt; \n&gt; What would be the litmus test?\n&gt; \n\nEach request method should map to one and only one action, each action\nshould map to one and only one method, each method should mean the same\nthing for all resources controlled by the application.  This results in\na &quot;consistent set of semantics for all resources&quot; and avoids the\nproblems of the early Web which precluded caching, as per Fielding\n5.1.4.\n\n&gt;\n&gt; &gt; The fact remains, that only the use of the DELETE method on a\n&gt; &gt; URI-by- URI basis is visible to intermediaries.  This is the only\n&gt; &gt; way to prevent the user who requested the deletion from reloading\n&gt; &gt; the deleted content from cache.  Except, of course, to not cache\n&gt; &gt; anything -- thereby defeating the entire premise of using REST to\n&gt; &gt; begin with...\n&gt; \n&gt; \n&gt; The example this thread started from creates a unique resource using\n&gt; PUT only to immediately discard it using DELETE, without ever\n&gt; retrieving that resource.\n&gt; \n\nPresumably, the user has retrieved the unique entries to be deleted, in\norder to know they need deletion.  If I send the server a list of URLs\nto be deleted, or create a &quot;delete factory&quot; resource, then I&#39;m not\ntransferring a representation of any application state -- no matter if\nit&#39;s retrieved or not.\n\n&gt;\n&gt; I provided some justification for why it would be better to replace\n&gt; the PUT/DELETE pair with a POST, likely against a resource that will\n&gt; never be retrieved. I think that falls under the uniform interface.\n&gt; \n\nNo, in a uniform interface, an action is taken against a target URI.\nIf the resource to be deleted has a URI, then a DELETE request is made\nagainst that URI -- not some other URI and/or some other method.  Your\nPOST solution consists of multiple instructions to the server, not a\nrepresentation of an application state.  That&#39;s RPC, not REST.\n\n&gt;\n&gt; I&#39;m not interested in forcing caching down the throat of this use\n&gt; case: the only interesting resources we operate on are never\n&gt; retrieved. So strawman aside, why is this use of POST not uniform\n&gt; interface?\n&gt; \n\nThis is no strawman argument.  If, in order for an API to function as\nits developer intends, caching must be disabled:  then the developer\nmust ask himself if his API is RESTful.  &quot;Do you Etag?&quot;  If you can&#39;t\ncache representations of the individual resources you intend to subject\nto batch delete, in order to make batch delete work, then you&#39;ve\nobviously broken the uniform interface constraint.  If you hadn&#39;t,\nyou&#39;d be able to cache without it breaking your API.\n\nYou&#39;re saying that the &quot;only interesting resources we operate on&quot;\ndoesn&#39;t include the individual resources making up the delete batch.\nI&#39;m saying that yes, those individual resources *are* the interesting\nresources, and it&#39;s *those* URIs we want to DELETE, not some other URI\nacting as a temporary stand-in.\n\n&gt; \n&gt; Separately, cache control has provisions for preventing clients from\n&gt; reloading deleted content, and often enough, the deleted content we\n&gt; want them to forget is not deleted by them. So you can cache\n&gt; resources and be able to magically remove not by DELETE and be very\n&gt; uniform interface about it.\n&gt; \n\nThe only intermediaries of interest here, are those between the user\nwho requests the DELETE and the server.  No other user requested the\ndeletion, though -- the only person who might wish to confirm that an\noffensive comment has been removed is the moderator who decided to\nremove it.  When that moderator reloads the offensive comment, or the\nthread that used to contain it, the deleted comment should never, ever\nappear.  This is very, very simple to accomplish -- explicitly DELETE\nthe URI assigned to the offensive content.\n\nThis does nothing about keeping other users from continuing to see the\ncomment until its cache-control values expire.  But those users didn&#39;t\nrequest the DELETE, either.  In a batch-delete situation which bypasses\nthe DELETE method, nothing is visible to intermediaries, and any cached\nresource won&#39;t be expired, leading the hypothetical moderator who wants\nto confirm the deletion to see the resource is still there, try\ndeleting it again, get a failure message, and become very confused.\n\nIf you are removing one resource by manipulating some other resource,\nthen you haven&#39;t designed a uniform interface.  REST is about\nperforming each discrete action against a resource by manipulating that\nresource directly at its URI.  Not some other URI.  This is fundamental.\n\n-Eric\n\n"}}