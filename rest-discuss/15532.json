{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"yG8g95dcrVkHwJN5X5OID5EEM_Pl2TqgX0UrrarSdDz-dlrWjNcnic-Y1FcopppJfl0KIw4hMZwLjVG4B20r83vTnhLuf4cvLkyIlf2uWg","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Determining which Media type for post/put","postDate":"1275595928","msgId":15532,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNjAzMTQxMjA4LmUwMjY5ODdkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlra3ZmaWhhZDFsVXFTZE5pLThaM2p6aVctMGIzSFEyU0FzaldsUUBtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PEFBTkxrVGlsazJZWnJnY2U5M3dYcDlFSjRHZnBpckxlUVZ2bUowSnhjeFBZSEBtYWlsLmdtYWlsLmNvbT4JPEFBTkxrVGltTzROM0ZTeDg5bjR2Sm43RkpsMzJYaC1ERnNZUl93dG5Pd3VYdUBtYWlsLmdtYWlsLmNvbT4JPDNEREQwQkU2NTU4NjlENEVBNTA2NjUyQjM4MDNBRUY2MTU2RDlFNkNAUFJJU00uY2FmZmVpbmUtaXQubmV0Pgk8QUFOTGtUaW5Hc3JWaUdXSUJTWElmd3YxeTY1dDRNbTEyRW1PcXNnNTlONmUyQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExMDUxNTEuZTYzZjgyMmEuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWxIU3RDNWNpU0N5MHg5ZFFmRUJsdHluVld5ZEdLblZlbjZaYm1KQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExNzU2NDEuZjZhY2FhMjguZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaW5kdzJsN0tDcUpkelh2OU8yLUdGMUtfamM3d1FjanBrbmhIZm5oQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDMwNTE1MDkuYjUxOWI4ZWIuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtrdmZpaGFkMWxVcVNkTmktOFozanppVy0wYjNIUTJTQXNqV2xRQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":15531,"nextInTopic":15533,"prevInTime":15531,"nextInTime":15533,"topicId":15466,"numMessagesInTopic":82,"msgSnippet":"... Why would the intermediary need to know about resource relationships? Origin servers manage those.  Caches only deal with the caching parameters of","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 50365 invoked from network); 3 Jun 2010 20:12:43 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m3.grp.sp2.yahoo.com with QMQP; 3 Jun 2010 20:12:43 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.re1.yahoo.com with SMTP; 3 Jun 2010 20:12:43 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 458BF509DA;\n\tThu,  3 Jun 2010 16:12:32 -0400 (EDT)\r\nDate: Thu, 3 Jun 2010 14:12:08 -0600\r\nTo: Mike Kelly &lt;mike@...&gt;\r\nCc: Sebastien Lambla &lt;seb@...&gt;, mike amundsen &lt;mamund@...&gt;,\n Glenn Block &lt;glenn.block@...&gt;, &quot;rest-discuss@yahoogroups.com&quot;\n &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100603141208.e026987d.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTikkvfihad1lUqSdNi-8Z3jziW-0b3HQ2SAsjWlQ@...&gt;\r\nReferences: &lt;AANLkTilk2YZrgce93wXp9EJ4GfpirLeQVvmJ0JxcxPYH@...&gt;\n\t&lt;AANLkTimO4N3FSx89n4vJn7FJl32Xh-DFsYR_wtnOwuXu@...&gt;\n\t&lt;3DDD0BE655869D4EA506652B3803AEF6156D9E6C@...-it.net&gt;\n\t&lt;AANLkTinGsrViGWIBSXIfwv1y65t4Mm12EmOqsg59N6e2@...&gt;\n\t&lt;20100601105151.e63f822a.eric@...&gt;\n\t&lt;AANLkTilHStC5ciSCy0x9dQfEBltynVWydGKnVen6ZbmJ@...&gt;\n\t&lt;20100601175641.f6acaa28.eric@...&gt;\n\t&lt;AANLkTindw2l7KCqJdzXv9O2-GF1K_jc7wQcjpknhHfnh@...&gt;\n\t&lt;20100603051509.b519b8eb.eric@...&gt;\n\t&lt;AANLkTikkvfihad1lUqSdNi-8Z3jziW-0b3HQ2SAsjWlQ@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Determining which Media type for post/put\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nMike Kelly wrote:\n&gt;\n&gt; Eric J. Bowman wrote:\n&gt; \n&gt; &gt; Mike Kelly wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Eric J. Bowman wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; &gt; That Atom and only Atom resource is a *different resource* whose\n&gt; &gt; &gt; &gt; entity happens to overlap with that of some other resource --\n&gt; &gt; &gt; &gt; which happens all the time in REST.\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Agreed, that does happen all the time, but at a significant cost\n&gt; &gt; &gt; to visibility since it results in invisible resources\n&gt; &gt; &gt; dependencies.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; What cost?  What dependencies?  There is no &quot;invisible dependency&quot;\n&gt; &gt; between a negotiated resource and any resources that also happen to\n&gt; &gt; be variants.  That makes no sense whatsoever.\n&gt; &gt;\n&gt; \n&gt; Given that URI&#39;s are opaque, the following resources:\n&gt; \n&gt; /sales-order/123\n&gt; /sales-order/123.html\n&gt; /sales-order/123.pdf\n&gt; \n&gt; Could share a dependency that is not visible to an intermediary if\n&gt; you avoid conneg.\n&gt; \n\nWhy would the intermediary need to know about resource relationships?\nOrigin servers manage those.  Caches only deal with the caching\nparameters of representations.  You&#39;ll notice my demo doesn&#39;t implement\nconneg, but sends Vary and Content-Location as if it did.  This doesn&#39;t\nmatter to a cache, which just maps all Accept headers to one single\nrepresentation, effectively.  Activating conneg won&#39;t impact cache\nperformance, because of the layered-system constraint.\n\nWhen the origin server changes its behavior, caches change their\nbehavior to match, without needing any knowledge (and definitely\nwithout being able to make any assertions about anything, there&#39;s no\nguarantee on the Web that you&#39;ll get fresh data) of the system the\norigin server implements to manage its resources.  This is dumb caching,\nand it&#39;s proven to scale; why replace it with smart caching, the\ncoupling of which can&#39;t possibly scale?  REST is all about leveraging\nscalable, dumb caching.\n\nThese dependencies you speak of aren&#39;t invisible, they&#39;re phantoms.\n\n&gt;\n&gt; What does PUT /sales-order/123 do to the html/pdf resources from a\n&gt; cache&#39;s point of view, does it invalidate them? It probably should,\n&gt; that&#39;s a pretty useful behavior to be able to rely on.\n&gt; \n\nFirst, a cache invalidates only that resource involved in the PUT\ntransaction -- it probably shouldn&#39;t behave any other way since that\nwould defeat the entire purpose of REST and be some other, totally\nunproven, theoretical architecture bearing no resemblance to the\nreal-world Web of today.\n\nSecond, this is one of many uses of the &#39;must-revalidate&#39; directive.  I\nserve HTML representations of Atom resources (if you will) to browsers,\nbut the mechanism whereby content is posted is based on Atom Protocol.\nObviously, updating the Atom resources updates the negotiated resources,\nbut the way REST architecture works is that I include &#39;must-revalidate&#39;\non negotiated variants such that they cache-validate properly.\n\nGranted, this results in overhead, but then again the overall bandwidth\nsaved dwarfs the bandwidth consumed by &#39;must-revalidate&#39; traffic (sub-\n1K/hit 304 traffic I can serve all day) and renders the fact that caches\ncan&#39;t expire negotiated resources properly without it, moot.\n\nOptimizing PUT to begin with isn&#39;t really worthwile though, as REST\nemphasizes optimizing the hell out of GET because that&#39;s over 99% of a\nreal-world system&#39;s traffic.  I care more about having those variants\ncache properly than I do about having intermediaries synchronously\nexpire them when one changes -- the coupling required for such a system\nwould go against fundamental REST architecture -- for the sake of what,\nyou have failed to explain.\n\n&gt; \n&gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Reduced visibility directly impacts on your ability to leverage\n&gt; &gt; &gt; the layered constraint which, amongst other things, weakens your\n&gt; &gt; &gt; ability to compensate for the inefficiencies that emerge from the\n&gt; &gt; &gt; REST style. That is a problem. Particularly at scale.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; By leveraging the layered system constraint, do you mean caching?\n&gt; &gt; The caching on my Atom files served from non-negotiated URIs is more\n&gt; &gt; efficient than that of the exact same files served as variants of a\n&gt; &gt; negotiated URI. In fact, if I don&#39;t assign the variants their own\n&gt; &gt; URIs and send that along in Content-Location, caching breaks down\n&gt; &gt; entirely on the negotiated resources.\n&gt; &gt;\n&gt; \n&gt; That doesn&#39;t make sense - isn&#39;t this what the Vary mechanism is for?\n&gt; \n\nI spent years studying how caching works before I began shooting my\nmouth off about it on mailing lists.  The Vary header informs client\nconnectors of two things.  First, that the resource implements conneg\n(most often, for compression).  Second, which request headers the\norigin server considered to generate the varied response.\n\nMost caches, and certainly the overwhelming majority of deployed shared\ncaches on the public Web, simply won&#39;t cache responses whose Vary\nheader consists of anything more than &#39;Accept-Encoding&#39; in the absence\nof a Content-Location URI.  Which makes perfect sense, as caches &quot;key&quot;\ntheir database of stored representations by... URI, of course.\n\nThis makes no difference when the conneg only varies by compression,\nan intermediary can store the representation compressed or not, then\nzip or unzip it on-the-fly as needed.  But, when varying by media type,\nthe intermediary needs to store multiple representations associated\nwith the negotiated URI.  Assuming these variants will send Content-\nLocation keeps cache development simple, as mapping is URI-based.\n\nSome caches, certainly not widely-enough deployed to have an appreciable\nimpact, will in fact use an internal identifier and store variants even\nwithout Content-Location headers.  Most, however, rely on the URI sent\nin the Content-Location header.  Let&#39;s break this down a bit -- cache\nreceives response for request /a with Content-Location /a.html .  Cache\nreceives subsequent request for /a.html and serves it without making a\nrequest to the origin server (unless there&#39;s a &#39;must-revalidate&#39;),\nsince the requested representation is already cached.  GET optimization.\n\nSo in fact, caches have enough information to expire /a on PUT to\n/a.html but it is not in Web architecture nor REST architecture for the\ncache to make any assumption about the connection between the two.  The\nintermediary passing on the PUT request may not be in-circuit for the\nresponse.  If the response was 4xx then the cache which expired /a has\njust violated the assumption rule, and it&#39;s pretty presumptuous (albeit\nspecified) for it to have even expired /a.html .\n\nThis is called the &#39;stateless messaging&#39; constraint.  Caches just can&#39;t\nknow what effect the PUT request to one variant&#39;s URI, or even to the\nnegotiated URI, will have on any other variant because they may not be\nparty to the response to the PUT request.  Solutions to this &quot;problem&quot;\ninclude using FTP or other stateful protocol, or advocating that the\ntelco infrastructure revert from packet-switching to circuit-switching.\n\n&gt; \n&gt; &gt; You can&#39;t seriously be claiming that assigning URIs to variants of a\n&gt; &gt; negotiated resource somehow has a negative impact on visibility?\n&gt; &gt;\n&gt; \n&gt; Seriously.\n&gt; \n\nThen you&#39;ll have your work cut out for you, as you&#39;ll need to rebut\nChapter 5 of Roy&#39;s thesis paragraph-for-paragraph using the language\nand examples established in Chapters 1-4.  Start with the identification\nof resources constraint, it&#39;s closest to the top, and explain why it&#39;s\na bad thing.\n\nOr, respond to what I said the other day -- if your context is such\nthat conneg is required, that&#39;s one resource.  If your context is such\nthat a specific media type is required, that&#39;s another resource\nentirely.  The fact that one variant of the negotiated resource happens\nto be the same as the representation of some other resource, is part of\nthe style (author&#39;s preferred version), which mandates that each\nresource have its own URI.\n\nSo the key mistake you&#39;re making, is failing to identify two discrete\nresources with two discrete URIs, i.e. you&#39;re failing to apply the\nidentification of resources constraint.  This is fundamental to REST,\narguing against it is tilting at a windmill.\n\n&gt; \n&gt; &gt; Reality itself proves otherwise, since caching the variants of a\n&gt; &gt; negotiated resource only works (except for compression) when you\n&gt; &gt; assign URIs to those variants.  Only the visibility provided by the\n&gt; &gt; Content-Location URI allows for scaling to occur on systems which\n&gt; &gt; implement conneg.\n&gt; &gt;\n&gt; \n&gt; Really?\n&gt; \n&gt; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44\n&gt; \n\nI explained the two functions of the Vary header, above.  Neither has\nto do with caching.  Content-Location in the absence of Vary means that\ndifferent intermediaries will cache different variants, depending upon\nthe media type the server sent in response to the first request for the\nresource passing through each intermediary.  Vary screams &#39;conneg&#39; to\nall interested parties, which in turn, if they even care, may decide\nfor themselves whether they&#39;re interested in the parameters of the Vary.\n\nVary in the absence of Content-Location (with the exception of\ncompression) works out, in reality on the Web, as an uncacheable\nresponse (which is why this best-practice is labeled as SHOULD).  There\nis also considerable interoperability variation with real-world caches\nwhen Vary-header parameters get too complicated.\n\nMost can handle one or two, but many fail with my system, which\nsometimes sends &#39;Vary: Accept, User-Agent, Accept-Encoding&#39; which some\ncaches will reject just by virtue of having three fields, or by virtue\nof one of the fields being User-Agent, or by combining User-Agent with\nAccept.\n\nThat&#39;s why the advice on this list where conneg is concerned is KISS.\nReal-world caching is less effective the more complex the conneg scheme.\nUnfortunately, the leading use of conneg, after compression, is probably\ndealing with IE by parsing User-Agent strings, which have such infinite\nvariation that caching is defeated.\n\nMy system is designed to maximize cachability of the variants making up\nnegotiated resources, in a way which offsets caching penalties from the\nconneg for the initial representation by including persistent data from\nmultiple, more-cache-persistent sources.  These source files are also\nthe representations transferred using PUT and POST, so rendering a\nsteady-state in HTML also primes the local cache with the Atom file\nincluded by other resources (like the editing page), and gives the user\nagent the Etag it will need when making a conditional PUT request.\n\nThat&#39;s GET optimization, and as the analysis of my server logs shows,\nit&#39;s quite effective at reducing traffic over the wire.  My most-complex\nVary headers are for resources whose HTML content is just a stub, which\nlinks to a persistent XSLT file, which includes more-cache-persistent\nresources to build the steady-state.  My architectural approach moots\nthe deficiencies of HTTP 1.1 conneg by *applying* REST, not working\naround it.  HTTP&#39;s limitations aren&#39;t REST&#39;s fault nor are they\nlimitations of REST, but REST can make HTTP&#39;s limitations irrelevant. \n\n&gt; \n&gt; &gt;\n&gt; &gt; As with cookies, what you propose also violates the self-descriptive\n&gt; &gt; messaging constraint.  This is simple enough to check -- does the\n&gt; &gt; response representation vary depending on the context of the\n&gt; &gt; request?\n&gt; &gt;\n&gt; &gt; If @type worked the way you wanted it to, dereferencing a resource\n&gt; &gt; would return a media type based on the native Accept header if the\n&gt; &gt; URI is typed or pasted in, or a link is followed from a page that\n&gt; &gt; doesn&#39;t set @type.  Yet if the same URI is dereferenced from some\n&gt; &gt; other page that does set @type, the response representation has\n&gt; &gt; just changed based on the prior application state, i.e. shared\n&gt; &gt; context.\n&gt; &gt;\n&gt; \n&gt; Yes, this is exactly the behavior I am advocating. This problem would\n&gt; be avoided if, say, the browser address bar was amended by the\n&gt; Content-Location header of the negotiated response.\n&gt; \n\nWow.  There&#39;s active debate on why browsers break with the spec and\nfail to change the address bar for Location headers.  But one point\nthat everybody but you agrees on, is that the entire purpose of conneg\nis that the address bar *doesn&#39;t* change to reflect Content-Location.\n\nSo the solution to your non-problem is that we scrap Web architecture\nand start over, because everybody but you fails to recognize this as\nbroken behavior?  How should the address bar change to inform the user\nthat an uncompressed variant was selected, as opposed to compressed?\n\nSeriously.  I point out a behavior that breaks a REST constraint, you\nthen say that&#39;s exactly what you&#39;re advocating, but claim to be\nfollowing REST?  Because what you&#39;re advocating results in exactly the\nbehavior that is typically accomplished using cookies, and nobody who\nclaims such a solution to be RESTful can be taken seriously -- unless\nthey&#39;ve taken the trouble to rebut Chapter 5, chapter and verse, first.\n\n&gt;\n&gt; Besides, I thought URIs were opaque and hypertext was the engine of\n&gt; application state?\n&gt; \n\nYes, URIs are opaque, this is why it goes against both Web architecture\nand REST for the aforementioned PUT to expire anything beyond the\nresource involved in the request.\n\nYes, hypertext is the engine of application state, in fact the Content-\nLocation header is hypertext which informs client connectors (browsers,\ncaches etc.) of the URI for the returned representation.\n\n&gt; \n&gt; &gt;\n&gt; &gt; This is a major problem, which totally violates the layered-system\n&gt; &gt; and identification of resources constraints also, which may be\n&gt; &gt; easily and simply avoided by the best-practice solution of\n&gt; &gt; assigning URIs to variants.  Problem _solved_.  Period.\n&gt; &gt;\n&gt; \n&gt; It doesn&#39;t violate any constraints, the only problem it does pose is\n&gt; potential UX issues - which can be solved.\n&gt; \n\n-1\n\nThe constraint violations have been thoroughly detailed for you.  Your\nrefusal to engage, and insistence on dismissing everything I&#39;ve said\nout-of-hand to restate your positions, is Exhibit A for cognitive-REST-\ndissonance.  Servers send representations which inform user agents how\nto render application steady-states.  They don&#39;t send representations\nwhich modify how user agents work at the protocol level.\n\nIf you can&#39;t describe, in REST terms, what the problem is with\nassigning URIs to variants, and you can&#39;t explain, in REST terms, what\nis wrong with my (and others&#39;) analysis of the constraints you&#39;re\nblatantly violating, then you just aren&#39;t going to convince me that\nthere&#39;s a problem here to begin with, let alone one worth solving.\n\nThis fundamental separation of client-server concerns is called the\nlayered system constraint, and it&#39;s how the real-world Web happens to\nhave always worked.  When a server is breaking through the separation\nof layers to dictate to the client how it should behave at the protocol\nlevel, the layered system constraint is broken.  This is a feature of\nREST and Web architecture, not a bug.  Cookies are bad enough.\n\n(For the hundredth time...)\n\nIf the server needs to instruct the client to retrieve a specific media\ntype, then the server needs to send the client the URI for that\n_separate_ resource, instead of the URI for the negotiated resource.\nNOT the same resource.  Again, this is the identification of resources\nconstraint.  If you&#39;re serious about REST, then you need to accept the\nfundamentals of the style, especially those which are reflected in how\nthings actually work on the Web, instead of railing against them.\n\n&gt;\n&gt; Your post is too long and this conversation is getting tiresome, I\n&gt; think I&#39;m pretty much spent here unless we can condense this stuff a\n&gt; bit more.\n&gt; \n\nYes, I modified my last response to remove the part where I point out\nyour obvious cognitive dissonance, quote what Seb said days ago, and\ngive it a +1.  But, I feel it&#39;s important to clear up your misinformed\npoint of view for anyone reading the thread in the properly open frame\nof mind required to learn, even if it has no effect on you.  We&#39;ve\nreached the point where it&#39;s pretty obvious you&#39;re more committed to\ndefending your assumptions than learning REST, and continuing to take\nyou seriously would only serve to encourage you.  Tiresome, indeed.\n\nIf you want to engage me in actual debate to change my opinion on any\ntopic in the world, your grasp of fundamentals must first be sound.\nOtherwise, long lectures aimed at others struggling to actually learn\n(to prevent their being misinformed) will be the result...\n\n&gt;\n&gt; I do have one final question though; Assuming what you&#39;re saying is\n&gt; right, what is the benefit in drawing any high level distinction\n&gt; between representations and resources if all we are actually talking\n&gt; about is resources and link relations? It&#39;s confusing. (Range-14\n&gt; confusing)\n&gt; \n\nThis whole thread has been about that very benefit.  Without the\ndistinction, it wouldn&#39;t be possible to have late binding based on the\ncapabilities of the client.  Think about compression.  Are the zipped\nand unzipped variants of a resource, different resources?  No?  Then\nsurely they need to share an identifier, right?\n\nThe resource vs. representation distinction follows naturally from this\nproblem of having one text &quot;noun&quot; and one binary &quot;noun&quot; which both\n&quot;adverb&quot; the same &quot;noun&quot;.  Saying this distinction is philosophical\nrather than real is to dispute the fact that compression really does\nwork on the Web, and it&#39;s nothing more than content negotiation.\n\n(For more information on exactly why this distinction must be made, and\nwhy it has been made in terms of resource vs. representation, don&#39;t\ntake my word for it, see Roy&#39;s thesis.  While it isn&#39;t aging well in\nterms of examples given using WAIS and such, it&#39;s about the most\ninformative piece of work that&#39;s been written about a specific\napplication of networked software architecture, and definitely ahead of\nits time.  When you understand Roy&#39;s thesis, you will understand why\nRange-14 couldn&#39;t be resolved in any other way, and it ceases to be\nconfusing.  Keep at it, all.)\n\nWhat&#39;s the link relationship between zipped and unzipped variants?\nNone.  I assure you, whatever semantics you wish to use to describe it,\nthere does exist a distinction between resource and representation, and\ncompression wouldn&#39;t work without it.  It would be pretty stupid to\nhave no mechanism in HTTP for compressing text, or to require clients\nto implement decompression in order to read text, or to consider the\ntwo to be different things, or allow HTML to force a user agent to\nrequest a compressed file it can&#39;t decipher by altering request headers.\n\nREST shows that there are valid reasons why things are the way they\nare on the Web, with solid grounding in the fundamentals of computer\nscience.  Despite its flaws, which require a successor protocol instead\nof the radical changes to the existing architecture you propose, the\nHTTP 1.1-based Web has proven to be wildly successful.  To learn REST\nis to learn why the Web works as well as it does, so you can hit a sweet\nspot where it works incredibly well in terms of scaling (i.e. 1KB/hit\nwith a 70% cache-hit ratio).\n\nInstead of learning REST, you&#39;re taking well-established best practices\nthat can be demonstrated to work incredibly well, finding flaws which\nnobody else can see, and proposing solutions which, by implication,\nfault a whole buttload of work by a whole buttload of people agreeing\non certain fundamentals which you alone insist are incorrect.\n\nGood luck with that,\nEric\n\n"}}