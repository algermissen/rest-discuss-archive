{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":184797058,"authorName":"Benjamin Carlyle","from":"Benjamin Carlyle &lt;benjamincarlyle@...&gt;","profile":"fuzzybsc","replyTo":"SENDER","senderId":"IHj3mMGqbD69DtPuLnD2Cw4hCd9_ItSJLiJ3aBihXXBSL_lNio8t7H-wVx0RAMp4C5c0JlXr6oUBdvZP48wxzDkoez8CD_3NEF0EROjJiAIRBazx84mvXy4","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: The XML Semantic Web","postDate":"1172754964","msgId":8029,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDExNzI3NTQ5NjQuNDczOC40MC5jYW1lbEBsb2NhbGhvc3QubG9jYWxkb21haW4+","inReplyToHeader":"PDFmMmVkNWNkMDcwMjI1MTI1M3IxNmVmNWRlMXg4OTYzYzMzMjRkYTE5OWU1QG1haWwuZ21haWwuY29tPg==","referencesHeader":"PDExNzE5NjkxNzYuMjA3LjI3NTcyLm0xNkB5YWhvb2dyb3Vwcy5jb20+CSA8NDVEQUQyNjIuMjM4Ny4zRUFBNjg3QGFuZHJ6ZWouY2hhZXJvbi5jb20+CSA8MTE3MjAwNTEwMC4xMjIwMi4xMC5jYW1lbEBsb2NhbGhvc3QubG9jYWxkb21haW4+CSA8NDVEQjdDRTUuNTA1MDFAZGVob3JhLm5ldD4JIDw5Mjc0NDFiMzA3MDIyMDE4MTB1NDQ3Yjk4OWZzYjZlMjBhMGI3MzQ4MmEwNEBtYWlsLmdtYWlsLmNvbT4JIDw0NURDMTMzRi4xMDIwMDA1QGRlaG9yYS5uZXQ+CSA8MTE3MjI2Nzc3MS40NzU1LjYxLmNhbWVsQGxvY2FsaG9zdC5sb2NhbGRvbWFpbj4JIDw0NUUwODZCNy43MDUwODA3QGRlaG9yYS5uZXQ+CSA8OWRjNzhkN2IwNzAyMjUwOTAzeDI3ZTUwMmI3bmRhZjRhMTM1ODlmODFjOTJAbWFpbC5nbWFpbC5jb20+CSA8MWYyZWQ1Y2QwNzAyMjUxMjUzcjE2ZWY1ZGUxeDg5NjNjMzMyNGRhMTk5ZTVAbWFpbC5nbWFpbC5jb20+"},"prevInTopic":7987,"nextInTopic":8030,"prevInTime":8028,"nextInTime":8030,"topicId":7927,"numMessagesInTopic":81,"msgSnippet":"... That s fine in the abstract sense, but * An atom document has an atom structure * A html document has a html structure * A train list document has a train","rawEmail":"Return-Path: &lt;benjamincarlyle@...&gt;\r\nX-Sender: benjamincarlyle@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 39409 invoked from network); 1 Mar 2007 13:18:05 -0000\r\nReceived: from unknown (66.218.66.71)\n  by m37.grp.scd.yahoo.com with QMQP; 1 Mar 2007 13:18:05 -0000\r\nReceived: from unknown (HELO mail32.syd.optusnet.com.au) (211.29.132.63)\n  by mta13.grp.scd.yahoo.com with SMTP; 1 Mar 2007 13:18:04 -0000\r\nReceived: from c210-49-73-43.rochd2.qld.optusnet.com.au (c210-49-73-43.rochd2.qld.optusnet.com.au [210.49.73.43])\n\tby mail32.syd.optusnet.com.au (8.13.1/8.13.1) with ESMTP id l21DG5v5031849;\n\tFri, 2 Mar 2007 00:16:05 +1100\r\nTo: Danny Ayers &lt;danny.ayers@...&gt;, Bill de hOra &lt;bill@...&gt;,\n        Mark Baker &lt;distobj@...&gt;\r\nCc: Steve Loughran &lt;steve.loughran.soapbuilders@...&gt;,\n        rest-discuss@yahoogroups.com\r\nIn-Reply-To: &lt;1f2ed5cd0702251253r16ef5de1x8963c3324da199e5@...&gt;\r\nReferences: &lt;1171969176.207.27572.m16@yahoogroups.com&gt;\n\t &lt;45DAD262.2387.3EAA687@...&gt;\n\t &lt;1172005100.12202.10.camel@...&gt;\n\t &lt;45DB7CE5.50501@...&gt;\n\t &lt;927441b30702201810u447b989fsb6e20a0b73482a04@...&gt;\n\t &lt;45DC133F.1020005@...&gt;\n\t &lt;1172267771.4755.61.camel@...&gt;\n\t &lt;45E086B7.7050807@...&gt;\n\t &lt;9dc78d7b0702250903x27e502b7ndaf4a13589f81c92@...&gt;\n\t &lt;1f2ed5cd0702251253r16ef5de1x8963c3324da199e5@...&gt;\r\nContent-Type: text/plain\r\nDate: Thu, 01 Mar 2007 23:16:04 +1000\r\nMessage-Id: &lt;1172754964.4738.40.camel@...&gt;\r\nMime-Version: 1.0\r\nX-Mailer: Evolution 2.6.3 \r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Benjamin Carlyle &lt;benjamincarlyle@...&gt;\r\nSubject: Re: [rest-discuss] Re: The XML Semantic Web\r\nX-Yahoo-Group-Post: member; u=184797058; y=cLiv73hZPhaeEplyiht_2D6tONapqE4wYiKvn6EquMxzaYw\r\nX-Yahoo-Profile: fuzzybsc\r\n\r\nOn Sun, 2007-02-25 at 21:53 +0100, Danny Ayers wrote:\n&gt; Wow, what a thread. I&#39;ll respond at greater length once I&#39;ve re-read a\n&gt; couple of times and thought a bit... but there is one point I can pick\n&gt; up on right away, from Benjamin:\n&gt; [[\n&gt; I challenge the effectiveness of RDF on a number of points\n&gt; * The effectiveness of the graph structure for conveying data machine\n&gt; to\n&gt; machine\n&gt; ]]\n&gt; The Web is a graph structure.\n\nThat&#39;s fine in the abstract sense, but\n* An atom document has an atom structure\n* A html document has a html structure\n* A train list document has a train list structure\n\nThese are the structures I really want to get at when I process\ninformation from another component in the network. If these are encoded\ndirectly in XML I can extract this information use tree-walking\nalgorithms. If they are encoded into RDF I need a tool that does\ntree-walking to build up an RDF graph, then I need to do graph-walking\nto build the structure I really want to extract.\n\nNot only is the graph structure level unnecessary, it is more\nalgorithmically complex than the tree walk. I suggest that it is at a\nfundamental level easier to write a feed reader that understands\natom/xml than it is to write a feed reader tha understands atom/rdf, no\nmatter how good your tools are for processing the underlying format or\nmodel.\n\nIn either the case of RDF of XML, you still need to specialise your\ndocument type. In RDF you need vocabulary. In XML you need schema, which\nencompasses vocabulary and structure.\n\nI coneed that uniform structure is important when you want to throw data\ninto a database and allow query over it. However, I would contend that\nthis is not a common function in machine-to-machine interoperation. Most\nmachine processing needs to do something specific with the data it\nreceives, and for that we do need the higher-level vocabulary or schema\nto be well-defined.\n\nIf it is a prerequisite of the machine-processable web to have fully\nself-describing documents, then we can always translate these to RDF for\nour storage needs if we really want to. In the mean-time, I would\nsuggest that RDF complicates the common case in favour of an uncommon\ncase that can be solved in a different way once the common case is dealt\nwith.\n\nI believe Mark Baker has a different perspective on this, one which I\nwould like to understand better.\n\nOn Sat, 2007-02-24 at 18:40 +0000, Bill de hOra wrote: \n&gt; Benjamin Carlyle wrote:\n&gt; &gt; As I will point out later in the document, I\n&gt; &gt; don&#39;t think RDF is as conducive to good vocabulary evolution as\n&gt; XML. \n&gt; XML isn&#39;t conducive to vocabulary evolution either. This is very\n&gt; strange \n&gt; juxtaposition. Most XML vocabulairies I&#39;ve seen that declare an \n&gt; extensibility based end up defining a subset of what RDF defines.\n\nI think the evidence says otherwise. We have html and other formats to\ndemonstrate that the basic approach behind good XML development works.\nThe important rules seem to be:\n* Use must-ignore semantics for anything that is not understood\n* Don&#39;t define new namespaces for extensions, so the extensions can one\nday be merged back into the base document type\n* Attack a specific problem space, align communities behind the common\nbrand-name, and hammer things out until it all interoperates\n\nI&#39;m not sure whether or not we have evidence of RDF vocabularies that\nhave survived similar kinds of pressures, though FOAF may be an example.\n\n&gt; &gt; RSS was defined in terms of RDF so that it\n&gt; &gt; could be easily aggregated. However, aggregation did not happen at\n&gt; the\n&gt; &gt; RDF level in practice. Instead, RSS was aggregated at a higher\n&gt; level.\n&gt; But you don&#39;t say why that was. Why was that?\n\nI would guess: Because it wasn&#39;t useful. Because the graph structure is\ntoo low-level to meet application-specific data integration requirements\nautomatically. Do you have any alternative thoughts on that?\n\n&gt; &gt; Must-ignore semantics mean that a document with additional elements\n&gt; will\n&gt; &gt; be ignored by old implementations. \n&gt; mI in my mind is about having having a trailing &quot;else&quot; in the code\n&gt; that \n&gt; logs to disk instead of throwing an exception. It&#39;s a sensible \n&gt; programmatic default.\n\nThe evidence seems to suggest that mI is critical to long-term evolution\nof documents. It is about handling messages from the future and from the\npast: Only require information if you need it to function. Ignore what\nyou don&#39;t understand.\n\n&gt; &gt; This allows new versions of the\n&gt; &gt; document type to be deployed without breaking the architecture. It\n&gt; also\n&gt; &gt; allows extensions to be added for various purposes. If we continue\n&gt; to\n&gt; &gt; use mime we can be specific about particular kinds of subclasses.\n&gt; For\n&gt; &gt; example, I might sub-class atom for the special purpose of\n&gt; indicating\n&gt; &gt; the next three trains that will arrive at a railway station:\n&gt; &gt; application/pids+atom+xml.\n&gt; &gt;\n&gt; &gt; RDF isn&#39;t really as flexible. \n&gt; I can&#39;t agree. RDF&#39;s handling of unknown triples is far more flexible \n&gt; than mI.\n\nCould you provide some examples of this?\n\n&gt; [aside: it&#39;s weird to watch people argue up the uniform interface as\n&gt; a \n&gt; key constraint of REST, but happily rail on uniform data. ]\n\nThis was part of Mark&#39;s recent statements. I would like to attack the\nissue from a specific direction, and that is application-to-application\ninteroperability.\n\nOne of my impressions from WSEC was that there wasn&#39;t a great maturity\nof understanding about the uniform interface being displayed around the\nroom. Everyone was looking for the practical benefits of specific\nmethods, which is fine, but weren&#39;t quite seeing the benefits of uniform\ninterfaces in general.\n\nOne voice in the room asked why he should care about uniform methods,\nwhen the component that recieves a message still has to understand the\nwhole thing. He didn&#39;t see the point of using a uniform method vs an ad\nhoc method when the whole message still had to be understood in a very\nspecific way... and the thing is that in a static architecture he is\nexactly right. The uniform interface doesn&#39;t offer a fundamental benefit\nin a static architecture. It is only as we evolve our architectures and\nallow different webs to interact with each other that the key rule takes\neffect, and that is:\n\n* The kinds of interactions in an architecture and the kinds of data\ntransferred in the interactions should be decoupled from each other.\n\nThat is to say, the set of methods and the set of content types should\nbe decoupled from one another. The reason for this is that they vary at\ndifferent rates. I am very rarely going to need to need to add new\nmethods or return codes to form new interactions in the architecture,\nbut very often going to need to add new kinds of information. I am very\noften going to need to add new content types.\n\nThe goal of application-to-application integration is to constrain the\nkinds of message that are sent around an architecture so that the\nmessages can be understood wherever they arrive. Whenever the data\nschemas of two components line up, I should be able to configure them to\ntalk to have specific kinds of interactions with each other. I might\nwant them to have the GET interaction, or the PUT, or the SUBSCRIBE. The\nthing is that uniform methods are just an underpinning for uniform\ninteractions, and that uniform data is still required.\n\nI see the claim that RDF provides uniform data, but it really doesn&#39;t.\nIt doesn&#39;t any more than XML provides uniform data. It just provides a\nuniform way of creating different data types. Uniform data only comes\nabout with RDF when you add vocabulary to it. Uniform data only comes\nabout with XML when you add both vocabulary and structure to it.\n\nThus, I suggest that RDF and REST are not an automatic fit to each\nother. It is necessary to prove that RDF facilitates better ways of\nconstructing uniform kinds of data than XML does. RDF&#39;s uniform\nstructure is not in and of itself a clear win for REST.\n\nBenjamin.\n\n\n"}}