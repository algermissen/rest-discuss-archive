{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":199324805,"authorName":"Guilherme Silveira","from":"Guilherme Silveira &lt;guilherme.silveira@...&gt;","profile":"guilherme_azevedo_silveira","replyTo":"SENDER","senderId":"FQjeG-8RaArENNHnG7TXMYXXJJd0HzI4HWcCpEDkyb5sKbObgnOLa5FnMQuq28HyvJDyYYxNjnQCMrekspuqovjvEX21HgJ_dS1tqTrN728qvlApy4XloCMTWPY","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] minimizing coupling with rest processes/trying to \tachieve a goal","postDate":"1275010948","msgId":15434,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEFBTkxrVGlsWmJKTGJwbTJDODB2MU5FZV9STk5OOGxNVlR3OWRfRzZhR2N0YkBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PEFBTkxrVGlrT0QtbUNhTHZKcDV6clRaekxhZHdHUk5VT3V2TEtrVUpxY21BOUBtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PEFBTkxrVGltU3lZclg5SFphSzY5dC1zYWVDNS1YN3BRQVBQMEN1Y3BzV0d3M0BtYWlsLmdtYWlsLmNvbT4gCTxBQU5Ma1Rpbnc2d2drYlREMTBZZGduWG1EYUhWRTF5RXc2YzhwRTBVT0JJeFdAbWFpbC5nbWFpbC5jb20+IAk8QUFOTGtUaWxoWEtPTk1WWVg1RHkyT0JQcU9oa0RnYkZTMUhLN1BFYVBTM3Z0QG1haWwuZ21haWwuY29tPiAJPEFBTkxrVGlrT0QtbUNhTHZKcDV6clRaekxhZHdHUk5VT3V2TEtrVUpxY21BOUBtYWlsLmdtYWlsLmNvbT4="},"prevInTopic":15432,"nextInTopic":15443,"prevInTime":15433,"nextInTime":15435,"topicId":15425,"numMessagesInTopic":10,"msgSnippet":"Hello Will, Thats great... all the 4 constraints you showed me are found within the code I posted, so I totally agree with the definition, it might be ... The","rawEmail":"Return-Path: &lt;guilherme.silveira@...&gt;\r\nX-Sender: guilherme.silveira@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 92884 invoked from network); 28 May 2010 01:42:50 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m10.grp.re1.yahoo.com with QMQP; 28 May 2010 01:42:50 -0000\r\nX-Received: from unknown (HELO mail-fx0-f52.google.com) (209.85.161.52)\n  by mta3.grp.re1.yahoo.com with SMTP; 28 May 2010 01:42:49 -0000\r\nX-Received: by fxm19 with SMTP id 19so43618fxm.11\n        for &lt;rest-discuss@yahoogroups.com&gt;; Thu, 27 May 2010 18:42:48 -0700 (PDT)\r\nX-Received: by 10.239.185.203 with SMTP id d11mr1042914hbh.213.1275010968108; \n\tThu, 27 May 2010 18:42:48 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.239.135.139 with HTTP; Thu, 27 May 2010 18:42:28 -0700 (PDT)\r\nIn-Reply-To: &lt;AANLkTikOD-mCaLvJp5zrTZzLadwGRNUOuvLKkUJqcmA9@...&gt;\r\nReferences: &lt;AANLkTimSyYrX9HZaK69t-saeC5-X7pQAPP0CucpsWGw3@...&gt; \n\t&lt;AANLkTinw6wgkbTD10YdgnXmDaHVE1yEw6c8pE0UOBIxW@...&gt; \n\t&lt;AANLkTilhXKONMVYX5Dy2OBPqOhkDgbFS1HK7PEaPS3vt@...&gt; \n\t&lt;AANLkTikOD-mCaLvJp5zrTZzLadwGRNUOuvLKkUJqcmA9@...&gt;\r\nDate: Thu, 27 May 2010 22:42:28 -0300\r\nX-Google-Sender-Auth: lJ9qoT2b73AukGf4heVeN8Kq7a0\r\nMessage-ID: &lt;AANLkTilZbJLbpm2C80v1NEe_RNNN8lMVTw9d_G6aGctb@...&gt;\r\nTo: Will Hartung &lt;willh@...&gt;\r\nCc: rest-discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Guilherme Silveira &lt;guilherme.silveira@...&gt;\r\nSubject: Re: [rest-discuss] minimizing coupling with rest processes/trying to \n\tachieve a goal\r\nX-Yahoo-Group-Post: member; u=199324805; y=GsxnEs_xxvrgT5EvzRCnB5Ulesp1UoGYJNt2zEDKWluPH--Wb8u3ZBD96SsO3gqopYGIxjs\r\nX-Yahoo-Profile: guilherme_azevedo_silveira\r\n\r\nHello Will,\n\nThats great... all the 4 constraints you showed me are found w=\r\nithin\nthe code I posted, so I totally agree with the definition, it might b=\r\ne\nonly a matter of my lack of mastery on the english language:\n\n&gt; 1) Server=\r\ns servicing requests behing load balancers... Since REST is\n&gt; stateless, se=\r\nrver transitions ideally can be done more easily.\nThe server is stateless, =\r\nincluding - *but not limited to*, no session,\ncookies or anything alike tha=\r\nt connects a client to a specific state\nin memory.\n\n&gt; 2) Proxies... Caching=\r\n has lots of issues, and\n&gt; is difficult to do right. But the capability is =\r\nthere, again, at the\n&gt; HTTP protocol level. The REST Client wouldn&#39;t be ign=\r\norant of the fact\n&gt; that a Proxy intervened.\nThe client actually behaves as=\r\n a non-dumb REST client. i.e. If you\nhave a resource in your hands and ask =\r\nto GET it again through another\nlink relation but the resource representati=\r\non, it will not issue the\nGET request because the representation is fresh. =\r\nIf also works fine\nwith etag and last modified headers.\n\n&gt; 3) HTTP Redirect=\r\n. At the HTTP Protocol, this is a client routing\n&gt; instruction. Most every =\r\nother popular protocol lacks this kind of\n&gt; feature, the ability to tell so=\r\nmeone at Window A to go to Window B.\n&gt; This is at the HTTP Protocol, not th=\r\ne REST protocol. A well\n&gt; implemented client will not even know the re-rout=\r\ning has happened...\nSame thing here. Where the server tells to redirect and=\r\n the http spec\nsays we can follow without questioning the clients (there ar=\r\ne some\nrestrictions, right), it follows without the client knowing about it=\r\n.\n\n&gt; 4) HATEOS. Following links. Client can connect to System A, who&#39;s\n&gt; pa=\r\nyload directs them to System B.\nIt follows links. Every decision it makes i=\r\ns according to the resource\nrepresentaiton in its hand and every decision m=\r\neans following a link\n(including sending some payload) to system B.\n\nIn the=\r\n example I mentioned, if you start supporting a new media type\non the serve=\r\nr side, A keeps running. If part of the A application is\nchanged to support=\r\n the new media type (and the old one not), it still\nruns. If system A point=\r\ns to a buying system B, it will also follow\nthis link without being aware o=\r\nf that.\n\nThose 4 restrictions were supported on the internal layers... the =\r\nDSL\nmakes it easier for you to read that you are actually following a\nlink,=\r\n i.e.:\n\n&quot;Then prepare the payment&quot; is actually defined earlier in the code =\r\nas\nfollowing links, taking care about media type information and data\nforma=\r\nts:\n\nresource.links.payment.post payload\n\n&quot;Then access an item&quot; could be im=\r\nplemented as:\n\nresource.items.item[5].links.self.get\n\nIn this case, automat=\r\nic redirection, cache and everything else takes place.\n\nSumming up, all tho=\r\nse 4 contraints are in the &quot;resource....&quot; code,\nwhich is aliased into human=\r\n readable statements through a DSL. But you\nstill use HATEOAS to follow lin=\r\nks and navigate through the state,\nsupport cache and so on.\n\nWhat do you th=\r\nink?\n\n&gt; I don&#39;t see good ways of making that easier, save simply trying to\n=\r\n&gt; empower developers to perhaps make those kinds of well behaved servers\n&gt; =\r\neasier to create for their users.\nSo from the tool point of view, I believe=\r\n I can call that REST.\n\n\n\nRegards\n\n\n\n&gt; At the base level, the client is\n&gt; a=\r\nware of this change, since the underlying address changes (and of\n&gt; course =\r\ncould run in to access issues -- perhaps the new address is to\n&gt; a blocked =\r\nserver, for example). But at the REST Client level, this is\n&gt; effectively i=\r\nnvisible. Since the URIs are opaque, &quot;one is as good as\n&gt; the other&quot; as lon=\r\ng as its role in the workflow is well defined. The\n&gt; &quot;#buyNow&quot; can be a com=\r\npletely different URI from request to request,\n&gt; but, ostensibly, any of th=\r\nem could be use by a REST client. This\n&gt; ability lets the servers direct th=\r\ne clients &quot;transparently&quot;, at the\n&gt; REST protocol level, for whatever reaso=\r\nn necessary (load, failure, new\n&gt; version of service, etc.).\n\n\n\nGuilherme S=\r\nilveira\nCaelum | Ensino e Inova=E7=E3o\nhttp://www.caelum.com.br/\n\n\n\n2010/5/=\r\n27 Will Hartung &lt;willh@...&gt;:\n&gt; On Thu, May 27, 2010 at 2:23 PM, G=\r\nuilherme Silveira\n&gt; &lt;guilherme.silveira@...&gt; wrote:\n&gt;&gt;&gt; Making th=\r\nat underlying infrastructure, the translating of the media\n&gt;&gt;&gt; types and su=\r\npported operations in to code easier to create would be a\n&gt;&gt;&gt; real boon. Su=\r\nch as doing a GET from #itemList, a GET that\n&gt;&gt;&gt; automatically redirects if=\r\n it has too. That alone would add a lot of\n&gt;&gt;&gt; robustness to client code.\n&gt;=\r\n&gt;\n&gt;&gt; I think thats the code I was trying to achieve earlier, less syntax\n&gt;&gt;=\r\n noise, easier to access through i.e http:\n&gt;&gt; &quot;at(&#39;entry_point&#39;).get.links.=\r\nrelation.get...&quot;\n&gt;&gt;\n&gt;&gt; I will try to keep following both paths.\n&gt;\n&gt; Truthfu=\r\nlly, this is where the robustness of a REST system comes from.\n&gt;\n&gt; A REST s=\r\nystems power, IMHO, is that it&#39;s underlying structure need not\n&gt; be static.=\r\n Simply ensuring that clients are looking up URIs out of\n&gt; payloads is a gr=\r\neat leap in robustness, because Well Behaved Servers\n&gt; can send out links t=\r\no other physical systems. The stateless nature\n&gt; allows for easier back end=\r\n transparency.\n&gt;\n&gt; Consider these 4 basic features of REST over HTTP, all o=\r\nf which add to\n&gt; its robustness and flexibility.\n&gt;\n&gt; 1) Servers servicing r=\r\nequests behing load balancers. Since much of\n&gt; HTTP can be connectionless, =\r\nload balancers can more freely direct\n&gt; traffic to different systems based =\r\non load or failure or whatever.\n&gt; This routing is (can be) invisible to the=\r\n client. Since REST is\n&gt; stateless, server transitions ideally can be done =\r\nmore easily.\n&gt;\n&gt; 2) Proxies. HTTP Proxies add robustness by offloading the =\r\norigin\n&gt; servers for frequent, appropriate requests. The Proxy can even ser=\r\nve\n&gt; up content if the host server is down. Caching has lots of issues, and=\r\n\n&gt; is difficult to do right. But the capability is there, again, at the\n&gt; H=\r\nTTP protocol level. The REST Client wouldn&#39;t be ignorant of the fact\n&gt; that=\r\n a Proxy intervened.\n&gt;\n&gt; 3) HTTP Redirect. At the HTTP Protocol, this is a =\r\nclient routing\n&gt; instruction. Most every other popular protocol lacks this =\r\nkind of\n&gt; feature, the ability to tell someone at Window A to go to Window =\r\nB.\n&gt; This is at the HTTP Protocol, not the REST protocol. A well\n&gt; implemen=\r\nted client will not even know the re-routing has happened. A\n&gt; SMART Client=\r\n will take the Redirect and, assuming it&#39;s a permanent\n&gt; redirect, perhaps =\r\nin the future always redirect the same request\n&gt; automatically so as not to=\r\n incur the cost of the redirect later. The\n&gt; Smart Client can maintain an i=\r\nnternal table of these, perhaps.\n&gt;\n&gt; 4) HATEOS. Following links. Client can=\r\n connect to System A, who&#39;s\n&gt; payload directs them to System B. At the base=\r\n level, the client is\n&gt; aware of this change, since the underlying address =\r\nchanges (and of\n&gt; course could run in to access issues -- perhaps the new a=\r\nddress is to\n&gt; a blocked server, for example). But at the REST Client level=\r\n, this is\n&gt; effectively invisible. Since the URIs are opaque, &quot;one is as go=\r\nod as\n&gt; the other&quot; as long as its role in the workflow is well defined. The=\r\n\n&gt; &quot;#buyNow&quot; can be a completely different URI from request to request,\n&gt; b=\r\nut, ostensibly, any of them could be use by a REST client. This\n&gt; ability l=\r\nets the servers direct the clients &quot;transparently&quot;, at the\n&gt; REST protocol =\r\nlevel, for whatever reason necessary (load, failure, new\n&gt; version of servi=\r\nce, etc.).\n&gt;\n&gt; The first two work with &quot;dumb clients&quot;. The second two requi=\r\nre a more\n&gt; robust client. Make these robust client easier to write is key,=\r\n I\n&gt; think, to moving REST farther down field and easier, BETTER, adoption.=\r\n\n&gt;\n&gt; I don&#39;t think there is much beyond this that can be done to keep\n&gt; stu=\r\npid applications from being stupid. Instead, more work can be done\n&gt; to pro=\r\nmote better practices, promote solid examples of those\n&gt; practices, and per=\r\nhaps tooling or libraries to enable better\n&gt; practices.\n&gt;\n&gt; For example, no=\r\n matter what is done at the client end, how it&#39;s coded,\n&gt; etc., there&#39;s not=\r\n much that can be done if the host server goes dead.\n&gt; And as the host serv=\r\ner service definition drifts from the\n&gt; specification implemented by the cl=\r\nient, the more close to death it\n&gt; becomes. It takes conscious effort and w=\r\nork to make a robust, backward\n&gt; compatible service layer and ages and evol=\r\nves well.\n&gt;\n&gt; It&#39;s easy to imagine how a service can add a new media type f=\r\nor a new\n&gt; version of a service. How existing types can have new references=\r\n added\n&gt; to them promoting the new types, but also having reference to the\n=\r\n&gt; original types for existing clients.\n&gt;\n&gt; How the clients need only implem=\r\nent the new media type, and change to\n&gt; start looking for the new relations=\r\nhips and following those, thus\n&gt; incrementally changing. Then, after 6 mont=\r\nhs, &quot;suddenly&quot; the service\n&gt; removes the old references, and perhaps suppor=\r\nt for the old media\n&gt; type. That, IMHO, is a well behaved service. But that=\r\n adds an extra\n&gt; work burden to the provider.\n&gt;\n&gt; I don&#39;t see good ways of =\r\nmaking that easier, save simply trying to\n&gt; empower developers to perhaps m=\r\nake those kinds of well behaved servers\n&gt; easier to create for their users.=\r\n Well Behaved Clients and Well\n&gt; Behaved Servers are the key to the real ro=\r\nbustness. REST gives us the\n&gt; ability to do both, and HTTP happens manifest=\r\n some of those\n&gt; characteristics in handy ways.\n&gt;\n\n"}}