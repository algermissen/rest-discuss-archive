{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":269496776,"authorName":"David Cornejo","from":"David Cornejo &lt;dave@...&gt;","profile":"ttag_dave","replyTo":"SENDER","senderId":"DDhdMo0BtpkNtcKPem3daptNFVc6LHHAi6SeKms0ky5X_DbUwvKHkUmYbtDZ9pO7ZozZojK0LucvbWCp822DHkmK7mDu","spamInfo":{"isSpam":false,"reason":"3"},"subject":"Re: [rest-discuss] more ssl clarifications please.","postDate":"1150157528","msgId":6320,"canDelete":false,"contentTrasformed":false,"systemMessage":true,"headers":{"messageIdInHeader":"PDcuMC4xLjAuMi4yMDA2MDYxMjEzNTMxNS4wMjJhOTk4MEB0LXRhZy5jb20+","inReplyToHeader":"PDcxMWE3M2RmMDYwNjEyMDUxNXE0YWViMmQ5NXE5YmZmN2U1ZDFkYjNmNWVkQG1haWwuZ21haWwuY28gbT4=","referencesHeader":"PDcxMWE3M2RmMDYwNjEyMDQwNG42MjM5YTY0NXM4MDAzYmRiMTg1NzA3M2ZjQG1haWwuZ21haWwuY29tPiA8ODdvZHd5aXBwNS5mc2ZAbmljZmVycmllci50YXBzZWxsZmVycmllci5jby51az4gPDcxMWE3M2RmMDYwNjEyMDUxNXE0YWViMmQ5NXE5YmZmN2U1ZDFkYjNmNWVkQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":6319,"nextInTopic":6323,"prevInTime":6319,"nextInTime":6321,"topicId":6313,"numMessagesInTopic":12,"msgSnippet":"... SSL is configurable to allow different levels of authentication - by default the client authenticates the server against a list of authorities.  We set up","rawEmail":"Return-Path: &lt;dave@...&gt;\r\nReceived: (qmail 25844 invoked from network); 13 Jun 2006 02:27:16 -0000\r\nReceived: from unknown (66.218.67.34)\n  by m11.grp.scd.yahoo.com with QMQP; 13 Jun 2006 02:27:16 -0000\r\nReceived: from unknown (HELO n23c.bullet.sc5.yahoo.com) (66.163.187.214)\n  by mta8.grp.scd.yahoo.com with SMTP; 13 Jun 2006 02:27:15 -0000\r\nReceived: from [66.163.187.122] by n23.bullet.sc5.yahoo.com with NNFMP; 13 Jun 2006 02:12:04 -0000\r\nReceived: from [66.218.69.2] by t3.bullet.sc5.yahoo.com with NNFMP; 13 Jun 2006 02:12:04 -0000\r\nReceived: from [66.218.66.87] by t2.bullet.scd.yahoo.com with NNFMP; 13 Jun 2006 02:12:04 -0000\r\nX-Sender: dave@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 31130 invoked from network); 13 Jun 2006 01:19:56 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m11.grp.scd.yahoo.com with QMQP; 13 Jun 2006 01:19:56 -0000\r\nReceived: from unknown (HELO t-tag.com) (66.160.160.22)\n  by mta3.grp.scd.yahoo.com with SMTP; 13 Jun 2006 01:19:55 -0000\r\nReceived: from Gecko.t-tag.com ([66.91.140.184]) by t-tag.com for &lt;rest-discuss@yahoogroups.com&gt;; Mon, 12 Jun 2006 17:12:26 -0700\r\nMessage-Id: &lt;7.0.1.0.2.20060612135315.022a9980@...&gt;\r\nX-Mailer: QUALCOMM Windows Eudora Version 7.0.1.0\r\nDate: Mon, 12 Jun 2006 14:12:08 -1000\r\nTo: &quot;Dave Pawson&quot; &lt;dave.pawson@...&gt;,\n &quot;REST Discuss&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nIn-Reply-To: &lt;711a73df0606120515q4aeb2d95q9bff7e5d1db3f5ed@...\n m&gt;\r\nReferences: &lt;711a73df0606120404n6239a645s8003bdb1857073fc@...&gt;\n &lt;87odwyipp5.fsf@...&gt;\n &lt;711a73df0606120515q4aeb2d95q9bff7e5d1db3f5ed@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: multipart/related;\n\ttype=&quot;multipart/alternative&quot;;\n\tboundary=&quot;=====================_534970109==.REL&quot;\r\nX-eGroups-Msg-Info: 2:3:4:0\r\nFrom: David Cornejo &lt;dave@...&gt;\r\nSubject: Re: [rest-discuss] more ssl clarifications please.\r\nX-Yahoo-Group-Post: member; u=269496776; y=Wdkdj1XAw2kvtKdEV5ZX8ojZHcHMYpImavo4kYupnbb0hBEG\r\nX-Yahoo-Profile: ttag_dave\r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: gonga_thrash &lt;distobj@...&gt; via web; 13 Jun 2006 02:12:04 -0000\r\n\r\n\r\n--=====================_534970109==.REL\r\nContent-Type: multipart/alternative;\n\tboundary=&quot;=====================_534970109==.ALT&quot;\r\n\r\n\r\n--=====================_534970109==.ALT\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;; format=flowed\r\n\r\nAt 02:15 AM 6/12/2006, Dave Pawson wrote:\n\n&gt;On 12/06/06, Nic James Ferrier \n&gt;&lt;&lt;mailto:nferrier%40tapsellferrier.co.uk&gt;nferrier@...&gt; wrote:\n&gt;\n&gt; &gt; &gt; It seems little better than using PKI over http\n&gt; &gt; &gt; where the client has public, server has private keys.\n&gt; &gt;\n&gt; &gt; It should all be more highlevel than that.\n&gt; &gt;\n&gt; &gt; From the HTTP point of view the interaction should just be:\n&gt; &gt;\n&gt; &gt; CL: &gt; PUT &lt;https://server/someresource&gt;https://server/someresource\n&gt; &gt; SRV: &lt; 200 (or whatever)\n&gt; &gt;\n&gt; &gt; in terms of SSL/TLS there&#39;s a lot going on underneath:\n&gt; &gt;\n&gt; &gt; CL: sends TCP connect request to server\n&gt; &gt; SRV: examines suggested crypto; responds with an algorithm\n&gt; &gt; CL: sends OK to algorithm selection\n&gt; &gt; SRV: sends certificate/key negotiation\n&gt; &gt; CL: OKs all that...\n&gt; &gt; SRV: OKs\n&gt; &gt; CL: sends data (in this case your HTTP request)\n&gt;\n&gt;Quite on line with this, Mark sent\n&gt;&lt;quote&gt; The client makes a connection, usually to port\n&gt;443, on which the server is listening using SSL. There\n&gt;is some negotiation - is the server going authenicate\n&gt;itself to the client, is the client going to authenicate\n&gt;itself to the server etc. In the case of just the\n&gt;server authenicating itself: the server sends the client\n&gt;its public certificate along with some data it signed\n&gt;with it the associated private key. The client checks the signature\n&gt;using the public certificate and then checks the public\n&gt;certificate has been signed by a CA it trusts. If all\n&gt;is OK the client and server go on to negotiate a symmetric\n&gt;key (there are various algorithms for this) - the symmetric\n&gt;key will be a lot smaller than the public key/private\n&gt;key pair (and so a lot faster to encrypt/decrypt stuff with)\n&gt;but will only be used for this connection. Once the symmetric\n&gt;key has been choosen the application data can be exchanged.\n&gt;It is useful to use keepalive when using HTTPS\n&gt;as you do not want to got through the whole phase of setting\n&gt;up the SSL connection each time a client wants to send something.\n&gt;\n&gt;You can treat the SSL connection as a black box, just as\n&gt;you treat the tcp connection as a black box with http.\n&gt;&lt;/quote&gt;\n&gt;\n&gt; &gt;\n&gt; &gt; and so on.\n&gt; &gt;\n&gt; &gt; But from HTTP(S) that&#39;s all transparent.\n&gt;Which isn&#39;t helping me. I&#39;m trying to do this programmatically.\n&gt;Java client and IIS server. I can see it working when Mark says,\n&gt;\n&gt;&quot;The client checks the signature\n&gt;using the public certificate and then checks the public\n&gt;certificate has been signed by a CA it trusts. &quot;\n&gt;\n&gt;I.e. If its &#39;does the client trust the server&#39;, I need to check that\n&gt;I trust the man at the end of the chain? Thawte etc.\n&gt;(Presumably using the Issuer information).\n&gt;\n&gt; &gt;\n&gt; &gt; Your client does need to have a keystore with the public key of the\n&gt; &gt; certificate provider who has signed your server&#39;s private key. I\n&gt; &gt; thought that most toolkits these days came with the main keys; just\n&gt; &gt; like browsers do; but there may be something you have to do to import\n&gt; &gt; a key.\n&gt;\n&gt;Which is a big part of my problem.\n&gt;\n&gt;I&#39;m trying a REST mc - mc transaction, and I guess I want either both way\n&gt;checks, or minimally I want the server to verify the client?\n&gt;this was the opposite of Marks (more usual?) scenario where the client\n&gt;needs to trust the server.\n&gt;\n&gt;I think this is where Nic&#39;s story comes in? I need to export\n&gt;(from the server keystore) a public key with an alias for use on the client\n&gt;as Nic suggests.\n&gt;\n&gt;ideally I&#39;d like to use a self certification (using the Java tools) but\n&gt;we couldn&#39;t get the java keystore values into the IIS &#39;store&#39;.\n&gt;Could be that IIS just won&#39;t play with Java (Sun).\n&gt;\n&gt;Chris wrote\n&gt;Why do you say &quot;seems little better than using PKI&quot;? It does use PKI.\n&gt;\n&gt;yes, I agree. And in my simplistic mode, I guess that if I could guess\n&gt;the user name and password, then any client could access this &#39;secure&#39;\n&gt;server - which left me thinking it was too easy.\n\nSSL is configurable to allow different levels of authentication - by \ndefault the client authenticates the server against a list of \nauthorities.  We set up a local Certificate Authority (CA) and gave \nboth the clients and servers signed certificates and then configure \nthe server to validate the clients certificates in addition to the \ndefault client check of the servers certificate.\n\nYou could, in theory, configure any combination of validations you like.\n\nProblems in importing keys usually come down to one of two things: \nformat and a confusion of the difference between a key and a \ncertificate.  There are several formats and several quirky \nimplementations of certificate stores, I&#39;ve always managed to find \nthe right incantation for key format conversion via Google.\n\nKeys are not the equivalent of certificates - a key is just that, a \nnumber you use to unlock the encrypted material, a certificate is a \ndocument that is signed by some authority to validate the content of \nthe certificate.  In encryption this document contains the key and \nsome sort of identifying information.\n\ndave c\nt-tag, inc.\nkailua, hi\n\n\n&gt;regards\n&gt;\n&gt;--\n&gt;Dave Pawson\n&gt;XSLT XSL-FO FAQ.\n&gt;&lt;http://www.dpawson.co.uk&gt;http://www.dpawson.co.uk\n&gt;\n\r\n--=====================_534970109==.ALT\r\nContent-Type: text/html; charset=&quot;us-ascii&quot;\r\n\r\n&lt;html&gt;\n&lt;body&gt;\nAt 02:15 AM 6/12/2006, Dave Pawson wrote:&lt;br&gt;&lt;br&gt;\n&lt;blockquote type=cite class=cite cite=&quot;&quot;&gt;On 12/06/06, Nic James Ferrier\n&lt;&lt;a href=&quot;mailto:nferrier%40tapsellferrier.co.uk&quot;&gt;\nnferrier@...&lt;/a&gt;&gt; wrote:&lt;br&gt;&lt;br&gt;\n&gt; &gt; It seems little better than using PKI over http&lt;br&gt;\n&gt; &gt; where the client has public, server has private keys.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; It should all be more highlevel than that.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; From the HTTP point of view the interaction should just be:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; CL: &gt; PUT\n&lt;a href=&quot;https://server/someresource&quot;&gt;https://server/someresource&lt;/a&gt;&lt;br&gt;\n&gt; SRV: &lt; 200 (or whatever)&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; in terms of SSL/TLS there&#39;s a lot going on underneath:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; CL: sends TCP connect request to server&lt;br&gt;\n&gt; SRV: examines suggested crypto; responds with an algorithm&lt;br&gt;\n&gt; CL: sends OK to algorithm selection&lt;br&gt;\n&gt; SRV: sends certificate/key negotiation&lt;br&gt;\n&gt; CL: OKs all that...&lt;br&gt;\n&gt; SRV: OKs&lt;br&gt;\n&gt; CL: sends data (in this case your HTTP request)&lt;br&gt;&lt;br&gt;\nQuite on line with this, Mark sent&lt;br&gt;\n&lt;quote&gt; The client makes a connection, usually to port&lt;br&gt;\n443, on which the server is listening using SSL. There&lt;br&gt;\nis some negotiation - is the server going authenicate&lt;br&gt;\nitself to the client, is the client going to authenicate&lt;br&gt;\nitself to the server etc. In the case of just the&lt;br&gt;\nserver authenicating itself: the server sends the client&lt;br&gt;\nits public certificate along with some data it signed&lt;br&gt;\nwith it the associated private key. The client checks the signature&lt;br&gt;\nusing the public certificate and then checks the public&lt;br&gt;\ncertificate has been signed by a CA it trusts. If all&lt;br&gt;\nis OK the client and server go on to negotiate a symmetric&lt;br&gt;\nkey (there are various algorithms for this) - the symmetric&lt;br&gt;\nkey will be a lot smaller than the public key/private&lt;br&gt;\nkey pair (and so a lot faster to encrypt/decrypt stuff with)&lt;br&gt;\nbut will only be used for this connection. Once the symmetric&lt;br&gt;\nkey has been choosen the application data can be exchanged.&lt;br&gt;\nIt is useful to use keepalive when using HTTPS&lt;br&gt;\nas you do not want to got through the whole phase of setting&lt;br&gt;\nup the SSL connection each time a client wants to send\nsomething.&lt;br&gt;&lt;br&gt;\nYou can treat the SSL connection as a black box, just as&lt;br&gt;\nyou treat the tcp connection as a black box with http.&lt;br&gt;\n&lt;/quote&gt;&lt;br&gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; and so on.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; But from HTTP(S) that&#39;s all transparent.&lt;br&gt;\nWhich isn&#39;t helping me. I&#39;m trying to do this programmatically.&lt;br&gt;\nJava client and IIS server. I can see it working when Mark says,&lt;br&gt;&lt;br&gt;\n&quot;The client checks the signature&lt;br&gt;\nusing the public certificate and then checks the public&lt;br&gt;\ncertificate has been signed by a CA it trusts. &quot;&lt;br&gt;&lt;br&gt;\nI.e. If its &#39;does the client trust the server&#39;, I need to check that&lt;br&gt;\nI trust the man at the end of the chain? Thawte etc.&lt;br&gt;\n(Presumably using the Issuer information).&lt;br&gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Your client does need to have a keystore with the public key of\nthe&lt;br&gt;\n&gt; certificate provider who has signed your server&#39;s private key.\nI&lt;br&gt;\n&gt; thought that most toolkits these days came with the main keys;\njust&lt;br&gt;\n&gt; like browsers do; but there may be something you have to do to\nimport&lt;br&gt;\n&gt; a key.&lt;br&gt;&lt;br&gt;\nWhich is a big part of my problem.&lt;br&gt;&lt;br&gt;\nI&#39;m trying a REST mc - mc transaction, and I guess I want either both\nway&lt;br&gt;\nchecks, or minimally I want the server to verify the client?&lt;br&gt;\nthis was the opposite of Marks (more usual?) scenario where the\nclient&lt;br&gt;\nneeds to trust the server.&lt;br&gt;&lt;br&gt;\nI think this is where Nic&#39;s story comes in? I need to export&lt;br&gt;\n(from the server keystore) a public key with an alias for use on the\nclient&lt;br&gt;\nas Nic suggests.&lt;br&gt;&lt;br&gt;\nideally I&#39;d like to use a self certification (using the Java tools)\nbut&lt;br&gt;\nwe couldn&#39;t get the java keystore values into the IIS &#39;store&#39;.&lt;br&gt;\nCould be that IIS just won&#39;t play with Java (Sun).&lt;br&gt;&lt;br&gt;\nChris wrote&lt;br&gt;\nWhy do you say &quot;seems little better than using PKI&quot;? It does\nuse PKI.&lt;br&gt;&lt;br&gt;\nyes, I agree. And in my simplistic mode, I guess that if I could\nguess&lt;br&gt;\nthe user name and password, then any client could access this\n&#39;secure&#39;&lt;br&gt;\nserver - which left me thinking it was too easy.&lt;/blockquote&gt;&lt;br&gt;\nSSL is configurable to allow different levels of authentication - by\ndefault the client authenticates the server against a list of\nauthorities.&nbsp; We set up a local Certificate Authority (CA) and gave\nboth the clients and servers signed certificates and then configure the\nserver to validate the clients certificates in addition to the default\nclient check of the servers certificate.&lt;br&gt;&lt;br&gt;\nYou could, in theory, configure any combination of validations you\nlike.&lt;br&gt;&lt;br&gt;\nProblems in importing keys usually come down to one of two things: format\nand a confusion of the difference between a key and a certificate.&nbsp;\nThere are several formats and several quirky implementations of\ncertificate stores, I&#39;ve always managed to find the right incantation for\nkey format conversion via Google.&lt;br&gt;&lt;br&gt;\nKeys are not the equivalent of certificates - a key is just that, a\nnumber you use to unlock the encrypted material, a certificate is a\ndocument that is signed by some authority to validate the content of the\ncertificate.&nbsp; In encryption this document contains the key and some\nsort of identifying information.&lt;br&gt;&lt;br&gt;\ndave c&lt;br&gt;\nt-tag, inc.&lt;br&gt;\nkailua, hi&lt;br&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;blockquote type=cite class=cite cite=&quot;&quot;&gt;regards&lt;br&gt;&lt;br&gt;\n-- &lt;br&gt;\nDave Pawson&lt;br&gt;\nXSLT XSL-FO FAQ.&lt;br&gt;\n&lt;a href=&quot;http://www.dpawson.co.uk&quot;&gt;http://www.dpawson.co.uk&lt;/a&gt;&lt;br&gt;\n &lt;/blockquote&gt;&lt;/body&gt;\n&lt;/html&gt;\n\r\n--=====================_534970109==.ALT--\r\n\n\r\n--=====================_534970109==.REL\r\nContent-Type: application/octet-stream; name=&quot;1fe2e4fd.jpg&quot;\r\nContent-ID: &lt;.0&gt;\r\nContent-Disposition: inline; filename=&quot;1fe2e4fd.jpg&quot;\r\n\r\n[ Attachment content not displayed ]\r\n--=====================_534970109==.REL--\r\n\n"}}