{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":23186829,"authorName":"Paul Prescod","from":"Paul Prescod &lt;paul@...&gt;","replyTo":"SENDER","senderId":"p2HNNABfyWocMMcTknfgDDTIUKGwvtiH9TjlBlnyGfROus9NpVzEAOzAb-6TB2QYypb__zjGAXMA9-5PQmnC0KTe3oGQfw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [XML-SIG] REST made more concrete still","postDate":"1014210005","msgId":758,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNDNzM5REQ1LjJFRjNFRDZCQHByZXNjb2QubmV0Pg==","referencesHeader":"PDNDNzJGNDVDLjNDRDUyNzRBQHByZXNjb2QubmV0PiA8MjAwMjAyMTkyMjM4MzkuQTIwMjA5QG1vemFydC5tZW1zLWV4Y2hhbmdlLm9yZz4gPDIwMDIwMjIwMDAwMDE3LkEyMTA2NUBtb3phcnQubWVtcy1leGNoYW5nZS5vcmc+"},"prevInTopic":757,"nextInTopic":759,"prevInTime":757,"nextInTime":759,"topicId":757,"numMessagesInTopic":8,"msgSnippet":"... Good question. I think that the answer is: * URIs are mostly opaque. This gives you tremendous flexibility as an application designer. If you relate to","rawEmail":"Return-Path: &lt;paul@...&gt;\r\nX-Sender: paul@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_2); 20 Feb 2002 13:02:33 -0000\r\nReceived: (qmail 24813 invoked from network); 20 Feb 2002 13:02:33 -0000\r\nReceived: from unknown (216.115.97.172)\n  by m11.grp.snv.yahoo.com with QMQP; 20 Feb 2002 13:02:33 -0000\r\nReceived: from unknown (HELO smtp1.ActiveState.com) (209.17.183.249)\n  by mta2.grp.snv.yahoo.com with SMTP; 20 Feb 2002 13:02:32 -0000\r\nReceived: from smtp3.ActiveState.com (smtp3.ActiveState.com [192.168.3.19])\n\tby smtp1.ActiveState.com (8.11.6/8.11.6) with ESMTP id g1KD2Up10530;\n\tWed, 20 Feb 2002 05:02:30 -0800\r\nReceived: from prescod.net (ssh1.ActiveState.com [192.168.3.32])\n\tby smtp3.ActiveState.com (8.11.6/8.11.6) with ESMTP id g1KD2SL31703;\n\tWed, 20 Feb 2002 05:02:28 -0800\r\nMessage-ID: &lt;3C739DD5.2EF3ED6B@...&gt;\r\nDate: Wed, 20 Feb 2002 05:00:05 -0800\r\nX-Mailer: Mozilla 4.76 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: akuchlin@...\r\nCc: &quot;rest-discuss@yahoogroups.com&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nSubject: Re: [XML-SIG] REST made more concrete still\r\nReferences: &lt;3C72F45C.3CD5274A@...&gt; &lt;20020219223839.A20209@...-exchange.org&gt; &lt;20020220000017.A21065@...-exchange.org&gt;\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nX-Filtered-By: PerlMx makes it fast and easy.  See http://www.ActiveState.com/Products/PerlMx/Header\r\nFrom: Paul Prescod &lt;paul@...&gt;\r\nX-Yahoo-Group-Post: member; u=23186829\r\n\r\nakuchlin@... wrote:\n&gt; \n&gt;...\n&gt; \n&gt;    REST version:\n&gt;    GET master/list_services\n&gt;    Returns a list of services as the body.\n&gt;    XXX should the optional &#39;application argument be a URL parameter? Then\n&gt;    you&#39;d do &quot;GET master/list_services;scope&quot; to get all the microscope\n&gt;    services. Or should it be the query string?\n\nGood question. I think that the answer is:\n\n * URIs are mostly opaque. This gives you tremendous flexibility as an\napplication designer. If you relate to resources through a URI then you\ncould actually move one resource physically to another mean and just\nupdate the link.\n\n * ;-parameters are opaque. So if you use them, you are saying that\nclient software should NOT understand what the stuff after the semicolon\nmeans. \n\n * ?-parameters are not opaque. You&#39;re saying that it&#39;s okay for the\nclient to try to understand tha part of the URI and fiddle with the part\nafter the ? mark. \n\nPractically speaking you could use &quot;?&quot; if you want to allow an HTML\nforms client to work with this stuff. That&#39;s a way of thinking through\nwhether you mean for it to be opaque.\n\n&gt;    XXX how should the returned result, which are (service ID, application\n&gt;    ID, host, port) 3-tuples, be encoded? As an XML-RPC array of structs?\n&gt;    As a little custom XML schema?\n\nNo real advice. Depends on whether you are trying to make life really\neasy for the client (xmlrpc.decode()) or whether you want to have other\npeople elsewhere on the Web support your little &quot;schema&quot; (in which case\na formal definition woudl be better) and whether you think message\nself-descriptiveness is important or not. A merger might look like:\n\n&lt;array role=&quot;service_description&quot;&gt;&lt;int role=&quot;id&quot;&gt;..&lt;/int&gt;&lt;int\nrole=&quot;host&quot;&gt;...&lt;/int&gt;...&lt;/array&gt;\n\nCosts and benefits to everything. Also consider an element with three\nattributes. Compact, very readable and trivial to work with in a DOM.\n\nBut then again, maybe this resource should just be *hyperlnks* to the\nservices. You could have an optimized &quot;report&quot; sub-resource for fetching\nbatch data, but I like the idea that Matisse server could incorporate\nservices described on other people&#39;s boxes just by reference. Part of\nthe benefit of REST. You might not take advantage of it but another\nMattise interface implementor might. ;) Build a web of Matisse&#39;s!\n\n&gt; &#92;begin{methoddesc}{get_service}{service}\n&gt; Returns a struct (= a Python dictionary or a Java &#92;class{Vector}\n&gt; instance) with information about the given service.  The contents of\n&gt; the struct are explained below.  &#92;var{service} is a string containing\n&gt; a service ID.\n&gt; &#92;end{methoddesc}\n&gt; \n&gt;    REST version: GET master/service;service ID. Returns an HTTP body,\n&gt;    encoded using the same schema/form as list_services().\n\nI&#39;d use &quot;/&quot; instead of &quot;;&quot; to indicate hierarchy but it doesn&#39;t matter\nmuch.\n\n&gt; Interface: Login\n&gt; \n&gt; &#92;begin{methoddesc}{get_service_ticket}{user_id, password, service_id}\n&gt; If the user ID and password are correct, returns a string containing a\n&gt; ticket for the given service.  If they&#39;re wrong, it will raise a fault\n&gt; with the fault code 1 and fault string ``IncorrectPassword&#39;&#39;.\n&gt; &#92;var{user_id}, &#92;var{password}, &#92;var{service_id} are all strings.\n&gt; &#92;end{methoddesc}\n&gt; \n&gt;    REST version: POST master/get_service_ticket. This must be HTTP\n&gt;    authenticated with the username (meaning a human-friendly ID as\n&gt;    opposed to a URI?) and password. The body is the service ID. Returns\n&gt;    an authorization ticket as the body.\n&gt;    XXX should the service ID be specified as a query string?\n&gt;    XXX or should this be a subset of the service&#39;s URI, so you&#39;d access\n&gt;    master/(service ID)/get_ticket, instead?\n\nYes, I like this latter one. *BUT* /-separated URIs are opaque so to be\nREST-y you need to have service_ids point to their ticket granting\ncomponents. The client shouldn&#39;t just paste together the URI. Once again\nthe virtue is that you can put the ticket granting component on any box\non the Web. Plus spiders can follow the links but not guess your URI\nconventions.\n\nShould the ticket be a resource? Here&#39;s are arguments in favor: the\nclient can DELETE when it is done with it. When we add notifications to\nHTTP, the client could WATCH it to see if the server DELETEs it because\nthe client is kicked off or something. A client that is kicked off could\ndo a GET to see if the authorization ticket disappeared or was just\nreplaced.\n\nOf course, like anything, you need to decide when more REST is more\neffort for not enough gain.\n\n&gt; Interface: Authorization\n&gt; \n&gt; &#92;begin{methoddesc}{check}{user_id, service_id}\n&gt; Returns a Boolean value.  Returns true if the user &#92;var{user_id}\n&gt; is permitted to access the service identified by &#92;var{service_id}.\n&gt; &#92;end{methoddesc}\n&gt; \n&gt;    REST version: POST master/check_auth\n&gt;    XXX how should the two parameters be passed? (XML-RPC again?)\n\nWhy not query params?\n\nI notice you have multiple top-level URIs. I think you should have a\nMatisse.xml which is a tiny vocabulary that points to them for the URI\nopacity reason I&#39;ve given before. One day you may move some methods off\nfor load reasons or something and you can do that by just redirecting a\nURI. Plus this is a simple form of interface introspection.\n\n&gt; Interface: MetadataStore\n&gt; \n&gt; &#92;begin{methoddesc}{get_cache_location}{ticket, metadata}\n&gt; &#92;var{ticket} and &#92;var{metadata} are both strings.  Returns a string\n&gt; containing an FTP URL; the data should be stored to this URL.\n&gt;\n&gt; (Rationale for choosing FTP: it&#39;s standard, it seems hard to improve\n&gt; on it for shipping data at high speed, and the DPSS code supports it.)\n&gt; &#92;end{methoddesc}\n\nDoes anyone use &quot;NETBLT&quot;? Someone pointed me at it a few months back.\n \n&gt;    REST version: POST master/get_cache_location. The body is your\n&gt;    authorization ticket. The returned body is the new URI for the data\n&gt;    time. HTTP PUT the content to the URI to store the data; HTTP PUT the\n&gt;    metadata to URI/metadata to store it.\n&gt;    XXX what if you crash after getting the new URI? You now have an empty\n&gt;    resource. Can this all be done in one HTTP operation?\n\nSure. Shove as much data as you want down the POST. Maybe it&#39;s mildly\nnon-HTTP-ish to create two resources with a single POST but it is very\nmild. If you want to be a purist, use HTTP POST and then a PUT for the\nmetadata. Have the data time URI point to its metadata.\n\nMethod names that start with &quot;get_&quot; bother me because they seem RPC-ish.\nOnes that start with get_ and do a POST kind of freak me out. ;) Maybe\ngenerate_data_time or something. Why is this a POST at all instead of a\nGET (perhaps dynamic)?\n\n&gt; Interface: MetadataSearch\n&gt; \n&gt; &#92;begin{methoddesc}{search}{ticket, condition1, condition2, ...}\n&gt; Returns a list of metadata IDs that match all of the given conditions.\n&gt; \n&gt; ... full description deleted ...\n&gt; &#92;end{methoddesc}\n&gt; \n&gt;    REST version: No equivalent is attempted. You could let Google crawl\n&gt;    the URIs for your data, build RDF or topic maps or whatever you like.\n&gt;    This interface goes away and is replaced by the panoply of search\n&gt;    technologies available for the Web.\n\nZEN! \n\nOf course you can always provide a search facility if you want using\nquery params. There&#39;s nothing wrong with it if you can implement it more\nefficiently server side.\n\n&gt; Interface: Preferences\n&gt; \n&gt; &#92;begin{methoddesc}{get_preferences}{ticket, service/application}\n&gt; Retrieve a string containing preferences information.\n&gt; &#92;end{methoddesc}\n&gt; &#92;begin{methoddesc}{set_preferences}{ticket, service/application, prefdata}\n&gt; Store the string &#92;var{prefdata} containing preferences information.\n&gt; &#92;end{methoddesc}\n&gt; \n&gt;    REST version: easy! To get preferences, POST\n&gt;    user-URI/prefs/applicationID, passing an authorization ticket as the\n&gt;    body. To set preferences, PUT to the same URI, passing the preference\n&gt;    data in the body.\n\nIf authorization tickets are resources then you can do a GET of the same\nform as this:\n\nuser-URI/prefs/applicationID?URI_encoded_authorization_URI....\n\nGET and PUT go nicely together. ;)\n\n Paul Prescod\n\n"}}