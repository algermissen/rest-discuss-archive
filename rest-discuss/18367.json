{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":211647110,"authorName":"Alexander Johannesen","from":"Alexander Johannesen &lt;alexander.johannesen@...&gt;","profile":"shelterit","replyTo":"SENDER","senderId":"v0xKQxOVWKUiEFPA5gkOF5BUN-y_-2Hqu8PmsYH6QKnkefp7tqFYps0nqkBHVciV7ABlaBjRWgwlPb_7xdfbFQ1GVK8UHeAPE8jkOwcIIyt_vNCoyzMCp4p3uVY","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: The &quot;new media types are evil&quot; meme","postDate":"1325819316","msgId":18367,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PENBRjg5YkNEQmFkUEdHRHNoMU9uVTBOPUxRMldSV2hoNTZDSEZ5TFY0WFBacjhIVlE4d0BtYWlsLmdtYWlsLmNvbT4="},"prevInTopic":18366,"nextInTopic":18368,"prevInTime":18366,"nextInTime":18368,"topicId":18183,"numMessagesInTopic":245,"msgSnippet":"Hiya, Bit late. Still on holidays. :) ... No, theye re not, an ontology is designed so that C2C works seamlessly. As long as humans who create programs know","rawEmail":"Return-Path: &lt;alexander.johannesen@...&gt;\r\nX-Sender: alexander.johannesen@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 26598 invoked from network); 6 Jan 2012 03:08:38 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m16.grp.sp2.yahoo.com with QMQP; 6 Jan 2012 03:08:38 -0000\r\nX-Received: from unknown (HELO mail-ee0-f46.google.com) (74.125.83.46)\n  by mta3.grp.sp2.yahoo.com with SMTP; 6 Jan 2012 03:08:38 -0000\r\nX-Received: by eekc4 with SMTP id c4so847713eek.5\n        for &lt;rest-discuss@yahoogroups.com&gt;; Thu, 05 Jan 2012 19:08:37 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.14.123.79 with SMTP id u55mr1637407eeh.120.1325819317444; Thu,\n 05 Jan 2012 19:08:37 -0800 (PST)\r\nX-Received: by 10.14.99.78 with HTTP; Thu, 5 Jan 2012 19:08:36 -0800 (PST)\r\nX-Received: by 10.14.99.78 with HTTP; Thu, 5 Jan 2012 19:08:36 -0800 (PST)\r\nDate: Fri, 6 Jan 2012 14:08:36 +1100\r\nMessage-ID: &lt;CAF89bCDBadPGGDsh1OnU0N=LQ2WRWhh56CHFyLV4XPZr8HVQ8w@...&gt;\r\nTo: Mike Kelly &lt;mikekelly321@...&gt;\r\nCc: REST Discuss &lt;rest-discuss@yahoogroups.com&gt;, \n\tNina Jeliazkova &lt;jeliazkova.nina@...&gt;, Jan Algermissen &lt;jan.algermissen@...&gt;\r\nContent-Type: multipart/alternative; boundary=e0cb4e43d0d173e21904b5d35dcd\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Alexander Johannesen &lt;alexander.johannesen@...&gt;\r\nSubject: Re: [rest-discuss] Re: The &quot;new media types are evil&quot; meme\r\nX-Yahoo-Group-Post: member; u=211647110; y=d2fAlboLR2u9HBTh5X8h_JaRGg_YqGXfUOJGpvKkWDU1meuD\r\nX-Yahoo-Profile: shelterit\r\n\r\n\r\n--e0cb4e43d0d173e21904b5d35dcd\r\nContent-Type: text/plain; charset=ISO-8859-1\r\n\r\nHiya,\n\nBit late. Still on holidays. :)\n\nOn Jan 4, &quot;Mike Kelly&quot; &lt;mikekelly321@...&gt; wrote:\n&gt; &gt; Why the human-readable part? View sourceness?\n&gt;\n&gt; No. It&#39;s key because those semantics are really being broadcast to\n&gt; humans (developers writing the consuming agents&#39; logic).\n\nNo, theye&#39;re not, an ontology is designed so that C2C works seamlessly. As\nlong as humans who create programs know how to deal with certain entities\nor given relationships, the rest of the nitty-gritty of business processes\ndo not need any human intervention, not even on the programming side.\nThat&#39;s the pipe we&#39;re trying to flow through.\n\n&gt; If I produce\n&gt; an hypertext application and expose its semantics as an &#39;ontology&#39;,\n&gt; those semantics will be consumed by developers first and foremost in\n&gt; order to develop their understanding of the way the application flows.\n\nNo, not necessarily, and this is key to the whole semantic schmantic web;\nunderstand a basic part of the ontology (so, the parts that touch the edges\nof its API) to avoid needing to know the whole. Derived ontologies infer\nfrom context their applicability, and one can map objects and relationships\nto workflows more easily than you can use a traditional API.\n\nExample; My app and your app both speak a small ontology about business\ninteraction (basic entities, for example). These apps are obviously made by\ndevelopers, but here&#39;s the clinch; if you speak that ontology, those maps\nof your data you&#39;ve got can be directly reused in more complex frameworks\nwhere underlying ontologies are derived from the basic ontology. An objects\ntype follows through the ontology, where relationships are specified and\ncan be acted upon. It basically means that objects that you&#39;ve defined as\ntype X can be popped into other systems, and interaction can happen,\nwithout any further devs involved.\n\nMore specifically, there&#39;s ontologies for working with semantics within\nmaps, and some apps can enrich your data without any devs. It enables the\ncreation of evolving ontologies for your applications domain and scope.\n\n&gt; I don&#39;t think it needs to get more complex than that, and I&#39;m not 100%\n&gt; on whether that lack of complexity fails to satisfy the definition of\n&gt; an &quot;ontology&quot;\n\nOntology is the language you use; the entities you&#39;ve got, their types, and\nthe relationships between them. You can make that as complex or simple as\nyou need, but of course even more subscribe to reuse of models.\n\n&gt; &gt; It has a defined use in information technology, so get used to it. :)\n&gt;\n&gt; As an application author my concern would be that presenting my\n&gt; application to client developers as an &#39;ontology&#39; would either confuse\n&gt; them or scare them off completely. But, like I said, I don&#39;t think the\n&gt; word we use matters /that/ much.\n\nCall it vocabulary, and relationships. If client developers don&#39;t get this,\nI suggest you need better clients. :)\n\n&gt; think you may have missed my point a bit here. I wasn&#39;t saying there\n&gt; is anything actually &#39;wrong&#39; with forms, just that introducing them to\n&gt; a machine app is (for the time being) a costly and mostly fruitless\n&gt; effort - it increases the complexity of consuming the application (by\n&gt; adding a requirement to understand form processing rules) without\n&gt; delivering much by way of improving evolvability - it doesn&#39;t bring\n&gt; much to the table, and many clients will either get it wrong or hack\n&gt; around it anyway.\n\nthis sounds ... profoundly wrong to me. Forms are costly and fruitless?\nIncreases complexities? What exactly is the difference between a form and\nRPC call in terms of complexity and bloat?\n\n&gt; This may well improve in the future but right now it\n&gt; doesn&#39;t seem like a good option from the practical, cost-benefit point\n&gt; of view (not the architecturally pure one).\n\nThe concept is that the server can prepare and ready-make forms that the\nclient can choose to instigate on and possibly fill out some blanks if they\nexists. The client doesn&#39;t need any pre-defined concept of the API; it is\ndelivered to you, and whether parameters are required, optional, what their\nsemantic weight is, and so on. You&#39;ve gt in forms both a\nmachine-understandable and human-interactionable, self-documenting, and so\non. The client focus more on the entities and relationships between things\n(concepts that are rarely to change) rather than the ins and outs of an API\n(that might change in the future, causing headaches).\n\nAnyway, I don&#39;t think we disagree too much, just on a few reusable things.\n:)\n\nregards,\n\nAlex\n\r\n--e0cb4e43d0d173e21904b5d35dcd\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;p&gt;Hiya,&lt;/p&gt;\n&lt;p&gt;Bit late. Still on holidays. :)&lt;/p&gt;\n&lt;p&gt;On Jan 4, &quot;Mike=\r\n Kelly&quot; &lt;&lt;a href=3D&quot;mailto:mikekelly321@...&quot;&gt;mikekelly321@gma=\r\nil.com&lt;/a&gt;&gt; wrote:&lt;br&gt;\n&gt; &gt; Why the human-readable part? View sourc=\r\neness?&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; No. It&#39;s key because those semantics are reall=\r\ny being broadcast to&lt;br&gt;\n&gt; humans (developers writing the consuming agen=\r\nts&#39; logic). &lt;/p&gt;\n&lt;p&gt;No, theye&#39;re not, an ontology is designed so th=\r\nat C2C works seamlessly. As long as humans who create programs know how to =\r\ndeal with certain entities or given relationships, the rest of the nitty-gr=\r\nitty of business processes do not need any human intervention, not even on =\r\nthe programming side. That&#39;s the pipe we&#39;re trying to flow through.=\r\n&lt;br&gt;\n\n &lt;br&gt;\n&gt; If I produce&lt;br&gt;\n&gt; an hypertext application and expose =\r\nits semantics as an &#39;ontology&#39;,&lt;br&gt;\n&gt; those semantics will be co=\r\nnsumed by developers first and foremost in&lt;br&gt;\n&gt; order to develop their =\r\nunderstanding of the way the application flows.&lt;/p&gt;\n&lt;p&gt;No, not necessarily,=\r\n and this is key to the whole semantic schmantic web; understand a basic pa=\r\nrt of the ontology (so, the parts that touch the edges of its API) to avoid=\r\n needing to know the whole. Derived ontologies infer from context their app=\r\nlicability, and one can map objects and relationships to workflows more eas=\r\nily than you can use a traditional API.&lt;/p&gt;\n\n&lt;p&gt;Example; My app and your ap=\r\np both speak a small ontology about business interaction (basic entities, f=\r\nor example). These apps are obviously made by developers, but here&#39;s th=\r\ne clinch; if you speak that ontology, those maps of your data you&#39;ve go=\r\nt can be directly reused in more complex frameworks where underlying ontolo=\r\ngies are derived from the basic ontology. An objects type follows through t=\r\nhe ontology, where relationships are specified and can be acted upon. It ba=\r\nsically means that objects that you&#39;ve defined as type X can be popped =\r\ninto other systems, and interaction can happen, without any further devs in=\r\nvolved.&lt;/p&gt;\n\n&lt;p&gt;More specifically, there&#39;s ontologies for working with =\r\nsemantics within maps, and some apps can enrich your data without any devs.=\r\n It enables the creation of evolving ontologies for your applications domai=\r\nn and scope.&lt;/p&gt;\n\n&lt;p&gt;&gt; I don&#39;t think it needs to get more complex th=\r\nan that, and I&#39;m not 100%&lt;br&gt;\n&gt; on whether that lack of complexity f=\r\nails to satisfy the definition of&lt;br&gt;\n&gt; an &quot;ontology&quot;&lt;/p&gt;\n&lt;p&gt;O=\r\nntology is the language you use; the entities you&#39;ve got, their types, =\r\nand the relationships between them. You can make that as complex or simple =\r\nas you need, but of course even more subscribe to reuse of models.&lt;/p&gt;\n\n&lt;p&gt;=\r\n&gt; &gt; It has a defined use in information technology, so get used to it=\r\n. :)&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; As an application author my concern would be that pr=\r\nesenting my&lt;br&gt;\n&gt; application to client developers as an &#39;ontology&#=\r\n39; would either confuse&lt;br&gt;\n&gt; them or scare them off completely. But, l=\r\nike I said, I don&#39;t think the&lt;br&gt;\n&gt; word we use matters /that/ much.=\r\n&lt;/p&gt;\n&lt;p&gt;Call it vocabulary, and relationships. If client developers don&#39=\r\n;t get this, I suggest you need better clients. :)&lt;/p&gt;\n&lt;p&gt;&gt; think you ma=\r\ny have missed my point a bit here. I wasn&#39;t saying there&lt;br&gt;\n&gt; is an=\r\nything actually &#39;wrong&#39; with forms, just that introducing them to&lt;b=\r\nr&gt;\n&gt; a machine app is (for the time being) a costly and mostly fruitless=\r\n&lt;br&gt;\n&gt; effort - it increases the complexity of consuming the application=\r\n (by&lt;br&gt;\n&gt; adding a requirement to understand form processing rules) wit=\r\nhout&lt;br&gt;\n&gt; delivering much by way of improving evolvability - it doesn&#=\r\n39;t bring&lt;br&gt;\n&gt; much to the table, and many clients will either get it =\r\nwrong or hack&lt;br&gt;\n&gt; around it anyway. &lt;/p&gt;\n&lt;p&gt;this sounds ... profoundly=\r\n wrong to me. Forms are costly and fruitless? Increases complexities? What =\r\nexactly is the difference between a form and RPC call in terms of complexit=\r\ny and bloat?&lt;/p&gt;\n&lt;p&gt;&gt; This may well improve in the future but right now =\r\nit&lt;br&gt;\n&gt; doesn&#39;t seem like a good option from the practical, cost-be=\r\nnefit point&lt;br&gt;\n&gt; of view (not the architecturally pure one).&lt;/p&gt;\n&lt;p&gt;The=\r\n concept is that the server can prepare and ready-make forms that the clien=\r\nt can choose to instigate on and possibly fill out some blanks if they exis=\r\nts. The client doesn&#39;t need any pre-defined concept of the API; it is d=\r\nelivered to you, and whether parameters are required, optional, what their =\r\nsemantic weight is, and so on. You&#39;ve gt in forms both a machine-unders=\r\ntandable and human-interactionable, self-documenting, and so on. The client=\r\n focus more on the entities and relationships between things (concepts that=\r\n are rarely to change) rather than the ins and outs of an API (that might c=\r\nhange in the future, causing headaches).&lt;/p&gt;\n\n&lt;p&gt;Anyway, I don&#39;t think =\r\nwe disagree too much, just on a few reusable things. :)&lt;br&gt;&lt;/p&gt;\n&lt;p&gt;regards,=\r\n&lt;/p&gt;\n&lt;p&gt;Alex&lt;/p&gt;\n\r\n--e0cb4e43d0d173e21904b5d35dcd--\r\n\n"}}