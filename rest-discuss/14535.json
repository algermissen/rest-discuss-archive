{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":289191104,"authorName":"Jan Algermissen","from":"Jan Algermissen &lt;algermissen1971@...&gt;","profile":"algermissen1971","replyTo":"SENDER","senderId":"UQy6cEQx1VJY-bWyxvQXvXQpF9a0lqwjjHpJpF4dvLUd0TniWMkFBlc0VnHjFHLdDw1v8UyzwHtCgwUQTnBaPuZx9cdaLWg1MD6gmiufrCM","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: about rel and HATEOAS (theoretical question)","postDate":"1263420978","msgId":14535,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEZBMThCNTUwLTdFNEUtNDZFMi04ODBDLTgwQ0ZDNzkxRDFFOUBtYWMuY29tPg==","inReplyToHeader":"PGhpbGNwdCt1MnJrQGVHcm91cHMuY29tPg==","referencesHeader":"PGhpbGNwdCt1MnJrQGVHcm91cHMuY29tPg=="},"prevInTopic":14534,"nextInTopic":14536,"prevInTime":14534,"nextInTime":14536,"topicId":14499,"numMessagesInTopic":68,"msgSnippet":"... When you build a client that understands media type A, you need to hard wire (or configure) two things into your client code: 1. knowledge about which","rawEmail":"Return-Path: &lt;algermissen1971@...&gt;\r\nX-Sender: algermissen1971@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 4990 invoked from network); 13 Jan 2010 22:16:23 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m12.grp.re1.yahoo.com with QMQP; 13 Jan 2010 22:16:23 -0000\r\nX-Received: from unknown (HELO asmtpout015.mac.com) (17.148.16.90)\n  by mta2.grp.re1.yahoo.com with SMTP; 13 Jan 2010 22:16:23 -0000\r\nMIME-version: 1.0\r\nContent-transfer-encoding: 7BIT\r\nContent-type: text/plain; charset=US-ASCII; format=flowed; delsp=yes\r\nX-Received: from [192.168.2.102] ([84.144.101.216])\n by asmtp015.mac.com (Sun Java(tm) System Messaging Server 6.3-8.01 (built Dec\n 16 2008; 32bit)) with ESMTPSA id &lt;0KW700B3YHV7PX80@...&gt; for\n rest-discuss@yahoogroups.com; Wed, 13 Jan 2010 14:16:23 -0800 (PST)\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-id: &lt;FA18B550-7E4E-46E2-880C-80CFC791D1E9@...&gt;\r\nTo: wahbedahbe &lt;andrew.wahbe@...&gt;\r\nIn-reply-to: &lt;hilcpt+u2rk@...&gt;\r\nDate: Wed, 13 Jan 2010 23:16:18 +0100\r\nReferences: &lt;hilcpt+u2rk@...&gt;\r\nX-Mailer: Apple Mail (2.936)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jan Algermissen &lt;algermissen1971@...&gt;\r\nSubject: Re: [rest-discuss] Re: about rel and HATEOAS (theoretical question)\r\nX-Yahoo-Group-Post: member; u=289191104; y=rJfBBTV_ODGpBWjWmpd6_SQ0_IEXhAYhy7nXhGPXQIyfjTbnUwLfcxic\r\nX-Yahoo-Profile: algermissen1971\r\n\r\n\nOn Jan 13, 2010, at 10:09 PM, wahbedahbe wrote:\n\n&gt;\n&gt; Is the media type a part of the service&#39;s contract or the client&#39;s?\n&gt;\n&gt; It seems to me that a key distinction between REST and RPC is that  \n&gt; in RPC the service provides the contract while in REST, the client  \n&gt; provides the contract (via the media type).\n&gt;\n&gt; A client, in the Accept header, constrains the set of acceptable  \n&gt; media types -- isn&#39;t this essentially run-time contract negotiation?\n&gt; The server agrees to the contract at run time by returning an  \n&gt; appropriate representation of the requested resource (or rejects the  \n&gt; contract by returning &quot;Not Acceptable&quot;).\n\nWhen you build a client that understands media type A, you need to  \nhard wire (or configure) two things into your client code:\n\n1. knowledge about which hypermedia elements are traversal options\n    (links, forms)\n2. knowledge about which media types to put into the Accept header\n    when the user (human or machine) of the client chooses to follow\n    a certain transition. (You do *not* code the client to simply list\n    all the media types it understands)\n\nDuring the request handling, there happens runtime negotiation of the  \ncontent but there is a piece of contract that is a design time  \nartifact (2. above). The question really is: On the basis of what  \ninformation does the client choose what types to put in the Accept  \nheader. It is not an arbitrary decision but a decision that  \nessentially reflects the client&#39;s design-time knowledge of the domain  \nprotocol supported by the service.\n\n&gt;\n&gt; *Typically*, services can easily extend their &quot;reach&quot; by supporting  \n&gt; as many media types as they like while clients support a fixed set  \n&gt; of media types. So in order to give a client reach, it is best to  \n&gt; support media types that are able to be used by a broad range of  \n&gt; services.\n\nI think it is the other way round: Services expect the clients to  \nunderstand a set of media types. This set constitutes the service&#39;s  \ntype.\n\n&gt;\n&gt; For example, HTML can obviously be used to express an incredible  \n&gt; range of services.\n\nHmm - I&#39;d argue that HTML oly expresses the semantics needed by a  \nbrowser to turn human targetted hypermedia into an interactive GUI.  \nThe &#39;incredible range&#39; is a by-product of humans controlling the  \nbrowser.\n\n&gt; VoiceXML (used by automated phone systems) can also be used to  \n&gt; express a broad range of services. Supporting one of these media  \n&gt; types would give a client a broad reach as it could interact with  \n&gt; many services. But a service could address both HTML and VoiceXML  \n&gt; clients via conneg (or simply two disjoint sets of URIs).\n\nHmm, not sure I understand that. Can you illustrate?\n\n&gt;\n&gt; Isn&#39;t this the root of the client-server decoupling provided by REST?\n\nThe decoupling is achieved by removing *any* assumption on the client  \nside about what the server may do next. (Except for, for example,  \nreturning images for requests to &lt;img href=&quot;&quot;&gt; target URIs. The server  \nmust not contradict itself.\n\nIn my posting regarding testing a couple of days ago I tried to  \n&#39;investigate&#39; the point by saying: &quot;A server can never send a wrong  \nresponse&quot; client&#39;s must expect anything. (See Jim&#39;s excellent point  \nabout &#39;anything&#39; being constrained by the used media types).\n\n&gt;\n&gt; If so -- then the question I keep coming back to is if a service  \n&gt; that uses a &quot;service-specific&quot; media type is really an instance of  \n&gt; REST. By service-specific, I don&#39;t mean &quot;not standardized&quot; or vendor- \n&gt; specific -- this has nothing to do with the nature of the media type  \n&gt; itself, just whether or not it&#39;s been approved by a standards body.  \n&gt; I mean that the media type represents a contract set by the service  \n&gt; because the media type is not designed to represent a set of  \n&gt; services. This is because the semantics of the media type map  \n&gt; exactly to the semantics of the service. You see this in most &quot;REST  \n&gt; APIs&quot; that are simply serializing service data structures as JSON or  \n&gt; XML.\n\nJSON or XML media types can never &#39;transport&#39; the semantics of a  \ncertain service or domain. They are so generic that they are useless  \nfrom a media type discussion POV. Maybe you are criticising the use of  \nsuch generic types and not really the issue of media types designed  \nfor a certain application?\n\nAlso, I think it is very important to diferentiate between service  \ntypes and service instances. This is sometimes hard to do when you  \nlook at the Web because there are mostly services that are unique (are  \ninstances of their own type). But services that implement AtomPub are  \n*instances* of the kind of service defined by RFC5023. This is why you  \ncan implement AtomPub clients without looking at a service instance.\n\nI do think that certain problem domains (or service types) need their  \nown media types (maybe mixed with existing types). But, yes, I agree  \nthat a media type should be designed for a set of services (aka type?)  \nand not for a single one.\n\nOTH, when Google provides a set of quasi-standardized extensions when  \npublishing a service - that is fine. How&#39;s that different from Google  \nminting a few types for the job?\n\n\n&gt;\n&gt; To me a RESTful service &quot;translates&quot; it&#39;s own internal semantics  \n&gt; into the media type(s) of the client(s) it is trying to address --\n\nI would rather say: A service expects clients to understand certain  \ntypes. If known-to-be-supported types do not do the job, then mint new  \ntypes or extensions and publish them and hope clients implement them.\n\n&gt; the specific translation used being negotiated at runtime. This, to  \n&gt; me is the point of having a distinction between resources and  \n&gt; representations in REST. The translation doesn&#39;t just allow the  \n&gt; service to &quot;reach&quot; a broader set of clients, but it also allows the  \n&gt; client to &quot;reach&quot; a broader set of services. This is because the  \n&gt; representation format captures information using semantics that are  \n&gt; specific to the client. By designing the client&#39;s format around the  \n&gt; information processing capabilities of the client, the client can  \n&gt; interact with as many services as possible.\n\nBut you cannot magically make a client understand a semantic needed to  \nexpress your (the server&#39;s) state machine.\n\n&gt;\n&gt; For example, HTML represents information in terms of common  \n&gt; structures of visually displayed, interactive text -- it&#39;s designed  \n&gt; around visual browsers. VoiceXML is designed around voice browsers.  \n&gt; Yes, you can write a spider to consume HTML (and VoiceXML). And yes,  \n&gt; you can use a screen reader to process HTML, but VoiceXML is a much  \n&gt; more natural way to represent information for speech-based  \n&gt; consumption and interaction (it won a standards war with SALT -- a  \n&gt; set of extensions to HTML for speech). So there are other ways to  \n&gt; consume the information (something afforded by the Principle of  \n&gt; Least Power), but that doesn&#39;t diminish the fact that the media type  \n&gt; is designed to cater to a specific flavor of client.\n&gt;\n&gt; So when a media type is designed around a service rather than a type  \n&gt; of client, I question if the result can be called REST. For example,  \n&gt; a banking service that spits out a JSON format that simply  \n&gt; serializes the account and transaction data structures used  \n&gt; internally to represent the service&#39;s resources. i.e. if you aren&#39;t  \n&gt; targeting a specific &quot;type&quot; of client by translating to that  \n&gt; client&#39;s media type are you violating the constraints of REST?\n\nHmm - are you trying to say that media types should be design for a  \nkind of application (online purchasing, online bank account management  \netc.)? If so - yes, of course!\n\n\n&gt;\n&gt; What specific constraints are being violated is a hard question and  \n&gt; the reason I have a hard time explaining this\n\nSounds like you are talking about visibility in a sense. At least  \nputting application specific stuff into generoc formats and relying on  \nout-of-band contracts to fill the void violates the visibility  \nconstraint.\n\n&gt; -- I would point to &quot;Self-descriptive messages&quot; and its requirement  \n&gt; for standard media types but the meaning of &quot;standard&quot; in the  \n&gt; context of REST is so hard to pin down. Or maybe this is just  \n&gt; inherent in the distinction between representations and resources.\n\n&gt; &quot;Self-descriptive messages&quot; are another form of saying &#39;visibility&#39;.\n\n&gt;\n&gt; Or maybe this isn&#39;t part of REST&#39;s constraints at all... I don&#39;t  \n&gt; know -- that&#39;s why I keep asking (but based on the answers I get, I  \n&gt; don&#39;t think I ever get the question across properly). Anyways, I&#39;m  \n&gt; interested in all of your thoughts.\n\nHope they help.\n\nJan\n\n\n\n&gt; Regards,\n&gt;\n&gt; Andrew\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; ------------------------------------\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n\n--------------------------------------\nJan Algermissen\n\nMail: algermissen@...\nBlog: http://algermissen.blogspot.com/\nHome: http://www.jalgermissen.com\n--------------------------------------\n\n\n\n\n"}}