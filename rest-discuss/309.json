{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":0,"authorName":"S. Alexander Jacobson","from":"&quot;S. Alexander Jacobson&quot; &lt;alex@...&gt;","replyTo":"SENDER","senderId":"iF6RobUxyNhF0jQbPwv6NNOIWxB77Ez299ftLgYnknS9d425dcwEWLKbZeHzDJigtv-nKya-3FEMTfe5c4uAAszTHRTbUKbGSoPNLw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Why is HTTP hard to design with?","postDate":"1011997933","msgId":309,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PFBpbmUuV05ULjQuNDMuMDIwMTI1MTY1NjU1MC4xNDAwLTEwMDAwMEBnYW5kb2xwaC5BU0dBUkQuam1zPg==","inReplyToHeader":"PDNDNTFDNkQ0LjRCMDA0MUNAcHJlc2NvZC5uZXQ+"},"prevInTopic":308,"nextInTopic":310,"prevInTime":308,"nextInTime":310,"topicId":209,"numMessagesInTopic":77,"msgSnippet":"... Remember worse is better. ... You are talking about user-agents, not MTAs or relays. ... Only if you think any use of an HTTP endpoint is a protocol.  If I","rawEmail":"Return-Path: &lt;alex@...&gt;\r\nX-Sender: alex@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_1_3); 25 Jan 2002 22:31:24 -0000\r\nReceived: (qmail 34237 invoked from network); 25 Jan 2002 22:31:24 -0000\r\nReceived: from unknown (216.115.97.172)\n  by m3.grp.snv.yahoo.com with QMQP; 25 Jan 2002 22:31:24 -0000\r\nReceived: from unknown (HELO mail.vo.com) (208.36.81.99)\n  by mta2.grp.snv.yahoo.com with SMTP; 25 Jan 2002 22:31:23 -0000\r\nReceived: from gandolph.ASGARD.jms (alexhome2 [66.108.152.69])\n\tby mail.vo.com (8.12.1/8.12.1) with ESMTP id g0PMUkFv028135\n\t(version=TLSv1/SSLv3 cipher=RC4-MD5 bits=128 verify=NO);\n\tFri, 25 Jan 2002 17:30:49 -0500\r\nDate: Fri, 25 Jan 2002 17:32:13 -0500 (Eastern Standard Time)\r\nTo: Paul Prescod &lt;paul@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nSubject: Re: [rest-discuss] Why is HTTP hard to design with?\r\nIn-Reply-To: &lt;3C51C6D4.4B0041C@...&gt;\r\nMessage-ID: &lt;Pine.WNT.4.43.0201251656550.1400-100000@...&gt;\r\nX-X-Sender: alex@...\r\nMIME-Version: 1.0\r\nContent-Type: TEXT/PLAIN; charset=US-ASCII\r\nFrom: &quot;S. Alexander Jacobson&quot; &lt;alex@...&gt;\r\nX-Yahoo-Group-Post: public\r\n\r\nOn Fri, 25 Jan 2002, Paul Prescod wrote:\n&gt; There is nothing wrong with inventing a new protocol to solve new\n&gt; problems or to solve old problems better.\n\nRemember worse is better.\n\n&gt; &gt; .. In particular, you have to\n&gt; &gt; rewrite RFC2821(SMTP) to ride on top of HTTP.\n&gt;\n&gt; Well, millions of people access their email through HTTP (with or\n&gt; without HTML). And millions of people do File Transfers without the File\n&gt; Transfer Protocol. So I don&#39;t see why SMTP will remain immune to the\n&gt; onslaught of HTTP.\n\nYou are talking about user-agents, not MTAs or\nrelays.\n\n&gt; But anyhow, we&#39;re talking about inventing new protocols anyhow. If\n&gt; you&#39;re sending purchase orders over SMTP and you have complex workflows\n&gt; etc., you are inherently inventing a new protocol.\n\nOnly if you think any use of an HTTP endpoint is a\nprotocol.  If I send POs over SMTP and they get\nsent back approved or rejected, I am defining\nsomething that endpoints are doing.  I am not\ninventing a new transport protocol.\n\n&gt;  Here&#39;s what an essay\n&gt; &lt;p&gt;There is a subtlety here: people think that they can get network\n&gt; effects by switching from HTTP to SMTP (e.g. for asychronous\n&gt; messaging). Of course there is some truth in this. If you were writing\n&gt; an email client today it would not make sense to support HTTP instead\n&gt; of SMTP. That&#39;s simple support for a legacy code base -- like\n&gt; supporting CICS.\n\nThe same is true of the presence application.  You\nknow the joke about the creationist talking to the\nprogrammer.  The creationist said: God created the\nworld in 6 days.  The Programmer responded &quot;Yeah,\nthats because he didn&#39;t have an installed base&quot;\n\nYou reuse what is available and have to be\ncompatible.\n\n&gt; &lt;p&gt;On the other hand, if you were developing a new application\n&gt; then the network effects in SMTP&#39;s favour are not so strong. Getting\n&gt; bits from one machine to another asynchronously is the least of your\n&gt; problems in a complicated buzzword-compliant, secure, work-flow based\n&gt; business-to-business application. The hard problems involve security\n&gt; and accountability. And those hard problems are easier solved with a\n&gt; universal addressing mechanism like the one built into HTTP.\n\nAsynchronous delivery may be one of your  problems\nand SMTP does a decent  job.  And if your project\nis that big, I think you would rather reuse SMTP\nthan invent a new asynch protocol just for your\nproject.  The hard problems of security and\naccountability are orthogonal issues.\n\n&gt; &lt;p&gt;People\n&gt; believe that SMTP is great because it allows asynchronous notifications\n&gt; but KnowNow has shown how a few hundred bytes of JavaScript can\n&gt; implement peer-to-peer asynchronous notifications using HTTP. Would an\n&gt; SMTP solution be any smaller or simpler?\n\nIf you have a fixed set of players then perhaps\nKnowNow is the best solution.  But I don&#39;t think\nyou want every party to be permanently connected\nto every other just to recieve messages.\n\nI do think you may want to interop with\norganizations that do not use KnowNow.\n\nWhere is the KnowNow RFC?\n\n&gt; Right. So choosing based on what server you have hanging around makes no\n&gt; sense. You should choose based on which will help you to model your app\n&gt; in the most flexible, scalable, extensible, secure, reliable way. HTTP\n&gt; has URIs. They allow all of that stuff. SMTP does not. It makes that\n&gt; stuff really hard.\n\nWhen you want asynchronous messaging, use SMTP.\nWhen you want synchronous tracking, use HTTP.\nThese are orthogonal.\n\n&gt; &gt; Then your definition of RPC is incoherent.\n&gt; &gt; Suppose that XML-RPC were modified so that the\n&gt; &gt; method name appeared in the URL rather than the\n&gt; &gt; body, would it stop being RPC?\n&gt;\n&gt; It depends? Are they setting up private namespaces in the parameters? Or\n&gt; are all parameters either URIs or resource representations?\n\nObviously function names in URLs are private\nnamespaces because URLs are opaque.\n\nAll parameters are not URIs.  They are form-data\ndelivered via HTTP post.\n\nYou know all this.  You are avoiding the issue.\n\n&gt; &gt; Nothing prevents the server from returning a\n&gt; &gt; status URL AND commiting to deliver via email.\n&gt;\n&gt; Fine. Now you are starting to make your solution more complex so that it\n&gt; starts to resemble mine in scope and features. How does your client\n&gt; cancel the request if it realizes that the computation is wasted?\n\nMy initial spec didn&#39;t require the tracking\nthat you seem to want.  You kept expanding the\nscope of my spec to justify your features.\n\nIf we want computation cancelation, then perhaps\nwe return a location header with the 202.  But, if\nwe want to support users with web browsers\n(CICS!), we should really return the location of a\nform in the body that will allow the user to\ninquire.  The location of the target is irrelevant\nin such a case.\n\n&gt; &gt;...\n&gt; &gt; Your point about disco clients is just insane.\n&gt; &gt; Have you heard of SMTP relay?\n&gt;\n&gt; Can you read?\n\nI can.  Can you?  Here is what RFC2821 says:\n\n   As discussed above, when the SMTP server receives\n   mail from a particular host address, it could\n   activate its own SMTP queuing mechanisms to\n   retry any mail pending for that host address.\n\nIn other words.  When a disco client reconnects,\nit can just (mail) ping the server to get\nmessages.  It doesn&#39;t ping unless it has been\ndisco for a while so this is a very different type\nof polling.\n\n&gt; &gt; &gt; Disconnected clients have the option of polling which they do\n&gt; &gt; &gt; not with SMTP (unless there is a mailbox intermediary).\n&gt;\n&gt; SMTP relay *is* the mailbox intermediary. Sometimes polling is a better\n&gt; solution. That&#39;s why POP uses it. My solution allows polling *and*\n&gt; direct notification *and* intermediated queued notification. And as a\n&gt; new RESTer pointed out it would be easy to add server-queued\n&gt; notification.\n\nNo.  Your solution requires the client to poll\neven when it has been connected.   With SMTP the\nclient may choose either to get direct\nnotification or to poll (in which case\nit supplies the polling server!).\n\nYour solution requires the application server to\nbear the cost of operating a polling server and\nthe client to poll repeatedly.\n\n&gt; &gt; I am not objecting to supporting both!  My\n&gt; &gt; contention is simply that using HTTP only\n&gt; &gt; precludes callbacks.\n&gt;\n&gt; I have no idea what you&#39;re saying. How can using HTTP preclude\n&gt; callbacks?\n\nBecause the server has no way to back contact the\nclient. It has to wait for the client to\nreconnect.\n\nYou can of course propose a new protocol by which\nthe client supplies a URL to which the server\nshould POST the result, but that is a new\nprotocol and you have yet to show why that\nmechanism is a better protocol (for example it\nhas no reliability!).\n\n&gt; &gt; ...\n&gt; &gt; &gt; If I use XHTML or RSS am I using XML? It is real life HTTP up until the\n&gt; &gt; &gt; point that where I start doing things against the HTTP model such as\n&gt; &gt; &gt; inventing private namespaces or telling the server what to do through\n&gt; &gt; &gt; method names or using POST for logical queries.\n&gt; &gt;\n&gt; &gt; Terrorist_or_not.com uses POST for logical\n&gt; &gt; queries?  Is that a problem?  How would you solve\n&gt; &gt; it?\n&gt;\n&gt; If you want asynch then you are involving server state, so you need to\n&gt; use POST.\n\nYou are evading the issue.  Simple\nterrorist_or_not.com does not require asynch, but\nstill must use POST for logical queries.\n\n&gt; &gt; My general point is that you are defining a new\n&gt; &gt; protocol on which endpoints have to have made\n&gt; &gt; &quot;a priori agreement&quot; (to use MBs words).\n&gt;\n&gt; Call it a new protocol. What does it matter? Terrorist.com is going to\n&gt; require a new &quot;protocol&quot; in some sense regardless. Especially if you set\n&gt; up a status URI then you are setting up a protocol that spans *two\n&gt; other* protocols.\n\nYour missing the point.  Terrorist.com is just an\napplication.  A new user doesn&#39;t have to set up\nanything new to use it.  She simply opens up a web\nbrowser, adds 2 image files to the form and a\nreply-to email address.\n\nThe server either gives her an immediate answer or\ntells her that it is too busy and that it\nwill send her the the answer when it gets to it.\nIn the meantime, she can update/check status at\n*this* location.\n\nIn contrast, your solution would require her to\nset up a special HTTP server to recieve the\ncallback using a new callback HTTP protocol.\n\n&gt; We&#39;re going to take the &quot;common problem&quot; of asynch notifications and\n&gt; develop standard conventions. If you want to call that a new protocol\n&gt; then that&#39;s okay too. As longas we don&#39;t abuse HTTP as POSTing\n&gt; getStateName does, then what does it matter what we call it?\n\nLook.  If you want to develop a protocol\ncalled HTTP-MTP, thats fine.  Just realize that\nyou are competing head-on with SMTP without\noffering any majorly visible advantages.\n\nAny any advantages you do get, might be better\nachieved through evolutionary improvement in SMTP.\n\n&gt; The point is that everything that is already in HTTP is basically\n&gt; *right* and we are building on it, rather than working around the flaws\n&gt; in it.\n\nIf HTTP is so right, talk to me about the lack of\nlogical queries with large bodies?\n\n&gt; &gt; Your argument is like saying that HTTP is not a\n&gt; &gt; new protocol because it already uses TCP/IP.\n&gt;\n&gt; Are cookies a new protocol? Or an extension to HTTP?\n\nI believe they are defined by a different RFC.  In\nparticular, supporting HTTP does not enail\nsupporting cookies.\n\n&gt; &gt; To be clear both to you and to Mike.  I am\n&gt; &gt; objecting to polling and to the work involved in\n&gt; &gt; reinventing the wheel on asynch.\n&gt;\n&gt; Polling is just an option. Not a requirement. HTTP asych does not\n&gt; require polling.\n\nPolling is necessary unless you invent a new HTTP\nasynch delivery protocol.\n\n&gt; Reinventing the wheel is necessary if we want to bring asnch to the web.\n\nI don&#39;t see you as bringing asynch to the web. The\nissues are all orthogonal.\n\n&gt; SMTP has no concept of URI. Therefore it is not web aware.\n\nShow me something you want to do that requires a\nchange in SMTP?  There is no reason you can&#39;t have\nSMTP servers also expose an HTTP server in which\nyou inquire about message-ids it has delivered,\nbut that is irrelevant to the actual delivery of\nmessages.\n\n-Alex-\n___________________________________________________________________\nS. Alexander Jacobson                   i2x Media\n1-212-787-1914 voice                    1-603-288-1280 fax\n\n\n\n"}}