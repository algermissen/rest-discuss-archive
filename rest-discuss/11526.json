{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":364579677,"authorName":"Mike","from":"Mike &lt;mike@...&gt;","profile":"pleb1985","replyTo":"SENDER","senderId":"YF1DMT9Z-6M7HXHJzxEEcDqv14EdcEaX5A9_tcHwhj79KS5pZYY03h4OR2PaKeGdidSKp6lwYcRZ700DMx_5cw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] HTML5 and RESTful HTTP in browsers","postDate":"1227010922","msgId":11526,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ5MjJCMzZBLjMwOTA4MDRAbXlrYW5qby5jby51az4=","inReplyToHeader":"PDIwMDgxMTE4MDA1OTQ5LmFiNzQ0YmVkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PDIwMTUxMDEwLjIzNjg3MTIyNjkxOTk1NDUzMi5KYXZhTWFpbC5zZXJ2bGV0QGt1bmRlbnNlcnZlcj4gPDIwMDgxMTE4MDA1OTQ5LmFiNzQ0YmVkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":11525,"nextInTopic":11527,"prevInTime":11525,"nextInTime":11527,"topicId":11508,"numMessagesInTopic":82,"msgSnippet":"... If the solution uses JavaScript for Accept headers and PUT/DELETE requests, is that browser support or JavaScript virtual machine support? Maybe someone","rawEmail":"Return-Path: &lt;mike@...&gt;\r\nX-Sender: mike@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 17851 invoked from network); 18 Nov 2008 12:16:33 -0000\r\nX-Received: from unknown (66.218.67.95)\n  by m55.grp.scd.yahoo.com with QMQP; 18 Nov 2008 12:16:33 -0000\r\nX-Received: from unknown (HELO moutng.kundenserver.de) (212.227.126.177)\n  by mta16.grp.scd.yahoo.com with SMTP; 18 Nov 2008 12:16:32 -0000\r\nX-Received: from [192.168.10.13] (evojsyfw02.evolve-online.com [213.133.221.98])\n\tby mrelayeu.kundenserver.de (node=mrelayeu6) with ESMTP (Nemesis)\n\tid 0ML29c-1L2PVP00Gj-0002so; Tue, 18 Nov 2008 13:16:32 +0100\r\nMessage-ID: &lt;4922B36A.3090804@...&gt;\r\nDate: Tue, 18 Nov 2008 12:22:02 +0000\r\nUser-Agent: Thunderbird 2.0.0.17 (X11/20080925)\r\nMIME-Version: 1.0\r\nTo: rest-discuss@yahoogroups.com, \n &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nReferences: &lt;20151010.236871226919954532.JavaMail.servlet@kundenserver&gt; &lt;20081118005949.ab744bed.eric@...&gt;\r\nIn-Reply-To: &lt;20081118005949.ab744bed.eric@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Provags-ID: V01U2FsdGVkX1+Yib45DzOFcclqrHhhpgXtHGwtBmFUeXFNaAK\n L+3Csi8KJvArF2jMr0c0xtXHWSb9y7Nc1pzI5PNy9uVQxP7zC0\n X6y0lop14Q1T5CrUnLkYNxJI6eQZ8RT\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Mike &lt;mike@...&gt;\r\nSubject: Re: [rest-discuss] HTML5 and RESTful HTTP in browsers\r\nX-Yahoo-Group-Post: member; u=364579677; y=BhMZvfe8oXKrJkaOBNfo_aeYiEJ9CUr1dut599zMIdJ2mV0\r\nX-Yahoo-Profile: pleb1985\r\n\r\nEric J. Bowman wrote:\n&gt; On Mon, 17 Nov 2008 12:05:54 +0100\n&gt; mike@... wrote:\n&gt;   \n&gt;&gt; To my mind, the best situation would be to have both options\n&gt;&gt; available for developers. Although, I assume that specifying\n&gt;&gt; content-type in a URI is violating RESTful principals; theoretically\n&gt;&gt; at least.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; Not at all.  Horribly bad practice, though...  A URI identifies a\n&gt; resource, there&#39;s nothing theoretically wrong with two resources having\n&gt; the following identifiers (since they&#39;re opaque):\n&gt;\n&gt; http://example.org/image;type=image/png\n&gt; http://example.org/image;type=image/jpeg\n&gt;\n&gt; Coupling that parameter to the Content-Type header returned by the\n&gt; server can certainly be done, but why?  Standard practice would look\n&gt; something like this:\n&gt;\n&gt; http://example.org/image.png\n&gt; http://example.org/image.jpg\n&gt;\n&gt; With a corresponding server configuration which bases Content-Type on\n&gt; filename extension. These are separate resources, in either case.  What\n&gt; you&#39;re missing, is that both resources can also be representations of\n&gt; the following negotiated resource:\n&gt;\n&gt; http://example.org/image\n&gt;\n&gt; Either resource may be returned as a representation of /image, using\n&gt; content negotiation based on Accept header.  The response should also\n&gt; include a Content-Location header giving the URL of the resource used\n&gt; to fulfill the request, and a Vary: Accept header to explicitly inform\n&gt; clients and intermediaries that multiple representations exist.\n&gt;\n&gt; If an HTML author or generator wishes to explicitly link to the PNG or\n&gt; the JPG, they have all the information they need to do so and avoid\n&gt; using the negotiated URL altogether, if the situation warrants.\n&gt;\n&gt; So it seems to me that there&#39;s already plenty of mechanism in place to\n&gt; do exactly what it is that you want to do, without adding @accept.\n&gt;\n&gt;   \n&gt;&gt; One argument that can be made for providing the option for both\n&gt;&gt; methods is browser bookmarking - can anyone tell me how browsers\n&gt;&gt; store bookmarks; do they store the entire request complete with\n&gt;&gt; headers? If this is not the case, the only feasible way to provision\n&gt;&gt; typed bookmarking is to specify the type in the URL.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; A browser&#39;s bookmarks have nothing to do with HTTP headers, at least\n&gt; not in any that I&#39;ve ever seen.  Bookmarks are fairly portable between\n&gt; browsers these days, I&#39;ve partially implemented import/export between\n&gt; blogroll and browser even, they&#39;re just links annotated in one way or\n&gt; another.  AFAIK, browsers only care about HTTP headers for caching.\n&gt;\n&gt;   \n&gt;&gt; Does anyone else agree that an Accept attribute would be a useful\n&gt;&gt; tool for making browser interaction more RESTful? Is it worth\n&gt;&gt; persuing this issue with the HTML5 working group?\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; Yes and no, and no comment as regards WHATWG.  There are cases where a\n&gt; Web application may need to override the browser&#39;s request headers, of\n&gt; course JavaScript can do this these days, but you do have a point that\n&gt; some provision should be made in markup.\n&gt;\n&gt;   \n&gt;&gt; A browser and a markup language that support the HTTP protocol.. what\n&gt;&gt; a novel idea..!\n&gt;&gt;\n&gt;&gt; This is just standard HTTP stuff, right? Surely it needs to be\n&gt;&gt; supported?\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt;\n&gt; I&#39;m not sure what you mean by browsers not supporting HTTP, just\n&gt; because HTML disallows PUT doesn&#39;t mean browsers can&#39;t send PUT.  As\n&gt; far as better HTTP support in markup languages, this has already been\n&gt; done in XForms 1.1, using submission elements inside the &#39;model&#39;:\n&gt;\n&gt; &lt;xfm:submission method=&#39;get&#39; resource=&#39;http://example.org/image&#39;&gt;\n&gt; &lt;xfm:header&gt;\n&gt;  &lt;xfm:name&gt;Accept&lt;/xfm:name&gt;\n&gt;  &lt;xfm:value&gt;image/png&lt;/xfm:value&gt;\n&gt; &lt;/xfm:header&gt;\n&gt; &lt;/xfm:submission&gt;\n&gt;\n&gt; This would retrieve image.png but never image.jpg from /image .\n&gt;\n&gt;   \n&gt;&gt; I can&#39;t seedevelopers moving to implement multiple representations at\n&gt;&gt; single URIsif the browsers (and HTML) can&#39;t even make use of it\n&gt;&gt; without having toresort to all of this javascript voodoo nonsense.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; Developers have been implementing content negotiation for years, and\n&gt; browsers have sent request headers for years.  So browsers make use of\n&gt; negotiated resources all the time, the advantage to the developer is\n&gt; the opportunity to offer multiple representations without any advance\n&gt; knowledge of client preference or capability.\n&gt;\n&gt; Overriding clients&#39; innate HTTP headers without Javascript is a noble\n&gt; goal, but content negotiation is hardly useless, pointless or not\n&gt; implemented because of it, since conneg is done at the protocol level,\n&gt; and is not a function of media-type\nIf the solution uses JavaScript for Accept headers and PUT/DELETE \nrequests, is that browser support or JavaScript virtual machine support?\n\nMaybe someone can correct me here, but as I understand it; content types \nserved at a given URI are effectively that given resource&#39;s representations.\n\nA URI should be used to indicate a resource, but (even though it is \npossible) is it good practice for a resource to indicate a \nrepresentation? Clearly, this is common practice now, whether it is a \nquery parameter or a &#39;file extension&#39; - but it seems to me that this \nviolates the principal of what a resource is (at least according to my \ninterpretation of  the definition in Roy&#39;s dissertation). I would argue \nthat the reason for this is because HTML has not provided browsers with \na hypertext mechanism for protocol conneg. I think developers should at \nleast be given the option, personally.\n\nIsn&#39;t one of the benefits of statelessness that any state can be stored \nby a user (i.e. bookmarked)? If browsers aren&#39;t currently providing this \nfunctionality in a way which leverages these benefits - I agree entirely \nthat it is not feasible to completely discount conneg over URIs, but if \nno movement is made to have HTML encourage browsers to be better HTTP \nclients, it is likely that nothing will be done about it.\n\nRegards,\nMike\n\n"}}