{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"fSBqbr2D7_eQNX1zx1fxX69R3hTc7zuaORqUu1W7JFVbqNMM1efsNpZHNVkzNFRzLRE8r1937rels1KsjuKN046faXl7MmAGqwx6MbWiog","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Good examples of REST implementations","postDate":"1261253321","msgId":14240,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkxMjE5MTMwODQxLmU3MWRkNzc5LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEIwM0FGQUMxLUQ1QUUtNDREQS04NzVDLTJCOTlEMDU2RDBEMEBzdWJidS5vcmc+","referencesHeader":"PGhlbXBjaCszbGRuQGVHcm91cHMuY29tPgk8OUI4OTYwM0QtQTI4Mi00ODUwLUFDRkUtRjEyRjNBOTEwMzhEQGJibGZpc2gubmV0Pgk8ZWM4NjEzYTgwOTEyMTEwMjA5cjcwNGMwNjNhazM4MGNmYjQxYzVjZTY3MjNAbWFpbC5nbWFpbC5jb20+CTwyMDA5MTIxNTAxNTcwMS4xOWJjM2IxMy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxCMDNBRkFDMS1ENUFFLTQ0REEtODc1Qy0yQjk5RDA1NkQwRDBAc3ViYnUub3JnPg=="},"prevInTopic":14194,"nextInTopic":14242,"prevInTime":14239,"nextInTime":14241,"topicId":14060,"numMessagesInTopic":20,"msgSnippet":"... I think, as the hypertext constraint is a critical part of the REST architectural style, any system that falls short in this area can t be called REST at","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 53949 invoked from network); 19 Dec 2009 20:08:46 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m11.grp.re1.yahoo.com with QMQP; 19 Dec 2009 20:08:46 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.sp2.yahoo.com with SMTP; 19 Dec 2009 20:08:45 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 42AAE509DA;\n\tSat, 19 Dec 2009 15:08:44 -0500 (EST)\r\nDate: Sat, 19 Dec 2009 13:08:41 -0700\r\nTo: Subbu Allamaraju &lt;subbu@...&gt;\r\nCc: Ian Davis &lt;lists@...&gt;, swschilke &lt;steffen.schilke@...&gt;,\n rest-discuss@yahoogroups.com, Story Henry &lt;henry.story@...&gt;\r\nMessage-Id: &lt;20091219130841.e71dd779.eric@...&gt;\r\nIn-Reply-To: &lt;B03AFAC1-D5AE-44DA-875C-2B99D056D0D0@...&gt;\r\nReferences: &lt;hempch+3ldn@...&gt;\n\t&lt;9B89603D-A282-4850-ACFE-F12F3A91038D@...&gt;\n\t&lt;ec8613a80912110209r704c063ak380cfb41c5ce6723@...&gt;\n\t&lt;20091215015701.19bc3b13.eric@...&gt;\n\t&lt;B03AFAC1-D5AE-44DA-875C-2B99D056D0D0@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Good examples of REST implementations\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nSubbu Allamaraju wrote:\n&gt;\n&gt; IMHO, Roy&#39;s post below must be taken with a bit of reality mixed.\n&gt; Like most things in software, it is not an absolute standard to\n&gt; measure &quot;goodness&quot; of RESTful web services.\n&gt; \n\nI think, as the hypertext constraint is a critical part of the REST\narchitectural style, any system that falls short in this area can&#39;t be\ncalled REST at all.  The result is a different architectural style\naltogether.  Someone needs to name this style (preferably a name that&#39;s\nbuzzword-worthy) and analyze it in terms of networked software\narchitecture, just like REST is.  The result would enable a comparison\nchart to be made which lays out exactly what the differences are, in\nterms of constraints and desirable properties.\n\nIf a project can live without the desirable properties induced by REST,\nthen perhaps this other architectural style is appropriate for it.  But,\nsuch a project should not call itself REST, because that would imply\ndesirable properties exist on that system, when this can&#39;t be proven\ndue to the obvious lack of some constraint or other.  I really would\nlike to see this hypertext-constraint-less, but otherwise RESTful,\narchitectural style formalized for the plethora of REST claimants that\nare actually using this other style out in the wild.\n\nThe most important takeaways from Roy&#39;s post I linked to:\n\n&quot;\nA REST API should spend almost all of its descriptive effort in\ndefining the media type(s) used for representing resources and driving\napplication state, or in defining extended relation names and/or\nhypertext-enabled mark-up for existing standard media types. Any effort\nspent describing what methods to use on what URIs of interest should be\nentirely defined within the scope of the processing rules for a media\ntype... A REST API must not define fixed resource names or hierarchies\n(an obvious coupling of client and server).\n&quot;\n\nI&#39;ll describe this further, down below in my example.\n\n&gt;\n&gt; Most publicly visible web services are meant for mashing up data.\n&gt; Communicating URIs in representations is one thing, but using them to\n&gt; drive application flow is an entirely different beast. Most mashup\n&gt; scenarios require fair bit of control on the flow. Take Flickr for\n&gt; example. Even if it is fixed to use HTTP correctly, making it\n&gt; hypermedia driven for application flow does not get Flickr very far.\n&gt; \n\nAgreed.  REST is not the solution to all problems.  Neither is HTTP.\nThe Web, and the Internet itself, are constantly evolving new\narchitectural styles.  Take RFC 5694, for instance.  P2P is now gaining\nsome formalization as a networked-software architectural style.  This\nsort of formalization should also be applied to the plethora of\nnon-REST APIs out there that wouldn&#39;t be better off as REST, so there&#39;s\nsome common architectural ground rather than everyone just winging it.\n\n&gt;\n&gt; Of course, using hypermedia to drive application flow makes sense\n&gt; when the server can control the flow.\n&gt; \n\nExactly.  Let&#39;s take a look at part of Talis&#39; API:\n\nhttp://n2.talis.com/wiki/Contentbox\nhttp://n2.talis.com/wiki/Text_Search_Syntax\n\nThey&#39;ve spent all their effort in describing what methods to use on\nwhat URIs of interest, none of which are in-scope for RSS, while\ndefining fixed resource names and hierarchies.  There&#39;s no sense of\nwhat the Contentbox resource is...  The documentation defines\nthe /items resource as containing a list of content items.  But the\nprotocol returns a search form if /items is dereferenced, not a list of\ncontents.  The overall result is an ad-hoc XML-RPC interface to a media\ntype obsoleted by Atom (which has a corresponding protocol so you don&#39;t\nhave to make up one of your own, as this API does).\n\nI&#39;m being harsh, though.  Throw out all the query stuff and the\nprotocol stuff, and focus on the &quot;Platonic Ideal&quot; of the resource type\nidentified as &quot;Contentbox&quot; and there&#39;s plenty to work with in terms of\nmaking it into a REST resource. But first, a note on resource types,\nanother valuable takeaway from Roy&#39;s post, in light of ongoing debate\non this list around the issue:\n\n&quot;\nA REST API should never have &quot;typed&quot; resources that are significant to\nthe client. Specification authors may use resource types for describing\nserver implementation behind the interface, but those types must be\nirrelevant and invisible to the client. The only types that are\nsignificant to a client are the current representationâ€™s media type and\nstandardized relation names.\n&quot;\n\nIt&#39;s perfectly legit to refer to different resource types in this\napplication with different names.  For example, Contentbox and Metabox\nmake fine resource type names, but will ultimately be defined as\ndifferent media types, which is the only concern the client has.  (Don&#39;t\ntry to somehow couple client behavior to the abstract notion of\n&quot;Contentbox&quot; or &quot;Metabox&quot;, just use them to describe your API for human\nconsumption.)  If, instead of beginning by defining a URI allocation\nscheme, this REST API&#39;s designers had followed a disciplined REST\napproach, the first thing they would have done with Contentbox would&#39;ve\nbeen to define how it conceptually fits within their system.\n\nThere&#39;s nothing special about it, it&#39;s easy to grasp, it&#39;s an index for\na flat-file media collection, plus a search interface. Whatever its\ndirectory name, producing a list of its contents is as easy as using\n&quot;Options: Directories&quot; in Apache. That isn&#39;t quite what we want,\nthough.  There is a duality to the Contentbox resource: first, we want\nit to list all contents as per the underlying filesystem; second, we\nwant it to provide a metadata-driven search interface to the media\nfiles.  So I see two Contentbox resource subtypes: Contentbox-search and\nContentbox-index. I could combine the two into a single index-and-search\nresource, but I&#39;m not making that design choice, for reasons having\nnothing to do with REST, though.\n\nThe next step is to figure out what media types we want to apply to\nContentbox.  So we dip into our handy REST toolbox and find that most\nfeatures we want, like pagination and editing, already exist as defined\nstandards -- Atom and Atom Protocol, plus standard extensions like\nOpenSearch.  Pagination and search-syntax media-type extensions\ndefinitely have a say in the URI allocation scheme, which is why we\ndon&#39;t start there, we start by defining which media types to use, plus\nidentifying what our resources are.\n\nLet&#39;s start with Contentbox-index.  This is a paginated list of files,\nwhich can be presented in either XHTML or as an Atom Feed of Atom media\nentries.  The Atom Protocol service document identifies Contentbox-\nindex as an Atom Protocol collection.  Here&#39;s where we throw out this\nportion of the n2 API:\n\nhttp://n2.talis.com/wiki/Contentbox#Request_Parameters\n\nThe &quot;query&quot; parameter applies to Contentbox-search, more about that\nlater. The &quot;max&quot; and &quot;offset&quot; parameters, which create a cache-defeating\n&quot;sliding door&quot; are tossed in favor of individually-numbered (in the\nURI) pages of predetermined length, which implement pagination as per\nRFC 5005.  The &quot;sort&quot; parameter is tossed, that&#39;s a client-side behavior\nthat doesn&#39;t belong in the URI (except perhaps in Contentbox-search).\nThe xsl parameter implements transformation in a bass-ackwards fashion,\nand the desired output Content-Type doesn&#39;t belong in the URL.  To do\nso, instead of honoring the Accept header, is a violation of:\n\nhttp://www.w3.org/2001/tag/doc/mime-respect.html\n\nThe output Content-Type is what the author/server intends, as coded in\nthe XSLT document.  What&#39;s needed here, is some Content Negotiation.\nAt this point, it should be obvious that the URL of a Contentbox is\nirrelevant in a REST API, so instead of coupling it to /{storename}/\nitems and limiting a store to one Contentbox, it should be up to the\nuser to name it /{storename}/foo/ or /{storename}/bar/ or even \n/{storename}/foo/bar/, or all three.  I&#39;ll use /{storename}/items/ with\nthe trailing-slash for this example.\n\nFor the Contentbox-index resource, we want paginated output in either\nXHTML or Atom depending on client preference.  With conneg, this gives\nus a URI allocation scheme like so:\n\n/{storename}/items/\n/{storename}/items/;page=2\n/{storename}/items/;page=3\n\nEtc.  The server responds with a Vary: Accept header, with Content-\nLocation headers like so:\n\n/{storename}/items/index.html\n/{storename}/items/index.atom\n/{storename}/items/index.html;page=2\n/{storename}/items/index.atom;page=2\n/{storename}/items/index.html;page=3\n/{storename}/items/index.atom;page=3\n\nThis makes every representation a resource in its own right.  The\nContent-Location, Alternates and Vary headers make conneg visible, so\neven without documentation, the self-descriptive messaging reveals that\nit&#39;s possible to bypass content negotiation and directly request Atom or\nXHTML based on filename extension.  This is a logical approach; putting\nthe MIME type (or a token like &#39;atom&#39; or &#39;html&#39;) in a query string is\nnot.\n\nThe XHTML output is simply transformed from the Atom using XSLT.  If\nsomeone wants their own XSLT output, there are Web services out there\nwhich allow the input of a source URL (the .atom resource directly) and\na stylesheet URL, this doesn&#39;t belong in the Contentbox request URIs.\nThe XHTML variant can include a form which links to such a service and\nruns its Atom alternate through a user-specified stylesheet, i.e. we\ncan apply the hypertext constraint to this feature.\n\nInstead of starting with resource identification, media type and link\nrelation selection before getting to URIs, the designers of the n2 API\npicked a bookmark URI (/items) and added a bunch of features to it\nthrough the query string.  Had they followed a disciplined REST\napproach, I doubt that they would have wound up identifying Contentbox\nas a plethora of resources, i.e. each sort key creates two new resource\nsubtypes, one for ascending, the other for descending, etc.\n\nAt some point, seeing the number of semantically-identical first-class\nresources, and attempting to define a URI allocation scheme for them,\nwould have revealed itself as a problem.  This problem does not reveal\nitself when a URI is defined, and a sort feature is added in the query\nstring, because there is no sense of what the Contentbox resource *is*\nusing that approach.  A disciplined approach here leads to an order of\nmagnitude fewer URIs for the server to manage, while vastly increasing\ncache efficiency (once again exploding the myth that REST creates &quot;too\nmany URLs&quot;).\n\nOn to Contentbox-search.  Again, /{storename}/items should be able to\nuse any name not reserved by the system, instead of just /items.  But\nthe idea is the same -- we want to search the -index of the same\nContentbox&#39;s metadata, and return a representation in either XHTML or\nAtom depending on client preference, listing the links to the contained\nresources.  The query syntax used is standardized by using OpenSearch.\n\n/{storename}/items\n/{storename}/items.html\n/{storename}/items.atom\n\n/{storename}/items?q={searchTerms}\n/{storename}/items.html?q={searchTerms}\n/{storename}/items.atom?q={searchTerms}\n\n/{storename}/items?q={searchTerms}&p={startPage?}\n/{storename}/items.html?q={searchTerms}&p={startPage?}\n/{storename}/items.atom?q={searchTerms}&p={startPage?}\n\nI&#39;m aware that OpenSearch allows output format to be specified as part\nof the query string, but I still believe supported output formats\nshould be differentiated in the Path to support content negotiation,\nwhile also enabling conneg to be cleanly bypassed.  Once again, the\nXHTML output is transformed from the Atom, using XSLT on the server.\n\nIf sort order is enabled in the URIs, it should only be on Contentbox-\nsearch, and should be worked out as a proposed extension to OpenSearch\n(if there isn&#39;t already such a beast).  For Contentbox-index, page-by-\npage client-based sorting should do.  If that&#39;s too fine-grained, the\nuser has the option of using Contentbox-search instead.  Two interfaces\nto one filesystem; I like it.\n\nSo there&#39;s a RESTful re-work of n2&#39;s Contentbox API, no hard feelings I\nhope.  In a nutshell, my advice here is &quot;Just Use Atom (tm).&quot;  By\nstarting with the conceptual visualization of the Contentbox resource\ntype and discovering its subtypes, followed by the selection of standard\nmethods, media types / extensions, and link relations (first, last,\nprev, next, edit, alternate, etc.), before even _thinking_ about URI\nallocation schemes, a disciplined approach to REST is being followed.\n\nWhat I&#39;ve described here can be fleshed out into an API which doesn&#39;t\ndefine fixed resource names or hierarchies.  Resource interfaces are\ngeneric, not object-centric.  Interaction is driven by hypertext, not\nout-of-band information.  Interaction is cleanly separated from\nidentification.  The API may be cleanly documented by describing the\nContentbox resource in terms of media types and link relations --\nmethods don&#39;t bear mentioning as their use is entirely defined within\nthe processing rules of the media types. Any server written to it would\nhave the freedom to manage its own namespace.  The whole thing is based\non selecting the standard media types best suited to the task at hand.\n&quot;Contentbox&quot; as a resource-type is irrelevant and invisible to the\nclient, as are its -search and -index sub-resources.\n\nI may be long-winded, but I hope I&#39;ve come around full-circle back to\nmy original point of, &quot;Go read Roy&#39;s post on &#39;REST APIs must be\nhypertext-driven&#39; as it explains exactly where this API goes wrong.&quot;\nThe result of following his advice in my example here is a state-of-the-\nart, pragmatic solution to the problem at hand, which may be widely\nunderstood by implementers right out of the starting gate -- without any\nmurmurs from this list about not being &quot;Roy Fielding&#39;s REST&quot;...\n\n-Eric\n\n"}}