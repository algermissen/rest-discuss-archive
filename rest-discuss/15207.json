{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"u7bx11wL4MlhAyXkuhjWJFCxZ3tg0-b2WcmG_nrsVFOhpuWiReJpu1sRTcUfzuk5yle2OUD2f0qwzI2-x_Zpg6Ha8IKKyFcCw_ODrxM16A","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the sense of Roy&#39;s dissertation?","postDate":"1270947866","msgId":15207,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNDEwMTkwNDI2LmQzZTE1NDlhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PGhwbnE5YStpazVwQGVHcm91cHMuY29tPg==","referencesHeader":"PDRENTgzMjFCLUZBQjYtNEI4MS1COTA2LUZGRkNCOUY3RDE1NkBtYWMuY29tPgk8aHBucTlhK2lrNXBAZUdyb3Vwcy5jb20+"},"prevInTopic":15206,"nextInTopic":15210,"prevInTime":15206,"nextInTime":15208,"topicId":15152,"numMessagesInTopic":30,"msgSnippet":"I think we both fundamentally agree on REST, however I m going to argue every point you just made, anyway.  REST is technology, but discussing REST crosses","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 41280 invoked from network); 11 Apr 2010 01:05:16 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m4.grp.sp2.yahoo.com with QMQP; 11 Apr 2010 01:05:16 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.re1.yahoo.com with SMTP; 11 Apr 2010 01:05:15 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 8CD89509DA;\n\tSat, 10 Apr 2010 21:05:02 -0400 (EDT)\r\nDate: Sat, 10 Apr 2010 19:04:26 -0600\r\nTo: &quot;wahbedahbe&quot; &lt;andrew.wahbe@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100410190426.d3e1549a.eric@...&gt;\r\nIn-Reply-To: &lt;hpnq9a+ik5p@...&gt;\r\nReferences: &lt;4D58321B-FAB6-4B81-B906-FFFCB9F7D156@...&gt;\n\t&lt;hpnq9a+ik5p@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the\n sense of Roy&#39;s dissertation?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nI think we both fundamentally agree on REST, however I&#39;m going to argue\nevery point you just made, anyway.  REST is technology, but discussing\nREST crosses into the philosophical, so I believe there&#39;s a happy\nmedium between how you are saying things and how I am saying things.\nWe just have to find it.\n\n&quot;wahbedahbe&quot; wrote:\n&gt;\n&gt; I would come at this from a different angle and note that client\n&gt; features tend to drive the creation and evolution of markup languages.\n&gt;\n\nWhat client?  Are you referring to a user agent or its client\nconnector?  Sometimes, end-user features (accessibility) drive\ndevelopment of markup languages, which adopt a compatible accessibility\nmechanism and incorporate the new markup as an evolution, which user\nagents then implement.  Evolution is circular and not coupled to the\nneeds of any specific component or connector or hypertext language.\n\n&gt; \n&gt; Client requirements drive markup languages which drive client code.\n&gt; The existence of clients that support a markup language drives the\n&gt; development of services that represent their resources in that\n&gt; language in order to reach those clients.\n&gt; \n\nOr, user requirements drive markup languages which drive user agents.\nThe existence of user agents that support a markup language drives the\nadoption of the vocabulary the markup encompasses, by other markup\nlanguages and user agents, increasing the likelihood that services will\nbe developed for user agents which consume the vocabulary, but some\nservices were created as specific cases of the vocabulary to drive its\ndevelopment... IMNSHO, evolution is entirely circular, and this is a\nfeature of the Web in general and REST specifically.\n\nMarkup languages drive (or rather, guide) user agents, not user\ncomponents. Only user components drive user agents, by choosing state\ntransitions which manipulate either application state or\nrepresentations of resource state, or both.\n\n&gt;\n&gt; Serendipitous re-use tends to come from the declarative nature of\n&gt; markup languages that, via the principle of least power, enables\n&gt; secondary clients (e.g. spiders) to also be driven by the markup\n&gt; language designed around the primary client.\n&gt; \n\nSerendipitous re-use comes from applying the constraints of the uniform\ninterface; in particular self-descriptive stateless messaging, which\nincreases the likelihood of re-use even without a self-documenting API.\nIt isn&#39;t just a function of media type and domain-specific vocabulary.\n\nGooglebot is driven by Google&#39;s indexing/search service instructing it\nto follow its nose, guided by hypertext, from an entry point (bookmark).\n\n&gt;\n&gt; The primary client can also drive the behavior of the secondary\n&gt; clients.\n&gt;\n\nGaaah!  I don&#39;t understand these terms.  Do you mean that a REST\nsystem&#39;s native application (self-documenting hypertext API) can drive\nthe behavior of a third-party application?  If so, I agree, as I\nexplained in my response to Jan about how a third-party application can\nuse RDF to learn how to accomplish a goal by following the native\nhypertext, and elaborate on below.\n\n&gt;\n&gt; For example, Google&#39;s spider isn&#39;t just about indexing the\n&gt; data in web pages. It must prioritize the data presented to users\n&gt; when they view a page in the browser. If &quot;invisible&quot; data (e.g.\n&gt; meta-data or even data hidden via CSS) was given the same priority as\n&gt; visible data, then the service would be less valuable to its users.\n&gt; Google isn&#39;t indexing the browser input -- it is indexing the browser\n&gt; output (to your screen). The declarative nature of HTML makes it easy\n&gt; to derive output from input.\n&gt; \n\nReally?  You may know more about it than I do, but I&#39;ve never noticed\nGoogle index any image that I&#39;m linking to from CSS, or miss indexing\nan image linked to from HTML.  Screen readers are supposed to speak\nanything with a CSS property of visibility:hidden, but not speak\nanything with a CSS property of display:none.  I also argue that\nGooglebot has nothing to do with indexing -- that&#39;s done by the search/\nindexing service acting as the user component driving the Googlebot\nuser agent.\n\nGooglebot, though, doesn&#39;t render and parse steady-states -- my demo\napp would need a server-side transformation representation for each\nresource in order to support Googlebot.  So I&#39;d say Google is indexing\nrepresentations, not steady-states.  What prioritizes results is the\nmarkup:  //head/title is the most relevant, followed by //body/h1, and\nthe CSS is never checked to see if that h1 is display:none or not.\n\n&gt;\n&gt; The single biggest flaw in most REST system design today is that\n&gt; markup languages are being designed around the service&#39;s view of the\n&gt; data. The markup should be a declarative program for the client --\n&gt; saying &quot;what&quot; the client does with the data rather than &quot;how&quot; it does\n&gt; it. Folks are using markup to denote &quot;what&quot; the data means, but to\n&gt; the service rather than the client. The clients then have to be\n&gt; designed around the service semantics -- this binds them to the\n&gt; service just as much as RPC does.\n&gt; \n\nAgain, what do you mean by client?  User agent, or perhaps client\nconnector on a cache?  Specific terminology exists for us to use, and I\nthink we&#39;d all confuse each other a lot less by sticking with it more.\nI do agree that most REST API claimants are flawed by the creation of a\nmarkup language that&#39;s then declared a (unregistered) media type,\ndespite lacking a media type definition that encompasses methods.\n\nThe user component tells the user agent *what* to do, not the markup.\nIf the user component wants to post a comment to my weblog, it relies on\nthe markup to tell the user agent *how* to carry out its instructions.\nThe &quot;what&quot; is self-implied, the &quot;how&quot; is the problem markup addresses.\n\nMy weblog&#39;s origin server provides an XHTML representation to a user\nagent, the user agent renders it into a steady-state which provides the\nuser with a choice of possible state transitions.  The user knows *what*\nit wants to do, but not *how* to do it, that&#39;s where the user agent\ncomes in.\n\nThe user agent, when informed of the user&#39;s choice to post a comment to\nmy weblog as the next state transition, discovers *how* to carry out\nthis transition by following its nose to the rel=&#39;replies&#39; which leads\nit to discover what URI to target with what method and what media type\nto send.  IOW, *how* to post a comment is contained in the hypertext,\nwhich is why the hypertext is a self-documenting API.\n\nMost details required by a third-party developer to figure out my\nweblog API are explained by HTTP, Atom, Atom Protocol and the IANA\nlink-relation registry documentation.\n\nThe markup can&#39;t tell the user agent *what* to do, that would be nothing\nless than the origin server leading the user agent around by the nose,\ninstead of having the user agent follow its nose in response to user\naction.  The markup instructs the user agent *how* to execute the state\ntransitions it contains, i.e. what URI to target with what method and\nwhat, if any, query string and/or media type to send.\n\n&gt;\n&gt; I&#39;ve been saying for years\n&gt; ( http://tech.groups.yahoo.com/group/rest-discuss/message/8411 ) that\n&gt; with REST, the API is in the client. The markup is a declarative\n&gt; program written to that API --  and being declarative means it can be\n&gt; adapted to other APIs. The scripts are optional imperative programs\n&gt; to fill in the feature gaps of the markup language. Content\n&gt; negotiation allows a single service to use other markup languages to\n&gt; target other sets of APIs. If you design your markup languages around\n&gt; this line of reasoning, you will get a lot more mileage out of them.\n&gt; \n\nI&#39;d say the API *executes* in the client, not *is* in the client.  The\nAPI is *in* the representations and response codes sent from the origin\nserver. IOW, the API is *in* the origin server(s).  What&#39;s on the\nclient are either resource states, or application steady-states,\ndepending on if by client you mean the client connector on an\nintermediary, or the user agent...\n\nOr you can say the REST API is *in* the steady-states of the native\nhypertext application.  A Web browser and an Atom Reader are different\nuser agents which use my API differently.  How a Web browser is to\ninteract with my system is laid out explicitly, and the domain-specific\nvocabulary used may be the subject of a contract.  How an Atom Reader\nuses my API is implicit in the media type, link relations and response\ncodes (if not by service document).  But that&#39;s unsupported and not\npart of any such contract.\n\nA third-party developer extending an Atom Protocol client to work\nwithout a service document, do my PATCH thingie, and otherwise interact\nwith my system and its services my way, can come up with a nifty\napplication with its own steady-states that aren&#39;t anything like my own.\nIt&#39;s unsupported, though, because it wouldn&#39;t be following the hypertext\nconstraint (it&#39;s ad-hoc) and therefore couldn&#39;t _be_ covered by any\ncontract, unless I make such API explicit, which I won&#39;t do if it isn&#39;t\nREST.\n\nThat third-party application would be using its own API to my system,\nnot my API to my system.  Unless... The user agent compiles the site-\nwide GRDDL XSLT file, content-negotiates for the default representation\nand applies the transformation whenever it dereferences a resource, in\norder to obtain the RDF it can then use as the pattern for discovering\nand following state transitions carried out on Atom representations --\nif this third-party application is reading my Xforms model, then it&#39;s\nalso following my API to my system, not its own.\n\nBetter to follow the RDF instead of the Xforms model, though, and be\nable to discover the proper interface wherever it appears in whatever\nmedia type and forms system I go with, to decouple and allow independent\nevolution.\n\nRemember, I can expose any number of non-RESTful services with a RESTful\nAPI, just as I can expose any number of perfectly RESTful services with\na non-RESTful API, and anything in between.  Trust me, I&#39;m completely\ncapable, and quite experienced, at exposing my perfectly REST-capable\nservices with a non-RESTful weblog API.  ;-)  The trick is to create a\nREST API regardless of the underlying implementation, or even your\nflavor-of-the-eon choice of media type -- what if HTML 5 requires some\nparameter to text/html to &quot;version&quot; it, perish the thought being\ndebated seriously?\n\nWhat if HTML 5 doesn&#39;t include RDF attributes?  Then my RDF will have\nto map to different metadata than it does now, but it still will expose\nhow to find the rel=&#39;edit&#39; and rel=&#39;replies&#39; interfaces -- the third-\nparty user agent will then need to know HTML 5 to understand how Atom\nis manipulated by my native hypertext application when it&#39;s updated.\n\nOr, the user-agent can negotiate for a different media type, and\nreference the RDF associated with that media type, as my system will\nmaintain backwards compatibility so as to allow user agents to evolve\nindependently to support HTML 5, or not, as they see fit.  I have no\ncrystal ball, but I&#39;m prepared to fly whichever way the wind eventually\nblows me by using this RDF approach to defining my application for\nmachine users (especially the ones I intend to code for site moderation\nand maintenance, I&#39;m maintaining backwards compatibility primarily out\nof self-interest, so my own applications may independently evolve).\n\nThanks for everyone&#39;s patience who&#39;s actually been reading through my\nwaxing philosophical about REST the last few days.  I&#39;m putting my mind\nto the machine-user problem I hadn&#39;t given much thought to before, and\nreally fleshing out my ideas through prosaic debate... not to mention\ngrasping the notion that m2m is the principal principle of the Semantic\nWeb and adopting it, finally, into my plans and talking-points for m2m.\n\n-Eric\n\n"}}