{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":242972596,"authorName":"Jørn Wildt","from":"=?iso-8859-1?Q?J=F8rn_Wildt?= &lt;jw@...&gt;","profile":"jorn_lind_nielsen","replyTo":"SENDER","senderId":"hn9wgvm1laDJVWAXDCJO8fMKRUwq6cEdRAHdr3lFD5JgRS-VL_2cP9nOkhfe_qvXqiZHCN6no_IZkSln7-m1PPqVaFwobwYDhti3VIDRBqVn3KBoBs1JEJo","spamInfo":{"isSpam":false,"reason":"3"},"subject":"Re: [rest-discuss] The &quot;purist&quot; C# REST client?","postDate":"1260479179","msgId":14117,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PENEQjUyMkFGQjE3MDQxQjlBNEIwRDM1MEQ2RUFBM0UyQEpyblBDPg==","inReplyToHeader":"PGI1NDhkZjY1MDkxMjA5MTQ1OGwyNTQ4Y2UyZG9hNGZiYzJlYWZmNmU5Y2M1QG1haWwuZ21haWwuY29tPg==","referencesHeader":"PEI1QUM5MEYyODQ5MzQ5OEI5MEU2MjAzRERFMkE0RTY1QEpyblBDPiA8YjU0OGRmNjUwOTEyMDkxNDU4bDI1NDhjZTJkb2E0ZmJjMmVhZmY2ZTljYzVAbWFpbC5nbWFpbC5jb20+"},"prevInTopic":14115,"nextInTopic":14118,"prevInTime":14116,"nextInTime":14118,"topicId":14110,"numMessagesInTopic":12,"msgSnippet":"... Yes, I understand this. From a framework point of view it s left to the programmer to decide what kind of object-builder to register with a certain mime","rawEmail":"Return-Path: &lt;jw@...&gt;\r\nX-Sender: jw@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 12393 invoked from network); 10 Dec 2009 21:05:51 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m3.grp.sp2.yahoo.com with QMQP; 10 Dec 2009 21:05:51 -0000\r\nX-Received: from unknown (HELO smtp1.cybercity.dk) (212.242.43.251)\n  by mta2.grp.sp2.yahoo.com with SMTP; 10 Dec 2009 21:05:51 -0000\r\nX-Received: from uf5.cybercity.dk (uf5.cybercity.dk [212.242.42.163])\n\tby smtp1.cybercity.dk (Postfix) with ESMTP id 0DB67586845;\n\tThu, 10 Dec 2009 22:08:52 +0100 (CET)\r\nX-Received: from JrnPC (port439.ds1-aroe.adsl.cybercity.dk [212.242.220.134])\n\t(Authenticated sender: dsl164923)\n\tby uf5.cybercity.dk (Postfix) with ESMTPA id CCFA82059A6;\n\tThu, 10 Dec 2009 22:05:27 +0100 (CET)\r\nMessage-ID: &lt;CDB522AFB17041B9A4B0D350D6EAA3E2@JrnPC&gt;\r\nTo: &quot;mike amundsen&quot; &lt;mamund@...&gt;\r\nCc: &quot;rest-discuss&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nReferences: &lt;B5AC90F28493498B90E6203DDE2A4E65@JrnPC&gt; &lt;b548df650912091458l2548ce2doa4fbc2eaff6e9cc5@...&gt;\r\nIn-Reply-To: &lt;b548df650912091458l2548ce2doa4fbc2eaff6e9cc5@...&gt;\r\nDate: Thu, 10 Dec 2009 22:06:19 +0100\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tformat=flowed;\n\tcharset=&quot;iso-8859-1&quot;;\n\treply-type=original\r\nContent-Transfer-Encoding: 8bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Windows Mail 6.0.6002.18005\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.0.6002.18005\r\nX-eGroups-Msg-Info: 2:3:4:0:0\r\nFrom: =?iso-8859-1?Q?J=F8rn_Wildt?= &lt;jw@...&gt;\r\nSubject: Re: [rest-discuss] The &quot;purist&quot; C# REST client?\r\nX-Yahoo-Group-Post: member; u=242972596; y=6rn-LlbetXK7ZLp_7FUVAm7m_5q7ua7b5Aj6y26FFJcVhbqqj9_h6fQ7_Ho\r\nX-Yahoo-Profile: jorn_lind_nielsen\r\n\r\n&gt; Using serializers also tends to lead programmers to\n&gt; tight-binding between the code and the HTTP\n&gt; response body. This means\n&gt; changes in the body may blow the serializer code.\n\nYes, I understand this. From a framework point of view it&#39;s left to the \nprogrammer to decide what kind of object-builder to register with a certain \nmime type. It can be a very specific parser/builder (like the movie example, \nor an image file) or a very loose builder (like a generic XML DOM object).\n\n&gt; I suspect you&#39;ll find that building a client to properly locate, identify,\n&gt; and understand the link semantics of a single media type\n&gt; (application/vnd.movies.movie+xml) is challenging by itself.\n\nFor a well documented and stable mime type it should not be a problem. But \nmaybe I have something to learn here :-)\n\n&gt; Building one\n&gt; that handles multiple media-types just adds to the fun\n\nThat&#39;s why the framework allows registration of one handler per mime type. \nMakes coding them quite a bit easier. Instead of having one handler for all \nmime types. But maybe I misunderstand you.\n\n&gt; I also encourage you to treat HTTP control data (headers) as top-level\n&gt; programming objects in your library\n\nWill do.\n\nThanks for the feedback, J�rn\n\n----- Original Message ----- \nFrom: &quot;mike amundsen&quot; &lt;mamund@...&gt;\nTo: &quot;J�rn Wildt&quot; &lt;jw@...&gt;\nCc: &quot;rest-discuss&quot; &lt;rest-discuss@yahoogroups.com&gt;\nSent: Wednesday, December 09, 2009 11:58 PM\nSubject: Re: [rest-discuss] The &quot;purist&quot; C# REST client?\n\n\nJ�rn:\n\nThis line stands out first: &quot;I have avoided Atom Links since, in my\nexperience, these don&#39;t serialize well in the C# standard XML serializer.&quot;\nMy advice is to be wary of serializers when coding for HTTP. There are so\nmany variances with incoming responses I think you&#39;ll find it a real task to\nbuild apps based on  successfully converting incoming response bodies into\ncode-able objects. Using serializers also tends to lead programmers to\ntight-binding between the code and the HTTP response body. This means\nchanges in the body may blow the serializer code. This is especially true\nwhen working with &quot;generic&quot; media-types such as XML and JSON, etc. since\nthey have very little semantic value built into them.\n\nThat leads me to another bit of advice I&#39;ll offer: think about link\nsemantics from the very start when creating your library. The Web browser\nclient works because the link semantics of the HTML media-type are\nwell-defined (and pretty narrow). There are a limited number of link\nelements. Some are in-doc links (IMG, LINK, SCRIPT, etc.), some are\nnavigational links (A, FORM). All, except FORM, are limited to using the GET\nmethod. It&#39;s the semantic model of HTML that allows browsers to properly\nhandle HTTP responses from previously unknown locations and still provide\nfull functionality - even a decade after the semantics where defined. I\nsuspect you&#39;ll find that building a client to properly locate, identify,\nand understand the link semantics of a single media type\n(application/vnd.movies.movie+xml) is challenging by itself. Building one\nthat handles multiple media-types just adds to the fun&lt;g&gt;.\n\nI also encourage you to treat HTTP control data (headers) as top-level\nprogramming objects in your library. Allowing programmers to decorate\nrequests with control data (content-encoding, media-type, authorization,\ncache-control, etc.) and have direct access to the control data on responses\nwill improve the flexibility of any client/server built w/ your library.\n\nIn the big picture, I prefer looking at HTTP programming from the\nstand-point of &quot;resource programming.&quot; I look for a code library that lets\nme define a resource, associate or or more URIs with that resource, handle\nmultiple representations of the resource (for both requests and response\nbodies), and properly decorate requests and responses w/ control data. I\nalso want to make sure it handles mime-types properly (conneg included),\nconditional requests (GET and PUT), and supports flexible authentication\nmodels.\n\nFWIW, I started work on a REST-ful HTTP C# framework a while back [1]. It&#39;s\nbeen dormant for quite some time as the current version works well for me,\nbut there are lots of places it needs work. I&#39;ve also built an HTTP\nutilities library [2] with most all the bits I need for building REST-ful\nHTTP apps. It&#39;s smaller and lighter than my &#39;framework&#39; library. I mention\nthese as some of the code there might be helpful and/or act as a cautionary\ntale as you work on your own projects.\n\nmca\nhttp://amundsen.com/blog/\n\n[1] http://exyus.com\n[2]\nhttp://code.google.com/p/mikeamundsen/source/browse/#svn/trunk/Amundsen.Utilities\n\n\n\nOn Wed, Dec 9, 2009 at 17:00, J�rn Wildt &lt;jw@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; There has been a lot of discussion about the right way to implement a REST\n&gt; service, but less focus on how you would actually code a client. I have \n&gt; been\n&gt; looking at RESTFulie[1], Subbu Alamarju[2], and the Starbucks[3] example,\n&gt; and would like to discuss a similar typed approach in C#.\n&gt;\n&gt; I am experimenting with an actual implementation and would like some\n&gt; feedback before getting too far :-)\n&gt;\n&gt; Thanks, J�rn\n&gt;\n&gt;\n&gt; [1] http://github.com/caelum/restfulie\n&gt; [2] http://www.infoq.com/articles/subbu-allamaraju-rest\n&gt; [3] http://www.infoq.com/articles/webber-rest-workflow\n&gt;\n&gt;\n&gt; *Service example documentation*\n&gt; In order to discuss a REST client we need a service example. My first use\n&gt; case is a movie shop where we can search for movies in a specific \n&gt; category.\n&gt; To do so the shop has published a single search service URL template:\n&gt; http://movies.org/movies?category={category&lt;http://movies.org/movies?category=%7Bcategory&gt;}.\n&gt;\n&gt;\n&gt; The shop also publishes three ressource mime types:\n&gt;\n&gt; // Example &quot;application/vnd.movies.movie+xml&quot;\n&gt; &lt;Movie&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;   &lt;Category&gt;Thriller&lt;/Category&gt;\n&gt;   &lt;Director href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt; &lt;/Movie&gt;\n&gt;\n&gt;  // Example &quot;application/vnd.movies.movie-collection+xml&quot;\n&gt; &lt;Movies&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies?category=Thriller&quot;/&gt;\n&gt;   &lt;Movie&gt;\n&gt;     &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;     &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;/Movie&gt;\n&gt;    &lt;Movie&gt;...&lt;/Movie&gt;\n&gt;   &lt;Movie&gt;...&lt;/Movie&gt;\n&gt; &lt;/Movies&gt;\n&gt;\n&gt; // Example &quot;application/vnd.movies.person+xml&quot;\n&gt; &lt;Person&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt;   &lt;Name&gt;Richard Strangelove&lt;/Name&gt;\n&gt;   &lt;Photo href=&quot;http://facebook.com/photos/hh31y1&quot;/&gt;\n&gt; &lt;/Person&gt;\n&gt;\n&gt; Comments\n&gt;\n&gt; - I have avoided Atom Links since, in my experience, these don&#39;t serialize\n&gt; well in the C# standard XML serializer. You could although create your own\n&gt; serializer, so this is not an important restriction.\n&gt;\n&gt; - Notice how the person type has external references :-)\n&gt;\n&gt;\n&gt; *Code example - Searching*\n&gt; The cleanest client usage I can come up with is:\n&gt;\n&gt;   // A link (template). This should be fetched from a configuration file.\n&gt;   Link MoviesSearchLink = new Link(&quot;\n&gt; http://movies.org/movies?category={category}&quot;);\n&gt;\n&gt;   // Anonymous class with search parameters. Reflection is used to extract\n&gt; values.\n&gt;   // This is about the simplest way to write a &quot;fixed hashmap&quot; in C#\n&gt;   var movieSearchParameter = new { category = &quot;Thriller&quot; };\n&gt;\n&gt;   // Get ressource stored at the link endpoint\n&gt;   MovieCollection movies =\n&gt; MoviesSearchLink.Get&lt;MovieCollection&gt;(movieSearchParameter);\n&gt;\n&gt;   // Iterate over all movies and print title\n&gt;   foreach (Movie movie in movies)\n&gt;     Console.WriteLine(&quot;Title: &quot; + movie.Title);\n&gt; Comments:\n&gt;\n&gt; - A Link is untyped. We do not know what lies at the end of it.\n&gt;\n&gt; - A link knows how to merge parameters into URL templates.\n&gt;\n&gt; - The result of GETing a link is typed. The actual type is defined by the\n&gt; returned mime type.\n&gt;\n&gt; - In order to do something usefull with the search we must assume that it\n&gt; returns a MovieCollection. Hence the generic type specifier in the \n&gt; Get&lt;T&gt;()\n&gt; method. This is apriori information which I cannot see how to code \n&gt; without.\n&gt;\n&gt;\n&gt; *Parsing ressources*\n&gt; One piece of magic is how Get&lt;MovieCollection&gt;(params) knows how to \n&gt; convert\n&gt; the bytes returned from the endpoint to a MovieCollection. For this we\n&gt; create a MimeTypeRegistry:\n&gt;\n&gt;   MimeTypeRegistry.Register&lt;MovieCollection,\n&gt; MovieCollectionBuilder&gt;(&quot;application/vnd.movies.movie-collection&quot;);\n&gt;\n&gt; which is equal to:\n&gt;\n&gt;    MimeTypeRegistry.Register(typeof(MovieCollection),\n&gt; typeof(MovieCollectionBuilder), \n&gt; &quot;application/vnd.movies.movie-collection&quot;);\n&gt;\n&gt; This means: when ever we must parse a specific mime type, we look up a\n&gt; builder in the registry and uses this to parse the returned ressource\n&gt; representation.\n&gt;\n&gt; The typed Get&lt;MovieCollection&gt;(params) method GETs the ressource data,\n&gt; instantiates the corresponding builder, verifies that the built object \n&gt; type\n&gt; matches the requested and returns the built object.\n&gt;\n&gt; Comments:\n&gt;\n&gt; - This is static typing which RESTafarians seems to shy away from. But the\n&gt; type depends on the returned ressource, _not_ the URL. So to my knowledge\n&gt; this is fine.\n&gt;\n&gt; - It is not required to use the type safe Get&lt;T&gt;(), you could also call\n&gt; Get() which returns an object. The actual returned type then depends \n&gt; solely\n&gt; on the mime type of the ressource, and it is up to the programmer to \n&gt; decide\n&gt; what to do with it.\n&gt;\n&gt; - I am quite sure you can write some pretty generic XML builders without\n&gt; much overhead.\n&gt;\n&gt; - This is not limited to XML, you could add image/jpeg and other well \n&gt; known\n&gt; mime types. You just need to supply a proper builder.\n&gt;\n&gt;\n&gt; *Code example - Getting sub-ressources*\n&gt; Now we want to get information about the director of the movie:\n&gt;\n&gt;   // One of the returned self links from the search query\n&gt;   Link movieLink = movies[0].Self;\n&gt;\n&gt;   // Get the actual movie\n&gt;   Movie movie = movieLink.Get&lt;Movie&gt;();\n&gt;\n&gt;   // Get the director\n&gt;   MoviePerson director = movie.Director.Get&lt;MoviePerson&gt;();\n&gt;\n&gt; Comments:\n&gt;\n&gt; - There are no hard coded links here.\n&gt;\n&gt; - The only apriori information we use is the knowledge of the types of the\n&gt; referenced ressources. These types are documented in the mime type in \n&gt; which\n&gt; the links are used.\n&gt;\n&gt;\n&gt; *Versioning*\n&gt; Now our wonderfull movie shop decides to be able to sell and rate movies.\n&gt; They do their own selling, but uses the fameous ratings.org service to\n&gt; rate their movies. So the shop creates a new version of the movie mime \n&gt; type:\n&gt;\n&gt; // Example &quot;application/vnd.movies.movie.*v2*+xml&quot;\n&gt; &lt;Movie&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;   &lt;Category&gt;Thriller&lt;/Category&gt;\n&gt;   &lt;Director href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt;   &lt;Orders href=&quot;http://movies.org/movies/91/orders&quot;/&gt;\n&gt;   &lt;Ratings href=\n&gt; http://ratings.org/ratings?item=http%3a%2f%2fmovies.org%2fmovies%2f91/&gt;\n&gt; &lt;/Movie&gt;\n&gt;\n&gt; In order to service both old and new clients the shop decides to return \n&gt; the\n&gt; initial movie mime type by default. Never clients should use the Accept\n&gt; header to indicate that they want the new version. The same goes for the\n&gt; movies collection type.\n&gt;\n&gt; Our existing client code works happily as it did before.\n&gt;\n&gt;\n&gt; *Code example - A new client*\n&gt; The new client code would look like this:\n&gt;\n&gt;    // A link (template). This should be fetched from a configuration file.\n&gt;   Link MoviesSearchLink = new Link(&quot;\n&gt; http://movies.org/movies?category={category}&quot;);\n&gt;\n&gt;   // Anonymous class with search parameters. Reflection is used to extract\n&gt; values.\n&gt;   // This is about the simplest way to write a &quot;fixed hashmap&quot; in C#\n&gt;   var movieSearchParameter = new { category = &quot;thriller&quot; };\n&gt;\n&gt;   // Setting up the Accept header\n&gt;   var movieSearchHeaders = new { Accept =\n&gt; &quot;application/vnd.movies.movie-collection.v2&quot; }\n&gt;\n&gt;   // Get ressource stored at the link endpoint\n&gt;   MovieCollection movies =\n&gt; MoviesSearchLink.Get&lt;MovieCollection&gt;(movieSearchParameter,\n&gt; movieSearchHeaders);\n&gt;\n&gt;   // Iterate over all movies and print title\n&gt;   foreach (Movie movie in movies)\n&gt;     Console.WriteLine(&quot;Title: &quot; + movie.Title);\n&gt;\n&gt; *Code example - Buying movies*\n&gt; Now we have a movie which has an embedded link to it&#39;s sales orders. To \n&gt; buy\n&gt; a movie we post a new order to the sales order collection:\n&gt;\n&gt;    // One of the returned self links from the search query\n&gt;   Link movieLink = movies[0].Self;\n&gt;\n&gt;   // Get the actual movie\n&gt;   Movie movie = movieLink.Get&lt;Movie&gt;();\n&gt;\n&gt;   // Create a new order request\n&gt;   MovieOrderRequest orderRequest = new MovieOrderRequest(movie.Self, 1 /*\n&gt; quantity */);\n&gt;\n&gt;   // Post the order request to the order collection\n&gt;   // Assume it returns the newly created order\n&gt;   MovieOrder order = movie.Orders.Post(orderRequest);\n&gt;\n&gt; Comments:\n&gt;\n&gt; - The POST result in a redirect to the newly created order. The system \n&gt; GETs\n&gt; this new order and returns it. This means we loose the intermediate data\n&gt; returned from the POST.\n&gt;\n&gt;\n&gt; *Other verbs*\n&gt; The Link class is has built-in support for GET/PUT/POST/DELETE. Other \n&gt; verbs\n&gt; can be executed through a generic &quot;Request&quot; method:\n&gt;\n&gt;   SomeType x = someLink.Request(&quot;SOMEVERB&quot;, somePayload);\n&gt;\n&gt;\n&gt; *Caching*\n&gt; The Link class and it&#39;s associted methods should of course respect ETag \n&gt; and\n&gt; if-not-modified-since etc. This would require the framework to be\n&gt; initialized with a cache implementation of some kind.\n&gt;\n&gt;\n&gt; *Error handling*\n&gt; I would suggest using execptions for error handling.\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; \n\n----- Original Message ----- \nFrom: &quot;mike amundsen&quot; &lt;mamund@...&gt;\nTo: &quot;J�rn Wildt&quot; &lt;jw@...&gt;\nCc: &quot;rest-discuss&quot; &lt;rest-discuss@yahoogroups.com&gt;\nSent: Wednesday, December 09, 2009 11:58 PM\nSubject: Re: [rest-discuss] The &quot;purist&quot; C# REST client?\n\n\nJ�rn:\n\nThis line stands out first: &quot;I have avoided Atom Links since, in my\nexperience, these don&#39;t serialize well in the C# standard XML serializer.&quot;\nMy advice is to be wary of serializers when coding for HTTP. There are so\nmany variances with incoming responses I think you&#39;ll find it a real task to\nbuild apps based on  successfully converting incoming response bodies into\ncode-able objects. Using serializers also tends to lead programmers to\ntight-binding between the code and the HTTP response body. This means\nchanges in the body may blow the serializer code. This is especially true\nwhen working with &quot;generic&quot; media-types such as XML and JSON, etc. since\nthey have very little semantic value built into them.\n\nThat leads me to another bit of advice I&#39;ll offer: think about link\nsemantics from the very start when creating your library. The Web browser\nclient works because the link semantics of the HTML media-type are\nwell-defined (and pretty narrow). There are a limited number of link\nelements. Some are in-doc links (IMG, LINK, SCRIPT, etc.), some are\nnavigational links (A, FORM). All, except FORM, are limited to using the GET\nmethod. It&#39;s the semantic model of HTML that allows browsers to properly\nhandle HTTP responses from previously unknown locations and still provide\nfull functionality - even a decade after the semantics where defined. I\nsuspect you&#39;ll find that building a client to properly locate, identify,\nand understand the link semantics of a single media type\n(application/vnd.movies.movie+xml) is challenging by itself. Building one\nthat handles multiple media-types just adds to the fun&lt;g&gt;.\n\nI also encourage you to treat HTTP control data (headers) as top-level\nprogramming objects in your library. Allowing programmers to decorate\nrequests with control data (content-encoding, media-type, authorization,\ncache-control, etc.) and have direct access to the control data on responses\nwill improve the flexibility of any client/server built w/ your library.\n\nIn the big picture, I prefer looking at HTTP programming from the\nstand-point of &quot;resource programming.&quot; I look for a code library that lets\nme define a resource, associate or or more URIs with that resource, handle\nmultiple representations of the resource (for both requests and response\nbodies), and properly decorate requests and responses w/ control data. I\nalso want to make sure it handles mime-types properly (conneg included),\nconditional requests (GET and PUT), and supports flexible authentication\nmodels.\n\nFWIW, I started work on a REST-ful HTTP C# framework a while back [1]. It&#39;s\nbeen dormant for quite some time as the current version works well for me,\nbut there are lots of places it needs work. I&#39;ve also built an HTTP\nutilities library [2] with most all the bits I need for building REST-ful\nHTTP apps. It&#39;s smaller and lighter than my &#39;framework&#39; library. I mention\nthese as some of the code there might be helpful and/or act as a cautionary\ntale as you work on your own projects.\n\nmca\nhttp://amundsen.com/blog/\n\n[1] http://exyus.com\n[2]\nhttp://code.google.com/p/mikeamundsen/source/browse/#svn/trunk/Amundsen.Utilities\n\n\n\nOn Wed, Dec 9, 2009 at 17:00, J�rn Wildt &lt;jw@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; There has been a lot of discussion about the right way to implement a REST\n&gt; service, but less focus on how you would actually code a client. I have \n&gt; been\n&gt; looking at RESTFulie[1], Subbu Alamarju[2], and the Starbucks[3] example,\n&gt; and would like to discuss a similar typed approach in C#.\n&gt;\n&gt; I am experimenting with an actual implementation and would like some\n&gt; feedback before getting too far :-)\n&gt;\n&gt; Thanks, J�rn\n&gt;\n&gt;\n&gt; [1] http://github.com/caelum/restfulie\n&gt; [2] http://www.infoq.com/articles/subbu-allamaraju-rest\n&gt; [3] http://www.infoq.com/articles/webber-rest-workflow\n&gt;\n&gt;\n&gt; *Service example documentation*\n&gt; In order to discuss a REST client we need a service example. My first use\n&gt; case is a movie shop where we can search for movies in a specific \n&gt; category.\n&gt; To do so the shop has published a single search service URL template:\n&gt; http://movies.org/movies?category={category&lt;http://movies.org/movies?category=%7Bcategory&gt;}.\n&gt;\n&gt;\n&gt; The shop also publishes three ressource mime types:\n&gt;\n&gt; // Example &quot;application/vnd.movies.movie+xml&quot;\n&gt; &lt;Movie&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;   &lt;Category&gt;Thriller&lt;/Category&gt;\n&gt;   &lt;Director href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt; &lt;/Movie&gt;\n&gt;\n&gt;  // Example &quot;application/vnd.movies.movie-collection+xml&quot;\n&gt; &lt;Movies&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies?category=Thriller&quot;/&gt;\n&gt;   &lt;Movie&gt;\n&gt;     &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;     &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;/Movie&gt;\n&gt;    &lt;Movie&gt;...&lt;/Movie&gt;\n&gt;   &lt;Movie&gt;...&lt;/Movie&gt;\n&gt; &lt;/Movies&gt;\n&gt;\n&gt; // Example &quot;application/vnd.movies.person+xml&quot;\n&gt; &lt;Person&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt;   &lt;Name&gt;Richard Strangelove&lt;/Name&gt;\n&gt;   &lt;Photo href=&quot;http://facebook.com/photos/hh31y1&quot;/&gt;\n&gt; &lt;/Person&gt;\n&gt;\n&gt; Comments\n&gt;\n&gt; - I have avoided Atom Links since, in my experience, these don&#39;t serialize\n&gt; well in the C# standard XML serializer. You could although create your own\n&gt; serializer, so this is not an important restriction.\n&gt;\n&gt; - Notice how the person type has external references :-)\n&gt;\n&gt;\n&gt; *Code example - Searching*\n&gt; The cleanest client usage I can come up with is:\n&gt;\n&gt;   // A link (template). This should be fetched from a configuration file.\n&gt;   Link MoviesSearchLink = new Link(&quot;\n&gt; http://movies.org/movies?category={category}&quot;);\n&gt;\n&gt;   // Anonymous class with search parameters. Reflection is used to extract\n&gt; values.\n&gt;   // This is about the simplest way to write a &quot;fixed hashmap&quot; in C#\n&gt;   var movieSearchParameter = new { category = &quot;Thriller&quot; };\n&gt;\n&gt;   // Get ressource stored at the link endpoint\n&gt;   MovieCollection movies =\n&gt; MoviesSearchLink.Get&lt;MovieCollection&gt;(movieSearchParameter);\n&gt;\n&gt;   // Iterate over all movies and print title\n&gt;   foreach (Movie movie in movies)\n&gt;     Console.WriteLine(&quot;Title: &quot; + movie.Title);\n&gt; Comments:\n&gt;\n&gt; - A Link is untyped. We do not know what lies at the end of it.\n&gt;\n&gt; - A link knows how to merge parameters into URL templates.\n&gt;\n&gt; - The result of GETing a link is typed. The actual type is defined by the\n&gt; returned mime type.\n&gt;\n&gt; - In order to do something usefull with the search we must assume that it\n&gt; returns a MovieCollection. Hence the generic type specifier in the \n&gt; Get&lt;T&gt;()\n&gt; method. This is apriori information which I cannot see how to code \n&gt; without.\n&gt;\n&gt;\n&gt; *Parsing ressources*\n&gt; One piece of magic is how Get&lt;MovieCollection&gt;(params) knows how to \n&gt; convert\n&gt; the bytes returned from the endpoint to a MovieCollection. For this we\n&gt; create a MimeTypeRegistry:\n&gt;\n&gt;   MimeTypeRegistry.Register&lt;MovieCollection,\n&gt; MovieCollectionBuilder&gt;(&quot;application/vnd.movies.movie-collection&quot;);\n&gt;\n&gt; which is equal to:\n&gt;\n&gt;    MimeTypeRegistry.Register(typeof(MovieCollection),\n&gt; typeof(MovieCollectionBuilder), \n&gt; &quot;application/vnd.movies.movie-collection&quot;);\n&gt;\n&gt; This means: when ever we must parse a specific mime type, we look up a\n&gt; builder in the registry and uses this to parse the returned ressource\n&gt; representation.\n&gt;\n&gt; The typed Get&lt;MovieCollection&gt;(params) method GETs the ressource data,\n&gt; instantiates the corresponding builder, verifies that the built object \n&gt; type\n&gt; matches the requested and returns the built object.\n&gt;\n&gt; Comments:\n&gt;\n&gt; - This is static typing which RESTafarians seems to shy away from. But the\n&gt; type depends on the returned ressource, _not_ the URL. So to my knowledge\n&gt; this is fine.\n&gt;\n&gt; - It is not required to use the type safe Get&lt;T&gt;(), you could also call\n&gt; Get() which returns an object. The actual returned type then depends \n&gt; solely\n&gt; on the mime type of the ressource, and it is up to the programmer to \n&gt; decide\n&gt; what to do with it.\n&gt;\n&gt; - I am quite sure you can write some pretty generic XML builders without\n&gt; much overhead.\n&gt;\n&gt; - This is not limited to XML, you could add image/jpeg and other well \n&gt; known\n&gt; mime types. You just need to supply a proper builder.\n&gt;\n&gt;\n&gt; *Code example - Getting sub-ressources*\n&gt; Now we want to get information about the director of the movie:\n&gt;\n&gt;   // One of the returned self links from the search query\n&gt;   Link movieLink = movies[0].Self;\n&gt;\n&gt;   // Get the actual movie\n&gt;   Movie movie = movieLink.Get&lt;Movie&gt;();\n&gt;\n&gt;   // Get the director\n&gt;   MoviePerson director = movie.Director.Get&lt;MoviePerson&gt;();\n&gt;\n&gt; Comments:\n&gt;\n&gt; - There are no hard coded links here.\n&gt;\n&gt; - The only apriori information we use is the knowledge of the types of the\n&gt; referenced ressources. These types are documented in the mime type in \n&gt; which\n&gt; the links are used.\n&gt;\n&gt;\n&gt; *Versioning*\n&gt; Now our wonderfull movie shop decides to be able to sell and rate movies.\n&gt; They do their own selling, but uses the fameous ratings.org service to\n&gt; rate their movies. So the shop creates a new version of the movie mime \n&gt; type:\n&gt;\n&gt; // Example &quot;application/vnd.movies.movie.*v2*+xml&quot;\n&gt; &lt;Movie&gt;\n&gt;   &lt;Self href=&quot;http://movies.org/movies/91&quot;/&gt;\n&gt;   &lt;Title&gt;Strange Dawn&lt;/Title&gt;\n&gt;   &lt;Category&gt;Thriller&lt;/Category&gt;\n&gt;   &lt;Director href=&quot;http://movies.org/persons/47&quot;/&gt;\n&gt;   &lt;Orders href=&quot;http://movies.org/movies/91/orders&quot;/&gt;\n&gt;   &lt;Ratings href=\n&gt; http://ratings.org/ratings?item=http%3a%2f%2fmovies.org%2fmovies%2f91/&gt;\n&gt; &lt;/Movie&gt;\n&gt;\n&gt; In order to service both old and new clients the shop decides to return \n&gt; the\n&gt; initial movie mime type by default. Never clients should use the Accept\n&gt; header to indicate that they want the new version. The same goes for the\n&gt; movies collection type.\n&gt;\n&gt; Our existing client code works happily as it did before.\n&gt;\n&gt;\n&gt; *Code example - A new client*\n&gt; The new client code would look like this:\n&gt;\n&gt;    // A link (template). This should be fetched from a configuration file.\n&gt;   Link MoviesSearchLink = new Link(&quot;\n&gt; http://movies.org/movies?category={category}&quot;);\n&gt;\n&gt;   // Anonymous class with search parameters. Reflection is used to extract\n&gt; values.\n&gt;   // This is about the simplest way to write a &quot;fixed hashmap&quot; in C#\n&gt;   var movieSearchParameter = new { category = &quot;thriller&quot; };\n&gt;\n&gt;   // Setting up the Accept header\n&gt;   var movieSearchHeaders = new { Accept =\n&gt; &quot;application/vnd.movies.movie-collection.v2&quot; }\n&gt;\n&gt;   // Get ressource stored at the link endpoint\n&gt;   MovieCollection movies =\n&gt; MoviesSearchLink.Get&lt;MovieCollection&gt;(movieSearchParameter,\n&gt; movieSearchHeaders);\n&gt;\n&gt;   // Iterate over all movies and print title\n&gt;   foreach (Movie movie in movies)\n&gt;     Console.WriteLine(&quot;Title: &quot; + movie.Title);\n&gt;\n&gt; *Code example - Buying movies*\n&gt; Now we have a movie which has an embedded link to it&#39;s sales orders. To \n&gt; buy\n&gt; a movie we post a new order to the sales order collection:\n&gt;\n&gt;    // One of the returned self links from the search query\n&gt;   Link movieLink = movies[0].Self;\n&gt;\n&gt;   // Get the actual movie\n&gt;   Movie movie = movieLink.Get&lt;Movie&gt;();\n&gt;\n&gt;   // Create a new order request\n&gt;   MovieOrderRequest orderRequest = new MovieOrderRequest(movie.Self, 1 /*\n&gt; quantity */);\n&gt;\n&gt;   // Post the order request to the order collection\n&gt;   // Assume it returns the newly created order\n&gt;   MovieOrder order = movie.Orders.Post(orderRequest);\n&gt;\n&gt; Comments:\n&gt;\n&gt; - The POST result in a redirect to the newly created order. The system \n&gt; GETs\n&gt; this new order and returns it. This means we loose the intermediate data\n&gt; returned from the POST.\n&gt;\n&gt;\n&gt; *Other verbs*\n&gt; The Link class is has built-in support for GET/PUT/POST/DELETE. Other \n&gt; verbs\n&gt; can be executed through a generic &quot;Request&quot; method:\n&gt;\n&gt;   SomeType x = someLink.Request(&quot;SOMEVERB&quot;, somePayload);\n&gt;\n&gt;\n&gt; *Caching*\n&gt; The Link class and it&#39;s associted methods should of course respect ETag \n&gt; and\n&gt; if-not-modified-since etc. This would require the framework to be\n&gt; initialized with a cache implementation of some kind.\n&gt;\n&gt;\n&gt; *Error handling*\n&gt; I would suggest using execptions for error handling.\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; \n\n\n"}}