{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":86585728,"authorName":"Eric Johnson","from":"Eric Johnson &lt;eric@...&gt;","profile":"eric_at_tibco","replyTo":"SENDER","senderId":"QWYMgFCC25HVVUExD-yHsNSzUYVOl8mpEo06YDPbmZ976woLHLEKiuve6qq0wtP4eh8XWTZzuYHbv9NhyTHTo8xN-Qc","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: [rest-discuss] Re: A standardized way to describe a new hypermedia format?","postDate":"1279928565","msgId":15973,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDRDNEEyOEY1LjgwNzAzQHRpYmNvLmNvbT4=","inReplyToHeader":"PGkyZDUxdCtxcDhyQGVHcm91cHMuY29tPg==","referencesHeader":"PGkyZDUxdCtxcDhyQGVHcm91cHMuY29tPg=="},"prevInTopic":15970,"nextInTopic":15975,"prevInTime":15972,"nextInTime":15974,"topicId":15963,"numMessagesInTopic":8,"msgSnippet":"I read the initial question as distinguishing between the client and the client/problem domain. I concur.  Almost by definition, a hypermedia format must know","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 94649 invoked from network); 23 Jul 2010 23:45:54 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m14.grp.re1.yahoo.com with QMQP; 23 Jul 2010 23:45:54 -0000\r\nX-Received: from unknown (HELO mx1-app.tibco.com) (63.100.100.142)\n  by mta2.grp.re1.yahoo.com with SMTP; 23 Jul 2010 23:45:54 -0000\r\nX-IronPort-AV: E=Sophos;i=&quot;4.55,250,1278313200&quot;; \n   d=&quot;scan&#39;208,217&quot;;a=&quot;13888147&quot;\r\nX-Received: from tibco-5.tibco.com (HELO na-pa-fe01.na.tibco.com) ([63.100.100.5])\n  by mx1-app.tibco.com with ESMTP; 23 Jul 2010 16:42:42 -0700\r\nX-Received: from koosh.na.tibco.com ([10.98.32.22]) by na-pa-fe01.na.tibco.com with Microsoft SMTPSVC(6.0.3790.3959);\n\t Fri, 23 Jul 2010 16:42:43 -0700\r\nMessage-ID: &lt;4C4A28F5.80703@...&gt;\r\nDate: Fri, 23 Jul 2010 16:42:45 -0700\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.10) Gecko/20100628 Thunderbird/3.0.5\r\nMIME-Version: 1.0\r\nTo: wahbedahbe &lt;andrew.wahbe@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nReferences: &lt;i2d51t+qp8r@...&gt;\r\nIn-Reply-To: &lt;i2d51t+qp8r@...&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------030201020404070302050309&quot;\r\nReturn-Path: eric@...\r\nX-OriginalArrivalTime: 23 Jul 2010 23:42:43.0221 (UTC) FILETIME=[BEBB1450:01CB2AC0]\r\nX-TM-AS-Product-Ver: SMEX-10.0.0.1412-6.000.1038-17522.007\r\nX-TM-AS-Result: No--43.059200-8.000000-31\r\nX-TM-AS-User-Approved-Sender: No\r\nX-TM-AS-User-Blocked-Sender: No\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: Eric Johnson &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: A standardized way to describe a new hypermedia\n format?\r\nX-Yahoo-Group-Post: member; u=86585728; y=C_XFHh50LFM1viJmNOE3_2HD3_qFyrST0eaxz-FxMlVA1XcNbGOZYA\r\nX-Yahoo-Profile: eric_at_tibco\r\n\r\n\r\n--------------030201020404070302050309\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\nI read the initial question as distinguishing between the client and the\nclient/problem domain.\n\nI concur.  Almost by definition, a hypermedia format must know about the\ndomain of the problem.  Doesn&#39;t need to know how the client works in\nthat domain, though.  For a trivial example, the difference between\nFirefox and Lynx - I can use both to browse large portions of the web -\nbut the presentations are radically different.\n\n-Eric J.\n\nOn 07/23/2010 03:28 PM, wahbedahbe wrote:\n&gt;  \n&gt;\n&gt;\n&gt;\n&gt; --- In rest-discuss@yahoogroups.com\n&gt; &lt;mailto:rest-discuss%40yahoogroups.com&gt;, Jan Algermissen\n&gt; &lt;algermissen1971@...&gt; wrote:\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; On Jul 23, 2010, at 7:36 PM, brendel.juergen wrote:\n&gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hello!\n&gt; &gt; &gt;\n&gt; &gt; &gt; Is there a standardized way to describe a new hypermedia format?\n&gt; &gt;\n&gt; &gt; No, but you might be interested in\n&gt; &gt;\n&gt; &gt; http://www.nordsc.com/blog/?p=6 and\n&gt; &gt; http://www.nordsc.com/blog/?p=8\n&gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Let me provide some context:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Yesterday, I had a long discussion on Twitter with Andrew Wahbe\n&gt; about the topic of whether it&#39;s even possible to create a hypermedia\n&gt; format without knowledge of the client.\n&gt; &gt; &gt;\n&gt; &gt; &gt; More specifically, the concern was that whatever hypermedia format\n&gt; you come up with would &#39;bind&#39; the client to that server: It&#39;s\n&gt; difficult to have a generic client, since instead you end up with\n&gt; clients that have to have specific knowledge about the particular\n&gt; hypermedia format you use.\n&gt; &gt;\n&gt; &gt; Yes, that is natural (and ok). User agents provide the interaction\n&gt; point between users and the application. They do this by\n&gt; &gt;\n&gt; &gt; - exposing information (e.g. render the content of &lt;title&gt; element in\n&gt; &gt; the browser window head or store the result of a link check run for\n&gt; &gt; a site in a database or file)\n&gt; &gt; - performing automatic transitions (e.g. GET an HTML inline image or\n&gt; &gt; recursively traverse links of a site for validation)\n&gt; &gt; - provide a means for the user to activate hypermedia controls\n&gt; &gt; (e.g. make links found in a page clickable, display forms)\n&gt; &gt;\n&gt; &gt; Doing all this requires in-depth knowledge of the media type and\n&gt; coding for all this requires in-depth, hard coded knowledge about the\n&gt; expected media types.\n&gt; &gt;\n&gt; &gt; It is simply ok that browsers implement HTML and that AtomPub\n&gt; clients implement the AtomPub media types. It is also ok that Google&#39;s\n&gt; indexed likely understands all media types it knows to be in use on\n&gt; the Web.\n&gt; &gt;\n&gt;\n&gt; Ah, but remember that the context here is that the hypermedia format\n&gt; is designed without knowledge of what the client does. So in the case\n&gt; of HTML, the client can do all the things you mention quite easily\n&gt; because HTML is explicitly designed for them -- well explicitly for\n&gt; the browser examples like &lt;title&gt; and perhaps implicitly for the\n&gt; spider examples by virtue of HTML following the Principle of Least\n&gt; Power. In short -- HTML was designed around a client domain\n&gt; (interactive information presentation).\n&gt;\n&gt; If the hypermedia format was not designed around the client domain,\n&gt; then the client would be tasked with mapping the data to its domain\n&gt; (which may not even be feasible). Also, the client would be bound to\n&gt; that domain -- restricting it from doing other things.\n&gt;\n&gt; For example, if Amazon designed it&#39;s hypermedia format before\n&gt; browser&#39;s and HTML existed it would likely revolve around buying books\n&gt; and other items. It would likely be impossible to express something\n&gt; like Facebook in this language - you&#39;d need some new format. An\n&gt; &quot;Amazon browser&quot; would not be able to interact with Facebook and vice\n&gt; versa, even though the client domain (again interactive information\n&gt; presentation) was the same.\n&gt;\n&gt; And before anyones says anything about this having to do anything with\n&gt; the user guiding the browser let me address this. CCXML is an example\n&gt; of a hypermedia language that does not drive clients with UIs. CCXML\n&gt; drives a call control platform that among other things, accepts,\n&gt; places and connects phone calls. It can be used for many applications\n&gt; -- for example you could create a Google-Voice-like application that\n&gt; looks at the number dialed and calls multiple phone numbers allowing\n&gt; you to have one phone number that rings your cell and your deskphone.\n&gt; Alternatively, a call center application might look at the number of\n&gt; the caller, figure out who they are whether they are a &quot;gold&quot;,\n&gt; &quot;silver&quot; or &quot;bronze&quot; customer (via a DB lookup) and connect them to\n&gt; the right agents for that customer pool. So the key difference is that\n&gt; in the first example we route based on number dialed and in the second\n&gt; based on the caller&#39;s number -- but the finer details of the apps can\n&gt; be quite different. Because CCXML is designed around what the raw\n&gt; telephony capabilities of the client and not the applications, the\n&gt; same hypermedia format and clients can be used for both types of\n&gt; applications.\n&gt;\n&gt; So it seems that you can get a &quot;broader reaching&quot; hypermedia format by\n&gt; designing it around the client. But the original question was if you\n&gt; have no knowledge of the client domain, can you design something that\n&gt; qualifies as a &quot;hypermedia format&quot;? Could you really implement a\n&gt; client that achieves HATEOAS based on a format that was designed\n&gt; without any consideration for the client domain? In my earlier Amazon\n&gt; browser example, I&#39;d imagined that the hypermedia format was designed\n&gt; for &quot;interactive information presentation&quot; but that the data\n&gt; structures and controls were customized for Amazon&#39;s domain -- hence\n&gt; the client is an &quot;Amazon browser&quot;.\n&gt;\n&gt; One might propose Atom/AtomPub. But I tend to think of this as\n&gt; designed with clients in mind -- a client is a feed processor that may\n&gt; also possibly allow publishing to the feeds. There are some very\n&gt; specific client workflows in mind here. Say that the content in the\n&gt; feeds is employee data. You can have a feed for all the employees in\n&gt; the company that allow clients to process the data in terms of a big\n&gt; list. But if the client wants to process the data as a hierarchy it\n&gt; can&#39;t do it. Of course you could define a link relation to capture the\n&gt; hierarchy, but now your just extending the hypermedia format to meet\n&gt; the needs of the client. (And that&#39;s maybe a dumb, toy example, but I\n&gt; couldn&#39;t think of another on the spot.)\n&gt;\n&gt; So can you design a hypermedia format that cuts across the full range\n&gt; of clients that one might want to have interact with a service or does\n&gt; HATEOAS _require_ that hypermedia formats are designed for a specific\n&gt; client domain?\n&gt;\n&gt; Does anyone have an example of client agnostic formats that allowed a\n&gt; truly RESTful client to be built?\n&gt;\n&gt; Regards,\n&gt;\n&gt; Andrew\n&gt;\n&gt; \n\r\n--------------030201020404070302050309\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta content=&quot;text/html; charset=ISO-8859-1&quot;\n http-equiv=&quot;Content-Type&quot;&gt;\n&lt;/head&gt;\n&lt;body text=&quot;#000000&quot; bgcolor=&quot;#ffffff&quot;&gt;\nI read the initial question as distinguishing between the client and\nthe client/problem domain.&lt;br&gt;\n&lt;br&gt;\nI concur.&nbsp; Almost by definition, a hypermedia format must know about\nthe domain of the problem.&nbsp; Doesn&#39;t need to know how the client works\nin that domain, though.&nbsp; For a trivial example, the difference between\nFirefox and Lynx - I can use both to browse large portions of the web -\nbut the presentations are radically different.&lt;br&gt;\n&lt;br&gt;\n-Eric J.&lt;br&gt;\n&lt;br&gt;\nOn 07/23/2010 03:28 PM, wahbedahbe wrote:\n&lt;blockquote cite=&quot;mid:i2d51t+qp8r@...&quot; type=&quot;cite&quot;&gt;&lt;span\n style=&quot;display: none;&quot;&gt;&nbsp;&lt;/span&gt;\n\n  &lt;div id=&quot;ygrp-text&quot;&gt;\n  &lt;p&gt;&lt;br&gt;\n  &lt;br&gt;\n--- In &lt;a moz-do-not-send=&quot;true&quot;\n href=&quot;mailto:rest-discuss%40yahoogroups.com&quot;&gt;rest-discuss@yahoogroups.com&lt;/a&gt;,\nJan Algermissen &lt;a class=&quot;moz-txt-link-rfc2396E&quot; href=&quot;mailto:algermissen1971@...&quot;&gt;&lt;algermissen1971@...&gt;&lt;/a&gt; wrote:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; On Jul 23, 2010, at 7:36 PM, brendel.juergen wrote:&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Hello!&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Is there a standardized way to describe a new hypermedia\nformat?&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; No, but you might be interested in&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &lt;a moz-do-not-send=&quot;true&quot; href=&quot;http://www.nordsc.com/blog/?p=6&quot;&gt;http://www.nordsc.com/blog/?p=6&lt;/a&gt;\nand &lt;br&gt;\n&gt; &lt;a moz-do-not-send=&quot;true&quot; href=&quot;http://www.nordsc.com/blog/?p=8&quot;&gt;http://www.nordsc.com/blog/?p=8&lt;/a&gt;&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Let me provide some context:&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Yesterday, I had a long discussion on Twitter with Andrew\nWahbe about the topic of whether it&#39;s even possible to create a\nhypermedia format without knowledge of the client.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; More specifically, the concern was that whatever hypermedia\nformat you come up with would &#39;bind&#39; the client to that server: It&#39;s\ndifficult to have a generic client, since instead you end up with\nclients that have to have specific knowledge about the particular\nhypermedia format you use.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Yes, that is natural (and ok). User agents provide the interaction\npoint between users and the application. They do this by&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; - exposing information (e.g. render the content of &lt;title&gt;\nelement in&lt;br&gt;\n&gt; the browser window head or store the result of a link check run for&lt;br&gt;\n&gt; a site in a database or file)&lt;br&gt;\n&gt; - performing automatic transitions (e.g. GET an HTML inline image\nor&lt;br&gt;\n&gt; recursively traverse links of a site for validation)&lt;br&gt;\n&gt; - provide a means for the user to activate hypermedia controls&lt;br&gt;\n&gt; (e.g. make links found in a page clickable, display forms)&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Doing all this requires in-depth knowledge of the media type and\ncoding for all this requires in-depth, hard coded knowledge about the\nexpected media types.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; It is simply ok that browsers implement HTML and that AtomPub\nclients implement the AtomPub media types. It is also ok that Google&#39;s\nindexed likely understands all media types it knows to be in use on the\nWeb.&lt;br&gt;\n&gt; &lt;br&gt;\n  &lt;br&gt;\nAh, but remember that the context here is that the hypermedia format is\ndesigned without knowledge of what the client does. So in the case of\nHTML, the client can do all the things you mention quite easily because\nHTML is explicitly designed for them -- well explicitly for the browser\nexamples like &lt;title&gt; and perhaps implicitly for the spider\nexamples by virtue of HTML following the Principle of Least Power. In\nshort -- HTML was designed around a client domain (interactive\ninformation presentation).&lt;br&gt;\n  &lt;br&gt;\nIf the hypermedia format was not designed around the client domain,\nthen the client would be tasked with mapping the data to its domain\n(which may not even be feasible). Also, the client would be bound to\nthat domain -- restricting it from doing other things. &lt;br&gt;\n  &lt;br&gt;\nFor example, if Amazon designed it&#39;s hypermedia format before browser&#39;s\nand HTML existed it would likely revolve around buying books and other\nitems. It would likely be impossible to express something like Facebook\nin this language - you&#39;d need some new format. An &quot;Amazon browser&quot;\nwould not be able to interact with Facebook and vice versa, even though\nthe client domain (again interactive information presentation) was the\nsame.&lt;br&gt;\n  &lt;br&gt;\nAnd before anyones says anything about this having to do anything with\nthe user guiding the browser let me address this. CCXML is an example\nof a hypermedia language that does not drive clients with UIs. CCXML\ndrives a call control platform that among other things, accepts, places\nand connects phone calls. It can be used for many applications -- for\nexample you could create a Google-Voice-like application that looks at\nthe number dialed and calls multiple phone numbers allowing you to have\none phone number that rings your cell and your deskphone.\nAlternatively, a call center application might look at the number of\nthe caller, figure out who they are whether they are a &quot;gold&quot;, &quot;silver&quot;\nor &quot;bronze&quot; customer (via a DB lookup) and connect them to the right\nagents for that customer pool. So the key difference is that in the\nfirst example we route based on number dialed and in the second based\non the caller&#39;s number -- but the finer details of the apps can be\nquite different. Because CCXML is designed around what the raw\ntelephony capabilities of the client and not the applications, the same\nhypermedia format and clients can be used for both types of\napplications.&lt;br&gt;\n  &lt;br&gt;\nSo it seems that you can get a &quot;broader reaching&quot; hypermedia format by\ndesigning it around the client. But the original question was if you\nhave no knowledge of the client domain, can you design something that\nqualifies as a &quot;hypermedia format&quot;? Could you really implement a client\nthat achieves HATEOAS based on a format that was designed without any\nconsideration for the client domain? In my earlier Amazon browser\nexample, I&#39;d imagined that the hypermedia format was designed for\n&quot;interactive information presentation&quot; but that the data structures and\ncontrols were customized for Amazon&#39;s domain -- hence the client is an\n&quot;Amazon browser&quot;. &lt;br&gt;\n  &lt;br&gt;\nOne might propose Atom/AtomPub. But I tend to think of this as designed\nwith clients in mind -- a client is a feed processor that may also\npossibly allow publishing to the feeds. There are some very specific\nclient workflows in mind here. Say that the content in the feeds is\nemployee data. You can have a feed for all the employees in the company\nthat allow clients to process the data in terms of a big list. But if\nthe client wants to process the data as a hierarchy it can&#39;t do it. Of\ncourse you could define a link relation to capture the hierarchy, but\nnow your just extending the hypermedia format to meet the needs of the\nclient. (And that&#39;s maybe a dumb, toy example, but I couldn&#39;t think of\nanother on the spot.)&lt;br&gt;\n  &lt;br&gt;\nSo can you design a hypermedia format that cuts across the full range\nof clients that one might want to have interact with a service or does\nHATEOAS _require_ that hypermedia formats are designed for a specific\nclient domain? &lt;br&gt;\n  &lt;br&gt;\nDoes anyone have an example of client agnostic formats that allowed a\ntruly RESTful client to be built?&lt;br&gt;\n  &lt;br&gt;\nRegards,&lt;br&gt;\n  &lt;br&gt;\nAndrew&lt;br&gt;\n  &lt;br&gt;\n  &lt;/p&gt;\n  &lt;/div&gt;\n\n\n&lt;!-- end group email --&gt;&lt;/blockquote&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------030201020404070302050309--\r\n\n"}}