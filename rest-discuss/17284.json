{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":474754157,"authorName":"Bob Ferris","from":"Bob Ferris &lt;zazi@...&gt;","profile":"b.ferris@rocketmail.com","replyTo":"SENDER","senderId":"NptIskuQZGCM0cU3J_WmYMqWEID6oPJibx0VF7DUSGjpl7J732rnf9_Rjq9U394OCH01YYgonryBqTf8bJNtlkJ1gqRo","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Why SPARQL endpoints aren&#39;t even remotely RESTful.","postDate":"1296663268","msgId":17284,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDRENDk4MkU0LjMwNzA2MDJAZWxia2xhbmcubmV0Pg==","inReplyToHeader":"PDIwMTEwMjAyMDc0MDI5LmZhYzgyMTlhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PDIwMTEwMjAyMDc0MDI5LmZhYzgyMTlhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":17281,"nextInTopic":17285,"prevInTime":17283,"nextInTime":17285,"topicId":17281,"numMessagesInTopic":22,"msgSnippet":"Hi Eric, thanks a lot for clarification the SPARQL-to-REST relation. So I can conclude that SPARQL endpoint/SPARQL query interface at least alá the ","rawEmail":"Return-Path: &lt;zazi@...&gt;\r\nX-Sender: zazi@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 36197 invoked from network); 2 Feb 2011 16:14:41 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m3.grp.sp2.yahoo.com with QMQP; 2 Feb 2011 16:14:41 -0000\r\nX-Received: from unknown (HELO shoutbox.org) (89.163.163.26)\n  by mta1.grp.sp2.yahoo.com with SMTP; 2 Feb 2011 16:14:41 -0000\r\nX-Received: from [192.168.1.100] (p5B2AC55D.dip.t-dialin.net [91.42.197.93])\n\t(using TLSv1 with cipher AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\t(Authenticated sender: zazi@...)\n\tby shoutbox.org (Postfix) with ESMTPSA id B7CC06C15F7\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Wed,  2 Feb 2011 16:14:39 +0000 (UTC)\r\nMessage-ID: &lt;4D4982E4.3070602@...&gt;\r\nDate: Wed, 02 Feb 2011 17:14:28 +0100\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.2.13) Gecko/20101207 Thunderbird/3.1.7\r\nMIME-Version: 1.0\r\nTo: rest-discuss@yahoogroups.com\r\nReferences: &lt;20110202074029.fac8219a.eric@...&gt;\r\nIn-Reply-To: &lt;20110202074029.fac8219a.eric@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Bob Ferris &lt;zazi@...&gt;\r\nSubject: Re: [rest-discuss] Why SPARQL endpoints aren&#39;t even remotely RESTful.\r\nX-Yahoo-Group-Post: member; u=474754157; y=l9v6QCrcgFx95TMTBw2aUTgd_XjZVidRZr2PA249HGNZIbbR2FvtP5KMyYG05aaM5fk\r\nX-Yahoo-Profile: b.ferris@...\r\n\r\nHi Eric,\n\nthanks a lot for clarification the SPARQL-to-REST relation. So I can \nconclude that SPARQL endpoint/SPARQL query interface at least al� the \nadvanced_search of Google can be RESTful. I didn&#39;t think that needs a \nseparate (query and/or) result media type, since one is able to \nserialize such results also into representation formats of RDF e.g., RDFa.\nThe thing I had and have always in mind was, of course, a more advanced \nquery interface than a simple text box (so, sorry that this obviously \ncauses misinterpretations). Even an interface like that of the \nadvanced_search of Google isn&#39;t quite comfortable, or? I rather can \nimagine a kind of faceted browsing interface to formulate a query, where \nthe end user didn&#39;t really get in touch with the statements behind. This \ndepends of course on the specific application domain, but generally one \noften needs such contexts like time or place. So selecting an \nappropriated time interval on a timeline interface, or selecting a \nplace/area on a world map interface might be better opportunity, or?\n\nCheers,\n\n\nBob\n\n\nAm 02.02.2011 15:40, schrieb Eric J. Bowman:\n&gt; Danny Ayers wrote:\n&gt;&gt;\n&gt;&gt; For example, if I go to:\n&gt;&gt;\n&gt;&gt; http://api.talis.com/stores/bbc-backstage/services/sparql\n&gt;&gt;\n&gt;&gt; and enter the query :\n&gt;&gt;\n&gt;&gt; select ?s where { ?s ?p ?o }\n&gt;&gt; limit 10\n&gt;&gt;\n&gt;&gt; then click the &quot;Search&quot; button, I get a bunch of results in SPARQL\n&gt;&gt; results format.\n&gt;&gt;\n&gt;\n&gt; When I go to that page, I see not even a clue about the nature of the\n&gt; interface, other than that I&#39;ll need the out-of-band knowledge of some\n&gt; query language to use it.  Where are the instructions for how to\n&gt; transition to the next application state, given *any* goal?  This is\n&gt; indeed an RPC endpoint, not a hypertext API.\n&gt;\n&gt; The corollary is to run your weblog by providing a textbox which takes a\n&gt; SQL query, instead of encapsulating SQL within a hypertext interface\n&gt; (i.e. running WordPress).  This is precisely what Roy is talking about,\n&gt; in his final bullet point, here:\n&gt;\n&gt; http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven\n&gt;\n&gt; Also, from the comments to that post:\n&gt;\n&gt; &quot;When I say hypertext, I mean the simultaneous presentation of\n&gt; information and controls such that the information becomes the\n&gt; affordance through which the user (or automaton) obtains choices and\n&gt; selects actions...  Machines can follow links when they understand the\n&gt; data format and relationship types...  It is the same basic issue as\n&gt; with human communication:  we will always need a common vocabulary to\n&gt; make sense of it. Exposing that vocabulary in the representations makes\n&gt; it easy to learn and be adopted by others.&quot;\n&gt;\n&gt; The data format is HTML, which says nothing about SPARQL, and there is\n&gt; no link relation.  So the vocabulary isn&#39;t exposed in hypertext at all.\n&gt; The interaction is not based on the information presented in the\n&gt; hypertext, therefore it is being driven by out-of-band information.\n&gt; Google&#39;s search API (though not entirely RESTful) accepts keywords,\n&gt; with a syntax defined here:\n&gt;\n&gt; http://www.google.com/advanced_search\n&gt;\n&gt; It should be obvious that there&#39;s a very fundamental difference between\n&gt; Google&#39;s homepage, and the advanced_search page -- the former relies on\n&gt; out-of-band information to add &#39;&num=10&#39;, the latter makes it a RESTful\n&gt; hypertext control; SPARQL endpoints don&#39;t even encode number of results\n&gt; as a name/value pair, instead making it part of one opaque search\n&gt; phrase (limit+10 tacked on at the end) and needlessly complicating the\n&gt; issue of input validation on both the client and the server sides.\n&gt;\n&gt; Taking Google&#39;s advanced_search interface a little further, RDFa could\n&gt; be used to describe the &quot;results per page&quot; control, and type it as an\n&gt; integer.  A more advanced forms language could express the range that\n&gt; the server will accept.  This allows client-side input validation.\n&gt; Google allows any value; what would make more sense would be to take\n&gt; their form control literally -- limiting results-per-page to a set\n&gt; number of values improves cacheability.\n&gt;\n&gt;&gt;\n&gt;&gt; then click the &quot;Search&quot; button, I get a bunch of results in SPARQL\n&gt;&gt; results format.\n&gt;&gt;\n&gt;\n&gt; No, it returns a representation as application/xml, which means I need\n&gt; to sniff in order to determine that it&#39;s a SPARQL result.  To meet the\n&gt; self-descriptive messaging constraint of REST, the results would\n&gt; properly be sent as application/sparql-results+xml, but making that\n&gt; change alone won&#39;t make the API RESTful.  As the results from an actual\n&gt; hypertext API, it makes a fine media type, although I&#39;d personally tack\n&gt; on an XML PI to call some XSLT to transform it into HTML, assuming my\n&gt; hypertext interface was also HTML.\n&gt;\n&gt;&gt;\n&gt;&gt; and enter the query :\n&gt;&gt;\n&gt;&gt; select ?s where { ?s ?p ?o }\n&gt;&gt; limit 10\n&gt;&gt;\n&gt;\n&gt; How do I know what to enter, when instead of entering keywords for a\n&gt; search, I have to enter a query formatted in a manner not afforded\n&gt; through hypertext controls?  A REST API would have one hypertext\n&gt; control for select=, providing me with the options the server has\n&gt; implemented.  Instead of making users guess at what namespaces are\n&gt; supported, a REST API would provide that list as a hypertext control.\n&gt; The server tells the user-agent the parameters of the API, such that\n&gt; the user-agent only needs to fill in the search terms (keywords, not\n&gt; instructions, particularly not instructions which amount to tunneling a\n&gt; custom method like CONSTRUCT over POST).\n&gt;\n&gt; *That&#39;s* what I mean by providing instructions for how to execute a\n&gt; state transition, not urlencoding an opaque query language and letting\n&gt; the server sort it out.  The goal of a REST API is not to encode query\n&gt; languages as URIs this way, it&#39;s to abstract away such implementation\n&gt; details behind a generic interface.  No (reasonable) CMS based on SQL\n&gt; presents SQL queries as URIs or in hypertext, that implementation\n&gt; detail is abstracted away behind the interface, which is exactly how\n&gt; SPARQL can be made RESTful (as opposed to providing non-hypertext-API\n&gt; endpoints).  The server converts the request into a SPARQL query for a\n&gt; back-end system in REST, as opposed to exposing a SPARQL endpoint -- no\n&gt; different from how SQL is handled in REST APIs.\n&gt;\n&gt; There is one way I can think of to use SPARQL queries in a REST app,\n&gt; which is to POST or PUT a representation as application/sparql-query to\n&gt; some URI.  Dereferencing that URI executes the query as a stored\n&gt; procedure, returning application/sparql-results+xml by default, but\n&gt; can also return the original query with Accept: application/sparql-\n&gt; query.  I&#39;ve used the eXist DB this way, creating cells containing\n&gt; XQuery, which is a nice way to create a Web app from an XML store.\n&gt;\n&gt; -Eric\n\n"}}