{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"83aWW1M2SbOQ7w1qiTbPT7YpsNyPOIDD4NW7SY_DKJ_Lt7X01uZY6m-zxjYELF9vgRP2PwWTPwudr6WXozgwaHbl4fFo5TJa0bIcokqLeQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Determining which Media type for post/put","postDate":"1275682156","msgId":15543,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNjA0MTQwOTE2LjNmZmQ3NTNjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlrSHZsZmJ2dkxQUUc2UmM5WjZMcjE5aFNheS1zT3VYSGJ5cXk0Q0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PEFBTkxrVGlsazJZWnJnY2U5M3dYcDlFSjRHZnBpckxlUVZ2bUowSnhjeFBZSEBtYWlsLmdtYWlsLmNvbT4JPEFBTkxrVGltTzROM0ZTeDg5bjR2Sm43RkpsMzJYaC1ERnNZUl93dG5Pd3VYdUBtYWlsLmdtYWlsLmNvbT4JPDNEREQwQkU2NTU4NjlENEVBNTA2NjUyQjM4MDNBRUY2MTU2RDlFNkNAUFJJU00uY2FmZmVpbmUtaXQubmV0Pgk8QUFOTGtUaW5Hc3JWaUdXSUJTWElmd3YxeTY1dDRNbTEyRW1PcXNnNTlONmUyQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExMDUxNTEuZTYzZjgyMmEuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWxIU3RDNWNpU0N5MHg5ZFFmRUJsdHluVld5ZEdLblZlbjZaYm1KQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExNzU2NDEuZjZhY2FhMjguZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaW5kdzJsN0tDcUpkelh2OU8yLUdGMUtfamM3d1FjanBrbmhIZm5oQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDMwNTE1MDkuYjUxOWI4ZWIuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtrdmZpaGFkMWxVcVNkTmktOFozanppVy0wYjNIUTJTQXNqV2xRQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDMxNDEyMDguZTAyNjk4N2QuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtNRFNEb1pveFdPNlVMczZlRHE3QXJwdmFmMUxrZF8tRVpURjJXQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDQwNzQ5NTYuYzllM2MxYzUuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaW1YV2NodTl0djR2YUV5aUZCOHpMWm0wTTJGNGk2UmNxTnlBRnNTQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDQwOTM5MTMuZWY2Y2VjMTkuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtIdmxmYnZ2TFBRRzZSYzlaNkxyMTloU2F5LXNPdVhIYnlxeTRDQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":15541,"nextInTopic":15545,"prevInTime":15542,"nextInTime":15544,"topicId":15466,"numMessagesInTopic":82,"msgSnippet":"... XHTML 1.0 is a polyglot media type which may be served as text/html or as application/xhtml+xml.  If you change your Content-Type from text/ html to","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 95893 invoked from network); 4 Jun 2010 20:10:13 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m11.grp.re1.yahoo.com with QMQP; 4 Jun 2010 20:10:13 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.sp2.yahoo.com with SMTP; 4 Jun 2010 20:10:13 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id E3A15509DB;\n\tFri,  4 Jun 2010 16:09:41 -0400 (EDT)\r\nDate: Fri, 4 Jun 2010 14:09:16 -0600\r\nTo: Tim Williams &lt;williamstw@...&gt;\r\nCc: Mike Kelly &lt;mike@...&gt;, Sebastien Lambla &lt;seb@...&gt;,\n mike amundsen &lt;mamund@...&gt;, Glenn Block &lt;glenn.block@...&gt;,\n &quot;rest-discuss@yahoogroups.com&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100604140916.3ffd753c.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTikHvlfbvvLPQG6Rc9Z6Lr19hSay-sOuXHbyqy4C@...&gt;\r\nReferences: &lt;AANLkTilk2YZrgce93wXp9EJ4GfpirLeQVvmJ0JxcxPYH@...&gt;\n\t&lt;AANLkTimO4N3FSx89n4vJn7FJl32Xh-DFsYR_wtnOwuXu@...&gt;\n\t&lt;3DDD0BE655869D4EA506652B3803AEF6156D9E6C@...-it.net&gt;\n\t&lt;AANLkTinGsrViGWIBSXIfwv1y65t4Mm12EmOqsg59N6e2@...&gt;\n\t&lt;20100601105151.e63f822a.eric@...&gt;\n\t&lt;AANLkTilHStC5ciSCy0x9dQfEBltynVWydGKnVen6ZbmJ@...&gt;\n\t&lt;20100601175641.f6acaa28.eric@...&gt;\n\t&lt;AANLkTindw2l7KCqJdzXv9O2-GF1K_jc7wQcjpknhHfnh@...&gt;\n\t&lt;20100603051509.b519b8eb.eric@...&gt;\n\t&lt;AANLkTikkvfihad1lUqSdNi-8Z3jziW-0b3HQ2SAsjWlQ@...&gt;\n\t&lt;20100603141208.e026987d.eric@...&gt;\n\t&lt;AANLkTikMDSDoZoxWO6ULs6eDq7Arpvaf1Lkd_-EZTF2W@...&gt;\n\t&lt;20100604074956.c9e3c1c5.eric@...&gt;\n\t&lt;AANLkTimXWchu9tv4vaEyiFB8zLZm0M2F4i6RcqNyAFsS@...&gt;\n\t&lt;20100604093913.ef6cec19.eric@...&gt;\n\t&lt;AANLkTikHvlfbvvLPQG6Rc9Z6Lr19hSay-sOuXHbyqy4C@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Determining which Media type for post/put\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nTim Williams wrote:\n&gt;\n&gt; &gt;\n&gt; &gt; You&#39;re exactly right. =A0I&#39;m saying that chan=\r\nging the semantics of\n&gt; &gt; @type from annotation to instruction, introduces =\r\ncoupling.\n&gt; \n&gt; Ah, I missed the distinction, thanks.  I don&#39;t see how its n=\r\necessarily\n&gt; harmful though.  I mean, if I&#39;ve got two representations of a =\r\ngiven\n&gt; resource and I give you links to both - it seems to me the result w=\r\nill\n&gt; be the same whether you used a @type attribute to populate your Accep=\r\nt\n&gt; header or used your own quality-based Accept header.  For example, if\n&gt;=\r\n I give you a link to &lt;a href=3D&quot;...&quot; type=3D&quot;text/html&quot; - wouldn&#39;t the\n&gt; r=\r\nesult would be the same whether it&#39;s a hint or instructive?\n&gt; \n\nXHTML 1.0 i=\r\ns a polyglot media type which may be served as text/html or\nas application/=\r\nxhtml+xml.  If you change your Content-Type from text/\nhtml to application/=\r\nxhtml+xml, and @type says text/html, if it&#39;s a hint\nthen a browser will ret=\r\nrieve application/xhtml+xml, if it&#39;s an\ninstruction then you have to update=\r\n all your HTML to reflect the change\ninstead of having user agents automati=\r\ncally adapt to that change.\n\nIf you have to update your markup to change a =\r\nmedia type, you&#39;re\ncoupled.  REST allows us to change a GIF to a PNG withou=\r\nt changing its\n*.gif URI, so there&#39;s no need to edit the markup to change t=\r\nhat file\nextension.  Unless @type is an instruction, in which case all link=\r\ns\nwith type=3D&#39;image/gif&#39; go 406, instead of letting the user agent just\ngr=\r\nab the file regardless of its media type, or negotiate for it.\n\nConversely,=\r\n how should a browser that doesn&#39;t handle application/xhtml+\nxml handle an =\r\n@type instruction that specifies application/xhtml+xml?\nForcing the user ag=\r\nent to ask the user to download the wrong variant\ninstead of negotiating fo=\r\nr the correct variant, kinda defeats the whole\npurpose of content negotiati=\r\non.\n\nIf you need clients to dereference a specific variant, then you send\nt=\r\nhe client the URI for that variant, not the negotiated URI.  I just\ndon&#39;t u=\r\nnderstand why this solution, a well-established best-practice\nwhich works p=\r\nerfectly well in practice, is somehow inadequate and\nrequires us to change =\r\nthe semantics of @type to accomplish exactly the\nsame thing (by violating R=\r\nEST constraints, no less)...\n\n&gt;\n&gt; &gt;&gt; The server could have:\n&gt; &gt;&gt; &lt;a rel=3Dn=\r\next type=3Dtext/html href=3D&quot;...&quot;&gt;Search Me&lt;/a&gt;\n&gt; &gt;&gt; &lt;a rel=3Dnext type=3Da=\r\npplication/atom+xml href=3D&quot;...&quot;&gt;Search Me&lt;/a&gt;\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; Well, it would =\r\nbe more RESTful for a representation to use as rel=3D\n&gt; &gt; &#39;next&#39; the same m=\r\nedia type as itself. =A0Then, make a list of rel=3D\n&gt; &gt; &#39;alternate&#39; links f=\r\nor each negotiated representation,\n&gt; \n&gt; I think either of these lives withi=\r\nn the constraints of REST - it\n&gt; seems more of a discussion about good medi=\r\na type design than\n&gt; RESTfulness to me.  The link relations aren&#39;t exclusiv=\r\ne though, so\n&gt; perhaps:\n&gt; \n\nYes, it is a discussion about proper media type=\r\n design, but it&#39;s a\ndiscussion of proper media type design within the conte=\r\nxt of REST.\nPresumably, the representation containing the alternate links w=\r\nas\nreturned as the result of content negotiation.  So it&#39;s safe to assume\nt=\r\nhat the browser&#39;s next request will use the same Accept header (except\nfor =\r\nIE &lt; 7 of course, sigh).  So if you&#39;re presenting a rel=3D&#39;next&#39; it\nmakes s=\r\nense that, if it doesn&#39;t just point to another negotiated\nresource, it woul=\r\nd point to the URI of a variant with the same media\ntype the server already=\r\n determined was correct for the user agent.\n\nThe concept in REST is that th=\r\ne most optimal representation is sent\nfirst, and that the representation co=\r\nntain enough hypertext that the\nuser agent can inform the user of other rep=\r\nresentations in case of\nproblems.  It is not the REST concept for conneg to=\r\n happen within the\napplication steady-state, i.e. before the next request i=\r\ns even made, by\nperforming non-HTTP-protocol-based negotiation (selecting t=\r\nhe best\noption from a list).\n\nError recovery in REST must be allowed to hap=\r\npen after-the-fact, not\nheaded off at the pass by trying to infer the next =\r\ntransition from a\nlist of possible media types -- conneg&#39;s a protocol-layer=\r\n action, not a\nmarkup-rendering action, i.e. HTTP conneg occurs over-the-wi=\r\nre.\n\nIn HTTP conneg, the server makes the decision by weighing the q values=\r\n\nof the Accept header against its internal qs values for the available\nmedi=\r\na types.  It isn&#39;t a matter of returning what the client prefers,\nit&#39;s a ma=\r\ntter of returning what the server deems to be the best\ncombination of clien=\r\nt preference and server quality.  For a server to\nsend a list of links to t=\r\nhe client, and for conneg to occur within the\napplication steady-state befo=\r\nre a transition may be understood, would\nrequire @qs in the markup and some=\r\n way to express the algorithm the \nserver is using to make the determinatio=\r\nn.\n\n&gt;\n&gt; &lt;a rel=3D&quot;next&quot; type=3D&quot;text/html&quot; href=3D&quot;...&quot;&gt;Search Me&lt;/a&gt;\n&gt; &lt;a =\r\nrel=3D&quot;next alternate&quot; type=3D&quot;application/atom+xml&quot; href=3D&quot;...&quot;&gt;Search\n&gt; =\r\nMe&lt;/a&gt;\n&gt; \n\nThis is not correct, as it&#39;s only valid to have one rel=3D&#39;next&#39;=\r\n.  While\nthere&#39;s nothing wrong with the syntax of rel=3D&#39;next alternate&#39;, o=\r\nr with\nmultiple alternates, &#39;next alternate&#39; means the link is an alternate=\r\n\nand is also the next transition in a series.  It doesn&#39;t mean it&#39;s the\n&quot;ne=\r\nxt&quot; alternate, the semantics of &quot;alternate&quot; mean an alternate to the\nloaded=\r\n representation, not the alternate for a &#39;next&#39; or &#39;prev&#39; or\nanything else.=\r\n\n\nThe list of alternate links is what allows a user agent to recover,\nusual=\r\nly through interaction with the user, in the case of an incorrect\nvariant b=\r\neing sent.  It is not meant to pre-negotiate a representation,\nthat is not =\r\nthe REST style.  This is a job for the server, not the\nclient, according to=\r\n the layered-system constraint of REST reflected in\nthe HTTP protocol.\n\n&gt;\n&gt;=\r\n &gt; ...  with separate\n&gt; &gt; URIs, and give their @types, so you&#39;re responding=\r\n with the most\n&gt; &gt; optimal representation first, then allowing the user age=\r\nnt to\n&gt; &gt; recover, instead of making the user agent pre-negotiate rel=3D&#39;ne=\r\nxt&#39;.\n&gt; \n&gt; Why separate URIs?  If it weren&#39;t for some UAs having mostly stat=\r\nic\n&gt; Accept headers, my preference would firmly be for the same URI and the=\r\n\n&gt; @type only used as a hint for the UA to perhaps adjust Accept header.\n&gt; =\r\nYou&#39;re saying this for practical reasons of UA behavior?\n&gt; \n\nYes, I&#39;d like =\r\nto give a link of alternates which have the same URI but\ndifferent media ty=\r\npes, and that&#39;s what I initially implemented.  But it\ndidn&#39;t work when I te=\r\nsted it, because real-world user agents just don&#39;t\nget it.  Why should they=\r\n?  RFC 2616 says you SHOULD assign URIs to\nvariants and send them in Conten=\r\nt-Location, and I&#39;ve never seen a good\nreason put forth for ignoring that S=\r\nHOULD when caching or direct-\nreferencing a variant are concerned.\n\nHTML me=\r\ndia types say nothing about how to evaluate or choose from a list\nof altern=\r\nates, they only describe what an alternate link *means*, there\nis no conneg=\r\n algorithm for HTML.  But there is one for HTTP.  So do your\nconneg in HTTP=\r\n where it&#39;s specified, not HTML.\n\nSo I&#39;m saying what I&#39;m saying for practic=\r\nal reasons of UA behavior,\nyes, but I&#39;m also saying there&#39;s nothing wrong w=\r\nith that UA behavior\nsince it follows what the specs and REST both say.  I&#39;=\r\nm saying assign\nURIs to your variants because that&#39;s Web architecture, whic=\r\nh is why\nbrowsers work the way they do, as specced in RFC 2616 with SHOULD,=\r\n and\nbecause it works.  It is best practice to assign URIs to variants,\nbec=\r\nause *that&#39;s how the Web works* not because UAs are broken and we\nmust work=\r\n with these broken UAs.\n\n&gt;\n&gt; &gt;&gt; In this case, @type is simply used as link =\r\nselection criteria in\n&gt; &gt;&gt; concert with @rel. =A0The URI may or may not be =\r\nexactly the same.\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; Exactly. =A0Although in practice, where the =\r\nURI is the same for a\n&gt; &gt; list of alternates, user agents won&#39;t see it that=\r\n way. =A0For\n&gt; &gt; example, browsers have no problem displaying a feed icon i=\r\nn the\n&gt; &gt; presence of a link rel=3D &#39;alternate&#39; with type=3D&#39;application/at=\r\nom\n&gt; &gt; +xml&#39;, provided that the href isn&#39;t the same as the request URI for\n=\r\n&gt; &gt; the current application state.\n&gt; \n&gt; Didn&#39;t know that, I was more thinki=\r\nng of the static Accept header\n&gt; limitation of UAs not this, but that&#39;s int=\r\neresting.\n&gt; \n\nThere&#39;s nothing in the HTML media types which says anything a=\r\nbout a\nrelationship between alternate links and Accept headers.  So I don&#39;t=\r\n\nsee how a user agent can be expected to infer that a list of alternates\nwi=\r\nth the same URI but different media types, correlates in any way with\nits A=\r\nccept header, or conneg, or anything else but to present the user\nwith some=\r\n options if it can&#39;t render the dereferenced representation.\nOr display a f=\r\need icon, if a link exists with one of a set of specific\nmedia types, which=\r\n is presenting the user with an alternative in case\nthe representation they=\r\n&#39;re viewing is inadequate or unreadable due to\nits styling, or if the user =\r\nwants to subscribe to a related feed.\n\n&gt;\n&gt; &gt; So assigning URIs to variants =\r\nnot only clears things up for caches,\n&gt; &gt; but for browsers as well.\n&gt; \n&gt; Ju=\r\nst when I thought I got it.  It seems to me, we should promote\n&gt; fixing the=\r\n UAs rather than assigning URIs to each representation.\n&gt;\n\nI don&#39;t agree th=\r\nat UAs are broken -- they&#39;re interpreting RFC 2616 the\nway it should be int=\r\nerpreted, which is that variants of negotiated\nresources are expected to ha=\r\nve their own URIs.  Again, since assigning\na URI is just no big deal, has n=\r\no downside, and has no interoperability\nissues, I am still confused as to w=\r\nhy following that SHOULD would cause\nany problems for anyone, let alone lea=\r\nd to this much debate.  Follow\nbest practice, and user agents will work fin=\r\ne.  Deviating from best\npractice is shaky ground from which to claim that u=\r\nser agents, or HTML,\nor HTTP or REST are broken, or inadequate, or anything=\r\n else.\n\nWhat do you see as the downside to assigning URIs to variants, as t=\r\nhe\nspec calls for?  Nobody has explained this to me yet, except in FUD\nterm=\r\ns.  I build systems this way.  They work.  I have no complaints.\nOthers ref=\r\nuse to build their systems this way, their systems don&#39;t\nwork, but the faul=\r\nt lies elsewhere?  Seriously, I just don&#39;t get it.\n\n&gt;\n&gt; this list, sometime=\r\ns it&#39;s tough for me to determine whether folks are\n&gt; arguing a particular p=\r\nosition because of the merits of the idea or\n&gt; because of the practical con=\r\nditions of existing, running software in\n&gt; the wild.\n&gt;\n\nYeah, that&#39;s bound =\r\nto happen since REST is an architectural style.  In\nmost cases, people here=\r\n are trying to build systems for the real-world\nWeb as-is, and REST is all =\r\nabout hitting the scaling sweet-spot there.\nBut, REST also applies to other=\r\n systems, and may be used to analyze any\nchanges proposed to the existing s=\r\nystem.  Building a REST system using\nHTTP conneg for use on the as-is real-=\r\nworld Web, requires you to assign\nURIs to your variants just like RFC 2616 =\r\nsays you should.\n\nProtesting that you don&#39;t want to do it that way but woul=\r\nd prefer @type\nto mandate the Accept header just doesn&#39;t seem very producti=\r\nve.  The\nWeb doesn&#39;t work like that, REST&#39;s constraints argue against such\n=\r\nchange, and again, it&#39;s a non-problem since you can always follow HTTP\nand =\r\nassign URIs to variants.  What real-world problem that causes is\nstill a co=\r\nmplete mystery to me, left unarticulated by those who want to\nchange @type&#39;=\r\ns semantics.\n\nTo me, it&#39;s the same as insisting that because you want it to=\r\n work that\nway, URI fragments should be sent to the server, when anything t=\r\nhat can\nbe a fragment can also be sent as a query.  Yet some insist that qu=\r\nery\nisn&#39;t right, fragment is, so we need to fix the broken UAs.  I don&#39;t ge=\r\nt\neither argument.  If I want to drive a rough county road, I take my\n4x4, =\r\ninstead of taking my Prelude and bitching about road maintenance\nwhen I get=\r\n stuck.  The truck works, use that.  Query works, use that.\nAssigning URIs =\r\nto variants *works*, so use that.  Assigning URIs to\nvariants is Pragmatic =\r\nREST.\n\n&gt;\n&gt; In this case, on a practical note, I agree that this is\n&gt; what w=\r\ne&#39;re stuck with but would you agree that the ideal is to fix the\n&gt; source (=\r\ne.g. UAs)?  That&#39;s my interpretation of section 5.2.1.1 too:\n&gt; \n\nBut I don&#39;=\r\nt agree that UAs are broken in this way.  If you don&#39;t care\nabout caching y=\r\nour variants, if you don&#39;t care about accessing them\ndirectly, then don&#39;t a=\r\nssign them URIs (it&#39;s only a SHOULD, after all).\nHowever, if you are expect=\r\ning your variants to cache, and you desire\ndirect variant access without a =\r\nconneg layer, then a solution exists\nthat&#39;s so simple I can&#39;t believe I&#39;m s=\r\npending this much time defending\nit as if it didn&#39;t work or something.  Giv=\r\ne your variants URIs.  In\nREST, we call this the &quot;identification of resourc=\r\nes&quot; constraint.  That\nbrowsers and caches require you to abide by it, doesn=\r\n&#39;t mean they&#39;re\nbroken, it means they&#39;re expecting you to follow RFC 2616&#39;s=\r\n SHOULD.\n\n&gt;\n&gt; &quot;This abstract definition of a resource enables key features =\r\nof the\n&gt; Web architecture. First, it provides generality by encompassing ma=\r\nny\n&gt; sources of information without artificially distinguishing them by\n&gt; t=\r\nype or implementation. Second, it allows late binding of the\n&gt; reference to=\r\n a representation, enabling content negotiation to take\n&gt; place based on ch=\r\naracteristics of the request. Finally, it allows an\n&gt; author to reference t=\r\nhe concept rather than some singular\n&gt; representation of that concept, thus=\r\n removing the need to change all\n&gt; existing links whenever the representati=\r\non changes (assuming the\n&gt; author used the right identifier).&quot;\n&gt; \n\nYes, RES=\r\nT allows the late binding of representation to resource. Which\nis why I can=\r\n&#39;t understand why @type should be an instruction which\nprevents this from o=\r\nccurring.  Having the browser perform some sort of\n@type juju amounts to bi=\r\nnding the representation to the resource before\nthe request has even been m=\r\nade!  Such coupling is not copasetic to the\nREST style -- if you want to av=\r\noid conneg, don&#39;t instruct the client to\nuse a negotiated URI.  It&#39;s really=\r\n that simple, which is why it amazes\nme that we keep having this debate her=\r\ne.  No downside =3D=3D no problem.\n\n-Eric\n\n"}}