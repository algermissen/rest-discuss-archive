{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":23186829,"authorName":"Paul Prescod","from":"Paul Prescod &lt;paul@...&gt;","replyTo":"SENDER","senderId":"KoRImdhKG8r4QawUOChohhoCvi8ROg7BeJpfLWEDq6Zhj0Jnq4EHeeqvS1mBk7fhsBSEMP6QfmKCvRfuaMwjlNxbC5DN0g","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Comments Welcome","postDate":"1019122142","msgId":1055,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNDQkU5MURELkQ4MTQyQTYwQHByZXNjb2QubmV0Pg=="},"prevInTopic":0,"nextInTopic":1060,"prevInTime":1054,"nextInTime":1056,"topicId":1055,"numMessagesInTopic":3,"msgSnippet":"Please do not forward this too widely yet. I intend to publish it on xml.com. In particular, please don t forward links to it yet. It s canonical home should","rawEmail":"Return-Path: &lt;paul@...&gt;\r\nX-Sender: paul@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_3_1); 18 Apr 2002 09:27:45 -0000\r\nReceived: (qmail 69676 invoked from network); 18 Apr 2002 09:27:41 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m6.grp.scd.yahoo.com with QMQP; 18 Apr 2002 09:27:41 -0000\r\nReceived: from unknown (HELO smtp1.ActiveState.com) (209.17.183.249)\n  by mta2.grp.scd.yahoo.com with SMTP; 18 Apr 2002 09:27:41 -0000\r\nReceived: from smtp3.ActiveState.com (smtp3.ActiveState.com [192.168.3.19])\n\tby smtp1.ActiveState.com (8.11.6/8.11.6) with ESMTP id g3I9Rb210368\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Thu, 18 Apr 2002 02:27:37 -0700\r\nReceived: from prescod.net (ssh1.ActiveState.com [192.168.3.32])\n\tby smtp3.ActiveState.com (8.11.6/8.11.6) with ESMTP id g3I9RZe31769\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Thu, 18 Apr 2002 02:27:35 -0700\r\nMessage-ID: &lt;3CBE91DD.D8142A60@...&gt;\r\nDate: Thu, 18 Apr 2002 02:29:02 -0700\r\nX-Mailer: Mozilla 4.76 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: &quot;rest-discuss@yahoogroups.com&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nSubject: Comments Welcome\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nX-Filtered-By: PerlMx makes it fast and easy.  See http://www.ActiveState.com/Products/PerlMx/Header\r\nFrom: Paul Prescod &lt;paul@...&gt;\r\nX-Yahoo-Group-Post: member; u=23186829\r\n\r\nPlease do not forward this too widely yet. I intend to publish it on\nxml.com. In particular, please don&#39;t forward links to it yet. It&#39;s\ncanonical home should be xml.com. Still needs proof reading and comments\nare welcome, as always.\n\n=====\n\n                        Google&#39;s Gaffe\n                               \nGoogle&#39;s release of an Application Programming Interface has\nbeen heralded as a bright moment for web services. It is true\nthat it is an exciting development, but at the same time there\nis a subset of the programmer community that is disappointed.\nGoogle had a similar XML-based API a year ago, but did not\ndocument it or hype it. Merely by adding the URL fragment\n&quot;/xml&quot; to your query, you could get back an XML representation\nof a query, for processing by any XML-aware programming\nlanguage or tool. It became a pay-only service last fall. We\nwere disappointed but understood why that would happen -\nlacking in advertisements, the service was a straight money\nloser.\n\nImagine our surprise when we heard the big announcement\nrecently. Google had revived the service, added new features,\ndocumented it and promoted it, but had moved it to a an\ninferior technical platform: SOAP. Over dozens of mailing\nlists, weblogs and discussion groups the reaction was mixed:\n&quot;An official Google API! But why use SOAP?&quot; It feels like one\nstep forward and two backwards.\n\nThis article will demonstrate that the choice to use SOAP was\na poor one. The much simpler HTTP URI technique was easier to\nuse and more powerful at the same time. I will recast the new\nGoogle API back into a URI and HTTP-based API and demonstrate\nthe virtues of the simpler HTTP strategy.\n\n                     Why Google Is Special\n                               \nIn the past, I have demonstrated how SOAP-based services can\nbe re-engineered around pure HTTP. These services can be\narbitrarily complex, transactional, read-write and secure.\nThere are thousands of web services out there and I do not\nhave time to re-invent each and every one of them as\nHTTP-based service. But the new Google API is special for a\nvariety of reasons.\n * Google has had an XML and HTTP based API in the past.\n   Their choice to use SOAP would seem to indicate a need to\n   move beyond HTTP. My experiment demonstrates that this is\n   not so.\n * Google&#39;s service seems almost unique in how simply and\n   clearly one can establish an HTTP interface. In essence,\n   it feels like a thin SOAP wrapper over a simple HTTP\n   service. Making an HTTP interface for Google is a\n   &quot;no-brainer&quot;.\n * Google the corporation has always been known for its\n   technological acumen and general cluefulness. I think that\n   they can be convinced to do the right thing and restore\n   the HTTP interface (perhaps alongside the buzzword\n   compliant SOAP interface).\n   \nIn addition, I think that the Google move is important\nsymbolically. I take the SOAP-ifying of Google as a sign that\nthe web services hype has now reached overdrive. I now\nregularly hear from customers that they have working XML\nsystems but: &quot;we know we&#39;ll have to move to SOAP soon.&quot; This\nis simply not true.\n\nSOAP is an unproven technology with a questionable design.\nWorse, when it is misused (as in the Google API) it has a\ndetrimental effect on the growth of the Web. As I will\ndemonstrate, at the heart of the Web is the concept of URIs.\nThe Google API substitutes a proprietary addressing mechanism\nfor URIs and thus hides information from Web-based software\nsuch as XSLT engines and XInclude implementations.\n\n                       Google&#39;s SOAP API\n                               \nLet&#39;s take a look first at Google&#39;s SOAP API. This is our\nstarting point. Here is a complete message from client to\nserver using their API:\n\nI set maxResults to 0 so that I won&#39;t actually get any\nresults. Google returns a ton of XML metadata about the query\nitself so working with query &quot;hits&quot; would make my examples too\nlong.\n\nThe message starts with HTTP headers because the Google API\nruns SOAP over HTTP. The only SOAP-specific header is the\nSOAPAction header which is theoretically useful for filtering\nSOAP traffic. Practically speaking it is optional and thus not\na good basis for filtering.\n\nThe XML part of the message starts with some namespace\ndeclarations, and a SOAP encodingStyle declaration (more or\nless boilerplate). After that comes a set of ordered\nparameters. The parameters to the operation consist of an\nordered list of values. The allowed values for the\ndoGoogleSearch command is are &quot;key&quot; (userid/password), &quot;q&quot;\n(query text), &quot;start&quot; (where in the results to start\nreturning), &quot;maxResult&quot; (number of allowed results), &quot;filter&quot;\n(filtering out very similar results), &quot;restrict&quot; (country or\ntopic restrictions), &quot;safeSearch&quot; (pornography filter), &quot;lr&quot;\n(language restrict), &quot;ie&quot; (input encoding) and &quot;oe&quot; (output\nencoding) properties.\n\nThe &quot;key&quot; property is special. It is more or less a password\nassigned to a particular software developer. The Google API\nseems not to support SSL so these always pass across the wire\nin cleartext.\n\nAs you can see, parameters are strongly typed. The client and\nserver know the types in advance but for some reason, most\nSOAP toolkits will inline the types into the messages. As you\nwill see, this is entirely unnecessary.\n\nHere is the message Google returns:\n\nNote that the resultElements element is empty. I warned you\nthat we would have quite a bit of XML to work with even\nwithout looking at any hits!\n\nThere are two more methods. doSpellingSuggestion requests a\nspelling correction suggestion. For instance it would suggest\nthat &quot;britney speers&quot; be corrected to &quot;britney spears&quot;. It\ntakes only a key and string as parameters, and returns only a\nstring for the suggestion.\n\ndoGetCachedPage requests a cached page from Google. It takes a\nkey and a URI as parameters and returns Base64-encoded data\nfor the cached page.\n\n                        HTTP Equivalent\n                               \nTo reinvent this as an HTTP-based web service, I merely have\nto translate the properties into &quot;query parameters&quot; in a URI.\nA couple of hundred lines of Python serve to implement the\nmapping from these query parameters into Google SOAP.\n\nHere is the sort of URI used to address into my version of the\nservice:\nhttp://localhost/scripts/search.py?key=0000&q=constantrevolution+rules+\nxml&maxResults=10\n\nThat&#39;s pretty ugly, but consider that nobody (even a\nprogrammer) ever needs to look at this URI. It can be\ngenerated, just as the SOAP message is. For instance here is a\ncomplete Python program to fetch the information from that\nURI:\nimport urllib\n\nparams = {&quot;key&quot;:&quot;0000&quot;,\n      &quot;q&quot;:&quot;constantrevolution rules xml&quot;,\n      &quot;maxResults&quot;:&quot;0&quot;,\n        }\nurllib.urlopen(&quot;http://localhost/scripts/search.py?&quot; +\n    urllib.urlencode(params))\n\nHTTP deals with optional arguments much more gracefully than\ndo most WSDL-based SOAP toolkits, so I&#39;ve left out any of the\narguments that can be inferred or omitted.\n\nLet&#39;s zoom in on the special key parameter. HTTP has a\nbuilt-in authentication mechanism so really that would be a\nbetter way to handle it. Recent implementations of HTTP have a\nchallenge/response [1]authentication scheme which is more\nsecure than simply passing a key in cleartext. Of course for\nultimate security (at a price in performance), I would\nrecommend you SSL encrypt the entire message. SOAP does not\nitself support authentication yet, and authentication is (as\nof this writing) still an [2]open issuefor SOAP&#39;s\nRPC-over-HTTP binding. I will leave key as a parameter for\nsimplicity and to more closely parallel the SOAP version.\n\nHere is the message that gets sent on the wire:\nGET /scripts/search.py?maxResults=0&key=XXX&q=constantrevolution+rules+\nxml HTTP/1.0\nHost: localhost\nUser-agent: Python-urllib\n\nThat&#39;s all!\n\nNow some might complain that the query parameters are all\n&quot;just strings&quot; whereas the SOAP parameters were strongly\ntyped. This is not necessarily true. On the wire, of course\nthe parameter are just strings, just as SOAP messages are just\nstrings. Only at the client and the server are the strings\ninterpreted as other types. The client must know the types of\nthe parameters in order to have made the call. The server must\nknow the types of the parameters in order to have implemented\nthe service. Given both parties already know the types, it is\na waste of bandwidth to declare the types of the parameters in\neach and every message. Even SOAP does not require this. It is\nmerely a common SOAP idiom.\n\nThis leaves the question of how that is communicated. Later I\nwill show a way to declare the types strongly and statically\nenough to satisfy the most ardent Java or C# masochist.\n\nHTTP allows any media type in the response to a message. It\ncould return any XML vocabulary whatsoever. Insofar as the\nGoogle SOAP API already embeds a simple schema, it makes sense\nto use that. I merely have to remove a few SOAP-isms (the\narrayType attribute, the SOAP-env element, etc.) and choose a\nnew root element type (I chose searchResult). I hereby\nchristen the purified language GoogleML. I&#39;ve written an XSLT\nstylesheet that I call &quot;pureGoogle.xsl&quot; which translates\nGoogleSOAP into GoogleML. The resulting documents are much\nsmaller, simpler and easier to read.\n\nHere is the stylesheet (minus a few namespace declarations):\n\nAnd here&#39;s a GoogleML equivalent to the response from before:\n\nHTTP provides the envelope so there would be no need for a\nredundant, second SOAP envelope. The types are known in\nadvance so they are stripped (although I could just as easily\nhave left them in). GoogleML documents are not constrained to\nthe features of XML supported by SOAP. GoogleML documents can\nuse a DOCTYPE and DTD, and could use processing instructions.\n\nThe most dramatic improvement comes in the getCachedPage\nrequest. HTTP can efficiently handle non-XML data. HTTP\ndelivers terabytes of binary data every day. Conversely, SOAP\nrequires non-XML data to be Base-64 encoded (unless the use of\nthe non-standards-track SOAP With Attachments specification).\nBase64 data is always more verbose than unencoded binary data\nso the HTTP/URI/GoogleML version of the service will always\nsave bandwidth and CPU power.\n\nCompare the SOAP doGetCachedPage request:\n\nNow compare that to an HTTP-style cachedPage request:\n    \n    \n\nCompare the SOAP response (embedding base64-encoded data):\n\nto the HTTP-style response:\n\nBecause HTTP has no problem directly embedding HTML\n(well-formed or not!), there is no reason to base64-encode the\ndata.\n\nFinally compare the old-style SOAP doSpellingSuggestion\nresponse:\n\nTo the HTTP version:\n\nI could have used XML for the response, but why? It is\noverkill for this job.\n\n                        Declaring Types\n                               \nUnfortunately many believe that the difference between\nHTTP-based services and RPC-based services is that the former\nare loosely or dynamically typed and the latter are strongly\nor statically typed. This is not really true. The choice\nbetween HTTP and SOAP is a choice between protocols. The\ndecision to statically type-check information passing across\nthe wire is more concerned with service description. The two\nissues are totally separate.\n\nI&#39;ve already demonstrated how one can strongly type-declare\nthe responses to HTTP-based services using XML Schema. If you\nwant to type-declare the query parameters then you can use a\nlanguage designed for type-declaring HTTP-based services like\nmy Web Resource Description Language (WRDL).\n\nWRDL is still under development but in fact you can already\nsolve this problem today using the more popular &quot;industry\nstandard&quot; language WSDL. WSDL has some basic HTTP-declaration\nfeatures. Although WSDL is most often used with SOAP, it can\nin fact type-declare the parameters for simple HTTP services.\nHere is the relevant bit of a WSDL for my HTTP version of the\ndoGetCachedPage method:\n\nIt turns out that WSDL&#39;s handling for the &lt;http:urlEncoded/&gt;\nworks almost perfectly. It gets the parameter names from the\noperation&#39;s part names. If you know WSDL then that will\nprobably be clear to you. If not, don&#39;t worry about it. The\ninput description for the other two methods is identical, so\nwe will concentrate on the output element.\n\nThe output for the doSpellingSuggestion has a media-type of\n&quot;text/plain&quot;:\n\nFinally, the output for doGoogleSearch\n\nThis refers to a part named searchResult which is based upon\nan element type of the same name.\n\nNow I do not want to oversell WSDL&#39;s HTTP features. You cannot\ndefine sophisticated HTTP-based web services with WSDL. WSDL\nfalls down as soon as a web resource generates links to\nanother web resource. WSDL cannot express the data type of the\ntarget resource. In other words it can describe only one\nresource and not the links between Web resources. SOAP lacks a\nfirst-class concept &quot;of resource&quot; and especially lacks a\nsyntax for linking them. It is thus not surprising that WSDL\ninherits this flaw. Nevertheless, I hope that this weakness\nwill be corrected in future versions of WSDL. In the meantime,\nthis is the primary reason for the existence of the WRDL\nlanguage.\n\nFor instance, imagine if the search API returned a URI to the\ncached page, just as it does in the HTML version of Google.\nYou could declared in WRDL (as opposed to WSDL) that the\ncachedPage element of searchResult resources points to a\ndocument of type text/html. I could also define a resource\ntype for Google &quot;directory catalogs&quot;, then I have strong types\nfor the links from search results to the directory catalogs\nand back. WRDL is designed (okay, being designed) to mirror\nthe structure of the Web, rather than impose a\ncomponent-oriented view on top of it.\n\nStill and all, you do not have to wait for WRDL. WSDL is\nsufficient for Google&#39;s current API because the API does not\nmake use of hyperlinks. This is a common failing of SOAP-based\nAPIs which follows from the component-centric thinking that\npervades the SOAP community.\n\n                  Advantages of the HTTP API\n                               \nLet&#39;s consider the benefits of the HTTP version. First, I have\nalready discussed how HTTP has standardized ways of doing\nauthentication and of handling non-XML (including non-textual)\ndata.\n\nThe message size is a tiny fraction of the original. More\nimportant, it is much, much easier for a typical system\nsecurity administrator to read. It is also vastly easier to\nfilter, log and monitor. The CPU load is also likely to be\nsignificantly smaller. I don&#39;t even want to know how many\ncycles are being wasted around the world building those silly\nGoogle SOAP messages (sometimes base64&#39;ing data!) and then\nparsing them down again on the other side. Remember that each\nand every message is also an HTTP message and must be built\nand parsed as such. Californian readers should remind Google\nthat electricity is precious. They could switch to HTTP and\nturn off a couple of wasted server clusters.\n\nI have no need to install a SOAP implementation like .NET&#39;s or\nApache&#39;s. You can use any HTTP implementation, including\nInternet Explorer, Netscape, Mozilla, Lynx, Opera, wget,\n&quot;java.net.URL&quot;, Python&#39;s httplib.HTTPConnection, Perl&#39;s LWP,\netc. In fact, you could easily test the API through a plain\nold HTML form!\n\nThe HTTP version is highly amenable to caching. You can set up\na standard HTTP cache on your local network, or use one at\nyour ISP. Google could also do server-side caching using\nsomething as simple as Squid. Of course caching of SOAP is\nalso possible: if you write the cache implementation yourself.\nWith HTTP, you can install any one of a variety of free or\ncommercial caching proxy implementations.\n\nThe HTTP version could use the little-known feature of HTTP\nknown as content negotiation. &quot;Conneg&quot; as it is known to its\nfans, allows each URI to map to a resource that can deliver up\nvarious representations of itself. For instance the service\ncould return the same URI in GoogleML, SOAP, XML-RPC and HTML,\ndepending on the preferences of the caller.\n\nBut all of these advantages are like the tiny diamonds that\nring the Big Rock.\n\n                   The Web&#39;s Crowning Glory\n                               \nThe most important advantage is that an HTTP version is part\nof the Web rather than merely being behind the web. This point\nis subtle but the most central. A piece of information is on\nthe Web if it has a URI or is embedded in a resource with a\nURI. When I expose the Google API through SOAP it is behind\nthe Web because the object with the web URI is the SOAP\ncomponent, not the actual query results. Only the component is\non the Web. But in the HTTP way of thinking about it, every\npossible query result has its own URI and thus is a\nfirst-class web data object.\n\nThis assigning of URIs is incredibly powerful. First, it means\nthat in standard hypertext documents it is possible to link to\nquery results. There are thousands of links around the Web to\nGoogle search result resources. Google&#39;s HTML incarnation is\nan important part of the web community as a service but it is\nalso an important part of the web through the thousands of\nvirtual &quot;resource documents&quot; it hosts like:\n[3]http://www.google.com/search?hl=en&q=xml+-soap\n\nNow it is time to move this concept into XML. You may recall\nthe days when XML was intended to be a way of publishing\nstructured information on the Web. One of the great virtues\nwas [4]supposed tobe that result sets could be more compact\nand could be manipulated (e.g. sorted and filtered) using\nclient-side scripting. Somehow I got sidetracked with RPC\nmodels and SOAP, but the core idea of delivering XML to the\ndesktop is alive and well in [5]Internet Explorer and\n[6]Mozilla.\n\nOf course public websites cannot depend upon client-side XML\nsupport being widely deployed yet, but companies like Google\nshould be laying the groundwork for a future XML-based Web\nrather than burying XML for use only in machine to machine\napplications. One of the virtues of XML we promoted in the\n1997 edition of the XML Handbook was that XML brought the\nrepresentation of information for machines and humans\ntogether. We still have not achieved that and will not until\nmachines and humans use the same access protocol: HTTP.\n\nBut URI-addressability is important even for information that\nwill never be seen by humans. Addressable XML can be composed\ninto extremely sophisticated &quot;compound-documents&quot; using\ntechnologies like XInclude, XSLT, XLink, RDF and Topic Maps.\nFor instance, consider a document that uses XInclude to\naggregate query results:\n\nNow consider an XSLT template that does the inclusions:\n\nAnd then a template in another XSLT transform could collect\nthe URL and snippet elements in the merged data, sort them by\nURL and transform them to HTML:\n\nNext consider an RDF assertion that related the query results\nto an individual&#39;s home pages:\n\nThis is the fundamental power of the Web. The Web&#39;s strength\nis that it allows us to address, link, compare, relate and\notherwise combine resources. The point that has not yet\nfiltered through to the mainstream of web services\nimplementors is that this is just as important for machine to\nmachine applications as it is for human-facing applications.\nTo repeat: linking is just as important for machine to machine\napplications as it is for human-facing applications. If it is\nimpossible to link to SOAP-exposed resources then they are\nless powerful and useful than HTTP-exposed ones. Let me\nrephrase that: until SOAP has an addressing mechanism as rich\nas HTTP URIs, SOAP is less, not more, powerful than HTTP.\n\nA less generous person might argue that SOAP services are\ncalled &quot;web services&quot; because they wish to partake of the\nWeb&#39;s success -- yet do not wish to build upon its core\ntechnologies: URIs and HTTP.\n\n                        Service as API\n                               \nAn important issue in all of this is ease-of-use. If it is no\nlonger simple for programmers to access the information then\nthe service will fail.\n\nLet&#39;s start from the point of view of a programmer with no\nspecial toolkit at all, just a standard programming language\ndistribution or IDE. Obviously the HTTP solution wins because\nSOAP and WSDL support is not yet embedded in most programming\nlanguage distributions. It takes five lines of Java to get a\ncached page or spelling correct from my version of the\nservice. You don&#39;t need even an XML parser installed. Of\ncourse working through search results will require an XML\nparser but it will not require a SOAP engine on top.\n\nOn the other hand, what if you already have a SOAP/WSDL\ntoolkit? Well if the toolkit is complete (good luck!) then it\nwill support WSDL&#39;s HTTP binding. You can use exactly the same\nAPI to access the service as if you were using the SOAP\nversion. For instance I can generate a statically typed C#\ninterface from my WSDL description and it is functionally\nidentical to the SOAP version. Truth in advertising: to get it\nactually working I did have to work around a few small bugs in\nMicrosoft&#39;s WSDL toolkit. WSDL implementors: please take\nWSDL&#39;s HTTP bindings seriously and implement them properly!\nNote that there is also a prototype of a WRDL-&gt;C# tool which\nwill do the same for WRDL descriptions.\n\nIf you are opposed to external service descriptions, there are\na variety of inline-type annotation techniques you could use.\nExamples include the OMG&#39;s XMI, Jacobson&#39;s MIME-RPC, Winer&#39;s\nXML-RPC, Allaire&#39;s WDDL and even SOAP&#39;s &quot;section 5&quot; encoding.\nNo one of these has become standardized because the common\nwisdom in the strongly typed XML world is that it will be much\nmore common to express the types in some form of external\nschema such asXML Schema, RELAX NG, Schematron or DT4DTDs.\nHTTP/WRDL works perfectly with all of these and unlike the\nSOAP/WSDL combination has no preference for one over the\nother.\n\nIf you like neither inline typing nor schemas then you have a\nthird choice: you can use a language-specific databinding\ntechnology such as Castor, JAXB or [7].NET Data Binding.\n\nIn other words, parsing XML into language-native data types is\na problem that has been solved over and over again. If you\nhappen to prefer the SOAP solution then use the SOAP encoding.\nSOAP is XML and can be used with various XML technologies. But\nremember that you can use the SOAP encoding without buying the\nwhole SOAP RPC-over-HTTP model. If you use the SOAP encoding\nwith HTTP-based URIs then you preserve the essential heart of\nthe Web: the ability to address information.\n\n                     What Would Frodo Do?\n                               \nBack in the days where XML was called SGML, we enthusiasts\nwere like Hobbits in the Shire, hearing tales of the distant\nwars between Wizards (tools vendors), Dragons (database\nvendors) and Armies (MIS departments). But we were relatively\nsheltered from them. Those days have long since passed. XML\nusers have a special understanding of the possibilities of the\nmarriage of hyperlinks, XML and the Web. We have a\nresponsibility to go out of the Shire and educate the other\nresidents of Middle Earth. Google is like the wizard Saruman,\na benign and powerful force inexplicably turned from the path\nof virtue. Nevertheless, I am confident that they can be won\nback! The white robe awaits on the delivery of the Google API\nbeta 3.\n\nWhat we need to do is gather together a fellowship of\nlike-minded Hobbits, Dwarves, Elves and men and go on a quest\nto improve the world in whatever small way we can. You can\njoin the quest by signing the [8]petition available , and if\nyou don&#39;t mind registering for Yahoo Groups, you can also\nparticipate in the thread discussing this topic. Please\nforward this article to mailing lists.\n\nWe must help our fellow technologists to use SOAP only after\nthey have understood its limitations and to understand that\nthey can make the Web a richer place by putting XML-based data\non the Web rather than behind it Yes, there are Wizards,\nDragons and Armies about, but Hobbits can influence events\nalso.\n\nReferences\n\n1. http://www.ietf.org/rfc/rfc2617.txt\n2. http://www.w3.org/TR/soap12-part2/#simpleauthfeat\n3. http://www.google.com/search?hl=en&q=xml+-soap\n\n5. http://www.xml.com/pub/a/2000/05/03/msie/\n6. http://www.mozilla.org/newlayout/xml/\n7.\nhttp://msdn.microsoft.com/msdnmag/issues/01/03/cutting/cutting0103.asp?frame=true\n\n"}}