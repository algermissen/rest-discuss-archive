{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"DqdOIffjqmJbTYt-DUVtwUvO-PYqtAR0J9o-MCX6YbVmdxFe0bBKCzoDxPdZtrv3yWqF1FhaypdWgBCW5oi6vn5l3XMZiD0su2n-TdO3gQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"HTTP is not REST, nor is Web3S.","postDate":"1182646916","msgId":9203,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PFc0NTk5NzIyNDQ2MjM3ODcxMTgyNjQ2OTE2QG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":0,"nextInTopic":0,"prevInTime":9202,"nextInTime":9204,"topicId":9203,"numMessagesInTopic":1,"msgSnippet":"There are several concurrent threads discussing similar points about HTTP.  To pick one example, Where does RFC 2616 say POST MUST be non- idempotent?  I say","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 43036 invoked from network); 24 Jun 2007 01:02:29 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m45.grp.scd.yahoo.com with QMQP; 24 Jun 2007 01:02:29 -0000\r\nReceived: from unknown (HELO mail.mailsnare.net) (209.236.228.78)\n  by mta9.grp.scd.yahoo.com with SMTP; 24 Jun 2007 01:02:28 -0000\r\nX-Virus-Scanned: by ClamAV at mailsnare.net\r\nX-Message-ID: 749f92e98ac7daa1b40c7093adeba4681e7bd0d5869d272e49d9ebde58f8da29\r\nReceived: from mail.mailsnare.net (unknown [209.236.228.74])\n\tby mail.mailsnare.net (Postfix) with ESMTP id 68E37520F3;\n\tSun, 24 Jun 2007 01:01:56 +0000 (UTC)\r\nTo: rest-discuss@yahoogroups.com\r\nImportance: Normal\r\nSensitivity: Normal\r\nMessage-ID: &lt;W4599722446237871182646916@...&gt;\r\nX-Mailer: Mintersoft EdgeDesk, Build 4.03.0105\r\nDate: Sun, 24 Jun 2007 01:01:56 +0000\r\nOrganization: Bison Systems Corporation\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;utf-8&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nReply-To: eric@...\r\nSubject: HTTP is not REST, nor is Web3S.\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nThere are several concurrent threads discussing similar points about \nHTTP.=\r\n  To pick one example, &quot;Where does RFC 2616 say POST MUST be non-\nidempoten=\r\nt?&quot;  I say it matters not, because HTTP is not REST.  An HTTP \napplication =\r\nis implemented RESTfully by constraining messages to be self-\ndescriptive, =\r\netc.  In one application, POST may be constrained to be \nidempotent and in =\r\nanother, POST may be constrained to be non-idempotent.  \nThe same goes for =\r\nthe debate over partial vs. full PUT.\n\nEither approach may be part of a RES=\r\nTful system and either approach may \nbe described by RFC 2616, but this doe=\r\ns not make the protocol vague \nbecause the append/annotate semantics of POS=\r\nT are specific.  If I \nconstrain POST to be non-idempotent in my REST API, =\r\nthat still isn&#39;t a \nguarantee that it won&#39;t appear to be idempotent from th=\r\ne user-agent \nperspective over some arbitrary period of time.  If I constra=\r\nin POST to \nbe idempotent in my REST API, more power to me but I can&#39;t expe=\r\nct to get \nany of the benefits of scale possible with methods recognized as=\r\n \nidempotent in the established protocols.  HTTP user-agents won&#39;t treat \nm=\r\nultiple POST requests as idempotent even if the responses appear \nidempoten=\r\nt because the non-idempotent semantics intended for POST are \nspecific.\n\nSi=\r\nmilarly, in one REST application PUT may be constrained to be a full \nrepla=\r\ncement, while in another REST application PUT may be treated as a \npartial =\r\nreplacement.  RFC 2616 may be interpreted to describe either \napproach, but=\r\n this doesn&#39;t make HTTP vague because the replacement \n(storage?) semantics=\r\n of PUT are clear.  If my REST API generates an \nXHTML representation with =\r\na server-assigned &lt;title&gt; and it constrains \nPUT to be a full replacement, =\r\nattempts by the user-agent to edit the \n&lt;title&gt; will fail in the same way e=\r\nven when the PUT is repeated without \nresulting in a 400 response.  The sem=\r\nantics are replacement, not merge, \neven though the result is a partial upd=\r\nate because the idempotent \nsemantics intended for PUT are specific.\n\nSo +1=\r\n from me for reviving PATCH to provide an HTTP method which \nconstrains mes=\r\nsages as having merge semantics.  Even if it isn&#39;t in RFC \n2616, the use of=\r\n an established, self-descriptive protocol method which \napplies a merge co=\r\nnstraint on the communication between the components \nof a distributed hype=\r\nrmedia system is very much in accordance with REST, \nwhereas the assignment=\r\n of merge semantics to PUT (even in a non-HTTP \nprotocol) is not.  Nor is t=\r\nhe introduction of a new method whose \nsemantics overlap those of other met=\r\nhods, because in a truly RESTful API \neach verb used maps to a different us=\r\ner-action and set of appropriate \nresponse codes, i.e. each method must hav=\r\ne its own semantics.\n\nSince Web3S is not an HTTP protocol we may evaluate i=\r\nt purely in terms \nof REST rather than in terms of RFC 2616.  It is my posi=\r\ntion that when \ndesigning a new protocol which re-uses existing, similar me=\r\nthods that the \nsemantics of the established methods not be changed.  Which=\r\n means I am not \nagainst the introduction of new methods in a new protocol =\r\nper se, only -1 \nagainst the use of UPDATE in Web3S.  REST application sema=\r\nntics must be \ndefined by the network interface, not the media type.\n\nWeb3S=\r\n fails to constrain protocol methods to have different meanings, \ntherefore=\r\n its messages are not self-descriptive.  Both PUT and UPDATE \nhave merge se=\r\nmantics in Web3S, while no method is constrained to have \nreplacement seman=\r\ntics.  The established protocols are specific about the \nintent of applicat=\r\nion actions, PUT clearly intends to have replacement \nsemantics and PATCH c=\r\nlearly intends to have merge semantics.  The failure \nto constrain the comm=\r\nunication between components in a Web3S interaction \nleads to the requireme=\r\nnt that the components understand that the media \ntype or schema override t=\r\nhe established replacement semantics of PUT with \nthe semantics of merge, a=\r\nnd no intermediary could ever hope to figure out \nthe semantics of UPDATE.\n=\r\n\nWhich makes Web3S appear to be a library-based, rather than a network-\nbas=\r\ned, API.  To paraphrase Dr. Fielding:  &quot;The result is an application \nthat =\r\nforbids any layers of transformation and indirection that are \nindependent =\r\nof the information origin, which is not so useful for an \nInternet-scale, m=\r\nulti-organization, anarchically scalable information \nsystem&quot; because the i=\r\nnterface is using nonstandard semantics, i.e. is not \nreally generic.  Whil=\r\ne requests may be directed at resources, it still \nsmells RPCish to me, bec=\r\nause Web3S doesn&#39;t seem to be much more than a \ntransport protocol.  Resour=\r\nce-oriented?  Yes.  REST?  Sadly, no.\n\nWhile neither HTTP nor Web3S are RES=\r\nT, a RESTful API may be implemented \nusing HTTP, but not with Web3S as curr=\r\nently written.\n\nThesis references follow,\nEric\n\n=3D=3D=3D=3D=3D=3D=3D=3D=3D=\r\n=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=\r\n=3D=3D=3D=3D=3D=3D=3D=3D\n\n5.3.1 Process View\n\nREST enables intermediate pro=\r\ncessing by constraining messages to be self-descriptive: interaction is sta=\r\nteless between requests, standard methods and media types are used to indic=\r\nate semantics and exchange information, and responses explicitly indicate c=\r\nacheability.\n\n5.4 Related Work\n\n[T]he real WWW architecture is independent =\r\nof any single implementation. The modern Web is defined by its standard int=\r\nerfaces and protocols, not how those interfaces and protocols are implement=\r\ned in a given piece of software.\n\n6.2.2 Manipulating Shadows\n\nAn origin ser=\r\nver maintains a mapping from resource identifiers to the set of representat=\r\nions corresponding to each resource. A resource is therefore manipulated by=\r\n transferring representations through the generic interface defined by the =\r\nresource identifier...  Forcing the interface definitions to match the inte=\r\nrface requirements causes the protocols to seem vague, but that is only bec=\r\nause the interface being manipulated is only an interface and not an implem=\r\nentation. The protocols are specific about the intent of an application act=\r\nion, but the mechanism behind the interface must decide how that intention =\r\naffects the underlying implementation of the resource mapping to representa=\r\ntions.\n\n6.2.4 Binding Semantics to URI\n\nIt is the nature of every engineer =\r\nto define things in terms of the characteristics of the components that wil=\r\nl be used to compose the finished product. The Web doesn&#39;t work that way. T=\r\nhe Web architecture consists of constraints on the communication model betw=\r\neen components, based on the role of each component during an application a=\r\nction. This prevents the components from assuming anything beyond the resou=\r\nrce abstraction, thus hiding the actual mechanisms on either side of the ab=\r\nstract interface.\n\n6.5.1 Advantages of a Network-based API\n\nA network-based=\r\n API is an on-the-wire syntax, with defined semantics, for application inte=\r\nractions. A network-based API does not place any restrictions on the applic=\r\nation code aside from the need to read/write to the network, but does place=\r\n restrictions on the set of semantics that can be effectively communicated =\r\nacross the interface. On the plus side, performance is only bounded by the =\r\nprotocol design and not by any particular implementation of that design.\n\nA=\r\n library-based API does a lot more for the programmer, but in doing so crea=\r\ntes a great deal more complexity and baggage than is needed by any one syst=\r\nem, is less portable in a heterogeneous network, and always results in gene=\r\nricity being preferred over performance. As a side-effect, it also leads to=\r\n lazy development (blaming the API code for everything) and failure to acco=\r\nunt for non-cooperative behavior by other parties in the communication.\n\n6.=\r\n5.2 HTTP is not RPC\n\nWhat makes HTTP significantly different from RPC is th=\r\nat the requests are directed to resources using a generic interface with st=\r\nandard semantics that can be interpreted by intermediaries almost as well a=\r\ns by the machines that originate services. The result is an application tha=\r\nt allows for layers of transformation and indirection that are independent =\r\nof the information origin, which is very useful for an Internet-scale, mult=\r\ni-organization, anarchically scalable information system.\n\n6.5.3 HTTP is no=\r\nt a Transport Protocol\n\nIt is possible to achieve a wide range of functiona=\r\nlity using this very simple interface, but following the interface is requi=\r\nred in order for HTTP semantics to remain visible to intermediaries.\n\nA tru=\r\ne application of HTTP maps the protocol user&#39;s actions to something that ca=\r\nn be expressed using HTTP semantics, thus creating a network-based API to s=\r\nervices which can be understood by agents and intermediaries without any kn=\r\nowledge of the application.\n\n\n\n\n"}}