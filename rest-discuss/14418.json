{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"vfjlny4rXOQ-AZQZBEG2suaUakWGBaBVokzEUqkPIwQM5kfJa-bq8-FWv2W1HLbRJK7pKKhtcq0pvez-FVS2Z7DS3ZqyTiiptB8QOWN5TA","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] REST isn&#39;t hard to learn, it&#39;s just taught wrong.","postDate":"1261727453","msgId":14418,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkxMjI1MDA1MDUzLjNjOTk5ZDdlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDYzNkU4QkVBLTMzOUMtNDFBMy1BN0UyLUU4M0I3NjBBN0YyMkBzdWJidS5vcmc+","referencesHeader":"PDIwMDkxMjIwMjEyNjMzLjcxNWNhOTQyLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDg3aXFjMHp6aWcud2wlYmVyZW5kQHBvYm94LmNvbT4JPDIwMDkxMjIwMjI0NjEyLmI4MzVmNTAyLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIwMjI1OTQwLjc1MzdlOTMxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIxMDAzNjA1LjdjZDkwNzBiLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIxMTcwNzM1LjZiMzkxOWNlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEJBNjU3OEYxLTQ3NzgtNDY0Ri1BRUM2LTlDQTYzQzRGMEJCRkBzdWJidS5vcmc+CTwzRkU5ODRGMi1GNThELTRGMkYtODhFNy1GRkJBMzFFMUI5RTJAaW5ub3EuY29tPgk8MjAwOTEyMjIxNDIyMzcuNDEwMDQyMDQuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8MzdBQzczMTUtMTlGRC00RjVELUFGREItNzMxMTE3RjhBQkM5QGlubm9xLmNvbT4JPDIwMDkxMjIzMTU1NTI5LmY4OWUzYjhkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDM1NTFFOTlBLTNERjgtNEMzQy04NDgwLTlBNkY3NDIzOUIxQUBpbm5vcS5jb20+CTwyMDA5MTIyMzIwMTMwMy41ZDk2NGNjZS5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTw2MzZFOEJFQS0zMzlDLTQxQTMtQTdFMi1FODNCNzYwQTdGMjJAc3ViYnUub3JnPg=="},"prevInTopic":14414,"nextInTopic":14419,"prevInTime":14417,"nextInTime":14419,"topicId":14255,"numMessagesInTopic":44,"msgSnippet":"... Uh, look back at those quotes of Roy s I excerpted, as he makes the argument better than I can.  The key to the REST style is that out-of- band information","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 93221 invoked from network); 25 Dec 2009 07:51:07 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m11.grp.re1.yahoo.com with QMQP; 25 Dec 2009 07:51:07 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.sp2.yahoo.com with SMTP; 25 Dec 2009 07:51:06 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 8601C509B4;\n\tFri, 25 Dec 2009 02:51:04 -0500 (EST)\r\nDate: Fri, 25 Dec 2009 00:50:53 -0700\r\nTo: Subbu Allamaraju &lt;subbu@...&gt;\r\nCc: Stefan Tilkov &lt;stefan.tilkov@...&gt;, rest-discuss\n &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20091225005053.3c999d7e.eric@...&gt;\r\nIn-Reply-To: &lt;636E8BEA-339C-41A3-A7E2-E83B760A7F22@...&gt;\r\nReferences: &lt;20091220212633.715ca942.eric@...&gt;\n\t&lt;87iqc0zzig.wl%berend@...&gt;\n\t&lt;20091220224612.b835f502.eric@...&gt;\n\t&lt;20091220225940.7537e931.eric@...&gt;\n\t&lt;20091221003605.7cd9070b.eric@...&gt;\n\t&lt;20091221170735.6b3919ce.eric@...&gt;\n\t&lt;BA6578F1-4778-464F-AEC6-9CA63C4F0BBF@...&gt;\n\t&lt;3FE984F2-F58D-4F2F-88E7-FFBA31E1B9E2@...&gt;\n\t&lt;20091222142237.41004204.eric@...&gt;\n\t&lt;37AC7315-19FD-4F5D-AFDB-731117F8ABC9@...&gt;\n\t&lt;20091223155529.f89e3b8d.eric@...&gt;\n\t&lt;3551E99A-3DF8-4C3C-8480-9A6F74239B1A@...&gt;\n\t&lt;20091223201303.5d964cce.eric@...&gt;\n\t&lt;636E8BEA-339C-41A3-A7E2-E83B760A7F22@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] REST isn&#39;t hard to learn, it&#39;s just taught\n wrong.\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nSubbu Allamaraju wrote:\n&gt; \n&gt; On Dec 23, 2009, at 7:13 PM, Eric J. Bowman wrote:\n&gt; \n&gt; &gt; Until such time as a standard is accepted, I will refer to my\n&gt; &gt; system as REST* because the system only becomes RESTful at that\n&gt; &gt; point, as if by magic...  If there&#39;s no standardization effort\n&gt; &gt; involved, then the proprietary result fragments the Web and does\n&gt; &gt; not achieve the goals of REST, and as a consequence, cannot be\n&gt; &gt; called REST or even REST* because of the lack of intent to use\n&gt; &gt; standards, a key element of the style.\n&gt; \n&gt; Sorry, but I must say that this is a fallacious approach for building\n&gt; networked applications. The goal of building *completely* decoupled\n&gt; applications (with *no* out-of-band knowledge) is as unsound as the\n&gt; &quot;local-is-remote&quot; approach that RPC tried.\n&gt;\n\nUh, look back at those quotes of Roy&#39;s I excerpted, as he makes the\nargument better than I can.  The key to the REST style is that out-of-\nband information be encompassed within standard methods, media types,\nand link relations.  This is what the self-descriptive messaging\nconstraint is all about, isn&#39;t it?  My shared understanding of well-\nknown media types I see in HTTP headers tells me an awful lot about\nprocessing the payload without my knowing any specifics of the system;\napplication/vnd.hypothetical tells me nothing unless I _do_ know the\nspecifics of the system...\n\n&quot;\nDo you see the difference?  Encoding knowledge within clients and\nservers of the other side&#39;s implementation mechanism is what we are\ntrying to avoid.\n&quot;\n\nHow does any non-standardizable media type that&#39;s tied to a specific\nimplementation where each side has encoded knowledge of the other\nside&#39;s implementation mechanism qualify as &quot;decoupled&quot;?\n\n&gt;\n&gt; The set of problems that\n&gt; demand that degree of decoupling is small, and extending that notion\n&gt; to every application (to be branded RESTful to satisfy a particular\n&gt; interpretation of REST) is prohibitively expensive.\n&gt;\n\nThe entire problem of the Web itself demands the decoupling illustrated\nby browsers evolving the capability of displaying inline images whose\nmedia types evolved one-at-a-time from image/gif through image/jpeg to\nimage/png, despite years of constant radical change within the\ntext/html media type&#39;s definition.  Along came text/css and text/\njavascript (initially and enduringly as application/x-javascript) and\nsyndication media types like RSS and Atom, then application/json.  The\nwhole fact that we can build cross-browser Rich Internet Applications\ntoday is due to a shared understanding of an evolving set of standard\nmedia types.  Why wouldn&#39;t this phenomenon be key to the REST style?\n\nThe REST style not only calls for standards-based evolution, it has been\ndefined by what happened on the real-world Web -- the fact that the\ndecoupling provided by standard media types is responsible for the\nspectacular growth and success of the Web.  I&#39;m going to have to throw\nanother Roy quote at you:\n\n&quot;\nREST is software design on the scale of decades: every detail is\nintended to promote software longevity and independent evolution. Many\nof the constraints are directly opposed to short-term efficiency...\nMost don&#39;t think they need to design past the current release.\n&quot;\n\nA shared understanding of well-known media types is what allows\ndecoupling, decoupling is what allows independent evolution (as we&#39;ve\nseen with browsers and what have come to be known as Rich Internet\nApplications), and every detail of REST (like standardization) is\nintended to promote this.\n\nNowhere can anything I have said be construed as suggesting that REST\nbe extended to every system.  I am in fact saying the opposite.  The\npurpose of starting a project by modeling resources and deriving a REST\narchitectural model is to guide the development of the implementation.\nThere may be no need for the initial release to contain a full mapping\nof the implementation to the model.  Subsequent releases are guided by\ndefining what additional mapping(s) to the model will be included in\nthe revised implementation.\n\nThe end result of achieving a REST system may take an amount of time\nbest measured in years.  Which is no big thing, because REST is meant\nto guide the development of systems whose lifespan may well encompass\ndecades.  But until all REST constraints in an architectural model are\nreflected in mappings to the implementation, the system cannot be\nconsidered REST, only a derivative of the style.  Which doesn&#39;t\nnecessarily matter.\n\nTo say that an implementation lacks mappings to a REST architectural\nmodel is not to pass a value judgment against the system.  It is meant\nto provide a measure by which to judge an implementation against the\nPlatonic Ideal for distributed hypermedia systems.  If the needs of the\nsystem at any point in time are being met by its implementation, then\nthere is no need to map it to additional REST constraints, is there?\n\nThe problem is that the needs of a system tend to change over time.\nUnanticipated growth could create the urgent need to apply another of\nREST&#39;s constraints.  The disciplined approach is to create additional\nmappings to the architectural model in the implementation, which has\nhopefully allowed for this by the developers&#39; recognition at some point\nin the past that growth requires change.\n\nInformed decisions to ignore constraints out-of-the-box but allow for\ntheir addition in a future release, can only be made for Web systems in\nterms of the benefits and tradeoffs of applying REST&#39;s constraints (as\nwe lack any other vocabulary).  My entire proposed model-centric\napproach to REST is to provide the basis for these informed decisions\nthrough the visualization and analysis of a REST architectural model and\nits implementation, as the system evolves over time.\n\nThe current conversation on this list is the epitome of current-\nrelease design:  starting by identifying the end result as REST and\nwinging it from there, as reflected in the state of real-world REST\nAPIs at this time, rather than starting by modeling resources and\nfollowing an informed approach.  Argument may be made that no new API\nneeds full-on REST conformity out-of-the-box, therefore REST is more\ndesirable as the goal of a release cycle.  Since REST is just an\narchitectural style, an abstract, REST must be modeled somehow in order\nto be used to guide that release cycle.\n\n&gt;\n&gt; Even in the case\n&gt; of the web, where things seem to work in an autonomous fashion, we\n&gt; need a &quot;human&quot; user to guess the semantics and drive the hypermedia\n&gt; engine for every application.\n&gt; \n\nNo we don&#39;t.  Advances like the GoodRelations ontology show us that\nit&#39;s possible to build a machine-readable interface for any number of\nspecific shopping cart implementations.  I go through socks pretty\nfast.  I like &#39;em fresh, besides, I haven&#39;t seen anybody darn a sock\nsince before my Grandmom died (although in these times, we may see a\nresurgence in sock darning).  So I need a new six-pack of Sock-brand\nmid-calf white athletic socks in size XL delivered to my shack in the\nboonies every six weeks.\n\nI ought to be able to create an agent allowing me to enter (or search\nfor) store URIs who sell Socks-brand socks online, at my convenience as\nconfiguration.  Once every six weeks, my agent places an order at the\nstore with the lowest combination of price and delivery charge, and\nonce every six weeks the local UPS lady delivers new socks to my door.\nI don&#39;t care where or how the order was placed, where it was out-of-\nstock, or what the price variation was -- so long as my Socks arrive\nat regular intervals and I&#39;m not overpaying for them.\n\nAs Web technology continues to evolve, this becomes possible -- best-\nprice cross-supplier automated resupply.  Despite the fact that each\nmerchant likely has its own human-driven interface, the fact that the\nmerchants have collectively accepted an ontology for use within\nstandard media types is what makes it possible for agents to get what\nthey need from the same representations intended for human manipulation.\n\nI&#39;m a bachelor guy, so I&#39;ll be an early adopter of any technology that\ndoes my shopping for me.  I hate not being able to find my specific\nbrand and flavor/scent of toothpaste/deodorant, despite the Wal-Mart\n20 miles away.  So please don&#39;t tell me I&#39;m doomed to forever having to\nactually *shop* for basic necessities, online or off...  :-(\n\n&gt;\n&gt; Let&#39;s say, we start with your assertion that (a) everything must be\n&gt; communicated in-band, and (b) the media type must be standard. Let&#39;s\n&gt; apply this to Flickr as an example...\n&gt;\n\nI&#39;d rather stick with Dare Obasanjo&#39;s example I excerpted and linked to\nabove in this thread, as it stayed on-topic to Roy&#39;s blog post.  There\nclearly exist several takes on the problem of a Contacts API, none of\nwhich are RESTful, and all of which are vendor-specific.  But there&#39;s\nnothing about a Contacts API that can&#39;t be implemented in the REST\nstyle.  So there&#39;s no reason a REST architectural model of a Contacts\nAPI can&#39;t be derived from these existing efforts, for the purpose of\nguiding a standardization effort.  I don&#39;t see how this leads to\nzillions of standards, but I do see how it leads away from the existing\nfragmentation to a Web where clients can easily interact with any vendor\nContacts List through the same generic REST API instead of being hard-\ncoded to support each vendor-specific non-REST Contacts API.\n\nThis derived REST architectural model guides use and/or development of\nmedia types and link relations.  A new media type would have to\ndescribe how methods are used.  Any new link relation or application of\nan existing link relation would need to be described by the new media\ntype.  Or, the REST architectural model guides the development towards\nstandard media types fleshed out with a Contact-API-specific ontology\nwithin, to allow more choice in media types and link relations within\nimplementations.  If vendors can agree on methods and media types,\nwhile each providing vendor-specific ontology within, interoperability\nbetween implementations is much easier for a net positive effect.\n\nImplementations derived from this model are the visualizations which are\nthen analyzed for interoperability.  The real-world analog would be the\ndevelopment of Atom Protocol, where analysis of the interoperability of\nevolving implementations led to revisions of the protocol.  The evolving\nstandard for a RESTful Contacts API is guided by the REST architectural\nmodel.  A RESTful Contacts API built using experimental media types\nor link relations is considered REST* because the standardization effort\nexists, but since it&#39;s subject to change based on REST how can it be\nREST until it&#39;s finalized?  Paradoxical, I know.\n\nSince the development of the new standard is guided by and evaluated\nagainst REST, the standard isn&#39;t complete until this is accomplished.\nSo how can an implementation of an evolving standard be considered REST\nwhen the standards process itself hasn&#39;t yet come to that conclusion?\nOnly when the experimental bits become standard, may the asterisk be\nremoved, because only then is out-of-band information encompassed\nwithin a well-known media type and decoupling of clients and servers\nachieved.\n\nExperimental implementations being used to guide development of a new\nmedia type can&#39;t be REST because the self-descriptive messaging\nconstraint is broken until the standard is finalized.  Until then,\nclients are coupled to servers by the use of the nonstandard media type.\nThere, I&#39;ve officially run out of ways to re-state that...\n\n&gt; \n&gt; A more reasonable thing to do is start off with some standard media\n&gt; types and formats, and mix them up with some conventions to make\n&gt; representations specific to each application domain. For example,\n&gt; using an atom:link in XML is a convention. Using RFC-3339 for dates\n&gt; and times is another convention. Mixing RDFa and microformats with\n&gt; HTML and XHTML is yet another convention. Such conventions don&#39;t aim\n&gt; to eliminate decoupling, but they reduce the amount of of specificity\n&gt; but leave room for evolution and promote interoperability. \n&gt; \n\nI don&#39;t understand how someone who wrote that paragraph can be\ndisagreeing with me on the importance of standards to the self-\ndescriptive messaging constraint (or the critical importance of that\nconstraint to the REST style).  You obviously understand the importance\nof self-documenting hypertext-driven APIs.  I obviously understand it\ntoo, as written above and because I chose these quotes from Roy to post:\n\n&quot;\nIt has value because it is far easier to standardize representation and\nrelation types than it is to standardize objects and object-specific\ninterfaces. In other words, there are fewer things to learn and they\ncan be recombined in unanticipated ways while remaining understandable\nto the client.\n\n...\n\nExposing that vocabulary in the representations makes it easy to learn\nand be adopted by others. Some of it will be standardized, some of it\nwill be domain-specific, but ultimately the agents will have to be\nadaptable to new vocabulary.\n&quot;\n\nSo it seems to me that we&#39;re disagreeing on where to start.  It is my\nbelief that the logical starting place is the modeling of resources.\nSome minimal REST architectural model must exist, before it can inform\ndecisions about which media types to use, how to recombine them in\nunanticipated ways (like my use of application/atomcat+xml as a delta\nto PATCH categories within application/atom+xml), as well as where this\napproach falls short and calls for the extension or creation of a media\ntype, and where to draw the line between standardized and domain-\nspecific ontologies within a media type.  There are too many possible\nimplementations of any REST system to start with implementation details.\n\n-Eric\n\n"}}