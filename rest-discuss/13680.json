{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":371338898,"authorName":"Bill Burke","from":"Bill Burke &lt;bburke@...&gt;","profile":"patriot1burke","replyTo":"SENDER","senderId":"VE8Dj6pGl2P5T8SAHLEMB2g1B1vHHgFyyhxym4p9FtKCp4Nfwl7qVUtxk7l2RpDwFhAmTfllPjG7Nr9gjQ4RJZtItz1G","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: Credit Cards, Transactions, and REST","postDate":"1254758440","msgId":13680,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDRBQ0ExODI4LjMwMTA2MDFAcmVkaGF0LmNvbT4=","inReplyToHeader":"PGhhYjRyOCtvdTZwQGVHcm91cHMuY29tPg==","referencesHeader":"PGhhYjRyOCtvdTZwQGVHcm91cHMuY29tPg=="},"prevInTopic":13679,"nextInTopic":13681,"prevInTime":13679,"nextInTime":13681,"topicId":13472,"numMessagesInTopic":21,"msgSnippet":"... Side discussion but, workflow is an interesting idea here.  You see, IMO, all a Transaction Manager is, is a specific re-ocurring workflow pattern. ... ","rawEmail":"Return-Path: &lt;bburke@...&gt;\r\nX-Sender: bburke@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 14444 invoked from network); 5 Oct 2009 16:45:03 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m5.grp.re1.yahoo.com with QMQP; 5 Oct 2009 16:45:03 -0000\r\nX-Received: from unknown (HELO mx1.redhat.com) (209.132.183.28)\n  by mta1.grp.sp2.yahoo.com with SMTP; 5 Oct 2009 16:45:03 -0000\r\nX-Received: from int-mx04.intmail.prod.int.phx2.redhat.com (int-mx04.intmail.prod.int.phx2.redhat.com [10.5.11.17])\n\tby mx1.redhat.com (8.13.8/8.13.8) with ESMTP id n95G0gSV026633;\n\tMon, 5 Oct 2009 12:00:42 -0400\r\nX-Received: from bill-burkes-computer.local (vpn-12-26.rdu.redhat.com [10.11.12.26])\n\tby int-mx04.intmail.prod.int.phx2.redhat.com (8.13.8/8.13.8) with ESMTP id n95G0eOm014612;\n\tMon, 5 Oct 2009 12:00:41 -0400\r\nMessage-ID: &lt;4ACA1828.3010601@...&gt;\r\nDate: Mon, 05 Oct 2009 12:00:40 -0400\r\nUser-Agent: Thunderbird 2.0.0.23 (Macintosh/20090812)\r\nMIME-Version: 1.0\r\nTo: William Martinez Pomares &lt;wmartinez@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nReferences: &lt;hab4r8+ou6p@...&gt;\r\nIn-Reply-To: &lt;hab4r8+ou6p@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Scanned-By: MIMEDefang 2.67 on 10.5.11.17\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Bill Burke &lt;bburke@...&gt;\r\nSubject: Re: [rest-discuss] Re: Credit Cards, Transactions, and REST\r\nX-Yahoo-Group-Post: member; u=371338898; y=Say7yHy7s0_HV22z4NsyJZG17pk5hN_7J7Mai2ykEe_cemJSInCZjA\r\nX-Yahoo-Profile: patriot1burke\r\n\r\n\n\nWilliam Martinez Pomares wrote:\n&gt;  \n&gt; \n&gt; Hello Bill.\n&gt; \n&gt; I would not tell you you are breaking REST constrains, but I would like \n&gt; to check on some notes.\n&gt; \n&gt; 1. The idea of the stateless server is an easy one. As a distributed \n&gt; system, you may have one or more servers that should be able to respond \n&gt; to any client. The request from that client may be the first one of an \n&gt; application sequence, or the 10th, you have to serve it with no memory \n&gt; of the other 9. In this way, you can add or remove servers with no \n&gt; problem to clients.\n&gt; \n&gt; 2. Now, resources are in the cloud. That means we cannot assume a \n&gt; resource is IN one particular server. Any server we contact will have to \n&gt; use the same resource. This is very difficult part of implementation, \n&gt; since you may need to implement duplication of information and fail \n&gt; overs. But that is totally unknown by client.\n&gt; \n&gt; 3. On, particular, two phase commit. For this, I assume there are two \n&gt; different data sources, and you can commit to each one separately, but \n&gt; when a transaction involves individual transactions at each source, then \n&gt; you use the famous two phase commit. Each source is a participant, right?\n&gt; \n&gt; 4. Ok, on to your proposal. One server dedicated to the management of \n&gt; transactions, given we need to send to it, manually, all the transaction \n&gt; steps and actions, may suffer some scalability problems.\n&gt; On the other hand you have the client that needs to do all that \n&gt; processing to commit the transaction.\n&gt; \n&gt; My feeling is that exposing the data entities as resources, and leaving \n&gt; to the client all the commit processing, is exposing too much the \n&gt; application detail. May not break REST, but adds unnecessary complexity.\n&gt; \n&gt; Now, the two phase commit assumes we have two sources, and you depict \n&gt; them as the airline resource and the hotel room resource. It is them \n&gt; implied that both are like databases, even more, separated database \n&gt; engines. And, your client will have to drive the transaction management \n&gt; to change data in both and then to commit. That is implicitly forcing \n&gt; the concepts of a resource, but still it sounds like REST.\n&gt; \n&gt; So far, so good. Now, my question would be: should I need to do all that \n&gt; to actually reserve a package using REST? Well, to imagine how would I \n&gt; do it, I&#39;d actually follow an online reservation workflow and see what \n&gt; happens:\n\n\nSide discussion but, &quot;workflow&quot; is an interesting idea here.  You see, \nIMO, all a Transaction Manager is, is a specific re-ocurring workflow \npattern.\n\n\n&gt; a. I enter and search for a flight. System returns a list of flights and \n&gt; I select one. At this time a draft reservation is created with my flight \n&gt; in it. (Think a PUT of the empty reservation followed by a POST of the \n&gt; flight).\n&gt; b. Then the system offers me to add a hotel reservation, and from the \n&gt; provided list I select one too. That is added to my draft reservation \n&gt; (another POST).\n&gt; c. Finally, I add my credit card information and post a confirmation \n&gt; (Another POST).\n&gt; \n&gt; This last action is served by server number 5 of 10 currently serving. \n&gt; That server 5 needs to complete the POST, and if unable, it will return \n&gt; an error to the client. Well, that server uses the draft reservation \n&gt; resource information to call a transaction manager to commit all \n&gt; changes. If it fails, server 5 returns the error. That is totally opaque \n&gt; to the client, which only confirms and receives a yes or no to that \n&gt; request. Depending on that response, the client retries, updates the \n&gt; selection of flights or hotel and confirms again, or even desists and \n&gt; eliminates the reservation. Simple, ha.\n&gt; \n\nCorrect me if I&#39;m wrong, but I think you&#39;re confusing the actors here. \nThe actors being Customer and Travel Agent.  It is the Travel Agent that \nhas to coordinate between different services, not the Customer.  So yes, \nthe Customer will be isolated from transactional semantics because it is \nonly dealing with one actor, the Travel Agent.  The Travel Agent on the \nother hand has to juggle a set of decoupled systems.\n\n\n&gt; The difference in this process is that client is freed from knowing the \n&gt; transaction is happening. Resources are just that, no databases nor \n&gt; tables that need transactions and the client doesn&#39;t have to choose the \n&gt; use of single or two phase commits. You can scale since you can change \n&gt; the number of servers or transaction managers without touching the \n&gt; client. AND, each client interaction leaves the system in a stable \n&gt; state. Actually, this can be RESTFull too!.\n&gt; \n&gt; So, if we can hide the complexity of the transaction, why do we need to \n&gt; expose that complexity to the client? I may do it if that brings some \n&gt; benefit. My question will then be, which benefits will I found from one \n&gt; implementation to the other one, or why one of them is not suitable for \n&gt; some particular business case.\n&gt; \n\nAll I know is somebody is going to have to do coordination work in a \nsystem that has more than two actors:  client and server.  My question \nis how can these coordination requirements be improved by RESTful \narchitectural principles.\n\n-- \nBill Burke\nJBoss, a division of Red Hat\nhttp://bill.burkecentral.com\n\n"}}