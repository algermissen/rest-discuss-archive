{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"-gyQZzci5NW5Uh8o3hbsQtdrls2AHBgcTImuwafjPBjDNNjV6VjyjIjRlPGGKqp9ObJlrFnhEIFMo_LyMqBKTwfABIKaUza47_Vm0zIh_Q","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Atom feed vs. list of orders","postDate":"1281433485","msgId":16250,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwODEwMDM0NDQ1LjMwOGRhN2I2LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGltME9aLT1Wc3Z6NTQ5YlptLW9jd29udUFZa2VpZThHc3dGN1lUM0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPgk8RjE5NjI2NDZEM0I2NDY0MkI3QzlBMDYwNjhFRTFFNjQwRTE0Mzg1N0BleDEwLmhvc3RlZGV4Y2hhbmdlLmxvY2FsPgk8RUE2MDczMkMtM0IwMC00NUQ0LThGRDgtMDJFQjFCMjE0NEY1QG1hYy5jb20+CTxGMTk2MjY0NkQzQjY0NjQyQjdDOUEwNjA2OEVFMUU2NDBFMTQzQjExQGV4MTAuaG9zdGVkZXhjaGFuZ2UubG9jYWw+CTxCRTNEODY1OS1CNzYyLTQ3NTktQkM4Qy0xM0I0REE5ODVDNUZAbWFjLmNvbT4JPEFBTkxrVGk9K0x6bk9DdFhma0xVek9CLWFCOEVPWkRyYXNiMzdtV0ItUFd2QkBtYWlsLmdtYWlsLmNvbT4JPDAxMzIzQkEzLTIwNzgtNEM3NS1BRTFCLThEMTg4NUU2NUIwOEBtYWMuY29tPgk8QUFOTGtUaW5OTzNqS3Y4Nj1xPWRtOGVtcVEweFJyaGtUOVBQbmNfN1NkXzgyQG1haWwuZ21haWwuY29tPgk8MzE3RjlBMzQtMUI3QS00QTAxLTkwNjYtRjY5QTZBQjU4ODhDQG1hYy5jb20+CTwyMDEwMDgwNzE3MDQzNC40NGI3ZWVmOC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbjlzRldQQ2ItRUxDU1dOZHRyeTl4dnNpVTRpY0hWV1d6Y1pMb0FAbWFpbC5nbWFpbC5jb20+CTwyMDEwMDgwOTE4MjA0Mi5iMzk0NTI1Yy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbTBPWi09VnN2ejU0OWJabS1vY3dvbnVBWWtlaWU4R3N3RjdZVDNAbWFpbC5nbWFpbC5jb20+"},"prevInTopic":16249,"nextInTopic":16251,"prevInTime":16249,"nextInTime":16251,"topicId":16194,"numMessagesInTopic":86,"msgSnippet":"... Of course representations are application-specific.  But that does not require the media type of the representation to be application-specific or say","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 63170 invoked from network); 10 Aug 2010 09:44:57 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m14.grp.re1.yahoo.com with QMQP; 10 Aug 2010 09:44:57 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 10 Aug 2010 09:44:57 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id C6A82509DA;\n\tTue, 10 Aug 2010 05:44:53 -0400 (EDT)\r\nDate: Tue, 10 Aug 2010 03:44:45 -0600\r\nTo: Peter Williams &lt;pezra@...&gt;\r\nCc: Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100810034445.308da7b6.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTim0OZ-=Vsvz549bZm-ocwonuAYkeie8GswF7YT3@...&gt;\r\nReferences: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143857@...&gt;\n\t&lt;EA60732C-3B00-45D4-8FD8-02EB1B2144F5@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143B11@...&gt;\n\t&lt;BE3D8659-B762-4759-BC8C-13B4DA985C5F@...&gt;\n\t&lt;AANLkTi=+LznOCtXfkLUzOB-aB8EOZDrasb37mWB-PWvB@...&gt;\n\t&lt;01323BA3-2078-4C75-AE1B-8D1885E65B08@...&gt;\n\t&lt;AANLkTinNO3jKv86=q=dm8emqQ0xRrhkT9PPnc_7Sd_82@...&gt;\n\t&lt;317F9A34-1B7A-4A01-9066-F69A6AB5888C@...&gt;\n\t&lt;20100807170434.44b7eef8.eric@...&gt;\n\t&lt;AANLkTin9sFWPCb-ELCSWNdtry9xvsiU4icHVWWzcZLoA@...&gt;\n\t&lt;20100809182042.b394525c.eric@...&gt;\n\t&lt;AANLkTim0OZ-=Vsvz549bZm-ocwonuAYkeie8GswF7YT3@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Atom feed vs. list of orders\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nPeter Williams wrote:\n&gt;\n&gt; &gt; Why would it need to? =A0Application-specific m=\r\nedia types are not\n&gt; &gt; part of the REST style, and for good reason.\n&gt; \n&gt; My=\r\n point is that is that html+gd is a much an application specific\n&gt; media ty=\r\npe as a custom xml format.  Not giving it a name does not\n&gt; change that fac=\r\nt.  Once the server adds gd annotations, and clients\n&gt; started depending on=\r\n them, the representations become application\n&gt; specific.\n&gt; \n\nOf course rep=\r\nresentations are application-specific.  But that does not\nrequire the media=\r\n type of the representation to be application-specific\nor say anything abou=\r\nt what domain-specific vocabularies are contained\nwithin.  Assigning a new =\r\nmedia type for every possible usage of an\nexisting media type goes against =\r\nREST, where ubiquitous media types are\nre-used except as a last resort in t=\r\nhe face of compelling need.\n\n&gt;\n&gt; I am not oppose to domain specific represe=\r\nntations so this does not\n&gt; really bother me.  My concern is that a client =\r\nthat needs html+gd, but\n&gt; asks for html is a lot less likely to get what it=\r\n needs than a client\n&gt; that explicitly requests what it needs.\n&gt; \n\nIf a cli=\r\nent is coded to interpret HTML + GD served as an HTML media\ntype, then I do=\r\nn&#39;t understand how it would be &quot;less likely&quot; to get what\nit&#39;s after by requ=\r\nesting that media type from a site whose markup\nclearly implements RDFa.  I=\r\nf I tell you my service responds with RDFa\nembedded in text/html, why would=\r\n you assume that it wouldn&#39;t, and what\ndo &quot;contracts&quot; guaranteeing that you=\r\n will have to do with REST?\n\nIf a client doesn&#39;t understand RDFa + GR, why =\r\nwouldn&#39;t I send it that\nrepresentation anyway if it asked for HTML?  Why wo=\r\nuld I want to set up\nconneg, to send a variant that&#39;s been stripped of any =\r\ndomain-specific\nvocabulary?  That variant sounds pretty useless by comparis=\r\non, and I\ndon&#39;t see any cost-benefit to performing all the work to make tha=\r\nt\nbehavior happen.\n\nIf user agents weren&#39;t required to ignore unknown eleme=\r\nnts and\nattributes, then yeah, it would make sense to proliferate media typ=\r\nes\nfor each and every possible use of known markup.  But, that isn&#39;t the\nar=\r\nchitectural style we&#39;re dealing with.\n\n&gt;\n&gt; &gt;  =A0REST has nothing to do\n&gt; &gt;=\r\n with negotiating between versions of an API.\n&gt; \n&gt; Sure it does.  The accep=\r\nt header allows the negotiation of API\n&gt; versions.\n&gt;\n\nIt had better not.  L=\r\nate binding of representation to resource should\nhave no effect on the API =\r\nthose representations describe.  If they\ndescribe different APIs, then how =\r\ncan they be variants?  My HTML and\nAtom variants describe the same API by u=\r\nsing the same link targets and\nrelations, for example.\n\n&gt;\n&gt; Consider `accep=\r\nt: text/html` vs `accept:\n&gt; application/atom+xml`.  One says the client wan=\r\nts to interact with the\n&gt; html version of the api, the other says the clien=\r\nt wants to interact\n&gt; with the atom version of the api.\n&gt; \n\nExactly.  Varia=\r\nnts of the *same* API, not different versions of the API.\nThere&#39;s no reason=\r\n the domain-specific vocabulary would need to change\nfrom one media type to=\r\n the next, in the above scenario.\n\nThere is no such thing as using conneg t=\r\no negotiate for a particular\nversion of HTML.  This idea is floated regular=\r\nly, but is consistently\nshot down as it goes against REST and Web architect=\r\nure.  It would be\nsilly to have conneg based on HTML 4 vs. HTML 5, the same=\r\n principles\nand reasoning apply to explain why we don&#39;t have text/html and =\r\ntext/\nhtml+rdfa -- representations are application-specific, not media type=\r\ns.\n\n&gt;\n&gt; &gt; &quot;The trade-off, though, is that a uniform interface degrades\n&gt; &gt; =\r\nefficiency, since information is transferred in a standardized form\n&gt; &gt; rat=\r\nher than one which is specific to an application&#39;s needs.&quot;\n&gt; \n&gt; I don&#39;t get=\r\n what you seem to get that from this quote.\n&gt;\n\nI get from it that text/html=\r\n is a standardized form, regardless of\nwhich particular elements and attrib=\r\nutes are included within a given\nrepresentation.  When media types are crea=\r\nted not to introduce new\nlanguages, but just to indicate domain-specific vo=\r\ncabulary tailored to\nthe application&#39;s exact needs, it goes directly agains=\r\nt this quote, and\neverything else Roy is trying to get across in his thesis=\r\n.\n\n&gt;\n&gt; Later in the same section we get this paragraph.\n&gt; \n&gt;    In order to=\r\n obtain a uniform interface, multiple architectural\n&gt;    constraints are ne=\r\neded to guide the behavior of components. REST is\n&gt;    defined by four inte=\r\nrface constraints: identification of resources;\n&gt;    manipulation of resour=\r\nces through representations; self-descriptive\n&gt;    messages; and, hypermedi=\r\na as the engine of application state.\n&gt; \n\nThe self-descriptive messaging co=\r\nnstraint goes on to say this:\n\n&quot;REST components communicate by transferring=\r\n a representation of a\nresource in a format matching one of an evolving set=\r\n of standard data\ntypes, selected dynamically based on the capabilities or =\r\ndesires of the\nrecipient and the nature of the resource.&quot;\n\nI&#39;ll explain my =\r\nposition again.  Yes, you can create a custom media\ntype.  However, if its =\r\nsole purpose is to be used in your application,\nand nobody else adopts it, =\r\nin what way is it standardized?  I&#39;d be all\nover adopting a new standard me=\r\ndia type indicating html+rdfa, if only I\nsaw any compelling need for it.\n\nC=\r\nreating new media types willy-nilly, specifically to avoid using\nubiquitous=\r\n media types, for the purpose of being tailored to the needs\nof the applica=\r\ntion, is clearly and unambiguously a violation of REST,\nwhich advocates the=\r\n principle of generality.  I really should use a\nlarger quote:\n\n&quot;By applyin=\r\ng the software engineering principle of generality to the\ncomponent interfa=\r\nce, the overall system architecture is simplified and\nthe visibility of int=\r\neractions is improved.  Implementations are\ndecoupled from the services the=\r\ny provide, which encourages independent\nevolvability. The trade-off, though=\r\n, is that a uniform interface\ndegrades efficiency, since information is tra=\r\nnsferred in a standardized\nform rather than one which is specific to an app=\r\nlication&#39;s needs.&quot;\n\nThe thesis is on and on about generality, aka re-use.  =\r\nCreating new\nmedia types willy-nilly is some architectural style that doesn=\r\n&#39;t\nemphasize the principle of generality, not REST.\n\n&gt;\n&gt; No where does that=\r\n suggest there is some limit to the allowable number\n&gt; of representation fl=\r\navors.\n&gt; \n\nNo, it doesn&#39;t, but REST does emphasize the principle of general=\r\nity.\nAnother way of looking at this, is that Roy was right.  Out of\ncountle=\r\nss thousands of media type identifiers folks have created over\nthe years, h=\r\now many succeed in becoming ubiquitous?  Why haven&#39;t folks\nlong since ditch=\r\ned text/html?  Maybe there&#39;s something to this\ngenerality stuff after all, =\r\nthen?\n\nThe purpose of REST is to tap in to the common knowledge encapsulate=\r\nd\nin ubiquitous media types, whenever your documentation needs to be out-\no=\r\nf-band.  If none of that out-of-band documentation is common knowledge\nbeca=\r\nuse everybody is winging it on defining new media types, the Web\nwould crum=\r\nble, because that is not following the proven, well-defined-\nby-Roy model o=\r\nf what made the Web a success in the first place.\n\nRoy was right.  The bene=\r\nfits of REST are indeed achievable when you re-\nuse ubiquitous media types =\r\n(as the thesis clearly says).  Proof:  Oh, I\ndon&#39;t know, Amazon, Best Buy, =\r\nO&#39;Reilly -- RESTful or not (and Amazon\nmost certainly is not), architecture=\r\ns based on sticking with ubiquitous\nmedia types have proven themselves capa=\r\nble of dealing with almost any\ntask imaginable over the Web.  The Web is pr=\r\noof enough of Roy&#39;s thesis.\n\nWe don&#39;t need separate media types for widget =\r\nsales vs. airline\nreservations vs. event tickets vs. online banking vs. sch=\r\nool enrollment\nvs. stock trading vs. conference bookings vs. list goes on..=\r\n. is your\nproblem really such a unique snowflake that it can&#39;t be solved ex=\r\ncept\nby an application-specific media type?\n\nIf it is, then I don&#39;t have a =\r\nproblem with that, who am I to judge the\nadequacy of your solution to your =\r\nproblem space?  My problem is if you\nfail to identify that as about the mos=\r\nt-obvious REST mismatch there is,\nand still call it REST -- you&#39;d be arguin=\r\ng that your bug is a feature.\n\n&gt;\n&gt; Your reading of the uniform interface se=\r\nems different than much of the\n&gt; community.\n&gt; \n\nYup.  Colored entirely by b=\r\nuilding websites since 1993 without any\nnefarious SOA influence.  Another r=\r\neason it took me so long to learn,\nis that for many years, I believed what =\r\nothers were telling me about\nREST -- which made me think that none of my wo=\r\nrk from pre-2004 was\nRESTful.\n\nWhen in reality, most of it was, like the pi=\r\nzza-delivery example I gave\nlast month.  It&#39;s amazing the number of REST mi=\r\nsmatches I used to see\nin that solution, like using query URIs, or having /=\r\ncgi-bin/ in my\npath, etc.  It took me over a year after reading Roy&#39;s &quot;REST=\r\n APIs must\nbe hypertext driven&quot; post, to understand all of this was nonsens=\r\ne, and\nthat by following the path of least resistance I&#39;d actually been doi=\r\nng\nREST years before I&#39;d ever heard of HTTP Request Object.\n\nIf you&#39;re publ=\r\nishing a distributed API over the Internet using HTTP,\nthen REST defines th=\r\ne path of least resistance and greatest scaling\nbenefit for you.  Unless yo=\r\nu&#39;re doing telephony or something, why not\nre-use HTML media types to drive=\r\n your hypertext API?  It&#39;s been proven\nto work, and has been wildly success=\r\nful across myriad problem domains.\n\n&gt;\n&gt; RestWiki is pretty quiet on the ide=\r\na of limiting media types being\n&gt; part of the uniform interface in both the=\r\n interface genericity&#39;s[1]\n&gt; and rest in plain english[2] pages.  Both seem=\r\n to imply that domain\n&gt; specific media types would be ok.\n&gt; \n\nRoy&#39;s thesis =\r\nis the only normative reference for REST.  Roy&#39;s further\nwritings on domain=\r\n-specific vocabulary vs. common-knowledge media types\nis where I&#39;ve gotten =\r\nmy information.  There&#39;s an interesting search to\nrun -- again, I&#39;m not mak=\r\ning this stuff up.  Why would Roy give an\nexample of using image/gif to mod=\r\nel a sparse-bit array, and say nothing\nabout how it would really be better =\r\nto define a new media type for this\napplication-specific purpose?\n\nBecause =\r\nthat would lead to defining new media types based on what an\nimage represen=\r\nts -- what we don&#39;t need, and what implicitly goes\nagainst the REST style, =\r\nis image/sba+gif, image/people+gif, image/dogs+\ngif, image/porn+gif, and so=\r\n on and so forth.  I see no difference\nbetween text/rdfa+html and image/por=\r\nn+gif.  Domain-specific vocabulary\ndoesn&#39;t belong in common-knowledge media=\r\n types, nor does it require new\nmedia types.\n\n&gt;\n&gt; Stefan Tilkov clearly sta=\r\ntes that multiple media types are acceptable\n&gt; in &#39;A Brief Introduction to =\r\nREST&#39;[3].\n&gt; \n&gt;    The result might be some company-specific XML format that=\r\n\n&gt;    represents customer information.  ...  Summary: Provide multiple\n&gt;   =\r\n representations of resources for different needs.\n&gt; \n\nI can use a variety =\r\nof ubiquitous media types to create domain-specific\nvocabulary for customer=\r\n information.  There&#39;s probably an RDF ontology\nor two for doing just that,=\r\n and I could always create a schema and link\nto that as further in-band doc=\r\numentation of domain-specific vocabulary.\nI see where that fits with Stefan=\r\n&#39;s quote, what I don&#39;t see is where\nStefan is advocating that domain-specif=\r\nic vocabulary requires a custom\nmedia type.\n\n&gt;\n&gt; But rather that it seems t=\r\nhat much of REST community does not hold\n&gt; your belief that html is a funda=\r\nmental, in inalienable, part of the\n&gt; uniform interface of the web.\n&gt; \n\nI w=\r\nould hope not, especially since I&#39;ve never made that assertion.  I\nam pushi=\r\nng back against the notion that HTML media types are somehow\nobsolete or in=\r\ncapable of doing the things folks are creating custom,\nnon-ubiquitous media=\r\n types for.  If the community was getting this\nright, there&#39;d be no need to=\r\n push back against it.\n\nI consistently phrase my posts to say that a REST A=\r\nPI is required to\nhave an interface consisting of hypertext controls, in a =\r\nmedia type\nthat&#39;s designed to drive a hypertext API.  There are several whi=\r\nch fit\nthis bill, primarily HTML, which is not to assert that HTML is someh=\r\now\na requirement of REST.\n\nI don&#39;t care what your back-end format is, or ho=\r\nw clients interact with\nit, all I do care about is that you provide hyperte=\r\nxt controls to\ndefine your API.  You can point a hard-coded Atom Protocol c=\r\nlient at my\nsystem and interact with it -- but this is not REST.  The way y=\r\nou\nfigure out how to hard-code a client against my system is by reading\nthe=\r\n developer documentation, i.e. my HTML code, as it represents a self-\ndocum=\r\nenting API to whatever internals I choose to publicize.\n\n&gt;\n&gt; Perhaps i am m=\r\nis-reading the community or perhaps i am totally wrong\n&gt; and html is key.  =\r\nI am willing to be convinced.  However, the best\n&gt; outcomes i have experien=\r\nced in m2m systems using rest have come from\n&gt; using explicitly named domai=\r\nn specific media types.\n&gt; \n\nI don&#39;t see why hypertext control APIs can&#39;t be=\r\n both human and machine\nreadable.  Especially given the success of RDFa and=\r\n GR.  HTML has always\nbeen a key component, like URI and HTTP, in the Web i=\r\nnstantiation of\nREST.  None of these are requirements of the REST style.  I=\r\nf your\nintention is to provide a distributed hypertext API to some sort of\n=\r\nback-end system over the public Internet using HTTP, then yeah, you&#39;d\nbette=\r\nr have a damn good reason for not just using HTML.\n\nIs your system really s=\r\nuch a unique snowflake, that the accepted\nstandards used to build distribut=\r\ned APIs for such purposes as widget\nsales, airline reservations, event tick=\r\neting, online banking, school\nenrollment, stock trading, conference booking=\r\ns and anything else under\nthe sun, just can&#39;t be adapted to your needs?  Th=\r\nat&#39;s kinda the whole\npoint of REST, fit your system to a uniform interface =\r\ninstead of an\napplication-specific interface, so that what it does and how =\r\nit works\nmay be decuced with tools as simple as curl.\n\n&gt;\n&gt; There is certain=\r\nly a trade off between using existing media types and\n&gt; creating new ones. =\r\n If an existing media type has the needed semantics\n&gt; it should definitely =\r\nbe used.  However, if no media type exists with\n&gt; the required semantics cr=\r\neating a new one that does seems superior to\n&gt; trying to infer such semanti=\r\ncs from an existing one based on\n&gt; out-of-band information.\n&gt; \n\nWhere we ap=\r\nparently differ, is that for every 1,000 custom media types\nI look at, I se=\r\ne maybe one that actually has semantics that aren&#39;t\nwell-covered by existin=\r\ng solutions.  That one, has about a 50/50 chance\nof becoming ubiquitous.  I=\r\nf the media type driving your hypertext API\nisn&#39;t ubiquitous, and stands ex=\r\nactly zero chance of ever becoming so,\nthen you simply aren&#39;t using the RES=\r\nT style.\n\n-Eric\n\n"}}