{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":289191104,"authorName":"Jan Algermissen","from":"Jan Algermissen &lt;algermissen1971@...&gt;","profile":"algermissen1971","replyTo":"SENDER","senderId":"t9X17BBN8uc2-CBeNqUZo8FNI0Pz15NZvbOF1pvbqeU6Ka_jIv_PEsyObVyG7t-ZDSqK3bS_xY7SLxEuW4q8RPLmXl09PQOxrZcME9L9K8A","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: Using URIs and PUT to model state machines.","postDate":"1194250979","msgId":9738,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEFENUQ0NTkyLUNFNEYtNDc5Ny05NzlFLTE0OUIxMEI1RjFCNEBtYWMuY29tPg==","inReplyToHeader":"PGZnbGZraCtrbzc5QGVHcm91cHMuY29tPg==","referencesHeader":"PGZnbGZraCtrbzc5QGVHcm91cHMuY29tPg=="},"prevInTopic":9733,"nextInTopic":9750,"prevInTime":9737,"nextInTime":9739,"topicId":9730,"numMessagesInTopic":8,"msgSnippet":"... Tunneling operations through POST breaks REST s uniform inerface constraint. You end up with client and server being coupled on the operation semantics. ","rawEmail":"Return-Path: &lt;algermissen1971@...&gt;\r\nX-Sender: algermissen1971@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 21326 invoked from network); 5 Nov 2007 08:23:05 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m43.grp.scd.yahoo.com with QMQP; 5 Nov 2007 08:23:05 -0000\r\nX-Received: from unknown (HELO smtpoutm.mac.com) (17.148.16.69)\n  by mta18.grp.scd.yahoo.com with SMTP; 5 Nov 2007 08:23:05 -0000\r\nX-Received: from mac.com (asmtp008-s [10.150.69.71])\n\tby smtpoutm.mac.com (Xserve/smtpout006/MantshX 4.0) with ESMTP id lA58N5gG008738;\n\tMon, 5 Nov 2007 00:23:05 -0800 (PST)\r\nX-Received: from [10.0.1.200] (e182064197.adsl.alicedsl.de [85.182.64.197])\n\t(authenticated bits=0)\n\tby mac.com (Xserve/asmtp008/MantshX 4.0) with ESMTP id lA58N1cr016645;\n\tMon, 5 Nov 2007 00:23:02 -0800 (PST)\r\nIn-Reply-To: &lt;fglfkh+ko79@...&gt;\r\nReferences: &lt;fglfkh+ko79@...&gt;\r\nMime-Version: 1.0 (Apple Message framework v752.3)\r\nContent-Type: text/plain; charset=US-ASCII; delsp=yes; format=flowed\r\nMessage-Id: &lt;AD5D4592-CE4F-4797-979E-149B10B5F1B4@...&gt;\r\nCc: REST Discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Transfer-Encoding: 7bit\r\nDate: Mon, 5 Nov 2007 09:22:59 +0100\r\nTo: amaeze77 &lt;amaeze@...&gt;\r\nX-Mailer: Apple Mail (2.752.3)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jan Algermissen &lt;algermissen1971@...&gt;\r\nSubject: Re: Using URIs and PUT to model state machines.\r\nX-Yahoo-Group-Post: member; u=289191104; y=LrgWdsnubZAaCbGoqrknoy9LZWwiVLl9BoXh0F8TwQkvk2zvpVDaGHQg\r\nX-Yahoo-Profile: algermissen1971\r\n\r\n\nOn 04.11.2007, at 23:04, amaeze77 wrote:\n\n&gt; --- In rest-discuss@yahoogroups.com, Jan Algermissen\n&gt; &lt;algermissen1971@...&gt; wrote:\n&gt;&gt;\n&gt;&gt; Hi amaeze77,    ....got a real name we can use?\n&gt;\n&gt; Amaeze works :)\n&gt;\n&gt;&gt; On 04.11.2007, at 16:56, amaeze77 wrote:\n&gt;&gt;\n&gt;&gt;&gt; Inherent to message-based architectures is the inclusion of\n&gt;&gt;&gt; operations in the message.  I use message-based architecture here,\n&gt;&gt;&gt; because I see it as being different from so-called RPC.\n&gt;&gt;&gt;\n&gt;&gt;&gt; REST-based architecture somewhat supports message-based\n&gt; architectures\n&gt;&gt;&gt; via the use of &quot;overloaded POST&quot;.  I can instruct a URI on what\n&gt;&gt;&gt; operation to perform based on the contents of the POST body.\n&gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt; If you do that you are *not* implementing a RESTful system.\n&gt;\n&gt; Why?  Because in your opinion I am using overloaded POST in the wrong\n&gt; way?  Overloaded POST is used for batches (for example), is that no\n&gt; longer RESTful\n\nTunneling operations through POST breaks REST&#39;s uniform inerface  \nconstraint.\nYou end up with client and server being coupled on the operation  \nsemantics.\n\n&gt;\n&gt; In my example, I am modeling the state transitions of an order after\n&gt; it has been &quot;received&quot; so in essence I don&#39;t have two parties\n&gt; communicating.  The system is moving the order along internally.\n\nIf you distribute your order processing, you effectively do have two  \nparties and\nyou should treat the coordination between them in the same way. If that\nseems overly complex then maybe REST isn&#39;t the right choice for the\nback end architecture?\n\n\n\n&gt; Hence I&#39;m not sure that the rest of your post is really applicable to\n&gt; me even though I think I get what you&#39;re getting at.  It seems like\n&gt; our contexts may be different.\n&gt;\n&gt; I am curious, what &quot;verb&quot; are you using to communicate these state\n&gt; changes?\n\nYou&#39;d use POST because the invocations are not idempotent.\n\nJan\n\n\n&gt;\n&gt;&gt; At this point the states of buyer and seller are aligned (they\n&gt; both\n&gt;&gt; know what\n&gt;&gt; state the other is in with regard to the process).\n&gt;&gt;\n&gt;&gt; The next state alignment to be made would be for the seller to\n&gt; tell\n&gt;&gt; the client it\n&gt;&gt; accepts (or rejects) the order and a different business document\n&gt;&gt; would be used for\n&gt;&gt; that message. Just as in traditional business making based on\n&gt; postal\n&gt;&gt; mail.\n&gt;&gt;\n&gt;&gt; If the buyer wants to cancel the order, it sends an order cancel\n&gt;&gt; document to\n&gt;&gt; wherever the seller told the client to send it to.\n&gt;&gt;\n&gt;&gt; Now the &#39;hypermedia as the engine of application state constraint&#39;\n&gt;&gt; enters the scene:\n&gt;&gt; In order for the two parties to conduct business, they have to\n&gt; have\n&gt;&gt; shared understanding\n&gt;&gt; of the business documents (e.g. both must know and agree what an\n&gt;&gt; order looks like) and\n&gt;&gt; of the possible state alignments (e.g. order cancelation). When a\n&gt;&gt; particular state alignment\n&gt;&gt; can be initiated and where is communicated by one party to the\n&gt; other\n&gt;&gt; using hypermedia.\n&gt;&gt; For example would the seller include in the order acceptance\n&gt; message\n&gt;&gt; some URI for the\n&gt;&gt; client to send cancelations to. The client, knowing about the\n&gt; meaning\n&gt;&gt; of a cancellation, would\n&gt;&gt; understand this &#39;form&#39; (-&gt; google for Mark&#39;s RDFForms) and keep\n&gt; the\n&gt;&gt; URI in case cancellation\n&gt;&gt; must be made.\n&gt;&gt;\n&gt;&gt; The beauty is that the coupling is minimized (you cannot do these\n&gt;&gt; state alignments with less\n&gt;&gt; shared knowledge) and therefore the freedom for both parties to\n&gt;&gt; change is maximized. All\n&gt;&gt; other software architectural styles that enable these kinds of\n&gt;&gt; coordinations require more\n&gt;&gt; coupling.\n&gt;&gt;\n&gt;&gt; You might want to take a look at UBL[1] for the business docs\n&gt; necessary.\n&gt;&gt;\n&gt;&gt; HTH,\n&gt;&gt; Jan\n&gt;&gt;\n&gt;&gt; [1] http://docs.oasis-open.org/ubl/os-UBL-2.0/UBL-2.0.html\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; For example, I could POST a &quot;ship&quot; instruction to\n&gt; &#92;orders&#92;[order_id]\n&gt;&gt;&gt; as the following:\n&gt;&gt;&gt; &lt;state&gt;ship&lt;/state&gt;\n&gt;&gt;&gt; &lt;qty&gt;5&lt;/qty&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; However, if I want to &quot;cancel&quot; that same order using the same\n&gt;&gt;&gt; resource (URI), the body of my POST would change to:\n&gt;&gt;&gt; &lt;state&gt;cancel&lt;/state&gt;\n&gt;&gt;&gt; &lt;qty&gt;0&lt;/qty&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; In my opinion, a much cleaner design is to create distinct (sub)\n&gt;&gt;&gt; resources for each state transition i.e. &#92;orders&#92;[order_id]\n&gt; &#92;shipped\n&gt;&gt;&gt; and &#92;orders&#92;[order_id]&#92;canceled then PUT indicating the need for\n&gt; the\n&gt;&gt;&gt; creation of the new state while updating the underlying resource.\n&gt;&gt;&gt; The PUT would return (at least) a link to the next logical state -\n&gt;  it\n&gt;&gt;&gt; could return links to all possible &quot;next&quot; states.  A GET on these\n&gt;&gt;&gt; (sub)resources would return true or false to indicate whether the\n&gt;&gt;&gt; parent resource is at that current state (business).\n&gt;&gt;&gt;\n&gt;&gt;&gt; An interesting result of such design is that it forces a designer\n&gt; to\n&gt;&gt;&gt; look at a system (and the entities in system) in the context of a\n&gt;&gt;&gt; state machine.  State machines are powerful!\n&gt;&gt;&gt;\n&gt;&gt;&gt; I&#39;ve been looking at REST for about a year and some these ideas\n&gt; are\n&gt;&gt;&gt; just beginning to crystallize.\n&gt;&gt;&gt;\n&gt;&gt;&gt; Any thoughts on this?\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Yahoo! Groups Links\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;\n&gt;\n&gt;\n\n\n"}}