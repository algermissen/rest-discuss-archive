{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":10266038,"authorName":"Jeff Bone","from":"Jeff Bone &lt;jbone@...&gt;","replyTo":"SENDER","senderId":"bLoqgxkqGx2yOMlGYaQM6CJrZMy4GYSLBXgK7xndM-0WPmuyd0aTQS-29WXmy7v4YugFnXhZ6INzi2Ck2ryaujI","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: [MIME-RPC] MIME-RPC versus the REST+XML  architectural style","postDate":"1011391093","msgId":62,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNDNDg5QTcxLjJEOEEyRTU4QGp1bXAubmV0Pg==","referencesHeader":"PFBpbmUuV05ULjQuNDMuMDIwMTE4MTEyMjM3MC4yMzQwLTEwMDAwMEBnYW5kb2xwaC5BU0dBUkQuam1zPg=="},"prevInTopic":60,"nextInTopic":66,"prevInTime":61,"nextInTime":63,"topicId":54,"numMessagesInTopic":6,"msgSnippet":"... Wrong.  Show me where in any of the HTTP spec it says that response bodies are any particular content-type or content-encoding?!  REST applications may use","rawEmail":"Return-Path: &lt;jbone@...&gt;\r\nX-Sender: jbone@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_1_3); 18 Jan 2002 21:59:17 -0000\r\nReceived: (qmail 94740 invoked from network); 18 Jan 2002 21:59:17 -0000\r\nReceived: from unknown (216.115.97.167)\n  by m3.grp.snv.yahoo.com with QMQP; 18 Jan 2002 21:59:17 -0000\r\nReceived: from unknown (HELO sm14.texas.rr.com) (24.93.35.41)\n  by mta1.grp.snv.yahoo.com with SMTP; 18 Jan 2002 21:59:16 -0000\r\nReceived: from jump.net (bu24242137-238.austin.rr.com [24.242.137.238])\n\tby sm14.texas.rr.com (8.12.0.Beta16/8.12.0.Beta16) with ESMTP id g0IM0xpL031918;\n\tFri, 18 Jan 2002 16:00:59 -0600\r\nMessage-ID: &lt;3C489A71.2D8A2E58@...&gt;\r\nDate: Fri, 18 Jan 2002 15:58:13 -0600\r\nOrganization: Clickfeed\r\nX-Mailer: Mozilla 4.7 [en] (Win95; I)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: &quot;S. Alexander Jacobson&quot; &lt;shop2it@...&gt;\r\nCc: Paul Prescod &lt;paul@...&gt;, rest-discuss@yahoogroups.com,\n   mime-rpc@...-rpc.com\r\nSubject: Re: [rest-discuss] Re: [MIME-RPC] MIME-RPC versus the REST+XML \n architectural style\r\nReferences: &lt;Pine.WNT.4.43.0201181122370.2340-100000@...&gt;\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nFrom: Jeff Bone &lt;jbone@...&gt;\r\nReply-To: jbone@...\r\nX-Yahoo-Group-Post: member; u=10266038\r\n\r\n\n\n&quot;S. Alexander Jacobson&quot; wrote:\n\n&gt; Note true.  The simple MIME-RPC response:\n&gt;\n&gt;    HTTP/1.1 200 OK\n&gt;\n&gt;    New York\n&gt;\n&gt; In contrast, the REST would be:\n&gt;\n&gt;     HTTP/1.1 200 OK\n&gt;     Content-type: text/xml; charset=utf-8\n&gt;\n&gt;     &lt;state xmlns=&quot;http://foo.com/bar/namespace&quot;&gt;New York&lt;/state&gt;\n\nWrong.  Show me where in any of the HTTP spec it says that response bodies\nare any particular content-type or content-encoding?!  REST applications may\nuse XML, but there&#39;s certainly no requirement there.  Even the use of the\ncontent-type header is a SHOULD, not a MUST.  (In cases where it&#39;s not\nprovided, clients MAY use heuristics to attempt to guess, and if the\ncontent-type remains unknown it SHOULD be treated as type\n&quot;application/octet-stream.&quot;  Cf. rfc2616, Section 7.2.1.)\n\nBottom line, the body belongs to the particular application, not HTTP\nitself.  And this is as it should be.\n\n&gt; The client\n&gt; is not required to parse XML and resolve a\n&gt; namespace just to get at the answer.\n\nThat&#39;s true for REST as well.\n\n&gt; The same arguments apply to your other examples\n&gt; so I won&#39;t expand on them here.  Nothing in\n&gt; MIME-RPC stops you from delivering an a text/xml\n&gt; as a response rather than a multipart/mixed.  I\n&gt; think it depends on the application which makes\n&gt; the most sense.\n\nLikewise for REST.\n\n&gt; I now realize that REST seems to want a new\n&gt; protocol that isn&#39;t either HTTP/1.0 or HTTP/1.1.\n\nNo, it just asserts that the semantics of HTTP are already rather\nwell-defined, and just wishes that people would understand (a) that fact, and\n(b) the generality afforded by the already-specified semantics.\n\n&gt; Claim: idempotent requests should use GET\n&gt;\n&gt; Reality: Many idempotent requests, e.g. SQL\n&gt; database queries, can&#39;t be sent with GET, because\n&gt; they are too large or entail too much structure.\n\nThis is troublesome, and it&#39;s been argued (by me, among others, before I\nreally &quot;got&quot; REST) that GET should be extended to include this\nfunctionality.  But that&#39;s really not the right answer --- doing so would\nrequire changes to the HTTP infrastructure, requiring that HTTP itself take\non the task of understanding at some semantic level the object\nrepresentations that it transfers.\n\nA reasonable position for REST to take is this:  idempotent requests which\nare &quot;too large&quot; to be effectively URL encoded in a reasonable way probably\nimply that the resources of the application aren&#39;t modeled and exposed\ncorrectly.  I.e., the only reason you need that much data in an idempotent\noperation would be if you were tunneling some other &quot;protocol&quot; (using the\nterm loosely) with some other view of the world (i.e., relational model, SQL\nbeing tunneled) through HTTP.  The REST position is therefore that you need\nto remodel your application to fit the HTTP model and thereby get all the\ngoodness of HTTP, rather than using it as a &quot;dumb&quot; conduit to tunnel other\nprotocols and map to other object models.  *Fully expose your application as\nresources that conform to the generic semantics of HTTP.*\n\n&gt; Claim: REST supports asynchronous messaging\n&gt;\n&gt; Reality: REST appears to require use of HTTP and\n&gt; HTTP does not support asynchronous requests.\n\nThis is (a) incorrect, as we&#39;ve already stated, and (b) rather ludicrous\nanyway.  Asynchrony as an application communication pattern doesn&#39;t require\nan asynchronous communication protocol --- if it did, it wouldn&#39;t be possible\nto build asynchronous applications with i.e. ONC RPC, CORBA, etc.  But we do\njust that.  Syncronous request-response protocols are sufficient for building\nasynchronous messaging on top of, and vice-versa --- both models are fully\ngeneral.\n\nIn HTTP, you would simply do asynchronous communication as callbacks:  a\nrequest supplies, potentially in an URL-encoded fashion, the URI to which\nresponses should be sent at a later date.  Responses are then passed back via\nlater HTTP methods invoked on the callback resource.\n\nWe *do* need some conventional ways for doing this, but it should be noted\nthat there are *many* kinds of asynchrony that are interesting to different\napplications.  For some apps, simple one-shot callbacks are sufficient.  For\nothers such as pub-sub, &quot;persistent&quot; callbacks are needed.  All of these and\nmore styles of communication are trivially built atop the existing HTTP\ninfrastructure with *no changes at all.*  A little bit of care must however\nbe exercised in order to ensure that you don&#39;t break the overall semanics of\nHTTP, i.e. caching, etc.  And even though all of this is trivially possible\n*today,* some cases may be common enough that extensions to the set of HTTP\nmethods might be reasonable optimizations.\n\n&gt; Claim: Applications should define new HTTP methods\n&gt;\n&gt; Reality: This is very difficult to deploy for many\n&gt; users and there is no standards process for\n&gt; defining these methods (limiting interop).\n\nReality:  REST doesn&#39;t claim that applications should add to the HTTP method\nset.  (BTW, that was my loudest and most passionate objection to REST before\nI &quot;got it.&quot;)  The REST claim is that almost anything you can think of doing\ncan be trivially recast within the context of HTTP&#39;s general, powerful\nmethods.  (Atomic read+delete is an example of one possible missing method,\nbut there aren&#39;t many of them.)\n\nThink about it this way:  the limited HTTP method set is analogous to the\nlimited file IO interface in UNIX.  And just as those interfaces have proven\n*incredibly* flexible and powerful --- almost anything can be recast as file\nIO and stream operations, cf. Plan 9 --- so is the limited HTTP method set\nmore flexible and powerful than it may appear at first glance.\n\n&gt;\n&gt; Very debatable.  In the states example, the\n&gt; MIME-RPC response was easier to read and shorter.\n&gt; In the baseball example, the multipart/mixed\n&gt; actually had fewer characters than the text/xml\n&gt; exampe.  Readability is in the eye of the\n&gt; beholder.\n\nAgain, REST is in no way married to XML.  Neither is it antagonistic to XML.\n\n&gt; I guess I just think that there are times when\n&gt; REST is incompatible with your needs,\n\nSuch as...?\n\njb\n\n\n\n"}}