{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"bJ0kOHeYClUXwANfX6F_dUDqAOVrE_a6zL5kScsSKs2XeF9oiuTR-8IQKftBIpUhndBqjvJnznk-bcMYChYsFkgXtEgLURUgdQ6PytIp2w","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Deigning representations of collections and  references","postDate":"1264677722","msgId":14696,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwMTI4MDQyMjAyLjljZjUxOTY4LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PGY4YjM5YWNlMTAwMTI4MDAwN3YyZjgzNTRjYm8yODA5M2MzODkxNzEyMTAzQG1haWwuZ21haWwuY29tPg==","referencesHeader":"PGhqcWNrNStidjc1QGVHcm91cHMuY29tPgk8MjAxMDAxMjgwMDA3NTQuZDU4OGRlNTEuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8ZjhiMzlhY2UxMDAxMjgwMDA3djJmODM1NGNibzI4MDkzYzM4OTE3MTIxMDNAbWFpbC5nbWFpbC5jb20+"},"prevInTopic":14695,"nextInTopic":14715,"prevInTime":14695,"nextInTime":14697,"topicId":14691,"numMessagesInTopic":15,"msgSnippet":"... Atom is namespace-extensible and follows a schema.  Unless and until JSON actually becomes a hypertext format, I ll stick to using hypertext and standard","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 19738 invoked from network); 28 Jan 2010 11:22:10 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m10.grp.re1.yahoo.com with QMQP; 28 Jan 2010 11:22:10 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.re1.yahoo.com with SMTP; 28 Jan 2010 11:22:10 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id F2F8B509DA;\n\tThu, 28 Jan 2010 06:22:05 -0500 (EST)\r\nDate: Thu, 28 Jan 2010 04:22:02 -0700\r\nTo: craigmcc@...\r\nCc: piers_lawson &lt;Piers@...&gt;, rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100128042202.9cf51968.eric@...&gt;\r\nIn-Reply-To: &lt;f8b39ace1001280007v2f8354cbo28093c3891712103@...&gt;\r\nReferences: &lt;hjqck5+bv75@...&gt;\n\t&lt;20100128000754.d588de51.eric@...&gt;\n\t&lt;f8b39ace1001280007v2f8354cbo28093c3891712103@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Deigning representations of collections and \n references\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nCraig McClanahan wrote:\n&gt;\n&gt; Eric J. Bowman wrote:\n&gt; \n&gt; &gt;\n&gt; &gt;\n&gt; &gt; &quot;piers_lawson&quot; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hi I&#39;ve been looking for advice on how to design the\n&gt; &gt; &gt; representation of a collection of references.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; Look no further than RFC 4287.\n&gt; &gt;\n&gt; &gt;\n&gt; I agree that Atom is a useful model for understanding how to represent\n&gt; collections.  But, every time I try to use it in anger, I keep\n&gt; running into some frustrations:\n&gt; \n&gt;  * Atom is XML only -- I find JSON much easier for a general client\n&gt; base to deal with.\n&gt; \n\nAtom is namespace-extensible and follows a schema.  Unless and until\nJSON actually becomes a hypertext format, I&#39;ll stick to using hypertext\nand standard link relations in REST applications.  I hold the opposite\nview from yours on the XML-vs-JSON issue, entirely.  There is no\nstandard means to represent collections of data as JSON.  Whereas there\nis application/atom+xml, which keeps that out-of-band knowledge wrapped\nup in a common-knowledge standard media type, where it belongs -- not\nin an API description.\n\n&gt;\n&gt; * Even when I&#39;m willing to deal with XML formats, it is pretty clumsy\n&gt; to represent\n&gt;   application specific content types -- you&#39;re pretty much talking\n&gt; about custom\n&gt;   XML namespaces, or about leveraging the XML &quot;any&quot; elements in the\n&gt; Atom schema,\n&gt;   which also basically negates the idea that a generic client is\n&gt; going to be able to\n&gt;   understand much about a particular message.\n&gt; \n\nNo, I&#39;m not even suggesting that.  Atom provides a wrapper for XML of\nany schema within atom:summary and atom:content elements.  All a\ngeneric client, or intermediary, needs to know is right there in the\nmedia type identifier of the response.  The user&#39;s agent will need to\nknow how to render the standard-or-nonstandard vocabulary presented in\nthe contents, but it needs no special knowledge of protocol-layer\nmessaging beyond that provided by Atom and Atom Protocol -- while an\nintermediary only needs knowledge of the protocol-layer messaging but\nno special knowledge of application-specific vocabulary.\n\nThe original question Piers was asking was also seeking advice on how\nto create and update collection members.  If you are dealing with data\nthat can be modeled in Atom, you can use Atom Protocol to handle\ncreating and updating members in a standardized fashion, regardless of\nthe vocabulary used within atom:summary or atom:content elements.  I\ndon&#39;t know how any &quot;generic&quot; client is supposed to understand any\napplication-specific messaging that isn&#39;t described by the use of a\nstandard media type.\n\n&gt;\n&gt; * There are a bunch of required attributes in the Atom &quot;envelope&quot;\n&gt; around the content that make perfect sense for the original use case\n&gt; (blog postings) but do not always make sense for particular\n&gt; application use cases.\n&gt; \n\nYou&#39;re right, Atom isn&#39;t always the answer.  But, it certainly helps to\nstart with modeling a system like Piers&#39; in Atom, since it&#39;s a pretty\nclose fit out-of-the-box.  Patient records have a patient ID and a\npatient Name and contact info.  In Atom, these would be under &lt;author&gt;\nelements instead of &lt;patient&gt; elements.\n\nThe question is, whether it causes so much confusion for the system to\ncall patients &quot;authors&quot; that it outweighs the benefit of being able to\nbuild the system using standard libraries for well-known media types\nlike Atom.  That same cost-benefit analysis needs to be applied to\nevery instance where a working model built with Atom is suboptimal to\nthe goals of the system.\n\nSo build a working model of the system, using Atom if it&#39;s even\nremotely close to workable, because then you know exactly what\nshortcomings are being addressed by the selection of some other\nstandard, or any custom, media types you proceed to choose or create.\nAtom is hardly limited to &quot;blogging&quot;, it applies to any sort of record\nwhere it&#39;s important to know who said what to whom, when.  If the\nactual data is a PDF or something, it can be handled as an attachment.\n\n&gt;\n&gt; * Yes, the concept of a standardized &lt;link&gt; element is quite useful\n&gt; for expressing\n&gt;   relationships between representations (and I like the idea that you\n&gt; can define\n&gt;   your own &quot;rel&quot; values).  \n&gt;\n\nBut, there&#39;s nothing standard about an application-specific link\nrelation.\n\n&gt;\n&gt; But ...\n&gt; \n&gt;   - You can have the same benefits in roll-your-own representations by\n&gt;     emulating the &lt;link&gt; semantics in some appropriate local syntax.\n&gt; \n\nNo, you can&#39;t.  Link semantics and syntax are clearly spelled out by\nthe relevant standards which describe them (as defined by media type\nidentifier used), and there is expected to be a new registry for\nstandardized link relations to be used in HTTP Link header syntax.\nREST quite clearly calls for the use of standard or standardizable\nmethods and media types, the combination of which encapsulates all out-\nof-band knowledge of an API within common knowledge.\n\nNonstandard vocabularies are allowed inside of standard media types,\nbut embedding standard link relations inside nonstandard vocabularies\ndefeats the entire purpose.\n\n&gt;\n&gt;   - Generic clients are not going to understand the semantics of\n&gt; custom &quot;rel&quot;\n&gt;     values anyway, so what is the value of packaging them in the\n&gt; standard Atom envelope?\n&gt; \n\nWho said anything about custom rel values?  The OP is clearly\ndescribing a problem that&#39;s easily solved by the standard link\nrelations defined within Atom.  Granted, those link relations can be\nused in other media types, but if those other media types aren&#39;t\nstandard then the system isn&#39;t built in the REST style.\n\nIf a patient can have an atom:id, then so can a Doctor.  It follows,\nthen, that a medical recordkeeping system would need a vocabulary of\nlink relations specific to that type of system, for linking Doctors and\npatients -- a patient record of a Dr. visit might have a link to the\natom:id of the referring Dr. which would need a different link relation\nthat that of the attending Dr.\n\nBut, Atom allows for such extension, and such a vocabulary, if generic\nenough, could see adoption elsewhere.  After which, a standard emerges\nestablishing consensus for a Medical Records extension vocabulary for\nAtom.  Now that I have said something about custom rel values, why\nwould a generic client, or intermediary, need to understand application\nspecifics like referring vs. attending physician?  All I care about is\nthat the (human|machine) user&#39;s agent can interpret this information.\n\nA hypertext application can easily be built based on those link\nrelations, which allows for the correct display and manipulation of\nsystem resources.  The user&#39;s agent is thus taught all it needs to\nknow, and the link relations don&#39;t need to be standardized for it to\nwork.  REST requires the standardization of these link relations, for\npurposes beyond just making the application work -- to make it work for\nothers in an interoperable way over time, requires that the out-of-band\nknowledge encapsulated in these link relations is (or becomes) common\nknowledge.\n\n&gt;\n&gt; Bottom line, I like the overall design paradigm that Atom defines,\n&gt; with well defined semantics for the various CRUD operations that are\n&gt; almost univeral across applications.  But, adhering to 4287 (versus\n&gt; my own custom collection representation that shares the spirit of the\n&gt; &lt;link&gt; element for cross referencing) doesn&#39;t seem to add huge\n&gt; amounts of value.  You&#39;re right, a generic Atom client might\n&gt; understand the coarse grained message structure of an\n&gt; &quot;application/atom+xml;type=feed&quot; media type, but I have a hard time\n&gt; seeing why this matters if the client can&#39;t understand the actual\n&gt; representation inside the &lt;atom:content&gt; element (or the equivalent\n&gt; custom XML elements that the &quot;any&quot; construct in the schema allows)\n&gt; anyway.\n&gt; \n\nI don&#39;t see why a client can&#39;t be instructed, via an XSLT\ntransformation, how to present any custom XML vocabulary presented\nwithin atom:summary/atom:content elements as HTML documents.  At the\nwire level, protocol interaction simply doesn&#39;t require knowledge of\nany custom vocabulary within representations of standard media types.\n\n&gt;\n&gt; For my own APIs (at least so far), I&#39;ve followed these principles:\n&gt; \n&gt; * Design a custom representation, with a custom media type,\n&gt;   for each individual data object &quot;class&quot;.\n&gt; \n\nOK, you&#39;re not the first person I&#39;ve heard promoting this design meme,\nbut you will be the first person I ask why...  Where do you find any\nsupport for this notion within REST or anything else Dr. Fielding has\nwritten about REST?  The REST style calls for obeying the standards\nused.  I&#39;m assuming you&#39;re using the HTTP protocol, in which case RFC\n2616 applies, along with its SHOULD NOT admonishment against using\nunregistered media types.\n\nI&#39;ve written extensively in recent threads about all the things Roy and\nREST do say about media type proliferation, so aside from going against\nRFC 2616 this design pattern does not have any conceivable support from\nwithin REST, which calls for the re-use of existing standard media\ntypes.  That there are people out there who are minting media types for\neach representation type on their system, boggles my mind.\n\nThis goes against all custom and practice in Web Development, where the\nclosest you&#39;ll come to an example was Atom Protocol&#39;s adding the type\nparameter to the application/atom+xml media type identifier.\nAdditionally, you suggest that Atom is only useful for blogging,\ninstead of its actual intent to be an extensible, all-purpose re-usable\nwrapper, the very notion of which seems alien to the mint-new-media-\ntypes-for-everything approach.  You also suggest a 1:1 relationship\nbetween media types and media type identifiers, which doesn&#39;t exist,\nand isn&#39;t required unless media type identifiers are being mis-used as\n&quot;contracts&quot;.\n\nREST development starts with modeling resources; once modeled, those\nresources are assigned an appropriate media type.  Only once all\nexisting media types are deemed inappropriate, is it OK to forge ahead\nwith minting a new one.  This is designing within the constraints of\nREST.  The unbounded-creativity approach of treating each of your\nrepresentations as a unique snowflake without considering the\npossibility that a standard media type may be a perfect fit, is in\ndirect conflict with the REST style.\n\n&gt;\n&gt; * Within the representation, include an extensible structure\n&gt;   akin to the Atom &lt;link&gt; element, to define relationships\n&gt;   between representations (as well as links to trigger state changers)\n&gt;   but without the extra baggage of &quot;required&quot; Atom elements that\n&gt;   are not relevant to the application specific use cases\n&gt;   (let alone the limitation to use XML).\n&gt; \n\nI certainly don&#39;t see how any generic client is going to understand\nwhat you suggest.  To quote from REST:\n\n&quot;\nThe trade-off, though, is that a uniform interface degrades efficiency,\nsince information is transferred in a standardized form rather than one\nwhich is specific to an application&#39;s needs.\n&quot;\n\nIf you&#39;re unwilling to make this trade-off, then perhaps REST isn&#39;t the\nright architecture for your system.  What you consider &quot;baggage&quot; is\nconsidered by plenty of others as the essential bare-minimum information\npertinent to who said what to whom, when.  While some of this data may\nbe irrelevant to your specific application, the use of a standard media\ntype allows for serendipitous re-use.  Atom does force you to provide\nthe who said what to whom, when-metadata, even if you aren&#39;t using it in\nyour interface, because it&#39;s critical to allowing others to use your\nAPI for purposes you never conceived.\n\nI also have no idea what you mean when you say Atom is limited to XML.\n\n&gt;\n&gt; * Design an additional representation, with a &quot;plural&quot; name in\n&gt;   the media type, for collections of the same type of data object.\n&gt;   In XML, this would typically be something like as &lt;customers&gt;\n&gt;   element around zero or more &lt;customer&gt; elements, with a\n&gt;   media type like &quot;application/vnd.com.example.myapp.Customers+xml&quot;\n&gt;   (or +json) for the collection, and\n&gt; &quot;application/vnc.com.example.myap.Customer+xml&quot;\n&gt;   for the representation of an individual customer.\n&gt; \n\nYou&#39;ve now minted two media types that are specific to your application\nand do not represent common knowledge.  Your API is thus driven by out-\nof-band knowledge presented in its documentation, rather than a shared\nunderstanding of common media types and link relations.  I don&#39;t\nunderstand how a generic client, or intermediary, can understand\nanything about your payload other than what&#39;s implied by application/xml\nbecause RFC 3023 allows for the extension of that media type identifier.\n\nHowever, no such corollary exists in RFC 4627, so your +json media type\nidentifiers will be treated by generic clients, or intermediaries, as\nan invalid declaration and may forward or interpret the message as\ntext/plain or application/octet-stream, or remove the Content-Type\nheader entirely.\n\nI also have no idea what you mean by &quot;typically be something like...&quot;\nIf you&#39;re just using Atom, and not Atom Protocol, then &lt;feed&gt; wraps\n&lt;entry&gt; unless &lt;entry&gt; is the root element, and either way they have\nthe same media type.  In Atom Protocol, it is optional to use a type\nparameter, both type=feed and type=entry are defined.  I don&#39;t bother\nwith type=entry, but I do use type=feed.  These are subtypes, and this\nis the proper way to handle collections/members rather than assigning\ntwo separate media type identifiers -- how is any generic client, or\nintermediary, to understand that *.Customer+xml and *.Customers+xml are\nin any way related to one another?  These are separate, opaque\nidentifers rather than an identical media type with separate, opaque\nsubtypes.\n\n&gt;\n&gt; I am aware that there are reasonable-sounding arguments for using\n&gt; &quot;standard&quot; representation formats when they are available.  I&#39;m just\n&gt; not sold on the value, at least for the APIs I have been involved in\n&gt; so far.\n&gt; \n\nREST doesn&#39;t call this an optional constraint -- self-descriptive\nmessaging is critical to the entire style.  If you&#39;re relying on out-\nof-band information based on the syntax of custom media type identifiers\nthen specific knowledge of your API is required for any intermediary or\nclient to make heads or tails of its payload.  If you&#39;re using standard\nmedia types, then generic clients may be instructed how to deal with\nany uncommon knowledge about your API, using hypertext representations.\n\nNobody has managed to sell me on any pragmatic value to disregarding\nthe self-descriptive messaging constraint.  There is value in allowing\nintermediaries and generic clients to determine the nature of a payload\nby keying on standard media type identifiers.  It comes with a tradeoff\nof efficiency that I&#39;m willing to make in order to gain the positive\nbenefits of scaling and serendipitous re-use, which is why I use REST.\nIf there were some hidden value in disregarding the self-descriptive\nmessaging constraint that disproves REST&#39;s utility, then I wouldn&#39;t pay\nREST any mind, but so far no such inherent contradiction has been\nexposed.  IOW, my response has nothing to do with dogma, and everything\nto do with why the Web succeeded in the first place.\n\n-Eric\n\n"}}