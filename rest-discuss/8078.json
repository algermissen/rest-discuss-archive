{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":265185497,"authorName":"Jerome Louvel","from":"Jerome Louvel &lt;contact@...&gt;","profile":"jerome.louvel","replyTo":"SENDER","senderId":"E-Tt3PRGxQ2Ri1IPnvhU0gEkEYkGm0kEzJRNYBaYosCotZ2NODRj8xqT0XRfyLiFg9JyzNyqIc3jsYjCLly2YycZgZh3Wb1kYdw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Acceptable Responses","postDate":"1173103022","msgId":8078,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGVzaDdqMiR2cHQkMUBzZWEuZ21hbmUub3JnPg==","inReplyToHeader":"PGVzaDEybCs3Z3R0QGVHcm91cHMuY29tPg==","referencesHeader":"IDxlc2gxMmwrN2d0dEBlR3JvdXBzLmNvbT4="},"prevInTopic":8077,"nextInTopic":8079,"prevInTime":8077,"nextInTime":8079,"topicId":8074,"numMessagesInTopic":13,"msgSnippet":"Hi Alan, Nice post. This is indeed an issue. I like the idea to leverage OPTIONS as a way to obtain metadata on the resource. One option could be to return a","rawEmail":"Return-Path: &lt;contact@...&gt;\r\nX-Sender: contact@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 18485 invoked from network); 5 Mar 2007 14:03:41 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m47.grp.scd.yahoo.com with QMQP; 5 Mar 2007 14:03:41 -0000\r\nReceived: from unknown (HELO ciao.gmane.org) (80.91.229.2)\n  by mta5.grp.scd.yahoo.com with SMTP; 5 Mar 2007 14:03:40 -0000\r\nReceived: from list by ciao.gmane.org with local (Exim 4.43)\n\tid 1HODgS-0006sZ-Kv\n\tfor rest-discuss@yahoogroups.com; Mon, 05 Mar 2007 14:57:00 +0100\r\nReceived: from m67.net81-67-81.noos.fr ([81.67.81.67])\n        by main.gmane.org with esmtp (Gmexim 0.1 (Debian))\n        id 1AlnuQ-0007hv-00\n        for &lt;rest-discuss@yahoogroups.com&gt;; Mon, 05 Mar 2007 14:57:00 +0100\r\nReceived: from contact by m67.net81-67-81.noos.fr with local (Gmexim 0.1 (Debian))\n        id 1AlnuQ-0007hv-00\n        for &lt;rest-discuss@yahoogroups.com&gt;; Mon, 05 Mar 2007 14:57:00 +0100\r\nX-Injected-Via-Gmane: http://gmane.org/\r\nTo: rest-discuss@yahoogroups.com\r\nDate:  Mon, 05 Mar 2007 14:57:02 +0100\r\nLines: 278\r\nMessage-ID: &lt;esh7j2$vpt$1@...&gt;\r\nReferences:  &lt;esh12l+7gtt@...&gt;\r\nMime-Version:  1.0\r\nContent-Type:  text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding:  8bit\r\nX-Complaints-To: usenet@...\r\nX-Gmane-NNTP-Posting-Host: m67.net81-67-81.noos.fr\r\nUser-Agent: Thunderbird 1.5.0.9 (Windows/20061207)\r\nIn-Reply-To: &lt;esh12l+7gtt@...&gt;\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Jerome Louvel &lt;contact@...&gt;\r\nSubject: Re: Acceptable Responses\r\nX-Yahoo-Group-Post: member; u=265185497; y=8mNN6NmtJYbabRi1YZ3T4Wu8FApCvCs0GX8IaZqa4PydBGq91DG98A\r\nX-Yahoo-Profile: jerome.louvel\r\n\r\nHi Alan,\n\nNice post. This is indeed an issue. I like the idea to leverage OPTIONS \nas a way to obtain metadata on the resource. One option could be to \nreturn a WADL snippet describing only the resource that is the target of \nthe OPTIONS method.\n\nOtherwise, your proposition to use new headers is even better. It is \nimportant to note that there are multiple aspects defining what is \nacceptable, the media type, the language, etc. If we add an \n&quot;Acceptable:&quot; header, we should also add &quot;Acceptable-Language&quot;, \n&quot;Acceptable-Charset&quot; and &quot;Acceptable-Encoding&quot;.\n\nActually, as the &quot;Accept-Ranges&quot; response headers already exists for \nsimilar purposes, we could simply reuse the request headers as response \nheaders: &quot;Accept&quot; to list acceptable media types, &quot;Accept-Language&quot;, \n&quot;Accept-Charset&quot; and &quot;Accept-Encoding&quot; for other metadata.\n\nRegards,\nJerome\n\n\nAlan Dean a ï¿½crit :\n&gt; \n&gt; \n&gt; I apologise up front for what will be a rather lengthy post to the\n&gt; group.\n&gt; \n&gt; I would like some feedback on something that I&#39;ve been thinking hard\n&gt; about recently: &quot;acceptable responses&quot;.\n&gt; \n&gt; What do I mean by this? Well, we all know that one of the strengths\n&gt; of REST is that the interface is &#39;well-known&#39; so we don&#39;t need to use\n&gt; WSDL (or equivalent) to bind to a RESTful endpoint - we just need a\n&gt; URL.\n&gt; \n&gt; As an example, we can quite happily have the following\n&gt; Request/Response to do a directory listing:\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; \n&gt; &lt;--\n&gt; 200 OK\n&gt; Content-Type: text/html\n&gt; \n&gt; &lt;html&gt;\n&gt; &lt;body&gt;\n&gt; &lt;a href=&quot;dir1/&quot;&gt;dir1&lt;/a&gt;\n&gt; &lt;a href=&quot;dir2/&quot;&gt;dir2&lt;/a&gt;\n&gt; &lt;a href=&quot;file.txt/&quot;&gt;Text File&lt;/a&gt;\n&gt; &lt;a href=&quot;file.html/&quot;&gt;HTML File&lt;/a&gt;\n&gt; &lt;/body&gt;\n&gt; &lt;/html&gt;\n&gt; \n&gt; Now, that&#39;s all fine and uncontroversial. A cient can parse the\n&gt; response representation, discover the text/html content type, load\n&gt; the body into a DOM and select each href - perhaps with the\n&gt; XPath //@href\n&gt; \n&gt; This also allows the response representation to be loaded in a\n&gt; browser and viewed by a human.\n&gt; \n&gt; However...\n&gt; \n&gt; What if the client is a robot?\n&gt; \n&gt; The above example text/html representation will probably be fine for\n&gt; most robots, such as search crawlers. But I wonder if this is really\n&gt; nothing more clever than screen-scraping. (Note that this approach\n&gt; would treat all href URLs the same)\n&gt; \n&gt; The obvious answer to this is to support multiple representations. In\n&gt; the example above, the request implicitly carries an Accept: */*\n&gt; header value. However, a robot might make the following request\n&gt; instead:\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: application/rdf+xml\n&gt; \n&gt; &lt;--\n&gt; 200 OK\n&gt; Content-Type: application/rdf+xml\n&gt; \n&gt; &lt;?xml version=&quot;1.0&quot;?&gt;\n&gt; &lt;rdf:RDF&gt;\n&gt; ...\n&gt; &lt;rdf:RDF&gt;\n&gt; \n&gt; Now the robot has obtained an RDF/XML representation of the directory\n&gt; contents. This is no longer simple screen-scraping, but semantically\n&gt; meaningful data.\n&gt; \n&gt; Again, this isn&#39;t terribly controversial. But note that we now have\n&gt; two alternate representations of the some resource and we have\n&gt; decided which is the default. Furthermore, there could be many other\n&gt; alternate representation formats - each as equally &#39;standard&#39; as\n&gt; text/html or application/rdf+xml - such as text/plain or text/csv and\n&gt; so on.\n&gt; \n&gt; This means that any of the following requests might be acceptable:\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: text/plain\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: text/csv\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: text/html\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: application/rdf+xml\n&gt; \n&gt; This now draws me towards the crux of my question.\n&gt; \n&gt; How does a client discover the supported representations?\n&gt; \n&gt; The client might ping the resource with each known (to the client)\n&gt; Content-Type, in the following manner:\n&gt; \n&gt; --&gt;\n&gt; HEAD /foo/\n&gt; Accept: application/xml\n&gt; \n&gt; &lt;--\n&gt; 406 Not Acceptable\n&gt; \n&gt; --&gt;\n&gt; HEAD /foo/\n&gt; Accept: text/html\n&gt; \n&gt; &lt;--\n&gt; 200 OK\n&gt; Content-Type: application/rdf+xml\n&gt; \n&gt; This has several drawbacks to it (latency and inefficiency both jump\n&gt; to mind).\n&gt; \n&gt; Some of you may be thinking that 300 Multiple Choices is the answer.\n&gt; But I suspect that, for this issue, the problem becomes circular at\n&gt; this point (what format should the 300 response representation itself\n&gt; use?).\n&gt; \n&gt; Furthermore, this issue is implicit in many requests. Consider what\n&gt; the representation format should be for any of the following:\n&gt; \n&gt; 1. An OPTIONS request (what are the supported representation formats?)\n&gt; 2. A 406 Not Acceptable response (what are acceptable representation\n&gt; formats?)\n&gt; 3. A 300 Multiple Choices response\n&gt; \n&gt; At first blush, we might decide that what we need is a standard\n&gt; representation. I thought about that and decided that it makes little\n&gt; sense - mostly for pragmatic and practical reasons, but also because\n&gt; it seems to fall foul of the same anti-pattern as WSDL.\n&gt; \n&gt; Then ... I thought about how allowed methods are communicated:\n&gt; \n&gt; --&gt;\n&gt; OPTIONS /foo/\n&gt; \n&gt; &lt;--\n&gt; 200 OK\n&gt; Allow: GET, HEAD, POST, PUT, DELETE\n&gt; \n&gt; I wonder if the answer to the dilemna outlined above is that we need\n&gt; an equivalent HTTP header for Content-Types? Consider the following:\n&gt; \n&gt; --&gt;\n&gt; OPTIONS /foo/\n&gt; \n&gt; &lt;--\n&gt; 200 OK\n&gt; Allow: GET, HEAD, POST, PUT, DELETE\n&gt; Acceptable: text/plain, text/html, application/rdf+xml\n&gt; \n&gt; --&gt;\n&gt; GET /foo/\n&gt; Accept: model/*\n&gt; \n&gt; &lt;--\n&gt; 406 Not Acceptable\n&gt; Acceptable: text/plain, text/html, application/rdf+xml\n&gt; \n&gt; This seems clean and elegant to me. What do you all think?\n&gt; \n&gt; Regards,\n&gt; Alan Dean\n&gt; http://thoughtpad.net/who/alan-dean/ &lt;http://thoughtpad.net/who/alan-dean/&gt;\n&gt; \n&gt; \n\n\n\n"}}