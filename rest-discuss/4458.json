{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":87113616,"authorName":"S. Mike Dierken","from":"&quot;S. Mike Dierken&quot; &lt;mdierken@...&gt;","profile":"mdierken","replyTo":"SENDER","senderId":"idFyYRiIQfNFGtSLL25o4BP5TxeuHBT6zMlnen-F06MlQRwtaX67SFs54TzyBThRd3V5KJqee_uqwzZsaS8ZgdYo81KuAHYWXw4BRHwBMw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Design questions for applying REST","postDate":"1087104276","msgId":4458,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEJBWTE2LURBVjQ4aGZBRW5SOXIwMDAzODdlZUBob3RtYWlsLmNvbT4=","referencesHeader":"PEJBWTE2LURBVjYwc0w2N1FsTkQwMDAzNjZmNkBob3RtYWlsLmNvbT4gPDQwQzlCMjI5LjYwMDAxQG5lZ2dpZS5uZXQ+IDxCQVkxNi1EQVYzME9SRlFHd1o0MDAwMzc4M2JAaG90bWFpbC5jb20+IDw0MENBRjkyMC42MDUwMDAyQG5lZ2dpZS5uZXQ+"},"prevInTopic":4457,"nextInTopic":4459,"prevInTime":4457,"nextInTime":4459,"topicId":4447,"numMessagesInTopic":13,"msgSnippet":"... handling ... I was just mentioning that it s a common pattern for a client to own the resource identifier and that HTTP supports this approach. It seems","rawEmail":"Return-Path: &lt;mdierken@...&gt;\r\nX-Sender: mdierken@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 28554 invoked from network); 13 Jun 2004 05:24:37 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m23.grp.scd.yahoo.com with QMQP; 13 Jun 2004 05:24:37 -0000\r\nReceived: from unknown (HELO hotmail.com) (65.54.186.228)\n  by mta3.grp.scd.yahoo.com with SMTP; 13 Jun 2004 05:24:37 -0000\r\nReceived: from mail pickup service by hotmail.com with Microsoft SMTPSVC;\n\t Sat, 12 Jun 2004 22:24:32 -0700\r\nReceived: from 207.202.171.254 by bay16-dav48.bay16.hotmail.com with DAV;\n\tSun, 13 Jun 2004 05:24:32 +0000\r\nX-Originating-Email: [mdierken@...]\r\nX-Sender: mdierken@...\r\nTo: &quot;John Belmonte&quot; &lt;john@...&gt;\r\nCc: &lt;rest-discuss@yahoogroups.com&gt;\r\nReferences: &lt;BAY16-DAV60sL67QlND000366f6@...&gt; &lt;40C9B229.60001@...&gt; &lt;BAY16-DAV30ORFQGwZ40003783b@...&gt; &lt;40CAF920.6050002@...&gt;\r\nDate: Sat, 12 Jun 2004 22:24:36 -0700\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2800.1409\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1409\r\nMessage-ID: &lt;BAY16-DAV48hfAEnR9r000387ee@...&gt;\r\nX-OriginalArrivalTime: 13 Jun 2004 05:24:32.0529 (UTC) FILETIME=[B5392010:01C45106]\r\nX-eGroups-Remote-IP: 65.54.186.228\r\nFrom: &quot;S. Mike Dierken&quot; &lt;mdierken@...&gt;\r\nSubject: Re: [rest-discuss] Design questions for applying REST\r\nX-Yahoo-Group-Post: member; u=87113616\r\nX-Yahoo-Profile: mdierken\r\n\r\n\n&gt; &gt; I also think that HTTP indicates that part of a server&#39;s job for\nhandling\n&gt; &gt; PUT is for the client to be able to specify the URI.\n&gt;\n&gt; I&#39;m not sure what your meaning is in that second sentence.\nI was just mentioning that it&#39;s a common pattern for a client to &#39;own&#39; the\nresource identifier and that HTTP supports this approach. It seems to fit\nwell with my design problem.\n\n\n&gt;\n&gt; &gt;&gt;In any case, you can make this plan more robust as follows: when the\n&gt; &gt;&gt;server creates a record for a new document, also store the digest of the\n&gt; &gt;&gt;request that caused it.  Then, if it receives a duplicate request from\n&gt; &gt;&gt;the client, ignore it and return the exiting resource location.\n&gt; &gt;\n&gt; &gt; I&#39;m not really worried about duplicate requests - the behavior would be\nto\n&gt; &gt; determine if the submitted content already had been submitted before.\nEither\n&gt; &gt; via the URI having the client-managed identifier or having the content\n&gt; &gt; contain the client-managed identifier.\n&gt;\n&gt; That&#39;s surprising to me.  From your original post, case c:\n&gt;\n&gt;     - requests can be safely re-tried. Bonus.\n&gt;\n&gt;  From what I gathered, you hadn&#39;t considered that this could be covered in\ncase b also.\nSorry - I meant that I wasn&#39;t worried how it would be implemented. I know\nthat POST /might/ be implemented in an idempotent manner, but the bonus is\nthat PUT /requires/ it - a client does not need extra &#39;coordination&#39;\n(pre-arranged commitment from the service author) to re-try a request.\n\n\n&gt;\n&gt; &gt;&gt;Also, assuming that input documents are not shared, the server could\n&gt; &gt;&gt;provide a query function that returns the output resource given an input\n&gt; &gt;&gt;resource URL.\n&gt; &gt;\n&gt; &gt; What would that look like? It&#39;d be a compound URI, right? Whatever it\nwould\n&gt; &gt; look like, I hadn&#39;t considered two resources - one for the stored input\n&gt; &gt; document and one with references to the synthesized output document, but\nin\n&gt; &gt; order to know about this second resource either the client generates\nthat\n&gt; &gt; resource identifier or that identifer is contained in a representation\nof\n&gt; &gt; the stored input document - and I might as well point to the synthesized\n&gt; &gt; output document directly.\n&gt;\n&gt; I&#39;m not sure where your concern comes from, as this is exactly what\n&gt; queries are for.  For example:\n&gt;\n&gt;    GET /myapp/outputs?input=/myapp/inputs/a98a6799 HTTP/1.1\n&gt;    Host: example.net\n&gt;\n&gt;    HTTP/1.1 302 Found\n&gt;    Location: http://example.net/myapp/outputs/14f322410\n&gt;\n&gt; This is exactly the same as going to &lt;http://example.net/myapp/outputs&gt;,\n&gt; entering &quot;/myapp/inputs/a98a6799&quot; in the &quot;input&quot; field of a form, and\n&gt; being automatically redirected to\n&gt; &lt;http://example.net/myapp/outputs/14f322410&gt;.\n&gt;\n&gt; -John\nI think there is something good in this, but I still need to see how it\nwould work in my system - I have a feeling that there is a disconnect\nsomewhere in our discussion (probably me). (Also, using a URI in a query\nterm probably has text encoding issues, like if the first URI already has\nquery terms in it).\n\n==========\nUsing option b (POST-based)\nIn this use case, uri_0 is a service meta-description, uri_1 is the\n&#39;container&#39; resource that accepts input documents, uri_2 is the newly\ncreated input document, uri_3 is the resource that holds a mapping between\nthe input document and the &#39;merged&#39; document and uri_4 is the final &#39;merged&#39;\ndocument.\n\n--- request 1: create new input document, another &#39;merged&#39; document is\nupdated from this input document as well ---\n  POST uri_1 HTTP/1.1\n  Content-type: text/xml\n  ...stuff...\n\n HTTP/1.1 201 Created\n Location: uri_2\n\n--- request 2: get service meta-description (this is of course done earlier\n& cached) ---\n  GET uri_0 HTTP/1.1\n  Accept: text/xml\n\n  HTTP/1.1 200 OK\n  Content-type: text/xml\n  ...description of how to generate resource identifiers...\n\n(process service description to generate resource identifier - basically\nuri_3 would have uri_2 (or something equivalent) in it.\nI realize now what my mistake was - I assumed the client had enough\ninformation to map to the final merged document - which isn&#39;t possible.)\n\n--- request 3: use generated resource identifier of resource that provides\nthe mapping to final &#39;merged&#39; document ---\n  GET uri_3 HTTP/1.1\n  Accept: text/xml\n\n  HTTP/1.1 303 See Other\n  Location: uri_4\n\n\n(You might be able to avoid the mapping step by using PUT and having the\nfirst request return the location of the &#39;merged&#39; document in the Location\nheader. Not sure if that is acceptable or not.)\n\n"}}