{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":121832671,"authorName":"inthedarkplace","from":"&quot;inthedarkplace&quot; &lt;inthedarkplace@...&gt;","profile":"inthedarkplace","replyTo":"SENDER","senderId":"j3oTo--uu7P2iHZldRS_mugTDx-3FSLlThYFTyp7y8CVQLg2442radddxIuTNcAYgLodgpb4oPFnL6zB9ME6gsBxlhiBRfpEPI-gAjXwzsUyHA","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: REST without PUT and other things...","postDate":"1032037326","msgId":2549,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGFtMDg0ZSttcTdoQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDAwMTYwMWMyNWMyMSQxNGViNWI0MCRhMDAwYThjMEBzZWFpcnRobGFwdG9wPg=="},"prevInTopic":2548,"nextInTopic":2554,"prevInTime":2548,"nextInTime":2550,"topicId":2548,"numMessagesInTopic":6,"msgSnippet":"Searith, There s absolutely no reason to ignore PUT. PUT is very good at what it does and it makes little sense to overload POST to mean update. In fact, I d","rawEmail":"Return-Path: &lt;inthedarkplace@...&gt;\r\nX-Sender: inthedarkplace@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_1_1_3); 14 Sep 2002 21:02:09 -0000\r\nReceived: (qmail 72871 invoked from network); 14 Sep 2002 21:02:09 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m11.grp.scd.yahoo.com with QMQP; 14 Sep 2002 21:02:09 -0000\r\nReceived: from unknown (HELO n2.grp.scd.yahoo.com) (66.218.66.75)\n  by mta2.grp.scd.yahoo.com with SMTP; 14 Sep 2002 21:02:09 -0000\r\nReceived: from [66.218.67.175] by n2.grp.scd.yahoo.com with NNFMP; 14 Sep 2002 21:02:09 -0000\r\nDate: Sat, 14 Sep 2002 21:02:06 -0000\r\nTo: rest-discuss@yahoogroups.com\r\nSubject: Re: REST without PUT and other things...\r\nMessage-ID: &lt;am084e+mq7h@...&gt;\r\nIn-Reply-To: &lt;001601c25c21$14eb5b40$a000a8c0@seairthlaptop&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 7818\r\nX-Mailer: Yahoo Groups Message Poster\r\nFrom: &quot;inthedarkplace&quot; &lt;inthedarkplace@...&gt;\r\nX-Yahoo-Group-Post: member; u=121832671\r\nX-Yahoo-Profile: inthedarkplace\r\n\r\nSearith,\n\nThere&#39;s absolutely no reason to ignore PUT. PUT is very good at what \nit does and it makes little sense to overload POST to mean update. \nIn fact, I&#39;d say using POST to mean UPDATE is a violation of REST \nbecause it suggests that there are user-visible, side-effects to \nsimple updates which 99.9% of the time there are not -- this is why \nPUT is idempotent and POST is not.\n\nFurther, your suggestion to use POST for limited updates isn&#39;t the \noptimal solution 90% of the time. Coarse-grained messaging (which I \nthink is one of the fundamentals of REST) has proven to be more \nscalable and it drastically simplifies the code that both the server \nand the client must deal with. Further it makes all types of things \neasier when you&#39;re dealing with whole resources.\n\nAlso your suggestion that DELETE return 4xx codes doesn&#39;t really \njive with the definition of DELETE. I think Fielding has commented \non this, and also it just makes sense, but DELETE should always \nreturn a 2xx if the server can guarantee that no resource exists at \nthe given URL at the time of request. It&#39;s perfectly fine to DELETE \nsomething that&#39;s already not there and this is partially why DELETE \nis idempotent: whether you DELETE something 1 time or a thousand \ntimes the resource is still not there at the end of the request \nsequence.\n\n- itdp\n\n--- In rest-discuss@y..., &quot;Seairth Jacobs&quot; &lt;seairth@s...&gt; wrote:\n&gt; In a recent post [1], I was asking about performing resource \ncreation with\n&gt; POST only.  My conclusion has been that this is a good thing.  \nWhat&#39;s more,\n&gt; as I was falling asleep last night, additional thoughts occurred \nto me that\n&gt; I now feel the need to share with the list.  Tell me what you \nthink...\n&gt; \n&gt; \n&gt; I contend that PUT does not fit well with the REST model.  First, \nthere is\n&gt; the issue of resource creation.  PUT is allowed to submit a &quot;non-\nexisting&quot;\n&gt; request-URI as if it did exist.  This request-URI has no identity \nwhatsoever\n&gt; (not even with the request-entity that will become the new \nresource).  From\n&gt; my ever-evolving understanding of REST, allowing the usage of URIs \nin this\n&gt; manner is just plain wrong.  I absolutely agree with this \nregardless of\n&gt; REST.  As I recently mentioned [1], I feel that using POST to \ncreate all\n&gt; resources is just as effective and keeps the URI rules simple.\n&gt; \n&gt; Second, there is the issue of resource update.  PUT is designed to \nonly\n&gt; replace an entire resource.  It is not capable of updating only a \npart of\n&gt; the resource.  Not only is this very limited in terms of \nfunctionality, but\n&gt; POST can do the same thing!  So, why have a separate PUT verb when \nPOST\n&gt; would work as well?  I can&#39;t think of a single good reason.\n&gt; \n&gt; Suppose, when working within the REST model, we were to entirely \nignore PUT.\n&gt; When using HTTP, the only verbs that would be recognized would be:\n&gt; \n&gt;     GET : safe, idempotent retrieval of an existing resource\n&gt;     POST: update of existing resource / creation of new resource.\n&gt;     DELETE: deletion of existing resource.\n&gt; \n&gt; GET is a no-brainer here.  We all pretty much agree how it should \nand show\n&gt; not be used.\n&gt; \n&gt; POST is now taking on the responsibility that PUT provided (not \nany more\n&gt; than it does now, really).  To clarify POST &quot;new&quot;\n&gt; responsibilities/capabilities:\n&gt; \n&gt; 1) POST may request the creation of a new resource.  If you want \nPOST to act\n&gt; like PUT, all you need to do is pass the URI that you would like \nto have the\n&gt; new resource located at.  This could be done in the request-\nentity, but I\n&gt; suggest instead using the &quot;Location:&quot; header (yes, I know it&#39;s a \nresponse\n&gt; header in the spec [2:14.30]).  This would allow a POST like the \nfollowing:\n&gt; \n&gt;     POST existing-URI-path\n&gt;     Location: new-URI\n&gt; \n&gt;     &lt;entity&gt;\n&gt; \n&gt; The server would be able to use the request-URI to appropriately \nact upon\n&gt; the request, and it may then choose to honor the requested \nLocation or not\n&gt; just as it would with a PUT&#39;s request-URI. The difference here is \nthat the\n&gt; request-URI must *always* exist, which is not the case for PUT.\n&gt; \n&gt; 2) POST may request that a resource be updated.  This could be \ndone in a\n&gt; couple different ways:\n&gt;     a) The request-URI is a resource responsible for updating other\n&gt; resources, where the resource knows enough context from the \nrequest to\n&gt; update the appropriate resource.  This could include the use of \nthe Location\n&gt; request header as well.\n&gt;     b) The request-URI is the resource that is to be updated.  This\n&gt; particular method is most like PUT.  However, unlike PUT it would \nstill be\n&gt; possible for the resource to be partially updated in this case.\n&gt; \n&gt; \n&gt; \n&gt; DELETE still works like it does now.  However, it should be noted \nthat usage\n&gt; of DELETE doesn&#39;t necessarily delete the actual resource.  It \ndefinitely\n&gt; invalidates the relationship between the request-URI and it&#39;s \ncurrently\n&gt; associated resource (thereby making *appear* as if the resource is \ndeleted\n&gt; to the client), but whether the actual resource goes entirely away \nis up to\n&gt; the server only.  I am of the mind that DELETE should return the \nfollowing:\n&gt; \n&gt; 200,202,204: If the URI was valid and the request is accepted (as \nstated in\n&gt; the spec [2:9.7]).\n&gt; 404: If the URI is invalid and the server does not know if it used \nto point\n&gt; at a resource.\n&gt; 410: If the URI is invalid and the server knows that it used to \npoint at a\n&gt; resource.\n&gt; \n&gt; This does mean that DELETE would not be strictly idempotent, but \nthe client\n&gt; could still act as if it were (i.e. treat all responses as the \nsame as 200).\n&gt; \n&gt; \n&gt; \n&gt; Part of the reason for suggesting that PUT should be depricated \nwhen working\n&gt; in the REST model is due to the REST model itself.  REST \nspecifically talks\n&gt; of simple, uniform interfaces.  As is evident from threads on this \nlist,\n&gt; having both a PUT and a POST is not a simple, uniform interface.  \nAs I see\n&gt; it, within the context of REST, POST is necessary, while PUT is \noptional.\n&gt; Getting rid of PUT provides a simple, uniform interface as REST \nmentions.\n&gt; \n&gt; An objection that I have seen in recent posts that will \nundoubtedly be\n&gt; brought back up due to my usage of POST above is the ability to \nPOST an\n&gt; update to the resource directly.  To some, this may be considered a\n&gt; violation of the proper use of POST, where the request-entity is \nconsidered\n&gt; to be subordinate to the resource.  To me, I see no conflict \nhere.  Take the\n&gt; directory-file example mentioned in the spec [2:9.5].  If you were \nto POST a\n&gt; &quot;file&quot; to a &quot;directory&quot;, this would also update the directory \nitself (since\n&gt; the file is part of the directory resource).  Any resource update \ncould be\n&gt; viewed within the same light (update of a subordinate is update of \nitself as\n&gt; well).  And I don&#39;t see anything in the HTTP spec that says a \nsubordinate\n&gt; must be accessible independently of the parent resource.\n&gt; \n&gt; Also, some (or maybe all) of you may be disagreeing with my usage \nof\n&gt; &quot;Location&quot; above.  However, this makes perfect sense to me.  Usage \nof\n&gt; Location in a POST request allows all of the functionality of PUT \nwithout\n&gt; having to embed any additional data in the request-entity itself.  \nFurther,\n&gt; by use Location instead of the request-URI to indicate a new URI, \nwe ensure\n&gt; that only existing URIs may be used for a request-URI.  This also \nadresses\n&gt; the ability for a client to be able to construct URIs.  A client \ncould\n&gt; construct a new string that will become a URI and place it in the \nLocation\n&gt; header.  The server could then act on it independent of the actual\n&gt; request-URI.  Therefore, the request-URI still stays opaque \nwithout losing\n&gt; any capabilities from the client&#39;s POV.\n&gt; \n&gt; \n&gt; [1] http://groups.yahoo.com/group/rest-discuss/message/2543\n&gt; [2] http://www.ietf.org/rfc/rfc2616.txt\n&gt; \n&gt; \n&gt; ---\n&gt; Seairth Jacobs\n&gt; seairth@s...\n\n\n"}}