{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":284728248,"authorName":"Scott Mohekey","from":"Scott Mohekey &lt;scott.mohekey@...&gt;","profile":"scottmohekey","replyTo":"SENDER","senderId":"zK6Hyv42WuzKfjvzjt_joJwoJnKxtqWqMmLHwV13X0DMUJMf2Vv7cA-ltWH4oQxzlIhlP9S40U9wH4f-jyHjaVcNSphqqQKdTx_kYSkBQqE","spamInfo":{"isSpam":false,"reason":"3"},"subject":"Re: [rest-discuss] http accept header","postDate":"1161118643","msgId":6669,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDExNjExMTg2NDMuODM5NS4zOTU1LmNhbWVsQGZlZG9yYT4=","inReplyToHeader":"PGVoMjc1Nys3MGVqQGVHcm91cHMuY29tPg==","referencesHeader":"PGVoMjc1Nys3MGVqQGVHcm91cHMuY29tPg=="},"prevInTopic":6668,"nextInTopic":6670,"prevInTime":6668,"nextInTime":6670,"topicId":6668,"numMessagesInTopic":12,"msgSnippet":"I ve recently written code to handle exactly this in the restian framework I m working on for .net. I m going to cut n paste the code in question below, and","rawEmail":"Return-Path: &lt;scott.mohekey@...&gt;\r\nX-Sender: scott.mohekey@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 74297 invoked from network); 17 Oct 2006 20:57:29 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m33.grp.scd.yahoo.com with QMQP; 17 Oct 2006 20:57:29 -0000\r\nReceived: from unknown (HELO nz.telogis.com) (203.98.10.169)\n  by mta2.grp.scd.yahoo.com with SMTP; 17 Oct 2006 20:57:29 -0000\r\nReceived: from 192.168.3.91 ([::ffff:192.168.3.91])\n  by nz.telogis.com with esmtp; Wed, 18 Oct 2006 09:57:23 +1300\n  id 00765DD1.453543B4.00000598\r\nTo: keith_peters &lt;keithpeters.26592230@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nIn-Reply-To: &lt;eh2757+70ej@...&gt;\r\nReferences: &lt;eh2757+70ej@...&gt;\r\nDate: Wed, 18 Oct 2006 09:57:23 +1300\r\nMessage-Id: &lt;1161118643.8395.3955.camel@fedora&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nX-Mailer: Evolution 2.6.3 (2.6.3-1.fc5.5) \r\nX-eGroups-Msg-Info: 2:3:4:0\r\nFrom: Scott Mohekey &lt;scott.mohekey@...&gt;\r\nSubject: Re: [rest-discuss] http accept header\r\nX-Yahoo-Group-Post: member; u=284728248; y=Hq0fxHG4AEgBoPq_uQ04lb-2c0G2SJGh-DLy0qicijTAvyzSodXQ\r\nX-Yahoo-Profile: scottmohekey\r\n\r\nI&#39;ve recently written code to handle exactly this in the restian\nframework I&#39;m working on for .net.\n\nI&#39;m going to cut n paste the code in question below, and then you can\nask any questions that may crop up.\n\nclass AcceptType {\n\tpublic AcceptType(double quality, string mimeType) {\n\t\tQuality = quality;\n\t\tMimeType = mimeType;\n\t}\n\n\tpublic double Quality;\n\tpublic string MimeType;\n\n\tpublic static int Compare(AcceptType type1, AcceptType type2) {\n\t\treturn type1.Quality.CompareTo(type2.Quality);\n\t}\n}\n\nprotected void SerializeResponse(GeorgeContext context) {\n\tHttpContext httpContext = HttpContext.Current;\n\t// If the request header Accept does not contain a mime type that we know how \n\t// to serialize to, we return a 406 (Not Acceptable).\n\n\tstring acceptHeader = null;\n\n\tif (httpContext.Request.Headers[&quot;Accept&quot;] == null || httpContext.Request.Headers[&quot;Accept&quot;] == &quot;&quot;) {\n\t\tacceptHeader = &quot;*/*&quot;;\n\t} else {\n\t\tacceptHeader = httpContext.Request.Headers[&quot;Accept&quot;];\n\t}\n\n\tstring[] accepted = acceptHeader.Split(&#39;,&#39;);\n\n\tList&lt;AcceptType&gt; types = new List&lt;AcceptType&gt;();\n\n\tforeach (string accept in accepted) {\n\t\tstring[] parts = accept.Split(&#39;;&#39;);\n\n\t\tstring mimeType = parts[0].Trim();\n\t\tdouble q = 1.0;\n\n\t\tfor (int i = 1; i &lt; parts.Length; i++) {\n\t\t\tif (parts[i].Trim().StartsWith(&quot;q&quot;)) {\n\t\t\t\tstring[] keyValue = parts[i].Trim().Split(&#39;=&#39;);\n\n\t\t\t\tq = double.Parse(keyValue[1].Trim());\n\t\t\t}\n\t\t}\n\n\t\ttypes.Add(new AcceptType(q, mimeType));\n\t}\n\n\ttypes.Sort(new Comparison&lt;AcceptType&gt;(AcceptType.Compare));\n\n\tforeach (AcceptType acceptType in types) {\n\t\tbool def = false;\n\n\t\tif (0 == acceptType.MimeType.CompareTo(&quot;*/*&quot;)) {\n\t\t\tdef = true;\n\t\t}\n\n\t\tforeach (IContentType contentType in ContentTypes) {\n\t\t\tif (contentType.Supports(context.Response.GetType()) && (def || (contentType.Provides(acceptType.MimeType)))) {\n\t\t\t\thttpContext.Response.ContentType = def ? contentType.Name : acceptType.MimeType;\n\t\t\t\thttpContext.Response.AppendHeader(&quot;Last-Modified&quot;, DateTime.UtcNow.ToLongDateString());\n\t\t\t\tcontentType.Serialize(context, httpContext.Response.OutputStream);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new HttpException(406, &quot;Unable to provide resource for requested media types.&quot;);\n}\n\n\n\nEssentially, I parse all of the accept types, sort them by q, and then\niterate over available content types, until a suitable one is found.\n\nSo the order of preference for accept types is governed by the order in\nwhich the content types are configured (not shown in the code above).\n\n\n\nOn Tue, 2006-10-17 at 09:18 +0000, keith_peters wrote:\n&gt; I am writing a web application. I want to leave the door open to add\n&gt; alternate representations of the resources in my app. To do this, I\n&gt; need to write something that selects the mime type of the response\n&gt; from the accept header of the request.\n&gt; \n&gt; My question is which mime type should be selected when more than one\n&gt; has the same quality value (i.e. q=1)? For example, below is the\n&gt; accept header of a get request from a firefox browser to the messages\n&gt; of this group\n&gt; (http://tech.groups.yahoo.com/group/rest-discuss/messages):\n&gt; \n&gt; Accept:\n&gt; text/xml,\n&gt; application/xml,\n&gt; application/xhtml+xml,\n&gt; text/html;q=0.9,\n&gt; text/plain;q=0.8,\n&gt; image/png,\n&gt; */*;q=0.5\n&gt; \n&gt; The mime types text/xml, application/xml, application/xhtml+xml and\n&gt; image/png all have the same quality. Assuming the server has both\n&gt; text/xml and application/xhtml+xml representations available. Which\n&gt; one should be selected as the mime type of the response? If I take the\n&gt; order of appearance into account (the spec doesn&#39;t mention anything\n&gt; about this), then it will be text/xml but TBH a request coming from a\n&gt; browser should really receive a application/xhtml+xml response if it\n&gt; requested it?\n&gt; \n&gt; Of course, the best solution is that the browser send a better accept\n&gt; header; one would think it would prefer xhtml, html and xml in that\n&gt; order. Pointless crying over spilt milk though.\n&gt; \n&gt; Any info, advice or otherwise would be greatly appreciated.\n&gt; Thanks, Keith.\n&gt; \n&gt; \n&gt; \n&gt; \n&gt;  \n\n\n"}}