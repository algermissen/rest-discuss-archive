{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"euJKOk6Dj_RfN8D-QFhbkOzxfZf4H9Fl0n4EyqIK1GMioneEi2TLxegJ0So4aWWUWMawmW51qGToJ0wbihho3_zWYSjJFXRNiLEo2OeBvA","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Atom feed vs. list of orders","postDate":"1281435606","msgId":16252,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwODEwMDQyMDA2LjI3NjJiNTAxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDRENTFBMENCLUQ3MkMtNENGRC1BNUFDLTg4N0IzRkJGNjA3MUBtYWMuY29tPg==","referencesHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPgk8RjE5NjI2NDZEM0I2NDY0MkI3QzlBMDYwNjhFRTFFNjQwRTE0Mzg1N0BleDEwLmhvc3RlZGV4Y2hhbmdlLmxvY2FsPgk8RUE2MDczMkMtM0IwMC00NUQ0LThGRDgtMDJFQjFCMjE0NEY1QG1hYy5jb20+CTxGMTk2MjY0NkQzQjY0NjQyQjdDOUEwNjA2OEVFMUU2NDBFMTQzQjExQGV4MTAuaG9zdGVkZXhjaGFuZ2UubG9jYWw+CTxCRTNEODY1OS1CNzYyLTQ3NTktQkM4Qy0xM0I0REE5ODVDNUZAbWFjLmNvbT4JPEFBTkxrVGk9K0x6bk9DdFhma0xVek9CLWFCOEVPWkRyYXNiMzdtV0ItUFd2QkBtYWlsLmdtYWlsLmNvbT4JPDAxMzIzQkEzLTIwNzgtNEM3NS1BRTFCLThEMTg4NUU2NUIwOEBtYWMuY29tPgk8QUFOTGtUaW5OTzNqS3Y4Nj1xPWRtOGVtcVEweFJyaGtUOVBQbmNfN1NkXzgyQG1haWwuZ21haWwuY29tPgk8MzE3RjlBMzQtMUI3QS00QTAxLTkwNjYtRjY5QTZBQjU4ODhDQG1hYy5jb20+CTwyMDEwMDgwNzE3MDQzNC40NGI3ZWVmOC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbjlzRldQQ2ItRUxDU1dOZHRyeTl4dnNpVTRpY0hWV1d6Y1pMb0FAbWFpbC5nbWFpbC5jb20+CTwyMDEwMDgwOTE4MjA0Mi5iMzk0NTI1Yy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxBQU5Ma1RpbTBPWi09VnN2ejU0OWJabS1vY3dvbnVBWWtlaWU4R3N3RjdZVDNAbWFpbC5nbWFpbC5jb20+CTw0RDUxQTBDQi1ENzJDLTRDRkQtQTVBQy04ODdCM0ZCRjYwNzFAbWFjLmNvbT4="},"prevInTopic":16251,"nextInTopic":16253,"prevInTime":16251,"nextInTime":16253,"topicId":16194,"numMessagesInTopic":86,"msgSnippet":"... What do you mean by service-specific?  Domain-sepcific vocabulary embedded in metadata is not some sort of design flaw.  Google and others understand","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 68119 invoked from network); 10 Aug 2010 10:20:16 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m8.grp.sp2.yahoo.com with QMQP; 10 Aug 2010 10:20:16 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 10 Aug 2010 10:20:16 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 508F5509DA;\n\tTue, 10 Aug 2010 06:20:15 -0400 (EDT)\r\nDate: Tue, 10 Aug 2010 04:20:06 -0600\r\nTo: Jan Algermissen &lt;algermissen1971@...&gt;\r\nCc: Peter Williams &lt;pezra@...&gt;, Rest List\n &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100810042006.2762b501.eric@...&gt;\r\nIn-Reply-To: &lt;4D51A0CB-D72C-4CFD-A5AC-887B3FBF6071@...&gt;\r\nReferences: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143857@...&gt;\n\t&lt;EA60732C-3B00-45D4-8FD8-02EB1B2144F5@...&gt;\n\t&lt;F1962646D3B64642B7C9A06068EE1E640E143B11@...&gt;\n\t&lt;BE3D8659-B762-4759-BC8C-13B4DA985C5F@...&gt;\n\t&lt;AANLkTi=+LznOCtXfkLUzOB-aB8EOZDrasb37mWB-PWvB@...&gt;\n\t&lt;01323BA3-2078-4C75-AE1B-8D1885E65B08@...&gt;\n\t&lt;AANLkTinNO3jKv86=q=dm8emqQ0xRrhkT9PPnc_7Sd_82@...&gt;\n\t&lt;317F9A34-1B7A-4A01-9066-F69A6AB5888C@...&gt;\n\t&lt;20100807170434.44b7eef8.eric@...&gt;\n\t&lt;AANLkTin9sFWPCb-ELCSWNdtry9xvsiU4icHVWWzcZLoA@...&gt;\n\t&lt;20100809182042.b394525c.eric@...&gt;\n\t&lt;AANLkTim0OZ-=Vsvz549bZm-ocwonuAYkeie8GswF7YT3@...&gt;\n\t&lt;4D51A0CB-D72C-4CFD-A5AC-887B3FBF6071@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Atom feed vs. list of orders\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nJan Algermissen wrote:\n&gt; \n&gt; &gt; My point is that is that html+gd is a much an application specific\n&gt; &gt; media type as a custom xml format.  Not giving it a name does not\n&gt; &gt; change that fact.  Once the server adds gd annotations, and clients\n&gt; &gt; started depending on them, the representations become application\n&gt; &gt; specific.\n&gt; \n&gt; Even worse: they become service specific and the client\n&gt; implementation couples itself to an (un-guarantee) particularity of\n&gt; that service. This is not different than having a service specific\n&gt; API in the first place.\n&gt; \n\nWhat do you mean by service-specific?  Domain-sepcific vocabulary\nembedded in metadata is not some sort of design flaw.  Google and\nothers understand GoodRelations.  Any service implementing GR has\nprovided a machine-readable API that Google interacts with.  These\nservices are in no way required to resemble one another.  So what do\nyou mean by coupling?  Agreeing to a domain-specific vocabulary\nimplemented using standard media types, is exactly what is meant by\ndecoupling.\n\n&gt;\n&gt; Actually, IMHO it is even worse than RPC in the long run because in\n&gt; the RPC-case there is usually an IDL defining the promissed service\n&gt; interface. In the case of extended HTML the client simply hoping for\n&gt; the format not to change. \n&gt; \n\nBut this is not an argument against what I say is REST.  REST has no\nnotion of these &quot;contracts&quot; you speak of, beyond an agreement to what a\nmedia type means.  IMHO, such IDLs are exactly what&#39;s meant by coupling.\nI don&#39;t understand why the question is always asked, &quot;What happens if\nthe interface changes?&quot;  Well, things may or may not break, but even if\nthey do, that&#39;s not within REST&#39;s scope, so pointing out that\nrepresentations change over time is also not an argument against what I\nsay is REST.\n\n&gt;\n&gt; I think it is a maintenance nightmare because the server owner won&#39;t\n&gt; have any idea what the client is actually hoping for.\n&gt;\n\nWhy should the server owner care?  If BestBuy changes from GR to\nsomething else, then Google can no longer identify items and prices,\nuntil Google implements the new ontology, at which point the client and\nserver again agree on implementations, and again the system works.\nThere is no requirement for the server owner to care, this notion of\n&quot;contracts&quot; on such things has nothing to do with REST.\n\n&gt; \n&gt; What I simply do not understand: If the service provider would take\n&gt; the design phase just a bit further and look a bit beyond the single\n&gt; one service it is about to implement the situation would be far\n&gt; better. The servic eprovider could make the extensions valuable\n&gt; beyond the single service, give the specification a name and hence\n&gt; mint a new media type (or a least a documented profile that can be\n&gt; used in conneg).\n&gt; \n&gt; What is the reason for this ubiquitous obsession of not standardizing\n&gt; extensions of hypermedia formats? (Standardizing meaning: making in\n&gt; applicable beyond the single service and documenting it outside the\n&gt; realm of the single service).\n&gt; \n\nOr asked another way, what is the obsession against embedding domain-\nspecific vocabulary within ubiquitous media types?  Domain-specific\nvocabularies don&#39;t need to be exposed at the protocol layer.  So why\nfragment the understanding of ubiquitous media types, by denying the\npossibility of defining any number of domain-specific vocabularies\nwithin a well-known hypertext container format?  (And by that, no, I\ndon&#39;t just mean HTML, stop making me bend over backwards to say that\nevery time I write hypertext please, folks...)\n\n&gt; \n&gt; &gt; I am not oppose to domain specific representations so this does not\n&gt; &gt; really bother me.  My concern is that a client that needs html+gd,\n&gt; &gt; but asks for html is a lot less likely to get what it needs than a\n&gt; &gt; client that explicitly requests what it needs.\n&gt; \n&gt; Exactly! And from the POV of change impact analysis on the server\n&gt; side it is horrible because the server developer needs to know all\n&gt; this additional stuff when working on the resource implementation for\n&gt; text/html.\n&gt; \n\nWhat REST constraint is violated, if a service changes to a media type\nthat causes user agents that used to work with it, not to any more?\nWhat I see as having to learn a bunch of additional stuff, is having to\nlearn a new media type as opposed to just learning a new domain-specific\nvocabulary within markup elements and attributes I&#39;m already familiar\nwith.  Especially if avoiding ubiquitous types has led to the re-\ninvention of common hypertext controls.\n\n\n&gt; \n&gt; &gt;&gt;  REST has nothing to do\n&gt; &gt;&gt; with negotiating between versions of an API.\n&gt; &gt; \n&gt; &gt; Sure it does.  The accept header allows the negotiation of API\n&gt; &gt; versions.  Consider `accept: text/html` vs `accept:\n&gt; &gt; application/atom+xml`.  One says the client wants to interact with\n&gt; &gt; the html version of the api, the other says the client wants to\n&gt; &gt; interact with the atom version of the api.\n&gt; \n&gt; Yes, exactly. Or consider:\n&gt; \n&gt; Accept: application/atom+xml  vs.  Accept: application/atom-v2+xml\n&gt; \n\nThat would tell me that you&#39;re requesting version 1 of Atom or version\n2 of Atom, not version 1 vs. version 2 of an API.  There is no need in\nREST to version APIs, or parameterize version information in media\ntypes.  The world tried this approach, but it lost out, proof of this\nis that HTML 5 is still text/html, not &#39;text/html; version=5&#39;.  If\nthere is an Atom 2, it would still be application/atom+xml, in keeping\nwith the REST style as instantiated on the Web.\n\n&gt; \n&gt; &gt; \n&gt; &gt;&gt; Referring once again to REST:\n&gt; &gt;&gt; \n&gt; &gt;&gt; &quot;The trade-off, though, is that a uniform interface degrades\n&gt; &gt;&gt; efficiency, since information is transferred in a standardized form\n&gt; &gt;&gt; rather than one which is specific to an application&#39;s needs.&quot;\n&gt; &gt; \n&gt; &gt; I don&#39;t get what you seem to get that from this quote.  Later in the\n&gt; &gt; same section we get this paragraph.\n&gt; &gt; \n&gt; &gt;   In order to obtain a uniform interface, multiple architectural\n&gt; &gt;   constraints are needed to guide the behavior of components. REST\n&gt; &gt; is defined by four interface constraints: identification of\n&gt; &gt; resources; manipulation of resources through representations;\n&gt; &gt; self-descriptive messages; and, hypermedia as the engine of\n&gt; &gt; application state.\n&gt; &gt; \n&gt; &gt; No where does that suggest there is some limit to the allowable\n&gt; &gt; number of representation flavors.\n&gt; \n&gt; Right. Roy refers to the fact that general-purpose payloads are\n&gt; naturally less efficient (in terms payload size) than payloads\n&gt; designed specifically for a single service.\n&gt; \n\nAnd by implication, more uniform.  The goal of a REST system is to\nbecome more uniform, at the tradeoff of efficiency, for the purposes of\nscaling and serendipitous re-use, in keeping with the principle of\ngenerality.\n\n&gt; \n&gt; &gt; Your reading of the uniform interface seems different than much of\n&gt; &gt; the community.\n&gt; &gt; \n&gt; &gt; RestWiki is pretty quiet on the idea of limiting media types being\n&gt; &gt; part of the uniform interface in both the interface genericity&#39;s[1]\n&gt; &gt; and rest in plain english[2] pages.  Both seem to imply that domain\n&gt; &gt; specific media types would be ok.\n&gt; \n&gt; Yes, of course they are ok. They are the *essence* of building\n&gt; RESTful systems beyond the existing human HTML and Feeds Web.\n&gt; \n\nI disagree vehemently.  Myriad diverse systems have been built using\nubiquitous media types.  These media types are capable of embedding\nmachine-readable, domain-specific vocabularies.  Ubiquitous media types\ndoes not mean HTML.  How many times must I mention telephony systems\nwith hypertext REST APIs that have nothing to do with HTML or browsers?\n\nUnless you have such a compelling use case for not using HTML, and no\nother ubiquitous type exists for your problem, then g&#39;head.  But, 999\ntimes out of 1,000 the nature of the system is not such a unique\nsnowflake that HTML + RDFa need to be dismissed out-of-hand.  There is\nsimply no reason that m2m can&#39;t be done this way, as proven by the m2m\ninteraction via HTML + RDFa that&#39;s happening more and more each day now\nthat GR is proliferating.\n\nHTML is capable of *accessibly* describing the hypertext controls of\nalmost any conceivable REST API.  It&#39;s well understood, and easily\nmaintainable (if well-written, but that goes for anything) because it\nis both human and machine readable.  Such a hypertext API can wrap any\nnumber of back-end formats and systems, RESTful or not, and make a REST\nsystem out of it.  999 out of 1,000 custom media types think they&#39;re\nproviding a hypertext API, but aren&#39;t really meeting the hypertext\nconstraint at all.\n\n-Eric\n\n"}}