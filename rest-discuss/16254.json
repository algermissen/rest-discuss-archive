{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":289191104,"authorName":"Jan Algermissen","from":"Jan Algermissen &lt;algermissen1971@...&gt;","profile":"algermissen1971","replyTo":"SENDER","senderId":"p55QFYPeic7BZ8wjOFKzMDnVhDHvbJO-0hViBLbLooEYebDfAWfWakp3o7nOut0TiWuPkpEAder3Hy7PFm-a-10rVv2QeJ5vWFW2twe1QNs","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Atom feed vs. list of orders","postDate":"1281438530","msgId":16254,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PERDQzA5QjA2LTNDNzMtNDMxOS05NzVDLTNENENDODEzQzc1QkBtYWMuY29tPg==","inReplyToHeader":"PDIwMTAwODEwMDQyMDA2LjI3NjJiNTAxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PEUyQjIwMjIyLUU1MTEtNEFCOC1BMkNFLUEyMUM4MTVFOTI1NEBtYWMuY29tPiA8RjE5NjI2NDZEM0I2NDY0MkI3QzlBMDYwNjhFRTFFNjQwRTE0Mzg1N0BleDEwLmhvc3RlZGV4Y2hhbmdlLmxvY2FsPiA8RUE2MDczMkMtM0IwMC00NUQ0LThGRDgtMDJFQjFCMjE0NEY1QG1hYy5jb20+IDxGMTk2MjY0NkQzQjY0NjQyQjdDOUEwNjA2OEVFMUU2NDBFMTQzQjExQGV4MTAuaG9zdGVkZXhjaGFuZ2UubG9jYWw+IDxCRTNEODY1OS1CNzYyLTQ3NTktQkM4Qy0xM0I0REE5ODVDNUZAbWFjLmNvbT4gPEFBTkxrVGk9K0x6bk9DdFhma0xVek9CLWFCOEVPWkRyYXNiMzdtV0ItUFd2QkBtYWlsLmdtYWlsLmNvbT4gPDAxMzIzQkEzLTIwNzgtNEM3NS1BRTFCLThEMTg4NUU2NUIwOEBtYWMuY29tPiA8QUFOTGtUaW5OTzNqS3Y4Nj1xPWRtOGVtcVEweFJyaGtUOVBQbmNfN1NkXzgyQG1haWwuZ21haWwuY29tPiA8MzE3RjlBMzQtMUI3QS00QTAxLTkwNjYtRjY5QTZBQjU4ODhDQG1hYy5jb20+IDwyMDEwMDgwNzE3MDQzNC40NGI3ZWVmOC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+IDxBQU5Ma1RpbjlzRldQQ2ItRUxDU1dOZHRyeTl4dnNpVTRpY0hWV1d6Y1pMb0FAbWFpbC5nbWFpbC5jb20+IDwyMDEwMDgwOTE4MjA0Mi5iMzk0NTI1Yy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+IDxBQU5Ma1RpbTBPWi09VnN2ejU0OWJabS1vY3dvbnVBWWtlaWU4R3N3RjdZVDNAbWFpbC5nbWFpbC5jb20+IDw0RDUxQTBDQi1ENzJDLTRDRkQtQTVBQy04ODdCM0ZCRjYwNzFAbWFjLmNvbT4gPDIwMTAwODEwMDQyMDA2LjI3NjJiNTAxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":16253,"nextInTopic":16255,"prevInTime":16253,"nextInTime":16255,"topicId":16194,"numMessagesInTopic":86,"msgSnippet":"... Specific to a service. Not orthogonal to the service. HTML is orthogonal to Amazon. Amazon s HTML style attributes are specifc to Amazon. ... How would the","rawEmail":"Return-Path: &lt;algermissen1971@...&gt;\r\nX-Sender: algermissen1971@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 78658 invoked from network); 10 Aug 2010 11:09:14 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m17.grp.re1.yahoo.com with QMQP; 10 Aug 2010 11:09:14 -0000\r\nX-Received: from unknown (HELO asmtpout023.mac.com) (17.148.16.98)\n  by mta3.grp.re1.yahoo.com with SMTP; 10 Aug 2010 11:09:13 -0000\r\nMIME-version: 1.0\r\nContent-transfer-encoding: 7BIT\r\nContent-type: text/plain; charset=us-ascii\r\nX-Received: from [192.168.2.105] ([84.143.191.9])\n by asmtp023.mac.com (Sun Java(tm) System Messaging Server 6.3-8.01 (built Dec\n 16 2008; 32bit)) with ESMTPSA id &lt;0L6X00CH0OARS090@...&gt; for\n rest-discuss@yahoogroups.com; Tue, 10 Aug 2010 04:08:57 -0700 (PDT)\r\nX-Proofpoint-Spam-Details: rule=notspam policy=default score=0 spamscore=0\n ipscore=0 phishscore=0 bulkscore=0 adultscore=0 classifier=spam adjust=0\n reason=mlx engine=6.0.2-1004200000 definitions=main-1008100050\r\nX-Proofpoint-Virus-Version: vendor=fsecure\n engine=2.50.10432:5.0.10011,1.0.148,0.0.0000\n definitions=2010-08-10_04:2010-08-10,2010-08-10,1970-01-01 signatures=0\r\nIn-reply-to: &lt;20100810042006.2762b501.eric@...&gt;\r\nDate: Tue, 10 Aug 2010 13:08:50 +0200\r\nCc: Peter Williams &lt;pezra@...&gt;,\n Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-id: &lt;DCC09B06-3C73-4319-975C-3D4CC813C75B@...&gt;\r\nReferences: &lt;E2B20222-E511-4AB8-A2CE-A21C815E9254@...&gt;\n &lt;F1962646D3B64642B7C9A06068EE1E640E143857@...&gt;\n &lt;EA60732C-3B00-45D4-8FD8-02EB1B2144F5@...&gt;\n &lt;F1962646D3B64642B7C9A06068EE1E640E143B11@...&gt;\n &lt;BE3D8659-B762-4759-BC8C-13B4DA985C5F@...&gt;\n &lt;AANLkTi=+LznOCtXfkLUzOB-aB8EOZDrasb37mWB-PWvB@...&gt;\n &lt;01323BA3-2078-4C75-AE1B-8D1885E65B08@...&gt;\n &lt;AANLkTinNO3jKv86=q=dm8emqQ0xRrhkT9PPnc_7Sd_82@...&gt;\n &lt;317F9A34-1B7A-4A01-9066-F69A6AB5888C@...&gt;\n &lt;20100807170434.44b7eef8.eric@...&gt;\n &lt;AANLkTin9sFWPCb-ELCSWNdtry9xvsiU4icHVWWzcZLoA@...&gt;\n &lt;20100809182042.b394525c.eric@...&gt;\n &lt;AANLkTim0OZ-=Vsvz549bZm-ocwonuAYkeie8GswF7YT3@...&gt;\n &lt;4D51A0CB-D72C-4CFD-A5AC-887B3FBF6071@...&gt;\n &lt;20100810042006.2762b501.eric@...&gt;\r\nTo: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nX-Mailer: Apple Mail (2.1081)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jan Algermissen &lt;algermissen1971@...&gt;\r\nSubject: Re: [rest-discuss] Atom feed vs. list of orders\r\nX-Yahoo-Group-Post: member; u=289191104; y=uDRItBhu1Yau1tqNUOiHQgWXdKVy6_Rb40ougfiS5GZqNHfukyJd1kwP\r\nX-Yahoo-Profile: algermissen1971\r\n\r\n\nOn Aug 10, 2010, at 12:20 PM, Eric J. Bowman wrote:\n\n&gt; Jan Algermissen wrote:\n&gt;&gt; \n&gt;&gt;&gt; My point is that is that html+gd is a much an application specific\n&gt;&gt;&gt; media type as a custom xml format.  Not giving it a name does not\n&gt;&gt;&gt; change that fact.  Once the server adds gd annotations, and clients\n&gt;&gt;&gt; started depending on them, the representations become application\n&gt;&gt;&gt; specific.\n&gt;&gt; \n&gt;&gt; Even worse: they become service specific and the client\n&gt;&gt; implementation couples itself to an (un-guarantee) particularity of\n&gt;&gt; that service. This is not different than having a service specific\n&gt;&gt; API in the first place.\n&gt;&gt; \n&gt; \n&gt; What do you mean by service-specific?  \n\nSpecific to a service. Not orthogonal to the service. HTML is orthogonal to Amazon. Amazon&#39;s HTML style attributes are specifc to Amazon.\n\n\n&gt; Domain-sepcific vocabulary\n&gt; embedded in metadata is not some sort of design flaw.  Google and\n&gt; others understand GoodRelations.\n\nHow would the server know that a user agent depends on it to fullfil its implemented goal?\n\nIf the user agent does not *depend* on GoodRelations then Acept: text/html is just fine. But if it *needs* the embedded stuff to work properly, Accept text/html is not. .. and there is a hidden contract that will eventualy break.\n\n&gt;  Any service implementing GR has\n&gt; provided a machine-readable API that Google interacts with.  These\n&gt; services are in no way required to resemble one another.  So what do\n&gt; you mean by coupling?  Agreeing to a domain-specific vocabulary\n&gt; implemented using standard media types, is exactly what is meant by\n&gt; decoupling.\n\nRight. And HTML + GoodRelations is not such a standardized media type, eh?\n\n&gt; \n&gt;&gt; \n&gt;&gt; Actually, IMHO it is even worse than RPC in the long run because in\n&gt;&gt; the RPC-case there is usually an IDL defining the promissed service\n&gt;&gt; interface. In the case of extended HTML the client simply hoping for\n&gt;&gt; the format not to change. \n&gt;&gt; \n&gt; \n&gt; But this is not an argument against what I say is REST.  REST has no\n&gt; notion of these &quot;contracts&quot; you speak of, beyond an agreement to what a\n&gt; media type means.  IMHO, such IDLs are exactly what&#39;s meant by coupling.\n&gt; I don&#39;t understand why the question is always asked, &quot;What happens if\n&gt; the interface changes?&quot;  Well, things may or may not break, but even if\n&gt; they do, that&#39;s not within REST&#39;s scope, so pointing out that\n&gt; representations change over time is also not an argument against what I\n&gt; say is REST.\n&gt; \n&gt;&gt; \n&gt;&gt; I think it is a maintenance nightmare because the server owner won&#39;t\n&gt;&gt; have any idea what the client is actually hoping for.\n&gt;&gt; \n&gt; \n&gt; Why should the server owner care?  If BestBuy changes from GR to\n&gt; something else, then Google can no longer identify items and prices,\n&gt; until Google implements the new ontology,\n\nSo then, why do we need HTM in the fisrt place? If this works so smoothly, why not just have Amazon send application/xml? Amazon would send a certain kind of XML, ya now: &lt;html&gt;&lt;title&gt;...&lt;/title&gt; ... &lt;/html&gt; and Google and browser implementors would just implement that. Then, if Amazon changes from that syntax to some other one, Google and our browsers can no longer work with the XML. Your train of thought implies that that is also just fine because once Google and the browsers follow the new stuff, everyone is happy again.\n\nSo - why do we need text/html as a media type?\n\n(Hint: because browsers (and Google) depend on it implementation-wise. They do not work with any application/xml. That is why they say: I &#39;Accept: text/html, application/xhtml+xml&#39; and as long as you send me something that conforms to one of those types I *can* carry out the implemented goal for the response to *this* request.)\n\nTo stress the point again: if the user agent&#39;s implementation of a certain user goal *depends* on a certain format of representation that must be expressed in the Accept header. If a user agent is implemented to wake up every hour and check the prices of items on various shoppping sites it has far more specific needs than a generic agent that displays a [Next] button if it encounters a next link or displays an [edit] button if it encounters an AtomPub edit link. The former fails to perform the goal, the latter does not.\n\nJan\n\n\n&gt; at which point the client and\n&gt; server again agree on implementations, and again the system works.\n&gt; There is no requirement for the server owner to care, this notion of\n&gt; &quot;contracts&quot; on such things has nothing to do with REST.\n&gt; \n&gt;&gt; \n&gt;&gt; What I simply do not understand: If the service provider would take\n&gt;&gt; the design phase just a bit further and look a bit beyond the single\n&gt;&gt; one service it is about to implement the situation would be far\n&gt;&gt; better. The servic eprovider could make the extensions valuable\n&gt;&gt; beyond the single service, give the specification a name and hence\n&gt;&gt; mint a new media type (or a least a documented profile that can be\n&gt;&gt; used in conneg).\n&gt;&gt; \n&gt;&gt; What is the reason for this ubiquitous obsession of not standardizing\n&gt;&gt; extensions of hypermedia formats? (Standardizing meaning: making in\n&gt;&gt; applicable beyond the single service and documenting it outside the\n&gt;&gt; realm of the single service).\n&gt;&gt; \n&gt; \n&gt; Or asked another way, what is the obsession against embedding domain-\n&gt; specific vocabulary within ubiquitous media types?  Domain-specific\n&gt; vocabularies don&#39;t need to be exposed at the protocol layer.  So why\n&gt; fragment the understanding of ubiquitous media types, by denying the\n&gt; possibility of defining any number of domain-specific vocabularies\n&gt; within a well-known hypertext container format?  (And by that, no, I\n&gt; don&#39;t just mean HTML, stop making me bend over backwards to say that\n&gt; every time I write hypertext please, folks...)\n&gt; \n&gt;&gt; \n&gt;&gt;&gt; I am not oppose to domain specific representations so this does not\n&gt;&gt;&gt; really bother me.  My concern is that a client that needs html+gd,\n&gt;&gt;&gt; but asks for html is a lot less likely to get what it needs than a\n&gt;&gt;&gt; client that explicitly requests what it needs.\n&gt;&gt; \n&gt;&gt; Exactly! And from the POV of change impact analysis on the server\n&gt;&gt; side it is horrible because the server developer needs to know all\n&gt;&gt; this additional stuff when working on the resource implementation for\n&gt;&gt; text/html.\n&gt;&gt; \n&gt; \n&gt; What REST constraint is violated, if a service changes to a media type\n&gt; that causes user agents that used to work with it, not to any more?\n&gt; What I see as having to learn a bunch of additional stuff, is having to\n&gt; learn a new media type as opposed to just learning a new domain-specific\n&gt; vocabulary within markup elements and attributes I&#39;m already familiar\n&gt; with.  Especially if avoiding ubiquitous types has led to the re-\n&gt; invention of common hypertext controls.\n&gt; \n&gt; \n&gt;&gt; \n&gt;&gt;&gt;&gt; REST has nothing to do\n&gt;&gt;&gt;&gt; with negotiating between versions of an API.\n&gt;&gt;&gt; \n&gt;&gt;&gt; Sure it does.  The accept header allows the negotiation of API\n&gt;&gt;&gt; versions.  Consider `accept: text/html` vs `accept:\n&gt;&gt;&gt; application/atom+xml`.  One says the client wants to interact with\n&gt;&gt;&gt; the html version of the api, the other says the client wants to\n&gt;&gt;&gt; interact with the atom version of the api.\n&gt;&gt; \n&gt;&gt; Yes, exactly. Or consider:\n&gt;&gt; \n&gt;&gt; Accept: application/atom+xml  vs.  Accept: application/atom-v2+xml\n&gt;&gt; \n&gt; \n&gt; That would tell me that you&#39;re requesting version 1 of Atom or version\n&gt; 2 of Atom, not version 1 vs. version 2 of an API.  There is no need in\n&gt; REST to version APIs, or parameterize version information in media\n&gt; types.  The world tried this approach, but it lost out, proof of this\n&gt; is that HTML 5 is still text/html, not &#39;text/html; version=5&#39;.  If\n&gt; there is an Atom 2, it would still be application/atom+xml, in keeping\n&gt; with the REST style as instantiated on the Web.\n&gt; \n&gt;&gt; \n&gt;&gt;&gt; \n&gt;&gt;&gt;&gt; Referring once again to REST:\n&gt;&gt;&gt;&gt; \n&gt;&gt;&gt;&gt; &quot;The trade-off, though, is that a uniform interface degrades\n&gt;&gt;&gt;&gt; efficiency, since information is transferred in a standardized form\n&gt;&gt;&gt;&gt; rather than one which is specific to an application&#39;s needs.&quot;\n&gt;&gt;&gt; \n&gt;&gt;&gt; I don&#39;t get what you seem to get that from this quote.  Later in the\n&gt;&gt;&gt; same section we get this paragraph.\n&gt;&gt;&gt; \n&gt;&gt;&gt;  In order to obtain a uniform interface, multiple architectural\n&gt;&gt;&gt;  constraints are needed to guide the behavior of components. REST\n&gt;&gt;&gt; is defined by four interface constraints: identification of\n&gt;&gt;&gt; resources; manipulation of resources through representations;\n&gt;&gt;&gt; self-descriptive messages; and, hypermedia as the engine of\n&gt;&gt;&gt; application state.\n&gt;&gt;&gt; \n&gt;&gt;&gt; No where does that suggest there is some limit to the allowable\n&gt;&gt;&gt; number of representation flavors.\n&gt;&gt; \n&gt;&gt; Right. Roy refers to the fact that general-purpose payloads are\n&gt;&gt; naturally less efficient (in terms payload size) than payloads\n&gt;&gt; designed specifically for a single service.\n&gt;&gt; \n&gt; \n&gt; And by implication, more uniform.  The goal of a REST system is to\n&gt; become more uniform, at the tradeoff of efficiency, for the purposes of\n&gt; scaling and serendipitous re-use, in keeping with the principle of\n&gt; generality.\n&gt; \n&gt;&gt; \n&gt;&gt;&gt; Your reading of the uniform interface seems different than much of\n&gt;&gt;&gt; the community.\n&gt;&gt;&gt; \n&gt;&gt;&gt; RestWiki is pretty quiet on the idea of limiting media types being\n&gt;&gt;&gt; part of the uniform interface in both the interface genericity&#39;s[1]\n&gt;&gt;&gt; and rest in plain english[2] pages.  Both seem to imply that domain\n&gt;&gt;&gt; specific media types would be ok.\n&gt;&gt; \n&gt;&gt; Yes, of course they are ok. They are the *essence* of building\n&gt;&gt; RESTful systems beyond the existing human HTML and Feeds Web.\n&gt;&gt; \n&gt; \n&gt; I disagree vehemently.  Myriad diverse systems have been built using\n&gt; ubiquitous media types.  These media types are capable of embedding\n&gt; machine-readable, domain-specific vocabularies.  Ubiquitous media types\n&gt; does not mean HTML.  How many times must I mention telephony systems\n&gt; with hypertext REST APIs that have nothing to do with HTML or browsers?\n&gt; \n&gt; Unless you have such a compelling use case for not using HTML, and no\n&gt; other ubiquitous type exists for your problem, then g&#39;head.  But, 999\n&gt; times out of 1,000 the nature of the system is not such a unique\n&gt; snowflake that HTML + RDFa need to be dismissed out-of-hand.  There is\n&gt; simply no reason that m2m can&#39;t be done this way, as proven by the m2m\n&gt; interaction via HTML + RDFa that&#39;s happening more and more each day now\n&gt; that GR is proliferating.\n&gt; \n&gt; HTML is capable of *accessibly* describing the hypertext controls of\n&gt; almost any conceivable REST API.  It&#39;s well understood, and easily\n&gt; maintainable (if well-written, but that goes for anything) because it\n&gt; is both human and machine readable.  Such a hypertext API can wrap any\n&gt; number of back-end formats and systems, RESTful or not, and make a REST\n&gt; system out of it.  999 out of 1,000 custom media types think they&#39;re\n&gt; providing a hypertext API, but aren&#39;t really meeting the hypertext\n&gt; constraint at all.\n&gt; \n&gt; -Eric\n&gt; \n&gt; \n&gt; ------------------------------------\n&gt; \n&gt; Yahoo! Groups Links\n&gt; \n&gt; \n&gt; \n\n-----------------------------------\n Jan Algermissen, Consultant\n NORD Software Consulting\n\n Mail: algermissen@...\n Blog: http://www.nordsc.com/blog/\n Work: http://www.nordsc.com/\n-----------------------------------\n\n\n\n\n\n"}}