{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":147780944,"authorName":"A. Pagaltzis","from":"&quot;A. Pagaltzis&quot; &lt;pagaltzis@...&gt;","profile":"a22pag","replyTo":"SENDER","senderId":"rceOfLmcbkq_p37Ts09_tk4sY6M54TK2RSu48IIWSHNDec1xwOUoItaENmusoDsFqw1LtsB-q8-wPR6Gfh9c_OEM7OO6jg9F","spamInfo":{"isSpam":false,"reason":"0"},"subject":"To PUT things right [was: The Ambiguous Semantics of PUT: Complete or Incomplete Representations] [also was: Linking and posting]","postDate":"1182884741","msgId":9261,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDcwNjI2MTkwNTQxLkdHMjAwNThAa2xhbmdyYXVtPg=="},"prevInTopic":0,"nextInTopic":0,"prevInTime":9260,"nextInTime":9262,"topicId":9261,"numMessagesInTopic":1,"msgSnippet":"... No, it doesn’t. (3) is what the client means by omitting certain parts. It does not change (2), which says the server may choose to act upon the request","rawEmail":"Return-Path: &lt;pagaltzis@...&gt;\r\nX-Sender: pagaltzis@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 63747 invoked from network); 26 Jun 2007 19:06:45 -0000\r\nReceived: from unknown (66.218.67.34)\n  by m54.grp.scd.yahoo.com with QMQP; 26 Jun 2007 19:06:45 -0000\r\nReceived: from unknown (HELO mail.gmx.net) (213.165.64.20)\n  by mta8.grp.scd.yahoo.com with SMTP; 26 Jun 2007 19:06:44 -0000\r\nReceived: (qmail invoked by alias); 26 Jun 2007 19:05:42 -0000\r\nReceived: from static-87-79-236-202.netcologne.de (EHLO klangraum) [87.79.236.202]\n  by mail.gmx.net (mp047) with SMTP; 26 Jun 2007 21:05:42 +0200\r\nX-Authenticated: #163624\r\nX-Provags-ID: V01U2FsdGVkX18DYu4Qne0DHgBRbxGs4uX6JxDS+Owx6/zzlSVMnm\n\tuptwkE01OeuliW\r\nDate: Tue, 26 Jun 2007 21:05:41 +0200\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-ID: &lt;20070626190541.GG20058@klangraum&gt;\r\nMail-Followup-To: rest-discuss@yahoogroups.com\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=utf-8\r\nContent-Disposition: inline\r\nContent-Transfer-Encoding: 8bit\r\nUser-Agent: Mutt/1.4.2.1i\r\nX-Originally-In-Reply-To: &lt;a6a6df360706252316l2611093cl657e5820a322a939@...&gt; &lt;a6a6df360706240517v6bd994d1ic091a2796ae70a70@...&gt; &lt;4666B722.5030902@...&gt;\r\nX-Y-GMX-Trusted: 0\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;A. Pagaltzis&quot; &lt;pagaltzis@...&gt;\r\nSubject: To PUT things right [was: The Ambiguous Semantics of PUT: Complete or Incomplete Representations] [also was: Linking and posting]\r\nX-Yahoo-Group-Post: member; u=147780944; y=2g00rVkEb3lABXzU0omvvTyY_Bt3WJ3iRYYIveJKhVcO\r\nX-Yahoo-Profile: a22pag\r\n\r\n* Nick Gall &lt;nick.gall@...&gt; [2007-06-24 14:20]:\n&gt; On 6/24/07, Robert Sayre &lt;sayrer@...&gt; wrote:\n&gt; &gt;The HTTP spec makes exactly this point. That&#39;s why it doesn&#39;t\n&gt; &gt;define how a PUT request affects the state of the server.\n&gt; &gt;\n&gt; &gt;I find it very puzzling that Julian is the only other person\n&gt; &gt;in this thread that seems to understand that the semantics of\n&gt; &gt;PUT are unambiguous, while the requirements on the servers are\n&gt; &gt;completely undefined.\n&gt; &gt;\n&gt; &gt;1.) the semantics of PUT are unambiguous\n&gt; &gt;2.) requirements on servers receiving PUT requests are\n&gt; &gt;undefined\n&gt; &gt;\n&gt; &gt;Both are true, and #2 does not change #1. Understanding that\n&gt; &gt;these two facts can be simultaneously true is key to\n&gt; &gt;understanding HTTP. It&#39;s not a problem, and it&#39;s not\n&gt; &gt;underspecified.\n&gt; \n&gt; I agree that (1) and (2) are true and (2) does not change (1).\n&gt; But way back in the thread\n&gt; &lt;http://tech.groups.yahoo.com/group/rest-discuss/message/9120&gt;,\n&gt; you appeared to want to add a third constraint\n&gt; \n&gt; 3.) &quot;[O]missions in a client PUT message [mean] unset those\n&gt; portions&quot;; omission does &quot;not mean only update the included\n&gt; elements.&quot;\n&gt; \n&gt; (1), (2), and (3) can NOT be all true. (3) contradicts (2)\n&gt; because it defines &quot;requirements on servers receiving PUT\n&gt; requests&quot;.\n\nNo, it doesn’t.\n\n(3) is what the client means by omitting certain parts. It does\nnot change (2), which says the server may choose to act upon the\nrequest in any way it desires, including ignoring such an\nomission.\n\n&gt; The ambiguity I&#39;ve been referring to all along is the ambiguity\n&gt; between (2) and (3). Some people think PUT defines the\n&gt; requirement of replacement semantics (the 3 camp) and some\n&gt; people think the choice between replacement and merge are\n&gt; undefined (left open to the parties applying HTTP) (the 2\n&gt; camp). I thought Robert was in the (3) camp. You can&#39;t be in\n&gt; both.\n\nNo.\n\nThe missing understanding is that RFC 2616 talks about what the\nclient means, not what the server must do.\n\nTake GET as an example. How do you make it completely free of\nside effects? Servers keep logs; reading a file on the server\nchanges its access time; etc. In practice, every request, even\na “safe and idempotent” one, *inevitably* has side effects in\nany application that does something interesting.\n\nHowever!\n\nRFC 2616 specifies that the client cannot be held responsible if\na GET initiates destructive changes. The meaning of the request\nis clear and unambiguous.\n\nAnd with that we return to PUT: RFC 2616 is perfectly clear that\nby using PUT, the client means that omitted parts of the entity\nare to be removed. This is 100% unambiguous. By PUT the client\nmeans “replace.”\n\nWhat RFC 2616 does not say is to what extent the server must\nhonuor this request. It’s completely within the server’s rights\nto retain certain parts of the resource if it so chooses.\n\nHere, too, however, the client cannot be held responsible for\nthis. The client’s request has unambiguous meaning.\n\nIn practice, the extent of a server’s deviation from the client\nrequest will depend on what is implementable on the server –\nf.ex., if the client PUTs an XML document on an XML DB server, it\nis sane to expect that the server will subsequently return a\nrepresentation that is equivalent to the client’s in terms of the\ninfoset, but probably unreasonle to expect that it will be\nbit-for-bit identical. However, even though the server modified\nthe client’s entity in a strict sense, this wouldn’t really be an\nissue.\n\n\nIn another message, Nick writes:\n\n* Nick Gall &lt;nick.gall@...&gt; [2007-06-26 08:20]:\n&gt; So let me guess this straight:\n&gt; \n&gt;   1. The HTTP spec clearly requires replacement semantics for\n&gt;   PUT\n&gt;   2. But the HTTP spec also clearly allows servers to ignore\n&gt;   such semantics if they choose\n&gt;   3. Because of (1), users of PUT will expect servers to adhere\n&gt;   to replacement semantics\n&gt;   4. Because of (3), users will think that servers that don&#39;t\n&gt;   adhere to replacement semantics &quot;suck&quot;\n&gt; \n&gt; And you think such convoluted logic is explicit intent of the\n&gt; writers of the HTTP spec? Riiiight (using my best Dr. Evil\n&gt; impersonation).\n\nThere’s nothing convoluted about it. Different applications vary\nin the specific strong assurance they need from the server.\nF.ex., while it is reasonable to expect that an XML DB server\nwill store arbitrary XML faithfully enough for infoset\nequivalence, it is an unreasonable burden to expect Atompub\nservers to always preserve all Extension Elements found in an\nEntry Document. OTOH, a weblog Atompub implementation will\nprobably store application/*+xml Media Resources bit-for-bit,\nwhich is too much to ask of the XML DB.\n\nTherefore, leaving the server free to judge the extent to which\nit can honour a client’s request in this way is vital to the\nprotocol’s implementability. If HTTP forced servers to make any\nstrong promises up front, it would be too costly to implement in\nnearly all of the scenarios it is currently applied to.\n\nInstead, the spec remains silent on that point and leaves users\nof HTTP to figure out what assurances they specifically need in\ntheir particular use case. The same quirk may lead the users of\none server implementation to consider it sucky, while the users\nof another server implementation may have no problem with it or\nmay even *want* that particular quirk – the difference is in the\nuse case of each group.\n\n\nNow, in another message, Jon wrote:\n\n* Jon Hanna &lt;jon@...&gt; [2007-06-06 15:35]:\n&gt; When we put we transfer *a* representation of the resource from\n&gt; client to server, just like when we GET we transfer *a*\n&gt; representation of the resource from server to client.\n&gt; \n&gt; Since a resource can have more than one representation, and we\n&gt; can only ever PUT one representation, any PUT is potentially\n&gt; affecting an innumerable number of representations as these may\n&gt; all depend on the server&#39;s knowledge of the resource - which we\n&gt; have just changed.\n&gt; \n&gt; All PUTs are therefore partial in this way.\n&gt; \n&gt; Following from that there is no reason why one may not send a\n&gt; representation that omits some information (it is indeed very\n&gt; common for one representation of a resource to contain\n&gt; information another does not). There is nothing faulty with\n&gt; such a representation and therefore no reason why it may not be\n&gt; used.\n&gt; \n&gt; Therefore whether partial PUTs may or may not be used becomes\n&gt; solely a matter of whether partial knowledge of a\n&gt; representation may be expressed in a particular content type.\n&gt; \n&gt; One can also do partial PUTs using content-range but this\n&gt; either requires either the entity to be of a type where\n&gt; over-writing a fixed number of octets makes sense, or else the\n&gt; use of a custom range-unit.\n\nAs you might guess at this point, I consider the “partial” issue\na red herring. It doesn’t matter if the representation\ntransmitted is unable to express the full state of the resource.\n\nIn general:\n\n    When a client issues a PUT, it means that the new state of\n    the resource is to be dependent solely on the content of the\n    enclosed entity.\n\nWhether the *server* merges in parts of the previous state of the\nresource is at the server’s discretion.\n\nIf you want the *client* to be able to express that the enclosed\nentity should be applied to the previous state of the resource in\norder to yield the new state, then you should habe the client use\na verb other than PUT. Like, I dunno, PATCH.\n\nRegards,\n-- \nAristotle Pagaltzis // &lt;http://plasmasturm.org/&gt;\n\n"}}