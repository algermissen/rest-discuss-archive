{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":23186829,"authorName":"Paul Prescod","from":"Paul Prescod &lt;paul@...&gt;","replyTo":"SENDER","senderId":"mckwrtaYfTPw-vhQUGf_Pfj4vQAKy_8xx-xvV7pNWGe7uEkKfK4t-QiAxFHixf7VRHTRmjUNt_2jBZ6rFcEnWgsrqhRQ9g","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Why is HTTP special?","postDate":"1012464530","msgId":473,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDNDNThGQjkyLjg4Nzg4QTA0QHByZXNjb2QubmV0Pg=="},"prevInTopic":0,"nextInTopic":498,"prevInTime":472,"nextInTime":474,"topicId":473,"numMessagesInTopic":11,"msgSnippet":"http://www.prescod.net/whyhttp.html Why is HTTP (1.1) Special? People learning REST will probably have the reaction that all of us did at first, why are these","rawEmail":"Return-Path: &lt;paul@...&gt;\r\nX-Sender: paul@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (EGP: mail-8_0_1_3); 31 Jan 2002 08:09:57 -0000\r\nReceived: (qmail 77928 invoked from network); 31 Jan 2002 08:09:57 -0000\r\nReceived: from unknown (216.115.97.167)\n  by m5.grp.snv.yahoo.com with QMQP; 31 Jan 2002 08:09:57 -0000\r\nReceived: from unknown (HELO smtp1.ActiveState.com) (209.17.183.249)\n  by mta1.grp.snv.yahoo.com with SMTP; 31 Jan 2002 08:09:57 -0000\r\nReceived: from smtp3.ActiveState.com (smtp3.ActiveState.com [192.168.3.19])\n\tby smtp1.ActiveState.com (8.11.6/8.11.6) with ESMTP id g0V89sN18046\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Thu, 31 Jan 2002 00:09:54 -0800\r\nReceived: from prescod.net (ssh1.ActiveState.com [192.168.3.32])\n\tby smtp3.ActiveState.com (8.11.6/8.11.6) with ESMTP id g0V89re27532\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Thu, 31 Jan 2002 00:09:53 -0800\r\nMessage-ID: &lt;3C58FB92.88788A04@...&gt;\r\nDate: Thu, 31 Jan 2002 00:08:50 -0800\r\nX-Mailer: Mozilla 4.76 [en] (Windows NT 5.0; U)\r\nX-Accept-Language: en\r\nMIME-Version: 1.0\r\nTo: &quot;rest-discuss@yahoogroups.com&quot; &lt;rest-discuss@yahoogroups.com&gt;\r\nSubject: Why is HTTP special?\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Transfer-Encoding: 7bit\r\nX-PerlMx-Spam: Gauge=, Probability=0%, Report=INTERNAL_HOST\r\nX-Filtered-By: PerlMx makes it fast and easy.  See http://www.ActiveState.com/Products/PerlMx/Header\r\nFrom: Paul Prescod &lt;paul@...&gt;\r\nX-Yahoo-Group-Post: member; u=23186829\r\n\r\nhttp://www.prescod.net/whyhttp.html\n\n\tWhy is HTTP (1.1) Special?\n\nPeople learning REST will probably have the reaction that all of us did\nat first, why are these people trying to make HTTP (1.1) into some kind\nof universal protocol? Let&#39;s start by saying that we aren&#39;t quite that\ncrazy. HTTP is not going to be replacing UDP for gaming or DNS for\nnaming etc. For legacy reasons it isn&#39;t even going to replace SMTP or\nPOP soon, even though it could do those jobs easily. \n\n\tHTTP is general\n\nStill, we suggest that it makes sense to build a wide range of\napplications using HTTP, whether they be asynchronous, peer-to-peer,\netc. At first, you may think our HTTP-fixation is an arbitrary fetish\nlike a fondness for cats over dogs. This is not so. HTTP really is a\nbetter protocol than SMTP or POP or IMAP in a very concrete sense. \n\nHTTP fits into a class of protocols that are designed to general\npurpose. Linda is a famous one. The various RPC protocols are also very\ngeneral purpose. Linda bills itself a &quot;coordination language&quot; -- used\nfor coordinating multiple software processes. Until I have a precise\ndefinition of that term I can&#39;t say for sure whether RPC protocols and\nHTTP are also coordination languages but the term seems to apply to\nthem. They are protocols for coordinating multiple independent software\ncomponents. \n\nDefinitions aside, the point remains: in terms of generality, HTTP has\nmore in common with SOAP than with SMTP. It is not just about moving\nHTML pages from servers to clients. \n\n\tGeneral purpose protocol\n\nI don&#39;t think that I can &quot;prove&quot; that HTTP is more general than other\nprotocols in a mathematically rigorous way. But I can nevertheless give\nyou a feeling for the generality of HTTP. \n\nThe most basic computational device is a Turing machine. A Turing\nmachine is driven by a program expressed as a set of states and a tape.\nThe tape represents some kind of storage. In the more advanced forms of\nthe Turing machine, you can read and write to the storage and address\nthe storage locations by numeric ID. \n\nHTTP is similar. HTTP allows you to read from the storage with GET,\nwrite to it with PUT and the addresses are URIs. Because disk space in\nthe real world is limited, HTTP also has DELETE. And because multiple\npeople will be using the system at once, there is a need for a method\nthat will create guaranteed-new &quot;storage locations&quot;. This is POST. POST\nis so incredibly general that you can use it for other things. But you\nonly absolutely need POST to deal with situations where there might be\nrace conditions. These primitives allow HTTP to be used as a\ncoordination language. \n\nInstead of a state machine, of course, we write our HTTP programs in\ngeneral purpose programming languages like Python or C++. The web server\ncan act as state for the computation (though it may also do much more).\nThis may not seem immediately interesting because most people have grown\naccustomed to using RAM and hard disks for their state. But HTTP allows\nus to build distributed applications that share state through HTTP\nservers. SMTP lacks equivalent &quot;methods&quot;. POP lacks equivalent\n&quot;methods&quot;. \n\nFTP is the closest protocol to HTTP conceptually. But really the gap\nbetween FTP and HTTP is huge. FTP lacks the POST method. It lacks\ncontent negotation. It lacks well-defined caching semantics. More\nimportant, though, FTP&#39;s semantics do not allow the server to be an\nactive participant in the computation. HTTP very precisely defines how\nthe server can do complicated computations by itself. It is not just a\nholder of bits -- it can embody a complex service! The web as we know it\ndemonstrates the extent to which it has succeeded. The Web is an\nexcellent, scalable, sophisticated e-commerce platform and this is\nlargely due to smart usage of HTTP by e-commerce providers. \n\nHTTP is also very extensible through new headers, new methods, new URIs\nand new content types. Let&#39;s concentrate on the extension of the four\nmain methods (GET, PUT, POST, DELETE). HTTP 1.1 defines some others.\nExtensions to HTTP also define new ones (such as WebDAV). Although the\nfour methods are &quot;sufficient&quot;, it is nice to have other ones for\nefficiency and modeling simplicity. For instance WebDAV has a LOCK\nmethod which could be modeled as a POST of a LOCk object. In theory the\nLOCK method may be a bit more efficient and a little bit simpler to\nimplement. \n\n\tModeling applications in HTTP\n\nIt is possible to compose these methods into an infinite variety of\napplcations. In some trivial sense you could run the web on top of SMTP\nby using it as a tunnel for HTTP. But in a much more concrete sense you\ncould model SMTP as a series of HTTP POSTs, GETs and PUTs. The resulting\nprotocol would be no more complicated than SOAP and probably about as\nefficient. Most people are probably more comfortable with POP (which\nthey probably use every day) than with SMTP, so I&#39;ll use that as an\nexample. \n\nWhat if your &quot;mailbox&quot; were just a password-protected section of your\nwebsite. It would store a bunch of resources with various content types\n(mostly text/plain). Your various mail clients would GET from it when\nthey want to update your client view. When they want to remove a message\nthey DELETE it. When they want to send a message they POST it to the\nmailbox on someone else&#39;s server. If the other server wasn&#39;t available\nthen you would instead POST it to queuing intermediary. If you wanted to\nupdate a message in the queue before it was sent you could PUT to it. \n\nYou can see how this modeling process works. You think about the things\nyou want to work with as resources and you apply HTTP methods to them.\nOne day I hope and expect that Web resource modeling will be as widely\nunderstood as object oriented modeling. \n\nIf you were away from a proper mail client you would just browse your\nmailbox using a standard web browser. Content negotation would ensure\nthat your mailbox &quot;looks like&quot; a web page when you access it from a\nbrowser. Every mail server could easily have the functionality of\nHoTMaiL (which is, after all, just an HTTP-based user interface). \n\nUnlike SMTP, POP, FTP etc., HTTP is a protocol that you can directly\nmodel applications in terms of. We can model all of the features of\nSMTP, POP, FTP etc. in HTTP. The interesting thing is that it usually\nisn&#39;t much of a conceptual stretch to do so. Just as it is typically\neasy to map any data format into XML (once you get the hang of it), it\nis easy to map any protocol into HTTP (once you get the hang of it).\nJust as any reasonable person will ask, when they see a new data\ninterchange syntax: &quot;Why couldn&#39;t you have done that as XMl&quot;, a person\ncould ask of a new protocol, &quot;Why didn&#39;t you do that as HTTP.&quot; Think of\nHTTP as the emerging default, quasi-universal syntax for TCP-based\nprotocols, as XML is the default, quasi-universal syntax for structured\ndata. \n\nI say &quot;quasi-universal&quot; because there are limits. Just as XML isn&#39;t\nreally great for binary media, HTTP isn&#39;t really great for streaming\nreal-time media. So for those applications you should use something\nelse. But if your application is within HTTP&#39;s purview (i.e. structured\nmessaging), then you should think twice before inventing Yet Another Way\nto manage connections, and manage content-negotiation and manage the\nheader/body split and invent yet another namespace, and figure out a new\nway to handle caching etc. There are huge economies of scale in figuring\nout all of these things just once for HTTP. \n\n\tVersus Other Generic Protocols\n\nSo HTTP is not properly compared with most of the other Internet\nprotocols. It is in a totally different class of generality. It might\nmore relevant to compare it with Tuple-space models (Linda, JavaSpaces,\nTspaces etc.) and the RPC protocols (DCOM, SOAP RPC, etc.). How does it\ncompare? \n\nWell, the tuple-space models seem to (as per the name!) require some\nkind of shared environment called the tuple space. I don&#39;t see how this\ncan scale up to an application the size of the Web. Maybe I\nmisunderstand something. \n\nHTTP&#39;s big advantage over RPC protocols (and this is another advantage\nover FTP) is that its whole model is organized around addresses.\nUbiquitous, powerful, direct and indirect addressing is what made the\nWeb so incredibly powerful. RPC protocols hide the &quot;addresses&quot; of\nobjects in parameters. When you pass a UUID to access a UDDI TModel, you\nare really addressing the thing, but because the address is hidden in a\nmethod, you can&#39;t address that thing anywhere, such as in an XSLT\nstylesheet, or an RDF assertion, or a web browser bookmark, or the\nURL-line of a browser, or ... \n\nRPC divides the world up into self-contained address spaces. This is the\nantithesis of the unviversal naming used on the Web. This will cause so\nmany problems that I am confident predicting that RPC protocols will\nfail. \n\n\tHTTP Limitations\n\nThere is no doubt that HTTP has its limitations. For one thing there is\nnot much software out there that knows how to deal with HTTP in a\npeer-to-peer or asychronous fashion. There is a lot of software out\nthere that claims to use HTTP but is well behind the HTTP specification.\nAlso, HTTP is not going to take over the universe from established\nprotocols with large software bases. Rather it will capture new markets\nthat have not yet been tapped. \n\nFinally, there is a lot of work to do in order to standarize HTTP\nsolutions to common problems. For instance WebDAV isa standardization of\ncontent management solutions in the HTTP framework. HTTPEvents is a\nstandardization of HTTP notifications (&quot;asynch&quot;, &quot;callbacks&quot; whatever\nyou want to call it). There are also proposals for making HTTP more\nreliable in the sense that every message gets delivered once and only\nonce.\n\n"}}