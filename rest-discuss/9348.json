{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":210067383,"authorName":"Nick Gall","from":"&quot;Nick Gall&quot; &lt;nick.gall@...&gt;","profile":"nick_gall_1117","replyTo":"SENDER","senderId":"yZBZoIJCYSl8pFUaEG6HqP2R4g0GBqXrwwUFT3lc748nO61pYhXOVvbjiq60zB_xkKVxxetWNN_odmfVffvpTTJuCXxpsJvr","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re:To PUT things right [was: The Ambiguous Semantics of PUT: Complete o","postDate":"1183754886","msgId":9348,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGY2bTlxNitqcXRmQGVHcm91cHMuY29tPg==","inReplyToHeader":"PFcxMTc5ODI3NzgyMzAyODkxMTgzNTEzMTAxQG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":9330,"nextInTopic":9356,"prevInTime":9347,"nextInTime":9349,"topicId":9304,"numMessagesInTopic":8,"msgSnippet":"... RFC. ... REST ... like ... of ... made ... is ... that ... WAIS. ... REST ... of ... and ... Implementing ... to ... REST. Wow! That s quite inventive","rawEmail":"Return-Path: &lt;nick.gall@...&gt;\r\nX-Sender: nick.gall@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 63515 invoked from network); 6 Jul 2007 20:48:27 -0000\r\nReceived: from unknown (66.218.66.72)\n  by m53.grp.scd.yahoo.com with QMQP; 6 Jul 2007 20:48:27 -0000\r\nReceived: from unknown (HELO n32c.bullet.scd.yahoo.com) (66.94.237.10)\n  by mta14.grp.scd.yahoo.com with SMTP; 6 Jul 2007 20:48:26 -0000\r\nReceived: from [66.218.69.2] by n32.bullet.scd.yahoo.com with NNFMP; 06 Jul 2007 20:48:06 -0000\r\nReceived: from [66.218.66.78] by t2.bullet.scd.yahoo.com with NNFMP; 06 Jul 2007 20:48:06 -0000\r\nDate: Fri, 06 Jul 2007 20:48:06 -0000\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-ID: &lt;f6m9q6+jqtf@...&gt;\r\nIn-Reply-To: &lt;W1179827782302891183513101@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative; boundary=&quot;1-0298768949-3993716536=:6&quot;\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;Nick Gall&quot; &lt;nick.gall@...&gt;\r\nSubject: Re:To PUT things right [was: The Ambiguous Semantics of PUT: Complete o\r\nX-Yahoo-Group-Post: member; u=210067383; y=cxU-HQo5an7apaqcGCk9SmhyHfl55jGiB1zgaN1ItCOcQTDZ4KMOMgs\r\nX-Yahoo-Profile: nick_gall_1117\r\n\r\n\r\n--1-0298768949-3993716536=:6\r\nContent-Type: text/plain; charset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n--- In rest-discuss@yahoogroups.com, &quot;Eric J. Bowman&quot; &lt;eric@...&gt; wrote:\n&gt; T=\r\nhere&#39;s some disagreement here, which stems from the wording of the\nRFC.\n&gt; B=\r\nut HTTP is not REST, if we are discussing the semantics of PUT in\nREST\n&gt; te=\r\nrms (generic interface) then store means replace in RFC 2616 just\nlike\n&gt; ST=\r\nOR means replace in RFC 765.\n&gt;\n&gt; &quot;REST does not restrict communication to a=\r\n particular protocol, but it\n&gt; does constrain the interface between compone=\r\nnts, and hence the scope\nof\n&gt; interaction and implementation assumptions th=\r\nat might otherwise be\nmade\n&gt; between components. For example, the Web&#39;s pri=\r\nmary transfer protocol\nis\n&gt; HTTP, but the architecture also includes seamle=\r\nss access to resources\nthat\n&gt; originate on pre-existing network servers, in=\r\ncluding FTP, Gopher, and\nWAIS.\n&gt; Interaction with those services is restric=\r\nted to the semantics of a\nREST\n&gt; connector.&quot;\n&gt;\n&gt; This tells me that a REST =\r\nconnector must understand that the semantics\nof\n&gt; GET equal the semantics o=\r\nf RETR, APPE=3DPOST, DELE=3DDELETE, LIST=3DOPTIONS\nand\n&gt; STOR=3DPUT in orde=\r\nr to meet the Uniform Interface constraint. \nImplementing\n&gt; PUT with merge =\r\nsemantics may not go against RFC 2616 (although I don&#39;t\n&gt; think that was th=\r\ne intent) but I don&#39;t see how it doesn&#39;t break REST\nto\n&gt; do so.  FTP includ=\r\nes methods not included in the semantics of a REST\n&gt; connector, just as HTT=\r\nP PATCH has no merge corollary in FTP, but the\n&gt; meaning of &quot;store&quot; is &quot;rep=\r\nlace&quot; in both FTP and HTTP according to\nREST.\n\nWow! That&#39;s quite inventive =\r\nreasoning, but I believe it is exactly\nbackwards.\n\nThe passage you cite fro=\r\nm the REST thesis tells me the exact opposite:\nthe protocols for FTP, Gophe=\r\nr, and WAIS must be &quot;restricted to the\nsemantics of [] REST&quot; -- not the oth=\r\ner way around. So just because FTP&#39;s\nSTOR method might be (but does not hav=\r\ne to be) mapped to PUT (thus\ngiving PUT in this particular case replacement=\r\n semantics), this doesn&#39;t\nimply that PUT must be restricted to replacement =\r\nsemantics in all cases.\n\nIn other words, just because for some applications=\r\n of HTTP the PUT\nmethod is described as having replacement semantics, this =\r\nprovides no\nevidence that RFC 2616 itself always restricts PUT to such sema=\r\nntics. By\nyour argument, the mapping of POST to FTP&#39;s APPE is evidence that=\r\n RFC\n2616 intends POST to have ONLY &quot;append semantics,&quot; which is clearly a\n=\r\nwrong argument.\n\nThe REST thesis passage that I think is more directly rele=\r\nvant to the\nreplacement vs. modification semantics issue (though by no mean=\r\ns\ndefinitive) is the following (section 6.2.3 Remote Authoring):\n\nThe resou=\r\nrce is not thestorage object. The resource is not a mechanism\nthat the serv=\r\ner uses to handlethe storage object. The resource is a\nconceptual mapping =\r\n=C3=A2=E2=82=AC=E2=80=9D the server receivesthe identifier\n(which identifie=\r\ns the mapping) and applies it to its currentmapping\nimplementation (usually=\r\n a combination of collection-specific deep\ntreetraversal and/or hash tables=\r\n) to find the currently responsible\nhandlerimplementation and the handler i=\r\nmplementation then selects the\nappropriateaction+response based on the requ=\r\nest content. All of\ntheseimplementation-specific issues are hidden behind t=\r\nhe Web interface;\ntheir naturecannot be assumed by a client that only has a=\r\nccess through\nthe Web interface. [emphasis added]\nThis suggests to me that =\r\nattempts to restrict the semantics of HTTP\nmethods specifically and RESTful=\r\n methods generally to storage-centric\nsemantics (like requiring PUT to alwa=\r\nys have replacement semantics) are\nmisguided. Now some might argue that loo=\r\nsening the semantics of PUT\nmakes it indistinguishable from POST. But they =\r\nwould be wrong. If\nSection 9.6 is clear about anything, it is clear (or at =\r\nleast clearer)\nabout the relationship between PUT and POST:\n\nThe fundamenta=\r\nl difference between the POST and PUTrequests is reflected\nin the different=\r\n meaning of the Request-URI. The URI in aPOST request\nidentifies the resour=\r\nce that will handle the enclosed entity.\nThatresource might be a data-accep=\r\nting process, a gateway to some other\nprotocol,or a separate entity that ac=\r\ncepts annotations. In contrast, the\nURI in a PUT requestidentifies the enti=\r\nty enclosed with the request --\nthe user agent knows whatURI is intended an=\r\nd the server MUST NOT attempt\nto apply the request to someother resource. [=\r\nemphasis added]\n\nSo the difference between PUT and POST is not in the diffe=\r\nrent meaning\nof their respective methods; it is only in the difference betw=\r\neen the\nrelationship of the method (whatever its semantics: process, replac=\r\ne,\nappend, modify) and the URI to which the method will be &quot;applied&quot;. So a\n=\r\nclient should not infer anything from the use of the method PUT on a URI\nbe=\r\nyond what the client should infer from a POST on the same URI, EXCEPT\nthat =\r\nin the former case, the client KNOWS that the request will be\napplied to th=\r\ne resource identified by the provided URI and not to some\nother resource. S=\r\no PUT merely means &quot;act upon the identified resource\nitself&quot;, while POST me=\r\nans &quot;use the identified resource to act upon other\nresources&quot;. Sections 6.2=\r\n.1 and 6.2.2 reinforce my belief that REST&#39;s\ngoal is to generalize the conc=\r\nept of resource and resource manipulation\n(via methods) AWAY FROM a restric=\r\ntive file/document storage model to a\nmore powerful (but more vague) concep=\r\nt of resource mapping:\n&quot;REST=C3=A2=E2=82=AC=E2=84=A2sdefinition of resource=\r\n derives from the central\nrequirement of the Web: independentauthoring of i=\r\nnterconnected hypertext\nacross multiple trust domains. Forcing theinterface=\r\n definitions to match\nthe interface requirements causes the protocolsto see=\r\nm vague, but that\nis only because the interface being manipulated is onlyan=\r\n interface and\nnot an implementation.&quot; [emphasis added]. PS: I find this on=\r\ne of the\nmost cryptic sentences in the Thesis, since Roy does not to a\nstep=\r\n-by-step analysis of how the interface requirements (aka the four\ninterface=\r\n constraints listed in 5.1.5) are actually applied to interface\ndefinitions=\r\n for GET, PUT, POST and DELETE.\n\n-- Nick\n\n\r\n--1-0298768949-3993716536=:6\r\nContent-Type: text/html; charset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n--- In rest-discuss@yahoogroups.com, &quot;Eric J. Bowman&quot; &lt;eric@...&gt; wrot=\r\ne:&lt;br&gt;&gt; There&#39;s some disagreement here, which stems from the wording of =\r\nthe RFC.  &lt;br&gt;&gt; But HTTP is not REST, if we are discussing the semantics=\r\n of PUT in REST &lt;br&gt;&gt; terms (generic interface) then store means replace=\r\n in RFC 2616 just like &lt;br&gt;&gt; STOR means replace in RFC 765.&lt;br&gt;&gt; &lt;br&gt;=\r\n&gt; &quot;REST does not restrict communication to a particular protocol, but it=\r\n &lt;br&gt;&gt; does constrain the interface between components, and hence the sc=\r\nope of &lt;br&gt;&gt; interaction and implementation assumptions that might other=\r\nwise be made &lt;br&gt;&gt; between components. For example, the Web&#39;s primary tr=\r\nansfer protocol is &lt;br&gt;&gt; HTTP, but the architecture also includes seamle=\r\nss access to resources that &lt;br&gt;&gt; originate on pre-existing network serv=\r\ners, including FTP, Gopher, and WAIS. &lt;br&gt;&gt; Interaction with those servi=\r\nces is restricted to the semantics of a REST &lt;br&gt;&gt; connector.&quot;&lt;br&gt;&gt; &lt;=\r\nbr&gt;&gt; This tells me that a REST connector must understand that the semant=\r\nics of &lt;br&gt;&gt; GET equal the semantics of RETR, APPE=3DPOST, DELE=3DDELETE=\r\n, LIST=3DOPTIONS and &lt;br&gt;&gt; STOR=3DPUT in order to meet the Uniform Inter=\r\nface constraint.  Implementing &lt;br&gt;&gt; PUT with merge semantics may not go=\r\n against RFC 2616 (although I don&#39;t &lt;br&gt;&gt; think that was the intent) but=\r\n I don&#39;t see how it doesn&#39;t break REST to &lt;br&gt;&gt; do so.  FTP includes met=\r\nhods not included in the semantics of a REST &lt;br&gt;&gt; connector, just as HT=\r\nTP PATCH has no merge corollary in FTP, but the &lt;br&gt;&gt; meaning of &quot;store&quot;=\r\n is &quot;replace&quot; in both FTP and HTTP according to REST.&lt;br&gt;&lt;br&gt;&lt;font face=3D&quot;=\r\narial&quot;&gt;Wow! That&#39;s quite inventive reasoning, but I believe it is exactly b=\r\nackwards.&lt;br&gt;&lt;br&gt;The passage you cite from the REST thesis tells me the exa=\r\nct opposite: the protocols for FTP, Gopher, and WAIS must be &quot;restricted to=\r\n the semantics of [] REST&quot; -- not the other way around. So just because FTP=\r\n&#39;s STOR method might be (but does not have to be) mapped to PUT (thus givin=\r\ng PUT &lt;i&gt;in this particular case&lt;/i&gt; replacement semantics), this doesn&#39;t i=\r\nmply that PUT must be restricted to replacement semantics in all cases.&lt;br&gt;=\r\n&lt;br&gt;In other words, just because for some &lt;i&gt;applications &lt;/i&gt;of HTTP the P=\r\nUT method is described as having replacement semantics, this provides no ev=\r\nidence that RFC 2616 itself &lt;i&gt;always &lt;/i&gt;restricts PUT to such semantics. =\r\nBy your argument, the mapping of POST to FTP&#39;s APPE is evidence that RFC 26=\r\n16 intends POST to have ONLY &quot;append semantics,&quot; which is clearly a wrong a=\r\nrgument.&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;font face=3D&quot;arial&quot;&gt;The REST thesis passage that I =\r\nthink is more directly relevant to the replacement vs. modification semanti=\r\ncs issue (though by no means definitive) is the following (section 6.2.3 Re=\r\nmote Authoring):&lt;br&gt;&lt;/font&gt;&lt;blockquote&gt;&lt;p class=3D&quot;MsoNormal&quot;&gt;&lt;span style=\r\n=3D&quot;font-family: Arial;&quot;&gt;The resource is &lt;u&gt;not thestorage object&lt;/u&gt;. The =\r\nresource is not a mechanism that the server uses to handlethe storage objec=\r\nt. The resource is a conceptual mapping =C3=A2=E2=82=AC=E2=80=9D the server=\r\n receivesthe identifier (which identifies the mapping) and applies it to it=\r\ns currentmapping implementation (usually a combination of collection-specif=\r\nic deep treetraversal and/or hash tables) to find the currently responsible=\r\n handlerimplementation and &lt;u&gt;the handler implementation then selects the a=\r\nppropriateaction+response based on the request content&lt;/u&gt;. All of theseimp=\r\nlementation-specific issues are hidden behind the Web interface; their natu=\r\nrecannot be assumed by a client that only has access through the Web interf=\r\nace. [emphasis added]&lt;/span&gt;&lt;span style=3D&quot;font-size: 10pt;font-family: Ari=\r\nal;&quot;&gt; &lt;/span&gt;&lt;span style=3D&quot;font-family: Arial;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;o&gt;&lt;/o&gt;&lt;/span=\r\n&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;font face=3D&quot;arial&quot;&gt;This suggests to me that attempts to=\r\n restrict the semantics of HTTP methods specifically and RESTful methods ge=\r\nnerally to storage-centric semantics (like requiring PUT to always have rep=\r\nlacement semantics) are misguided. Now some might argue that loosening the =\r\nsemantics of PUT makes it indistinguishable from POST. But they would be wr=\r\nong. If Section 9.6 is clear about anything, it is clear (or at least clear=\r\ner) about the relationship between PUT and POST:&lt;br&gt;&lt;br&gt;&lt;/font&gt;&lt;blockquote&gt;=\r\n&lt;span style=3D&quot;font-size: 10pt;font-family: Arial;&quot;&gt;The fundamental differe=\r\nnce between the POST and PUTrequests is reflected in &lt;u&gt;the different meani=\r\nng of the Request-URI&lt;/u&gt;. The URI in aPOST request identifies the resource=\r\n that will handle the enclosed entity. Thatresource might be a data-accepti=\r\nng process, a gateway to some other protocol,or a separate entity that acce=\r\npts annotations. In contrast, the URI in a PUT requestidentifies the entity=\r\n enclosed with the request -- the user agent knows whatURI is intended and =\r\nthe server MUST NOT attempt to apply the request to someother resource. [em=\r\nphasis added]&lt;/span&gt;&lt;br&gt;&lt;span style=3D&quot;font-size: 10pt;font-family: Arial;&quot;=\r\n&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;span style=3D&quot;font-size: 10pt;font-family: Arial;&quot;&gt;&lt;b=\r\nr&gt;So the difference between PUT and POST is not in the different meaning of=\r\n their respective &lt;i&gt;methods&lt;/i&gt;; it is only in the difference between the =\r\nrelationship of the method (whatever its semantics: process, replace, appen=\r\nd, modify) and the URI to which the method will be &quot;applied&quot;. So a client s=\r\nhould not infer anything from the use of the method PUT on a URI beyond wha=\r\nt the client should infer from a POST on the same URI, EXCEPT that in the f=\r\normer case, the client KNOWS that the request will be applied to the resour=\r\nce identified by the provided URI and not to some other resource. So PUT me=\r\nrely means &quot;act upon the identified resource itself&quot;, while POST means &quot;use=\r\n the identified resource to act upon other resources&quot;. Sections 6.2.1 and 6=\r\n.2.2 reinforce my belief that REST&#39;s goal is to generalize the concept of r=\r\nesource and resource manipulation (via methods) AWAY FROM a restrictive fil=\r\ne/document storage model to a more powerful (but more vague) concept of res=\r\nource mapping: &quot;&lt;/span&gt;&lt;span style=3D&quot;font-size: 10pt;font-family: Arial;&quot;&gt;=\r\nREST=C3=A2=E2=82=AC=E2=84=A2sdefinition of resource derives from the centra=\r\nl requirement of the Web: independentauthoring of interconnected hypertext =\r\nacross multiple trust domains. Forcing theinterface definitions to match th=\r\ne interface requirements &lt;u&gt;causes the protocolsto seem vague&lt;/u&gt;, but that=\r\n is only because the interface being manipulated is onlyan interface and no=\r\nt an implementation.&quot; [emphasis added]. PS: I find this one of the most cry=\r\nptic sentences in the Thesis, since Roy does not to a step-by-step analysis=\r\n of how the interface requirements (aka the four interface constraints list=\r\ned in 5.1.5) are actually applied to interface definitions for GET, PUT, PO=\r\nST and DELETE.&lt;/span&gt;&lt;br&gt;&lt;span style=3D&quot;font-size: 10pt;font-family: Arial;=\r\n&quot;&gt;&lt;br&gt;-- Nick&lt;br&gt;&lt;/span&gt;\n\r\n--1-0298768949-3993716536=:6--\r\n\n"}}