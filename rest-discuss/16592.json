{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"Zv24N_evH7Od_Shv_7f5aHThZ4as8ld2YXFi1Wuc10QlK10vMFjx29Ph8fX3Oj_l4oH1HE-Np_547FkDB54us2GLUMKY63f39v7NRfW-uA","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] To use registered media-types or not?","postDate":"1284363220","msgId":16592,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwOTEzMDEzMzQwLmM0ZDljOGMxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDEyODQyNDg2NDIuMjkyMC4xMDEuY2FtZWxAYmFja3BhY2s+","referencesHeader":"PEFBTkxrVGk9Y1JiVFFVQlVQUjdvQmJqY2dvc2VMakw9TDFDNmhQVkpEc0I1R0BtYWlsLmdtYWlsLmNvbT4JPEFBTkxrVGk9dnBpejNLZlp1bzkyQUtZalFYaDhKd05ndkowQTBvRGNRZkt1ckBtYWlsLmdtYWlsLmNvbT4JPDIwMTAwOTEwMDkxNzUyLjE5YThlOWRhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEFBTkxrVGluS3Y9OUt2WTY4Wjk3K1BEOHJvNENDV2Y4RjYySHg2aE1WU1VKK0BtYWlsLmdtYWlsLmNvbT4JPDIwMTAwOTEwMTExOTQ2LjdlYjY5ZjVjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEFBTkxrVGlrUFIyOHNEVmRrNnJ2VGMrdWZxZUgzWGgtck9YazBGd1EwPVBZNkBtYWlsLmdtYWlsLmNvbT4JPDIwMTAwOTEwMTIwMTQ5LjI3MDFjMDk1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEFBTkxrVGluNmZXdks2TGF6Z3dUZGo9VlowZFZrRnc2LVE9NUVfSGJSeE90MUBtYWlsLmdtYWlsLmNvbT4JPDIwMTAwOTEwMTM1NTE3LjNiN2Y0NmVjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEFBTkxrVGltblBPbnMrMW5HNG5zbV9FQVN0R1ZlNTlGS1lvZFc4TkNoPTg5eEBtYWlsLmdtYWlsLmNvbT4JPEFBTkxrVGluY0VSaXZlRFllWDBzYk8tYkticm9WMlRQcl9iTFBZSDlUUEg4Y0BtYWlsLmdtYWlsLmNvbT4JPDEyODQxNjU0NTYuMjkyMC43MC5jYW1lbEBiYWNrcGFjaz4JPDIwMTAwOTEwMjEwODU2LmJmNDc3MDcwLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEFBTkxrVGlrTXNwdk49bnpSTGNqODl0X09NaUpISGFOX3dqUGNiTHcwPWVCZkBtYWlsLmdtYWlsLmNvbT4JPDIwMTAwOTEwMjE1NjUzLjMxZDUxYTY5LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDRDOEJBMzc0LjUwOTAwMDBAd2VicjMub3JnPgk8QUFOTGtUaWtHQz1SOTRnWVRIeXF3RkdNZ0ZpeEsxPXY5TFVBWHljNEhHZj05QG1haWwuZ21haWwuY29tPgk8MTI4NDI0ODY0Mi4yOTIwLjEwMS5jYW1lbEBiYWNrcGFjaz4="},"prevInTopic":16591,"nextInTopic":16593,"prevInTime":16591,"nextInTime":16593,"topicId":16503,"numMessagesInTopic":98,"msgSnippet":"... Just defending my work.  I ve posted my /date service example many times over the past few years: http://en.wiski.org/date?iso=2010-09-12 The","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 49736 invoked from network); 13 Sep 2010 07:33:36 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m2.grp.sp2.yahoo.com with QMQP; 13 Sep 2010 07:33:36 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.sp2.yahoo.com with SMTP; 13 Sep 2010 07:33:35 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id DD1B1509DC;\n\tMon, 13 Sep 2010 03:33:34 -0400 (EDT)\r\nDate: Mon, 13 Sep 2010 01:33:40 -0600\r\nTo: juergen.brendel@...\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100913013340.c4d9c8c1.eric@...&gt;\r\nIn-Reply-To: &lt;1284248642.2920.101.camel@backpack&gt;\r\nReferences: &lt;AANLkTi=cRbTQUBUPR7oBbjcgoseLjL=L1C6hPVJDsB5G@...&gt;\n\t&lt;AANLkTi=vpiz3KfZuo92AKYjQXh8JwNgvJ0A0oDcQfKur@...&gt;\n\t&lt;20100910091752.19a8e9da.eric@...&gt;\n\t&lt;AANLkTinKv=9KvY68Z97+PD8ro4CCWf8F62Hx6hMVSUJ+@...&gt;\n\t&lt;20100910111946.7eb69f5c.eric@...&gt;\n\t&lt;AANLkTikPR28sDVdk6rvTc+ufqeH3Xh-rOXk0FwQ0=PY6@...&gt;\n\t&lt;20100910120149.2701c095.eric@...&gt;\n\t&lt;AANLkTin6fWvK6LazgwTdj=VZ0dVkFw6-Q=5E_HbRxOt1@...&gt;\n\t&lt;20100910135517.3b7f46ec.eric@...&gt;\n\t&lt;AANLkTimnPOns+1nG4nsm_EAStGVe59FKYodW8NCh=89x@...&gt;\n\t&lt;AANLkTincERiveDYeX0sbO-bKbroV2TPr_bLPYH9TPH8c@...&gt;\n\t&lt;1284165456.2920.70.camel@backpack&gt;\n\t&lt;20100910210856.bf477070.eric@...&gt;\n\t&lt;AANLkTikMspvN=nzRLcj89t_OMiJHHaN_wjPcbLw0=eBf@...&gt;\n\t&lt;20100910215653.31d51a69.eric@...&gt;\n\t&lt;4C8BA374.5090000@...&gt;\n\t&lt;AANLkTikGC=R94gYTHyqwFGMgFixK1=v9LUAXyc4HGf=9@...&gt;\n\t&lt;1284248642.2920.101.camel@backpack&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] To use registered media-types or not?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nJuergen Brendel wrote:\n&gt; \n&gt; Eric, I don&#39;t know you personally, but I applaud your insistence on\n&gt; your points. Sometimes people who insist on details to the point\n&gt; where others begin to roll their eyes are necessary to eventually\n&gt; help us see things more clearly.\n&gt; \n\nJust defending my work.  I&#39;ve posted my /date service example many\ntimes over the past few years:\n\nhttp://en.wiski.org/date?iso=2010-09-12\n\nThe most-prevalent feedback is that it would be more RESTful if,\ninstead of HTML, I were to define an application-specific media type\nwith an unregistered identifier.  This is how it goes with all my HTML\nexamples, so what good options am I left with?  Digging in at the\nexpense of people getting pissed off at me (right up to, and even a\nlittle past, the limits of my own sanity), seemed the best of a whole\npassle of bad alternatives.  Should I stop giving advice on rest-\ndiscuss anymore to avoid being mocked for suggesting not only using\nHTML, but that there are quantifiable advantages to doing so?\n\nFollowing the predominant advice being given would require me to write\na ton of out-of-band documentation I otherwise wouldn&#39;t have to bother\nwith, after massively increasing time-to-market for the service due to\nthe development of new types.  Really?  For /date?  It doesn&#39;t *do*\nanything, yet it would be more RESTful if only I&#39;d make it 10x more\ncomplicated?  So yeah, I thought this was an important point to raise.\nWhatever happened to the simplicity of being able to debug most REST\nsytems using common tools like browsers, instead of requiring custom\nclients?  I can debug /date in a browser, even though it isn&#39;t a &quot;web\nsite.&quot;\n\n&gt;\n&gt; Nevertheless, engineering (in the real world) is always about making\n&gt; the right compromises. I&#39;m sure we can all agree on that.\n&gt; \n\nAbsolutely!  But the feedback on /date advises me to make the wrong\ncompromise -- REST trades away efficiency in favor of scale; not re-\nusing HTML would be trading away scale for efficiency.  We first need\nto agree that each alternative involves such a tradeoff, before we\ncan discuss the implications of the alternatives.\n\nMy use of XBEL instead of HTML is sensible.  HTML is perfectly capable\nof expressing a hierarchical collection of annotated links, but no\nidentifier for HTML can instruct browsers to ask users if they&#39;d like\nto import that collection as bookmarks.  Until a registered identifier\nexists for XBEL, its use is limited to pointing a browser at a file\nknown to be XBEL from an in-chrome configuration, which isn&#39;t the\nhypertext constraint at all, so Content-Type doesn&#39;t matter, which is\nwhy everyone uses application/xml for XBEL (ugh).\n\nSo the deliberate choice to be NOT REST with my bookmarks (for a while,\nanyway) is a valid decision because there is currently no RESTful way\nto accomplish my goals, and therefore no benefit to my system from the\nre-use of _anything_ with a ubiquitous identifier for my bookmarks.\nOnly a new self-descriptive identifier will do, which means I need to\nIANA-register *something* which points to XBEL, even if it&#39;s in prs. to\nstart with. Otherwise I can only do what my XSLT code is doing now --\nconsuming it as XML -- and will never be able to instruct a browser to\nask users to import it using hypertext controls.\n\nI may never reach that goal even with registration, but it&#39;s certainly\nthe required place to start.\n\n&gt;\n&gt; While various specs and dissertations tell us (or imply) that IANA\n&gt; types are preferred and others are discouraged, the reality still\n&gt; comes in shades of gray. If someone doesn&#39;t use an IANA registered\n&gt; type, I won&#39;t tell them that their system is not RESTful if all other\n&gt; constraints are met. It may be only 95% RESTful, but for all\n&gt; practical purposes, that&#39;s &quot;good enough&quot;! It&#39;s RESTful. I&#39;m happy\n&gt; they are willing to put up with all the other REST constraints (which\n&gt; takes some effort) and give it a good shot. Everything can always be\n&gt; improved and maybe using IANA types would be an improvement. In the\n&gt; meantime, I applaud them for the effort.\n&gt; \n\nI sort-of agree.  If the identifier used looks like it&#39;s likely to be\nregistered, and such registration is pending, then pointing out that it\nisn&#39;t self-descriptive *yet* is nit-picking.  But if there&#39;s no\nintention to ever register the identifier and the context is the Web,\nit *is* important to identify that as a mismatch, if REST is to have\nany utility at all as a guide to the long-term development of the\nsystem.\n\nAlso, what are the stated goals of the system, how important to those\ngoals is the violated constraint, and is it really good enough or is\nthis an assumption that can&#39;t be made outside of the style, where\nresults aren&#39;t time-tested knowns, like they mostly are within the\nstyle?\n\nWhat I&#39;m driving at, is that it&#39;s a combination of all the constraints\nof a uniform interface which yield optimum results on the Web.  Leaving\none or two out means you can&#39;t expect to get the optimum results on the\nWeb, which are known to result from implementing *all* the constraints.\nIn which case, what yardstick are you measuring with?\n\nI&#39;m out there every day violating the self-descriptive messaging\nconstraint with one minor part of my system.  So that one mismatch\nisn&#39;t going to bother me at all, it&#39;ll work itself out eventually, at\nwhich time, if it&#39;s widely adopted, I will get some payoff for all that\ntime spent at &quot;95% REST&quot; because &quot;100% REST&quot; wasn&#39;t possible without a\nnew identifier, but will be, then.\n\nBut, if my system were dedicated to the exchange of bookmarks between\npeople and their various browsers, or with other people, IOW were built\naround XBEL, the system wouldn&#39;t be &quot;95% REST,&quot; it&#39;d be more like &quot;5%\nREST,&quot; and that would remain the case for a considerable amount of time\npending IANA approval, at which point that score starts to increase\ndepending on uptake.  Making the registration of an identifier what, 90%\nmore important for such a system as compared to mine?  ;-)  Maybe that&#39;s\nby design, for our own good...\n\n&gt; \n&gt; Maybe what we could say is that there is a series of degrees by which\n&gt; an architecture can be more and more RESTful. For example, the RMM\n&gt; ( http://martinfowler.com/articles/richardsonMaturityModel.html )\n&gt; doesn&#39;t mention media types at all! Yet, it discusses how an\n&gt; architecture can come closer to the REST ideal, by focusing on some of\n&gt; the other constraints.\n&gt; \n\nRe-reading Roy leads me to believe that there are degrees of RESTfulness\nbetween systems that implement *all* the constraints, and I believe we\nshould focus on that, rather than defining how RESTful it is to fail\none or more constraints.  You can implement all the constraints and\n*still* fail to be very RESTful if nobody else implements your\nprocessing model.  You can lead a horse to water, but you can&#39;t make it\ndrink.\n\nWith a registered identifier, it becomes possible for the existing\nWeb-based bookmark-exchange services to make importing an XBEL\ncollection of links into the browser as bookmarks, a hypertext\noperation.  It also becomes possible for Google to recognize\ncollections of bookmarks for exactly what they are, and re-use that\nknowledge to their advantage, usually with reciprocal benefit to the\nproducer.  Or it could be ignored...\n\nThe benefits of uptake accrue because the uniform interface is what\nmakes serendipitous re-use and anarchic scalability possible to begin\nwith.  These benefits aren&#39;t guaranteed to accrue with application/rss\n+xml because it doesn&#39;t explicitly define a processing model, only\nnarrows down the possibilities, even if it&#39;s approved, regardless of\nuptake -- it isn&#39;t self-descriptive if it requires introspection.\nLooks like RSS would&#39;ve been better off by choosing long ago to use the\nIETF RFC process, to me... maybe this is why IANA is picky about\nrecognizing standards bodies for standards-tree identifiers.\n\n&gt;\n&gt; I would say, let&#39;s agree that &quot;some level&quot; of RESTfulnes is better\n&gt; than none. We can describe the ideal system, but should realize that\n&gt; in the real world the ideal will rarely be reached. And to be really\n&gt; useful, we could try to outline which issues we would have to deal\n&gt; with for every constraint we chose NOT to implement 100%.\n&gt; \n\nActually, there can&#39;t be any &quot;fully RESTful&quot; system out there until\nsome successor protocol to HTTP comes along.  Chapter 6 explains some\ninherent REST mismatches in the existing architecture that we all have\nto accept for the time being.  They&#39;re important to understand, in\nterms of using REST as a tool to guide long-term development of systems.\n\nI would say that a minimal level of RESTfulness would be a network-\nbased API instead of a library-based API, IOW, a uniform interface is\nmore important than meeting cache or layered-system constraints -- or\neven, in this day and age, the client-server constraint.  REST prior to\nChapter 5 explains all the concepts being re-used, then Chapter 5\nexplains that the key feature of REST, the uniform interface, is based\non the principle of generality (i.e. re-use), then Chapter 6 discusses\nthe benefits and consequences of the re-use of MIME by HTTP, as well as\nother decisions about re-use in practice.\n\nSo it makes sense to me, to focus on re-use of standardized what-have-\nyous as an inescapable fundamental aspect of the style.  Or, put\nanother way, focus on the uniform interface constraints, they&#39;re harder\nto fix down the road if they&#39;re gotten wrong initially, unlike caching\nwhich you&#39;ll likely be fiddling with all the time anyway.\n\n&gt;\n&gt; Tomorrow I will give a talk about REST to some people and in preparing\n&gt; this talk, I just realized again that every time you don&#39;t design your\n&gt; system in a RESTful manner you end up having to hack around the way\n&gt; the Internet works for you. It (the Internet infrastructure, tools,\n&gt; systems, etc.) tries to be helpful, but can&#39;t if you don&#39;t have a\n&gt; RESTful system. If your system is RESTful, it all tends to fall in\n&gt; place so nicely, it&#39;s always amazing to see, almost beautiful in a\n&gt; way.\n&gt; \n\nExactly.  My self-interest as somebody who&#39;s decided to specialize in\nREST architecture, is to be able to teach the style through positive\nreinforcement by pointing to a variety of big-corporation REST APIs and\nexplaining why their design choices are *correct*.  If just one of\nthese corporations would actually give by-the-thesis REST a try for\nonce, I believe they&#39;d see an amazing and beautiful benefit to their\nbottom line, and actually consider the benefits of REST as an\narchitectural style instead of just as a buzzword, and evangelize\naccordingly...\n\nI can dream, can&#39;t I?  ;-)\n\n&gt;\n&gt; So, if we are insisting of various REST constraints, it might be good\n&gt; to fight that battle with the technical arguments, rather than quotes\n&gt; from specs.\n&gt;\n\nThat&#39;s what I thought I was doing by presenting arguments in Gopher, to\nbreak us out of the mindset of MIME types with IANA-syntax identifiers,\nin order to explain the difference between library-based and network-\nbased APIs, by drilling down to the fundamental technical essence of any\nuniform interface distributed hypertext application protocol.\n\nThe nut of the problem is the resource/representation dichotomy from\nwhich all else flows.  Some mechanism is required to send an identifier\nexternal to the payload, for expressing the sender&#39;s intended processing\nmodel, because this mechanism is what decouples representation from\nresource.\n\nThe implementation of this mechanism is perhaps the key distinction\nbetween uniform interface styles, and all other styles with a notion of\nresource vs. representation.  When an identifier is encountered, how do\nwe determine the shared understanding of what processing model it points\nto?\n\nIf the answer is to look up its normative reference in a spec, then\nit&#39;s prima facie evidence we&#39;re dealing with a network-based API.\nOTOH, if we have to make a case-by-case determination like we did by\nsearching for application/rss+xml in a DB of Apache code-commits, it&#39;s\nprima facie evidence we&#39;re dealing with a library-based API.\n\nYou can decouple resource from representation easily enough in practice,\nbut *how* you go about it makes all the difference between a uniform\ninterface network-based API (REST, Gopher or other style) and a library-\nbased API which misses the mark completely.\n\nIn Gopher (sorry to quote a spec, but it&#39;s legitimate to understand\nREST by comparing and contrasting known specs which instantiate the\nresource/representation dichotomy even if they don&#39;t call it that), if\n&#39;h&#39;=HTML came between &#39;g&#39;=GIF and &#39;i&#39;=plaintext, then it would also be\na self-descriptive identifier, one required distinction of any network-\nbased API (extensible registry like HTTP, or baked-in like Gopher).\n\nInstead, in order to discover the shared understanding of &#39;h&#39;=HTML, we\nneed to go digging through the code libraries of daemons and browsers\nwhich implement the Gopher protocol.  That *use* of Gopher constitutes\na library-based API, whereas using Gopher&#39;s self-descriptive identifiers\nconstitutes a uniform interface.  The failure of Gopher to allow the\nevolution of new identifiers/types without versioning the spec, is a\nstrong argument in favor of REST/HTTP requiring a registry.  Having a\nregistry is a requirement of a RESTful uniform interface, not network-\nbased APIs in general.\n\n&gt; \n&gt; The same analysis could be made for every constraint. Then, as an\n&gt; engineer, I can make an informed decision to implement a RESTful\n&gt; system (yes, still &#39;RESTful&#39;), which ignores a particular constraint\n&gt; with open eyes, for a particular, technical reason I might have.\n&gt; \n\nOr even within the same constraint.  Another key distinction between a\nlibrary-based API and a network-based API is the use of standardized\nmethods.  Gopher has no method other than the general retrieval\nmethod.  HTTP has evolved to include... the IANA HTTP Method Registry!\nThis conversation has crossed over into discussion of nonstandardized\nmethods.  No, they aren&#39;t RESTful, and no, I don&#39;t wonder why they\ncan&#39;t be, not on the Web.\n\nAll the same arguments apply -- if I can look up your method name in a\nregistry, your network-based API messaging is self-descriptive.  If I\nneed to go digging through some codebase to determine what the shared\nunderstanding of your method name might be, it&#39;s a library-based API\nwhich is fundamentally opposed to any uniform interface style.  Using,\nof course, concepts and definitions of terms from Roy&#39;s thesis, but ad-\nlibbing to avoid having to quote specs extensively to back up what\nshouldn&#39;t be a controversial position.\n\nConversely, I believe that REST no more encourages willy-nilly creation\nof new data types with IANA-unregistered identifiers than it encourages\nrequest method = WINGIT.  There&#39;s a fundamental difference between\nlibrary-based and network-based APIs, only one of which may be remotely\nconsidered a &quot;uniform&quot; interface based on the principle of generality\n(Gopher section 4 makes no mention of said principle, but the spirit of\nwhat&#39;s being said is exactly the same).\n\n&gt;\n&gt; Help me to make the right compromises! For example, if intermediaries\n&gt; on the Internet don&#39;t understand my media type, what could be some of\n&gt; the technical consequences/risks? That only needs to be stated once,\n&gt; clearly, and then the discussion can be over and done with. Because\n&gt; once it is communicated we have the knowledge to make informed\n&gt; decisions.\n&gt;\n\nI wish the simple takeaway here could be to not look for loopholes like\n&quot;discouraged&quot; in the specs.  The strongest technical argument I have\never been able to make as regards the configuration of any Internet\nprotocol for any purpose, is that you can&#39;t operate outside the RFCs\nand yet still _expect_ interoperability.\n\nIf you aren&#39;t doing the things which are required to achieve the\nexpected results, you can&#39;t expect those results to be achieved, and\nit&#39;s this lack of benefit that&#39;s more important than any discussion of\nthe consequences, which by necessity spreads out into all sorts of\ndifferent intermediary behaviors, and we already went down that road in\nthis discussion.\n\nIf you&#39;re choosing to ignore a constraint, you ought to be able to\narticulate the perceived benefit to your system, like I did above with\nXBEL, instead of requiring a detailed list of all the things that could\ngo wrong -- which nobody can possibly know, but the more experienced\namongst us know are lurking everywhere (see how quickly http-wg and TAG\ndiscussions stipulate to not having any idea *what* intermediaries may\nbe up to these days).\n\n&gt;\n&gt; You always here that discussions about REST can take on an somewhat\n&gt; scary religious intensity. Let&#39;s avoid that. If I don&#39;t adhere to a\n&gt; constraint I won&#39;t burn in hell. I might have to deal with some\n&gt; technical issues eventually, but that&#39;s something I may chose to deal\n&gt; with. Quotes won&#39;t convince me, but technical arguments may under some\n&gt; circumstances.\n&gt; \n\nYou can&#39;t operate outside the uniform interface and expect to have any\nyardstick by which to judge your system&#39;s performance.  Any uniform\ninterface network-based API is based on not going outside of what&#39;s\nbeen explicitly defined as compatible, unless there&#39;s compelling need\nto add something new.  Behavior outside the uniform interface is\nundefined -- you can&#39;t reliably benchmark your caching decisions over\ntime without a registered identifier, because you can&#39;t be certain your\nmessages aren&#39;t being ignored by the majority of caches.\n\nYou can&#39;t test your system against the Internet, you can only model it\nagainst what&#39;s known to work, and I promise you that everything that&#39;s\nknown to work has been standardized.  Which doesn&#39;t preclude new\nstandards from evolving, of course -- just sayin&#39; that the proof that\nsomething *is* known to work, is ubiquitous uptake, i.e.\nstandardization, which is why standardization is so central to REST.\n\nMaybe the extent to which I&#39;ll go to make a point about standardization\nis scary, but I believe my insistence on it is technically sound, and\nhas everything to do with following RFCs for 17 years, rather than\nbeing my attempt at shamanism.  :-)\n\n-Eric\n\n"}}