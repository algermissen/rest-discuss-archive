{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"92AFoZrAO0nYA9-Fl_jkMZ6rKpZEPBz_2o3fvRjgFnK7V6fkB0kkJMUpMEHEM77y5NKjDUkq7EXaJrPiby7Ph-iWdOwwl7vo8vbnO7T5xw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: HTML REST API example [was: Link relations]","postDate":"1292023738","msgId":17100,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAxMjEwMTYyODU4LmMxN2M2MGE5LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PGlkdGYzYSt2NzFtQGVHcm91cHMuY29tPg==","referencesHeader":"PDIwMTAxMjEwMDUwOTUzLmViMjVhYjMzLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPGlkdGYzYSt2NzFtQGVHcm91cHMuY29tPg=="},"prevInTopic":17099,"nextInTopic":17102,"prevInTime":17099,"nextInTime":17101,"topicId":17057,"numMessagesInTopic":43,"msgSnippet":"... Right, but what I m trying to explain is that once we move past that, we re beyond the scope of REST.  While it s fine to discuss the issues here, media","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 48491 invoked from network); 10 Dec 2010 23:29:01 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m16.grp.re1.yahoo.com with QMQP; 10 Dec 2010 23:29:01 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 10 Dec 2010 23:29:01 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id BE5A8509D9;\n\tFri, 10 Dec 2010 18:28:59 -0500 (EST)\r\nDate: Fri, 10 Dec 2010 16:28:58 -0700\r\nTo: &quot;wahbedahbe&quot; &lt;andrew.wahbe@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20101210162858.c17c60a9.eric@...&gt;\r\nIn-Reply-To: &lt;idtf3a+v71m@...&gt;\r\nReferences: &lt;20101210050953.eb25ab33.eric@...&gt;\n\t&lt;idtf3a+v71m@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: HTML REST API example [was: Link relations]\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\n&quot;wahbedahbe&quot; wrote:\n&gt;\n&gt; Let&#39;s move past that and assume we are not suggesting a media type\n&gt; for each type of resource (or even a subset of resource types).\n&gt;\n\nRight, but what I&#39;m trying to explain is that once we move past that,\nwe&#39;re beyond the scope of REST.  While it&#39;s fine to discuss the issues\nhere, media type and data type design aren&#39;t constrained by REST, which\nconstrains how media and data types are *used* in API design; with the\ngoal of standardization of any new types, with just enough procedural\nhurdles to limit proliferation of lookalike types (i.e. this is &quot;just\nlike Atom&quot; except for a twist, when the twist is an allowable extension\nwithin the existing media type).  IOW, it isn&#39;t just resource types and\ntheir subsets, it also isn&#39;t about domain-specific media types; except\nwhen that problem domain simply can&#39;t be addressed by re-using\n(extending) existing ubiquitous types (the uniform interface).  You can\nattempt to extend the uniform interface if you want, I prefer to use it\nas-is whenever possible.\n\n&gt;\n&gt; I think the differences between the two approaches are subtle and\n&gt; worth discussing, but let&#39;s get past the is/isn&#39;t RESTful arguments.\n&gt; \n\nJSON works just fine for transferring name-value pairs with a minimal\ndegree of typing.  But it doesn&#39;t constitute a hypertext API; it needs\nhypertext controls describing how the JSON is manipulated.  One\npossibility is Code on Demand within HTML, to provide a self-documenting\nAPI which describes what the variables are and delimits the values they\nmay contain (and, what they *mean*, for the m2m case).  Another\npossibility is JSON schema, the point is having a self-documenting\nhypertext API using ubiquitous types.  Beyond that, machine readability\n(self-describing vs. self-documenting or self-descriptiveness) is a\ncomponent-layer concern, outside the scope of REST.\n\nThis debate inherently toes the line between REST/NOT REST; I argue\nagainst solutions which implement m2m at the connector layer (making it\na REST problem), in favor of handling it at the component layer (moving\nthe problem outside of REST considerations).  If the starting point of\nyour API design process is to reject HTML (etc.) out-of-hand in favor of\ncreating new types (even if standardizable), you&#39;re working far too\nhard, because you&#39;ve started at the wrong layer (this isn&#39;t a REST\nproblem, so don&#39;t muck about creating new messaging semantics between\nconnectors unless your API really is a unique snowflake you expect to\nbe widely adopted quickly enough to get any ROI from REST implemented\nthat way -- which comes with no guarantee if standardization fails or\nuptake is insignificant).\n\n&gt;\n&gt; Now let&#39;s instead ask: for a given machine-client, is it better to use\n&gt; HTML (or another existing format) with RDFa/microformats/etc. layered\n&gt; on top or to design a hypermedia format specifically for that type of\n&gt; client. What are the pros and cons of layering a data model (that is\n&gt; not universally understood by all clients supporting the format) on\n&gt; top of a standard format vs. defining a new *standard* (or perhaps\n&gt; *standardizable*) format for a client when existing formats do not\n&gt; seem to be sufficient?\n&gt; \n\nThe reason RDFa obsoletes microformats (my aging demo code is an\noutdated hodgepodge) is the parsing model.  I came at this from the\nstandpoint of using RDFa to replace microformats, not as any sort of\nholy grail, only realizing the value in terms of REST much later -- what\nkept me away from the RDF world before the advent of RDFa was the\nunRESTfulness of the systems using it and the awkward-at-best\nintegration with HTML.  RDF never would&#39;ve clicked on that light bulb\nin my brain if it hadn&#39;t been for the microformats effort.  Embedding\nm2m RDF in h2m HTML enables a powerful RAD approach to the domain-\nspecific vocabulary problem, without mistaking it for a connector-layer\nproblem requiring a new standardized hypertext language to solve.  Thus\nsimplifying REST development, while the developer builds skills which\ntransfer from one REST project to the next (instead of creating or\nlearning a new markup language and processing model for each project).\n\nAnyway, the parsing model.  Each microformat has its own parsing model.\nSo out-of-band knowledge of the microformat is a prerequisite.  RDFa is\na generic parsing model based on link relations.  We&#39;re past self-\ndescriptiveness here, and into self-describing -- we don&#39;t want domain-\nspecific vocabularies to need formal standardization, what&#39;s required\nis a distributed mechanism for ad-hoc adoption using namespaces to\navoid naming collisions.  My example API re-uses FOAF and Dublin Core,\nbut could just as easily re-use a nonstandardized specification like\nGoodRelations.  We&#39;re beyond the scope of the uniform interface where\nstandardization matters, since the problem being solved has no impact\non messaging between connectors; so there&#39;s no need of a registry --\nRDFa is a generic parsing model for distributed, ad-hoc adoption of\nvocabularies without the procedural hurdles required for centralized\nmanagement of media types, data types and link relations in an orderly,\nuniform-interfacey manner.\n\nSo the bar for adoption is much lower, due to the wide availability of\nHTML, Atom and RDFa parsers.  If you define a new standardizable data\ntype and register a proper media type for it, you delay the benefits of\nREST until not only multiple, independent, interoperable systems make\nuse of it (standardization vs. specification), but they achieve ubiquity\nas well (wide availability of libraries and tooling).  Working within\nthe *existing* uniform interface is capable of achieving the benefits\nof REST from the get-go, particularly as RDFa support is added to other\nmarkup languages.  Lower development costs, and quicker time-to-market\nresult from using off-the-shelf libraries and avoiding standardization\nprocess delays and overhead.\n\nThe API is just the name-value pairs; that&#39;s self-descriptive with HTML\nand in many cases JSON (HTML forms and JSON schema delimit the allowed\nvalues).  But some mechanism is needed to describe the interaction with\nthe name-value pairs of the connector-layer API, at the component layer,\nto avoid having to treat this as a problem best solved by minting new\nmedia/data types.\n\nLayering a self-describing mechanism on top (the component layer) only\nhas any real value if it&#39;s a generic parsing model with a wide range of\nvocabularies available in the public domain.  Creating a vocabulary and\nhaving it adopted is much simpler than minting data/media types, in\nthat it doesn&#39;t require standardization or mass uptake to be effective\nwithin the REST style.  Particularly since common patterns may be\nexpressed using FOAF and/or Dublin Core, or other standardized\nvocabularies, reducing development costs and time-to-market even\nfurther by allowing a mix-and-match approach -- how would that work if\nevery permutation required a new media type to describe exactly the\nsame processing model?\n\nSerendipitous re-use comes not from being useful in browsers, but by\nnot requiring uncommon libraries to build components (client, server or\nintermediary) which use your API.  Also, you shouldn&#39;t be setting up a\nmust-understand situation; a user-agent that doesn&#39;t grok RDFa being\ndriven by a human works as a fallback because the paradigm is must-\nignore.  There is no guarantee that a purpose-built type, even if it\nachieves standardization, will ever have the scalability of HTML out-\nof-the-box.  Or take progressive rendering into consideration, or have\njavascript bindings or accessibility APIs, all of which contribute to\nthe overall goals of REST adoption.\n\n&gt;\n&gt; For example, in a bank I can use HTML for the tellers machines, web\n&gt; banking (and likely even Automated Teller Machines) and VoiceXML for\n&gt; phone banking apps and use conneg (or even just separate URI spaces)\n&gt; to choose between them.\n&gt; \n&gt; If I want a RESTful interface for automated check processing machines\n&gt; would it be better to: a) create an format specifically for check\n&gt; processing machines (not specific to my banks resource types, e.g.\n&gt; application/checkproc+xml); or b) use HTML with a &quot;check processor&quot;\n&gt; data model layered on top.\n&gt; \n\nOK, I&#39;ll humor you, but there are already electronic interchange\nformats for this sort of thing; besides, such systems have requirements\nwhich don&#39;t make them good candidates for REST.\n\n&gt;\n&gt; I prefer (a) and I don&#39;t think it violates any REST constraints at\n&gt; all. Standardizing the format would allow a bank to buy check\n&gt; processing machines from any vendor, plug them in, configure a single\n&gt; URI and go.\n&gt;\n\nOnly if the media/data types are not only standardized, but also\nubiquitous enough to actually be used in lieu of proprietary solutions\nwidely enough to foster competition.  It takes time, whereas ubiquitous\ntypes are insta-REST-enabled.\n\nYou&#39;re making an assumption that I require your check format to be\nHTML.  I don&#39;t.  REST requires a self-documenting hypertext API which\ndescribes how to manipulate that format, most likely HTML because\nthat&#39;s exactly the sort of thing HTML is designed for and excels at,\nwith RDFa raising the intriguing possibility of polyglot documents\nwhich effectively target both human and machine users, via agents built\naround the same widely-available libraries and vocabularies.  Speaking,\nas usual, pragmatically of Web instantiation of the style, rather than\nsaying REST normatively requires HTML or anything of the sort, of\ncourse.\n\nMy view here, is that an m2m data type can either be a polyglot based\non HTML, or a machine-oriented standalone on which an HTML interface is\nbased; either way, I consider the HTML (or whatever) to be mandatory\nactive online API documentation (the hypertext constraint), whether\ncomponents are hard-coded to it or follow a standardized parsing model\nto infer the meaning of the hypertext controls self-describing how the\nAPI is manipulated via representation.\n\n-Eric\n\n"}}