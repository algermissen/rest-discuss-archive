{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"XHg6Rg3htybh7HRQtVHI-vUV2dInC-CSUvWANQSrub1_I4kKaWWlCx9LjUS_3xUn9KGc-xn3JVrPdyMIRV3XClf6M5CoJP4E7DVtgbA3XQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] PUT/POST content type hints","postDate":"1273606180","msgId":15349,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNTExMTMyOTQwLjRjYjQ2Mjg0LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDRCRTk1MUNFLjMwNzAzMDhAc2l0ZXBlbi5jb20+","referencesHeader":"PEFBTkxrVGlseHpTY21NV1A4SndSclF0cTFyRHpOLU5VQzFrMjZyeUU0b2N3VUBtYWlsLmdtYWlsLmNvbT4JPDRCRTg2RjU4LjYwNjAyMDlAc2l0ZXBlbi5jb20+CTwyMDEwMDUxMTA0MzE0Ny5mOTVjYWU1MC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTw0QkU5NTFDRS4zMDcwMzA4QHNpdGVwZW4uY29tPg=="},"prevInTopic":15343,"nextInTopic":15400,"prevInTime":15348,"nextInTime":15350,"topicId":15322,"numMessagesInTopic":12,"msgSnippet":"... I don t follow.  The media type of a response to a GET request is a function of the client s Accept request header.  To override conneg, one uses the URI","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 40647 invoked from network); 11 May 2010 19:30:04 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m1.grp.sp2.yahoo.com with QMQP; 11 May 2010 19:30:04 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.re1.yahoo.com with SMTP; 11 May 2010 19:30:03 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id DC4B7509E2;\n\tTue, 11 May 2010 15:29:59 -0400 (EDT)\r\nDate: Tue, 11 May 2010 13:29:40 -0600\r\nTo: Kris Zyp &lt;kris@...&gt;\r\nCc: REST-Discuss Discussion Group &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100511132940.4cb46284.eric@...&gt;\r\nIn-Reply-To: &lt;4BE951CE.3070308@...&gt;\r\nReferences: &lt;AANLkTilxzScmMWP8JwRrQtq1rDzN-NUC1k26ryE4ocwU@...&gt;\n\t&lt;4BE86F58.6060209@...&gt;\n\t&lt;20100511043147.f95cae50.eric@...&gt;\n\t&lt;4BE951CE.3070308@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] PUT/POST content type hints\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nKris Zyp wrote:\n&gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; I believe one should be able to assume that the content type of\n&gt; &gt; &gt; the representation returned from a server from GET for URI is\n&gt; &gt; &gt; acceptable in a PUT request to that server for the same URI.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; Absolutely not. The late binding of representation to resource\n&gt; &gt; precludes this assumption. HTML is capable of providing an interface\n&gt; &gt; to an Atom system. What media type to PUT or POST to the system is\n&gt; &gt; explicitly provided in the markup, i.e. a self-documenting\n&gt; &gt; interface.\n&gt; &gt;\n&gt; &gt; Assuming that you can PUT or POST HTML to my system because that&#39;s\n&gt; &gt; the media type I sent on GET would not work -- I derive HTML from\n&gt; &gt; Atom, not the other way around.\n&gt; &gt;\n&gt; &gt; A PUT of an HTML document would show an intent to replace the\n&gt; &gt; self-documenting interface provided by the HTML representation, with\n&gt; &gt; some other application state. HTML is generated by my system, it is\n&gt; &gt; not subject to change via PUT to negotiated resources which happen\n&gt; &gt; to return text/html or application/xhtml+xml on GET with a Web\n&gt; &gt; browser, but happen to return Atom to a feed reader.\n&gt; &gt;\n&gt; \n&gt; I definitely agree that this assumption can be wrong, and a 415 could\n&gt; be returned with directions about what media type is acceptable. Or\n&gt; the client&#39;s preferred media type may override the GET&#39;s content type\n&gt; (in which case he probably wouldn&#39;t be asking this question).\n&gt;\n\nI don&#39;t follow.  The media type of a response to a GET request is a\nfunction of the client&#39;s Accept request header.  To &quot;override&quot; conneg,\none uses the URI assigned to the desired variant, instead of the\nnegotiated URI.  The client&#39;s desired media type will in no way affect\na non-negotiated resource.\n\nOn my system, one may directly dereference Atom representations by\nusing .atom extensions -- each variant representation is a resource in\nits own right.  Even so, REST isn&#39;t based on making assumptions about\nbeing able to PUT that .atom file back after editing it, by virtue of\nits media type being application/atom+xml.\n\nThe only allowable change for the requesting user, may be to change the\ntags associated with a post.  This could be done via PATCH, or via PUT\nto a subordinate resource, in either case using application/atomcat+xml.\nOnly the hypertext API can tell me this.\n\nIn REST, these specifics are communicated via hypertext.  A user agent\nfollowing its nose couldn&#39;t possibly run into a 415 error.  If it does,\nthe correct response from the broken server that led the user agent\nastray in the first place with incorrect hypertext, should be 500.\n\nI suspect you&#39;re expecting your dog to throw you the frisbee...  ;-)\n\n&gt;\n&gt; But\n&gt; requiring a client to simply &quot;know&quot; what media type the server needs\n&gt; (when the client could encode in multiple media types) rather than\n&gt; attempting to use the same media type from a GET would obviously\n&gt; require out of band information and badly violate REST.\n&gt; \n\nNo, both are equally bad violations of REST.  What media type to\nassociate with a PUT, POST or PATCH request must be explicitly stated\nin the hypertext which instructs user agents *how* to make PUT, POST or\nPATCH requests (by &quot;how&quot; I mean, is the request required by the system\nto be conditional, and such).\n\nIf you&#39;re relying on the assumption that the media type returned with a\nGET has anything to do with instructing the client what media type to\nuse for PUT, POST or PATCH then your API is based on out-of-band\ninformation that is not common knowledge encompassed within a media\ntype definition.\n\n&gt; \n&gt; RFC 2616 is sufficient for describing the semantics of PUT and DELETE.\n&gt; I don&#39;t need to know anything besides what RFC 2616 has clearly\n&gt; described.\n&gt; \n\nYes, you do, in REST.  HTTP describes a range of possible semantics for\nsome methods.  REST APIs must describe the specific method semantics as\nimplemented on your system, using standard media types.  HTTP allows you\nto DELETE an Atom Media Entry.  REST constrains that deletion to behave\nin accordance with the media type, i.e. the media file must also be\ndeleted.\n\nDELETE behavior on a collection resource is undefined in HTTP and Atom,\nmeaning the Atom media type allows different behaviors.  So a REST API\nmust self-document the DELETE behavior on collections, or even offer\nthe user a choice of behaviors.  HTTP does not a REST API make, there\nmust be hypertext instructing the user agent *how* to DELETE.\n\n&gt; \n&gt; JSON Schema effectively provides a forms language:\n&gt; http://tools.ietf.org/html/draft-zyp-json-schema-02\n&gt;\n\nI&#39;m sure you know more about the workings of the IETF than I do, but I\ndon&#39;t see how you can register application/schema+json without first\nrevising the JSON media type identifier definition to allow for this\nextensibility.  You should also reference RFC 3986, rather than 2396.\n\nIn my opinion, JSON lacks the basis for a schema language which defines\nlinking and forms.  This is significantly beyond the scope of JSON-as-\nwritten.  What you&#39;re after is a schema language for application/\nhyperjson, i.e. first you need a structured JSON language, then you\nhave the basis for schema on top of it.  Or somesuch.\n\n&quot;This specification is protocol agnostic.  The underlying protocol\n(such as HTTP) should sufficiently define the semantics of the\nclient-server interface, the retrieval of resource representations\nlinked to by JSON representations, and modification of those\nresources.&quot;\n\nNot really.  HTML markup implies GET in several ways, in addition to\ndefining GET as used in forms, but does not specify protocol.  Standard\nmethods are cross-protocol, with protocol determined by the URI.  An\nHTML form can just as easily GET and PUT FTP URIs as HTTP URIs.  This is\npart of the protocol-agnostic REST style, which relies on standard\nmedia types to constrain method semantics (or hypertext, where the\nmedia type lacks such constraints).\n\nAtom Protocol, for example, constrains the application/atom+xml media\ntype&#39;s method implementation.  HTTP allows PUT to create and/or replace\na resource.  REST constrains PUT to mean either create or replace for\nall resources on your system -- varying PUT semantics by media type is\nnot allowed.\n\nIn a REST system which implements Atom Protocol, PUT is constrained to\nreplacement semantics by the application/atom+xml media type.  Creation\nsemantics are assigned to POST.  The underlying protocol does _not_\nsufficiently define these semantics for REST, because the REST style is\nprotocol-agnostic.\n\nMethod semantics are defined by the protocols which implement them\n(HTTP, FTP etc.).  In REST, method implementation is constrained by\nmedia type (or API).  If Atom Protocol method semantics were left to the\nunderlying protocol, there wouldn&#39;t be interoperability because some\nsystems would use PUT to create, while other systems would use POST, due\nto the unconstrained nature of standard method semantics.\n\nIf a JSON schema language is to be of any use in REST development, then\nit must allow for the constraint of standard method semantics.  So\nfirst, there must be a JSON language which provides data structures for\ntraversal of a link (as with &lt;a href&gt;) vs. inclusion of a link (as with\n&lt;img src/&gt;) vs. processing instructions (as with &lt;link rel=\n&#39;stylesheet&#39;/&gt;), I think.\n\nNote that the media type, as with HTML, would define all of these cases\nas GET.  What your draft lacks, is any means to instruct user agents to\nfetch a resource for inclusion, vs. traversing the link and presenting\nthe retrieved representation as the next steady-state.  There&#39;s also no\nway to communicate constraints on method semantics, i.e. to assign PUT\nreplacement semantics and assign POST creation semantics, or vice-versa\ndepending on the needs of the schema/API developer.\n\nI believe what you&#39;re trying is possible, but it&#39;s my opinion that you\nhave enough in there for two separate proposals, while lacking the tools\nI would need to implement it as a REST developer.\n\n-Eric\n\n"}}