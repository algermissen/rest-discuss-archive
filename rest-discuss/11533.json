{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":364579677,"authorName":"Mike","from":"Mike &lt;mike@...&gt;","profile":"pleb1985","replyTo":"SENDER","senderId":"nhjLfLEAofWerUtw2vBn1KTKB2J8g_pA7LKfzN4TiQob2Dsfiu2n1wg9pbOqwE2OJi6X0DeYYA1ibJLayDi6nA","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] HTML5 and RESTful HTTP in browsers","postDate":"1227029888","msgId":11533,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ5MjJGRDgwLjkwNjA5MDZAbXlrYW5qby5jby51az4=","inReplyToHeader":"PDIwMDgxMTE4MDgxMzM2LmYxNTY5ZTg1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PDIwMTUxMDEwLjIzNjg3MTIyNjkxOTk1NDUzMi5KYXZhTWFpbC5zZXJ2bGV0QGt1bmRlbnNlcnZlcj4JPDIwMDgxMTE4MDA1OTQ5LmFiNzQ0YmVkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDQ5MjJCMzZBLjMwOTA4MDRAbXlrYW5qby5jby51az4gPDIwMDgxMTE4MDgxMzM2LmYxNTY5ZTg1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":11532,"nextInTopic":11534,"prevInTime":11532,"nextInTime":11534,"topicId":11508,"numMessagesInTopic":82,"msgSnippet":"... There is no practical reason to modify User-Agent in markup, the UA is probably the best indicator of this header, so I don t see how that is relevant","rawEmail":"Return-Path: &lt;mike@...&gt;\r\nX-Sender: mike@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 21967 invoked from network); 18 Nov 2008 17:32:40 -0000\r\nX-Received: from unknown (66.218.67.96)\n  by m36.grp.scd.yahoo.com with QMQP; 18 Nov 2008 17:32:40 -0000\r\nX-Received: from unknown (HELO moutng.kundenserver.de) (212.227.17.8)\n  by mta17.grp.scd.yahoo.com with SMTP; 18 Nov 2008 17:32:39 -0000\r\nX-Received: from [192.168.10.13] (evojsyfw02.evolve-online.com [213.133.221.98])\n\tby mrelayeu.kundenserver.de (node=mrelayeu0) with ESMTP (Nemesis)\n\tid 0MKwh2-1L2URI41ZF-0004dQ; Tue, 18 Nov 2008 18:32:38 +0100\r\nMessage-ID: &lt;4922FD80.9060906@...&gt;\r\nDate: Tue, 18 Nov 2008 17:38:08 +0000\r\nUser-Agent: Thunderbird 2.0.0.17 (X11/20080925)\r\nMIME-Version: 1.0\r\nTo: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;, \n rest-discuss@yahoogroups.com\r\nReferences: &lt;20151010.236871226919954532.JavaMail.servlet@kundenserver&gt;\t&lt;20081118005949.ab744bed.eric@...&gt;\t&lt;4922B36A.3090804@...&gt; &lt;20081118081336.f1569e85.eric@...&gt;\r\nIn-Reply-To: &lt;20081118081336.f1569e85.eric@...&gt;\r\nContent-Type: text/plain; charset=US-ASCII; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Provags-ID: V01U2FsdGVkX18bjeYIBRn6VCvjrPJwsFb/TO4E3+eAScJXGeP\n 26L7d5BzdRVrc6pGkZpSnX8baOo5v0uUiNEHCkc8R/OOe6Z4um\n BqgZi4mOfPnB3/dN0nJPdvcVTeQOiGM\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Mike &lt;mike@...&gt;\r\nSubject: Re: [rest-discuss] HTML5 and RESTful HTTP in browsers\r\nX-Yahoo-Group-Post: member; u=364579677; y=Py_qHeDUkJo6knJkh9pyxm-CCIr5nPORvbJyCnUhWnQFE-Q\r\nX-Yahoo-Profile: pleb1985\r\n\r\nEric J. Bowman wrote:\n&gt;&gt; Maybe someone can correct me here, but as I understand it; content\n&gt;&gt; types served at a given URI are effectively that given resource&#39;s\n&gt;&gt; representations.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; Errr, uhhh, a Content-Type is not a representation.  A URI may serve\n&gt; multiple representations, but there&#39;s no requirement for a 1:1\n&gt; relationship with MIME type.  A URI may serve HTML 4.01 to some clients\n&gt; and XHTML 1.0 to others, both as text/html, with content negotiation\n&gt; based on User-Agent rather than Accept, even.  Or, a URI may serve two\n&gt; different representations of an HTML 4.01 page, both served as\n&gt; text/html, one zipped and the other raw, with content negotiation based\n&gt; on Accept-Encoding.\n&gt;   \n\nThere is no practical reason to modify User-Agent in markup, the UA is \nprobably the best indicator of this header, so I don&#39;t see how that is \nrelevant here.\n\nAccept-Encoding; again I can&#39;t think of a practical use for specifying \nthis in markup.\n\n&gt; Compressing content is an example of conneg in everyday use.  When you\n&gt; implement GZIP on your server&#39;s output, you double the number of\n&gt; representations for each resource. If the compression is done\n&gt; beforehand rather than on-the-fly, the response headers should include a\n&gt; Content-Location with the URI of either the raw or the compressed\n&gt; representation.  I would want to directly reference any stored file,\n&gt; but could care less about directly referencing different output streams.\n&gt;\n&gt; Because there&#39;s no need to directly reference either the raw or the\n&gt; compressed representation as streams, there&#39;s no need to make them\n&gt; separate resources with different URIs.  There&#39;s no need to implement\n&gt; this negotiation in markup, nor would it make sense to do so. If I want\n&gt; to dereference the compressed representation as a stream, I just need to\n&gt; make sure the request includes Accept-Encoding: gzip, but since this\n&gt; representation has no URI it can&#39;t be directly referenced (bookmarked).\n&gt;\n&gt;   \n\nNot sure what you&#39;re getting at here, sorry.\n\n&gt;&gt; A URI should be used to indicate a resource, but (even though it is \n&gt;&gt; possible) is it good practice for a resource to indicate a \n&gt;&gt; representation? Clearly, this is common practice now, whether it is a \n&gt;&gt; query parameter or a &#39;file extension&#39; - but it seems to me that this \n&gt;&gt; violates the principal of what a resource is (at least according to\n&gt;&gt; my interpretation of  the definition in Roy&#39;s dissertation). I would\n&gt;&gt; argue that the reason for this is because HTML has not provided\n&gt;&gt; browsers with a hypertext mechanism for protocol conneg. I think\n&gt;&gt; developers should at least be given the option, personally.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; A resource is anything identified by a URI.\n\nIs it? I thought that people often misuse URIs to represent other \nhorrible things like.. methods!\n\n&gt; In the case of a\n&gt; negotiated URI with multiple representations, each representation may\n&gt; be a resource in its own right, you just have to assign it a URI.\n\nI noticed you used the word &#39;may&#39;. It pretty much has to as it stands, \nunless I use Javascript to control the Accept header in requests.\n\nI don&#39;t really see the value in distinguishing a representation of a \nresource as a resource in it&#39;s own right, other than working around \ninsufficiencies in technologies like HTML that prevent developers from \nindicating where a particular representation of a resource is appropriate.\n\nI would turn that on it&#39;s head and ask; Why do you want to make so many, \nessentially, superfluous URI&#39;s? What is gained by doing this with a \nrepresentation that is already addressable from this URI with the \ncorrect Accept headers?\n\n&gt; It\n&gt; is not bad practice to do this, it&#39;s how content negotiation is\n&gt; properly done (in most cases, the prominent exception being\n&gt; compression).  There&#39;s no violation of Roy&#39;s definitions of resource or\n&gt; representation here.\n&gt;\n&gt;   \n\nIt&#39;s how content negotiation is *presently* done. I&#39;d always understood \nResource as reference to any given abstract entity; &quot;report.html&quot; \ndoesn&#39;t seem very abstract to me.\n\n&gt; Content negotiation has nothing to do with HTML, really.\n\nYou&#39;re correct. That is the reason I have brought this up - to get give \ndevelopers the opportunity to make browsers negotiate content better - \nwithout having to embed it in URIs.\n\n&gt;  XForms or\n&gt; JavaScript allows a document author or generator to override request\n&gt; headers, overriding conneg is a different problem than implementing it.\n&gt; Since conneg is handled at the protocol level, it would be silly to\n&gt; implement it in markup, IMO.  HTML doesn&#39;t need its own content\n&gt; negotiation mechanism, just a way to override the client&#39;s request\n&gt; headers without using JavaScript.\n&gt;\n&gt;   \n\nMy initial suggestion was &quot;just a way to override the client&#39;s request \nheaders without using JavaScript&quot;. I don&#39;t see how this can be achieved \nwithout adding this into markup, what&#39;s your alternative?\n\n&gt;&gt; Isn&#39;t one of the benefits of statelessness that any state can be\n&gt;&gt; stored by a user (i.e. bookmarked)? If browsers aren&#39;t currently\n&gt;&gt; providing this functionality in a way which leverages these benefits\n&gt;&gt; - I agree entirely that it is not feasible to completely discount\n&gt;&gt; conneg over URIs, but if no movement is made to have HTML encourage\n&gt;&gt; browsers to be better HTTP clients, it is likely that nothing will be\n&gt;&gt; done about it.\n&gt;&gt;\n&gt;&gt;     \n&gt;\n&gt; A negotiated URI is easily bookmarked.  All variants represent the same\n&gt; state, though.  The property of being compressed or not, is wholly\n&gt; separate from application state.  Receiving a JPEG instead of a PNG\n&gt; doesn&#39;t change the application state.  Subsequent requests for a\n&gt; bookmark will return the same response, unless the server&#39;s algorithm\n&gt; has changed, or the client is upgraded and its request headers have\n&gt; changed.  This may change the format of the response, but not the\n&gt; application state represented by the response.\n&gt;\n&gt; There&#39;s no valid reason for a client to store request headers\n&gt; as part of the bookmark, this would defeat the entire purpose of\n&gt; content negotiation, not to mention evolvability. If there&#39;s some reason\n&gt; to bookmark a specific representation, then use the URI which identifies\n&gt; that representation as its own resource (if available), don&#39;t try\n&gt; storing the request headers and re-sending them -- that is not the Web\n&gt; architecture.\n&gt;   \n\nI wouldn&#39;t store all of the request headers, only the ones that were not \ndefault.\n\n&gt; HTTP headers are client specific, not request specific -- headers don&#39;t\n&gt; (shouldn&#39;t) change from one request to the next unless the client is\n&gt; upgraded. For example, an upgrade from Safari 2 to Safari 3 changes the\n&gt; Accept header to include &#39;application/xhtml+xml&#39;.  If a resource is\n&gt; negotiated based on Accept header, it may well give a different\n&gt; response to the upgraded browser -- it would be horrible practice if,\n&gt; when selecting a bookmark link, the browser sent the same stored Accept\n&gt; header it previously had, instead of the new one which more accurately\n&gt; reflects the client&#39;s capabilities, and letting the server do its\n&gt; conneg thing.\n&gt;   \n\nA browser is a special case UA though, I don&#39;t understand why it&#39;s \nAccept headers can&#39;t have their default overwritten from one request to \nthe next. That makes perfect sense to me; the fact that it&#39;s not \npossible in practice is the reason I am bringing this up.\n\nI see a bookmark as a store of a user&#39;s request, why would it be \nbeneficial for an upgrade to cause a change in a user&#39;s bookmark?\n\n&gt; That&#39;s tight coupling, not to mention needless complexity, and doesn&#39;t\n&gt; really solve any real-world problems, while precluding any benefit to\n&gt; using content negotiation in the first place, if all bookmarks must be\n&gt; altered when a browser is upgraded or stay locked in to a lower-quality\n&gt; representation.  The simple solution which has been proven to work, is\n&gt; to give each representation its own URI, instead of trying to invent\n&gt; uber-bookmarks for negotiated resources, or trying to implement content\n&gt; negotiation in markup.\n&gt;   \n\nI don&#39;t understand the tight coupling reference at all. Can you expand \nthis at all?\n\nIt doesn&#39;t &quot;solve&quot; any real-world problems but it encourages better use \nof URIs and Accept - to my mind, anyway.\n\n&gt; In REST, any resource of interest is given a URI, such that application\n&gt; state may be bookmarked.  But, that application state is not a function\n&gt; of the Content-Type.  A compressed representation doesn&#39;t need its own\n&gt; URI.  The argument for using separate URIs for image.jpg/image.png has\n&gt; more to do with proper caching, than being able to bookmark them\n&gt; separately, since they represent the same application state.\n&gt;   \n\nSo serving multiple representations from one URI doesn&#39;t work with caching?\n\nIf I we use the URI for conneg..\n\nand I PUT changes to /report.doc - how does my cache know that it needs \nto refresh /report.pdf and /report.xml ?\n\n&gt; I&#39;ve tried to elaborate here, rather than simplify, hope this helps.\n&gt;   \nNot really, no!\n\nThanks for your input\n\nRegards,\nMike\n\n"}}