{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"mqNKvIKp6Yp3zk4X3kgjKEo9zCbAywP9g2ujDypJD23laQUDiOVqYQ5ESOrCJbUs1wDvC0zdPSrnyeWUtpGlelsKY0Ko6oRZnQZ3P9mQjw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Doc types for batch updates","postDate":"1275842553","msgId":15560,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNjA2MTA0MjMzLjg2MjQ5ZGVlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlrN21CcmpOY1MzRzVNTjFEaTRQTjl4UUdLQzZrdkJ5OWV0ektEakBtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PGh1YzFkcStwc2pvQGVHcm91cHMuY29tPgk8MjAxMDA2MDUwNTAzNDIuMzk4MjQ1MjQuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWs3bUJyak5jUzNHNU1OMURpNFBOOXhRR0tDNmt2Qnk5ZXR6S0RqQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":15559,"nextInTopic":15561,"prevInTime":15559,"nextInTime":15561,"topicId":15547,"numMessagesInTopic":10,"msgSnippet":"... OK, let s call your table resource Resource A and stipulate that its representation is text/xml using the XHTML namespace and having  as the root","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 11895 invoked from network); 6 Jun 2010 16:42:49 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m12.grp.re1.yahoo.com with QMQP; 6 Jun 2010 16:42:49 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 6 Jun 2010 16:42:48 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id EF3DB509DB;\n\tSun,  6 Jun 2010 12:42:47 -0400 (EDT)\r\nDate: Sun, 6 Jun 2010 10:42:33 -0600\r\nTo: Chuck Hinson &lt;chuck.hinson@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100606104233.86249dee.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTik7mBrjNcS3G5MN1Di4PN9xQGKC6kvBy9etzKDj@...&gt;\r\nReferences: &lt;huc1dq+psjo@...&gt;\n\t&lt;20100605050342.39824524.eric@...&gt;\n\t&lt;AANLkTik7mBrjNcS3G5MN1Di4PN9xQGKC6kvBy9etzKDj@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Doc types for batch updates\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nChuck Hinson wrote:\n&gt; \n&gt; It&#39;s not that we&#39;re modeling our data as a table -=\r\n it is a table.\n&gt;\n\nOK, let&#39;s call your table resource &quot;Resource A&quot; and stip=\r\nulate that its\nrepresentation is text/xml using the XHTML namespace and hav=\r\ning &lt;table&gt;\nas the root element.  We need to interact with this resource, s=\r\no we\nneed to create a hypertext interface for it.  We&#39;ll call the hypertext=\r\n\nAPI &quot;Resource B&quot;.\n\nResource B&#39;s representation is an Xforms document, whic=\r\nh uses &lt;table&gt;\nmarkup to display a bunch of form fields.  These form fields=\r\n are\npopulated with the data from Resource A when the steady-state is\nrende=\r\nred.  The user can alter the form fields, which alters the loaded\nrepresent=\r\nation of Resource A.  When the user submits changes, a PUT\nrequest is made =\r\nto Resource A with the altered &lt;table&gt; as text/xml.\n\n&gt;\n&gt; We&#39;ve been asked t=\r\no provide users the ability to define and create\n&gt; tables with arbitrary nu=\r\nmbers of columns (this presents some\n&gt; interesting but solvable database is=\r\nsues).  Over time, they will need\n&gt; to update the values in various cells i=\r\nn these tables.  When they do\n&gt; their updates, they are going to want to ma=\r\nke all of their changes and\n&gt; then click save; they will not stand for havi=\r\nng to press save after\n&gt; editing each cell or row in the table - hence the =\r\nbatch update.\n&gt; \n\nI wouldn&#39;t say &quot;hence the batch update,&quot; I&#39;d say &quot;hence t=\r\nhe\narchitectural choices&quot; and avoid any discussion of batching.  Let&#39;s\ndefi=\r\nne Resources C-z as the fifty rows in the table.  When a PUT is\nmade to Res=\r\nource A, the origin server&#39;s processing of that request will\nupdate those R=\r\nesources C-z which need changing.  So that PUT to\nResource A was really a b=\r\natch-update request.\n\nSimilarly, a change to a single row that&#39;s PUT to Res=\r\nource C, would\namount to a partial update of Resource A, resulting in a dif=\r\nferent\nsteady-state next time Resource B is dereferenced.  In this way\nReso=\r\nurce A may be partially-updated without resorting to PATCH.  This\nis how we=\r\n solve partial- or batch-update problems in REST, by assigning\nURIs and mak=\r\ning architectural choices which avoid the need for batching.\n\n&gt;\n&gt; [Also, if=\r\n I send the changes as a single batch, I get a sort of\n&gt; poor-mans transact=\r\nion - either the request completes (and all of the\n&gt; changes in the batch a=\r\nre succeed) or the request fails (and all of the\n&gt; changes in the batch fai=\r\nl).]\n&gt; \n\nOK, but if each row is a separate request, it&#39;s easier to notify t=\r\nhe\nuser of where the error was which prevented the transaction, and it&#39;s\nmo=\r\nre user-friendly to accept the good data instead of rejecting the\nentire ch=\r\nange.  Just a thought.\n\n&gt; \n&gt; &gt; But, I don&#39;t think you need batch-update req=\r\nuests. =A0If you insist, I\n&gt; &gt; still think you should build your system wit=\r\nhout that optimization,\n&gt; &gt; first. =A0It&#39;ll be up and running faster, and g=\r\nive you a baseline to\n&gt; &gt; benchmark your PUT optimization against to prove =\r\nthat it doesn&#39;t do\n&gt; &gt; much...\n&gt; \n&gt; I dont think there&#39;s much question the =\r\nbatch update is needed.  If a\n&gt; user wants to update a status column in eve=\r\nry row in a 50 row table,\n&gt; I&#39;m not sure sending 50 PUT requests when they =\r\nclick the save button\n&gt; is appropriate.\n&gt; \n\nThere&#39;s nothing inappropriate a=\r\nbout it.  Many real-world Web pages wind\nup making dozens of GET requests t=\r\no render a steady-state.  If those 50\nrequests result from breaking a large=\r\n resource into more-manageable sub-\nresources, the size of the PUT requests=\r\n is small, so 50 fly right by.\n\nThat 50 separate PUT requests may result fr=\r\nom some action, only becomes\na scalability concern if the action that trigg=\r\ners it occurs frequently\nenough to account for significant traffic.  You ju=\r\nst don&#39;t save that\nmuch overhead on your system overall, by saving 49 PUT r=\r\nequests for a\ntransaction that occurs once for every 100 GET requests for a=\r\n steady-\nstate that&#39;s built with 50 GET requests.\n\n&gt;\n&gt; But that&#39;s really a =\r\nseparate issue, and it&#39;s not the one I&#39;m worried\n&gt; about.\n&gt;\n\nNo problem, ju=\r\nst trying to enlighten.\n\n&gt;\n&gt; The harder part is the result of dealing with =\r\nuser-defined\n&gt; tables with arbitrary numbers of columns.  I dont want to ge=\r\nt down in\n&gt; the weeds, but basically, rows from the user-defined tables do =\r\nnot map\n&gt; directly to records in the database.  Instead, each field in a ro=\r\nw is\n&gt; stored as a separate record in the database.  A table with 10 column=\r\ns\n&gt; and 50 rows is 500 records in the database.  If a user is only\n&gt; updati=\r\nng values in a single column I&#39;d rather only do 50 updates, and\n&gt; not 500.\n=\r\n&gt; \n&gt; I could change my logical model to let clients deal with tables at the=\r\n\n&gt; cell level, but that seems to me to be making clients deal with an\n&gt; unn=\r\necessarily complex model (though having the client mark which\n&gt; fields in a=\r\n row have been changed is probably not much different).  I\n&gt; would much rat=\r\nher stick with a logical model where clients can deal\n&gt; with the table at t=\r\nhe row level and not burden them with complexity\n&gt; that&#39;s really a result o=\r\nf the back-end implementation.\n&gt; \n\nAbstracting away the complexities and li=\r\nmitations of the backend is\nwhat I&#39;m trying to help you with, indeed that&#39;s=\r\n what REST is for.\nSpecifically, I&#39;m trying to get a feel for your resource=\r\ns.  Obviously,\nyour table is a resource, but your explanations lead me to c=\r\nonsider\nthat each row is also a resource since that seems to be how you&#39;re\n=\r\ntreating them...\n\n&gt; \n&gt; &gt;\n&gt; &gt; I&#39;m not sure I understand. =A0Is your applicat=\r\nion steady-state made\n&gt; &gt; up of multiple resources, i.e. each row has its o=\r\nwn URL?\n&gt; &gt;\n&gt; \n&gt; At this point, the primary resource is the user-defined ta=\r\nble.  It is\n&gt; possible that other services may want to access individual ro=\r\nws, but\n&gt; more likely, they&#39;ll want to be able to retrieve one or two colum=\r\nns\n&gt; for all of the rows in the table.  And even if they do want a single\n&gt;=\r\n row, it&#39;ll likely be addressed as a query of the table resource, and\n&gt; not=\r\n directly.  So most get requests will be for the table (or some\n&gt; portion o=\r\nf it) and not individual rows.\n&gt; \n\nExtracting a table row doesn&#39;t require a=\r\nny query language.  It merely\nrequires treating each row as a resource.  Th=\r\nis means assigning URIs to\nResources C-z, which could of course be hash URI=\r\ns.  Instead of querying\nfor a row, just identify it as /table#row2 by stick=\r\ning an @id in, like\n&lt;tr id=3D&#39;row2&#39;&gt;.  This references a nodeset containing=\r\n &lt;th&gt; and/or &lt;td&gt;\nelements.  Columns, different story.\n\n&gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; I&#39;m loo=\r\nking for examples of MIME types/protocols that work with\n&gt; &gt;&gt; collections o=\r\nf things, but support batch updates on collection\n&gt; &gt;&gt; members rather than =\r\nrequiring separate updates for each collection\n&gt; &gt;&gt; member.\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; \n&gt; M=\r\ny main concern at this point is to come up with a document type that\n&gt; can =\r\nbe used for all interactions with these user-defined tables.  I\n&gt; would pre=\r\nfer that clients not have to use a separate document type to\n&gt; do updates.\n=\r\n&gt; \n\nRight.  That&#39;s exactly what my Xforms approach does.  In fact, a submit=\r\n\nbutton for the whole table, and submit buttons for each row, can\ncoexist i=\r\nf Resources C-z are given (non-hash) URIs.  The master submit\nbutton is a P=\r\nUT to Resource A, each row&#39;s submit is a PUT to one\nResource C-z.  The mast=\r\ner submit doesn&#39;t have to trigger the PUT for\neach row, nor does it need to=\r\n be a batch request which addresses C-z\nfrom within a composite media type.=\r\n\n\nInstead of debating these intricacies, it would help if I could get my\nhe=\r\nad wrapped around your problem a little better.  Like, what are the\nshortco=\r\nmings in terms of what you&#39;re trying to do, with my Xforms\nResource A / Res=\r\nource B single-PUT update solution.\n\n-Eric\n\n"}}