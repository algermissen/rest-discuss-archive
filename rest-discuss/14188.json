{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"bgLiEIktQlhGT5CtElMAtp-Kor49U9wtIGtpI0aT1o1MB80sDcu86mN3gK--Yvy0yP84ysrNYpN1267KLeebn3sSQ3LcsH6THkNIE1lraQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Experience implementing custom media handlers","postDate":"1261035412","msgId":14188,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkxMjE3MDAzNjUyLmQ5MTQ1YjVjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDM5MTVjNjlkMDkxMjE2MTg1MnIyNmZiM2Q2OG0xMWQ1NjMwMjI2YzJlZDdlQG1haWwuZ21haWwuY29tPg==","referencesHeader":"PEZDOTIzNjczLUVGQzktNDYyNC04MTY5LTA1MEFGNEJFRTcyNUBpbm5vcS5jb20+CTwyMDA5MTIxNTAwMzA0Mi5lZDExYzhiZi5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTwzMDUzNTU0Ri1BQzk0LTQ1NkYtQUIzOS1DRTBERTM5MDRFNTJAbWFjLmNvbT4JPDIwMDkxMjE2MTc1NTM0LjUwZGI1MTIwLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDM5MTVjNjlkMDkxMjE2MTg1MnIyNmZiM2Q2OG0xMWQ1NjMwMjI2YzJlZDdlQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":14186,"nextInTopic":0,"prevInTime":14187,"nextInTime":14189,"topicId":14068,"numMessagesInTopic":20,"msgSnippet":"... That s an oversimplification of my argument.  There exist plenty of standard media types which aren t XHTML, like SVG.  The requirement is for hypertext of","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 31206 invoked from network); 17 Dec 2009 07:37:34 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m12.grp.re1.yahoo.com with QMQP; 17 Dec 2009 07:37:34 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 17 Dec 2009 07:37:34 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 42957509DD;\n\tThu, 17 Dec 2009 02:37:33 -0500 (EST)\r\nDate: Thu, 17 Dec 2009 00:36:52 -0700\r\nTo: Will Hartung &lt;willh@...&gt;\r\nCc: Jan Algermissen &lt;algermissen1971@...&gt;, Stefan Tilkov\n &lt;stefan.tilkov@...&gt;, rest-discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20091217003652.d9145b5c.eric@...&gt;\r\nIn-Reply-To: &lt;3915c69d0912161852r26fb3d68m11d5630226c2ed7e@...&gt;\r\nReferences: &lt;FC923673-EFC9-4624-8169-050AF4BEE725@...&gt;\n\t&lt;20091215003042.ed11c8bf.eric@...&gt;\n\t&lt;3053554F-AC94-456F-AB39-CE0DE3904E52@...&gt;\n\t&lt;20091216175534.50db5120.eric@...&gt;\n\t&lt;3915c69d0912161852r26fb3d68m11d5630226c2ed7e@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Experience implementing custom media handlers\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nWill Hartung wrote:\n&gt;\n&gt; On Wed, Dec 16, 2009 at 4:55 PM, Eric J. Bowman wrote:\n&gt; &gt; I disagree. If I were designing a REST system to deal with leasing\n&gt; &gt; contracts, the first thing I would do is research whether or not\n&gt; &gt; there exists a standard for representing leasing contracts. Upon\n&gt; &gt; finding none, my options as a REST developer are to re-use an\n&gt; &gt; existing media type by extending it to handle the specifics of a\n&gt; &gt; lease-contract representation, or create a new media type.\n&gt; &gt;\n&gt; &gt; If I do create a new media type, I wouldn&#39;t call the result RESTful\n&gt; &gt; unless and until that media type is standardized. I would simply use\n&gt; &gt; XHTML as the media type. If the client number is important\n&gt; &gt; information, then I would identify it as such using RDFa or a\n&gt; &gt; microformat approach, i.e. assign @id=&#39;client_number&#39; thereby giving\n&gt; &gt; clients the ability to glean a client number from any XHTML\n&gt; &gt; representation of a lease contract.\n&gt; \n&gt; If everything is XHTML, how do you know what kind of representation\n&gt; that the service wants? Sure, XHTML.\n&gt; \n\nThat&#39;s an oversimplification of my argument.  There exist plenty of\nstandard media types which aren&#39;t XHTML, like SVG.  The requirement is\nfor hypertext of a well-known media type.  I also allow for the\npossibility of new media types becoming well-known as they become\nstandardized.  No well-known media type exists for a lease contract, so\nI choose the well-known media type best suited to the task -- in this\ncase, that isn&#39;t SVG or anything else.\n\nIf my intention is to display a hypertext document on a client of any\nsort, then I&#39;ll stick to the standards and libraries defined within\napplication/xhtml+xml (even if I ultimately serve XHTML 1.0 as\ntext/html).  A lease contract is intended to be a human-readable\ndocument, which may be browsed online or printed.  At the same time, it\nis expected to be machine-readable to reliably extract certain\ninformation, regardless of how the document itself evolves over time.\n\n&gt;\n&gt; So &quot;&lt;html&gt;&lt;body&gt;This is my Lease for the White Van. It&#39;s 4\n&gt; weeks.&lt;/body&gt;&lt;/html&gt;&quot;, is that a valid Lease for your system?\n&gt;\n\nOf course not, as that is not valid XHTML. ;-)  The proper question is\nfor you:  What is it about a lease contract can&#39;t be displayed in a\nbrowser using XHTML + CSS + JS, or printed using an alternate\nstylesheet?  In simpler terms, why _not_ use XHTML as a starting\npoint?  A lease contract will have various levels of headings followed\nby paragraphs. There may be tables displaying various rates.  Why is it\nbetter to re-invent the wheel of marking up a table that can be\nunderstood as such by a machine that groks either text/html or\napplication/xhtml+xml?\n\nI always maintain that it doesn&#39;t matter whether the REST application\nis driven by a human or a program, the media type for most tasks is\nXHTML, optionally wrapped in Atom.  Which is why I like RDFa as opposed\nto dealing with straight RDF, as an extension to other host languages\n(not just XHTML).\n\n&gt; \n&gt; &gt; Clients that aren&#39;t interested in\n&gt; &gt; the client number will gracefully degrade, displaying a\n&gt; &gt; human-readable document.\n&gt; \n&gt; curl or Firefox may degrade gracefully, that python script someone\n&gt; wrote will go &quot;Uh, what&#39;s this&quot; and likely abort. No degradation there\n&gt; at all.\n&gt; \n\nThen the system wasn&#39;t designed properly, i.e. by applying REST\nconstraints.\n\nMy design goal is a self-documenting API (the hypertext constraint)\nutilizing a uniform interface (the self-descriptive messaging\nconstraint), for either a human or a machine to interact with a lease\ncontract.  If a client is coded to the API I describe below, any client\ncoded to it is immune from the documents&#39; evolution over time.\n\n&gt;\n&gt; You&#39;re still defining your own formats, payloads, and semantics, but\n&gt; now it just has a catch all media type of XHTML, oh, and it renders in\n&gt; a browser. Just because it&#39;s in XHTML doesn&#39;t make it any more\n&gt; interoperable. I can&#39;t write a shopping client that &quot;just works&quot; with\n&gt; Amazon and Best Buy, and they both use HTML.\n&gt; \n\nIt renders in a browser because it&#39;s a lease contract we want humans\nto read. The reason documents render in browsers is because, mostly,\nthey can be expressed using the semantics of XHTML as a widely-known\nbase. An inline table is an inline table, which can be written\naccessibly, such that the document works not only for the sighted who\ncan read a browser display or a printed page, but others as well\n(because accessibility in HTML equates to machine readability in a\nvery standardized fashion).\n\nThere&#39;s no standard for shopping-cart implementations.  Don&#39;t blame\nthat on me, please...  However, it is a simple matter to define a self-\ndocumenting API for the hypothetical lease contract...  let&#39;s not\nchange horses mid-stream...\n\n&gt;\n&gt; &gt; Whereas, if I create a new media type, I&#39;d be reinventing a whole\n&gt; &gt; bunch of different wheels -- headings, paragraphs, boldface,\n&gt; &gt; italics, links, link relations, HTTP methods and the whole #!.\n&gt; &gt; Clients that don&#39;t understand this new markup language will ignore\n&gt; &gt; the markup they don&#39;t recognize and display the representation as a\n&gt; &gt; big puddle of text.\n&gt; \n&gt; My point is that XHTML simply isn&#39;t specific enough and doesn&#39;t offer\n&gt; enough clarity to a client as to what it is seeing and what to expect.\n&gt;\n\nThat&#39;s why it&#39;s extensible.  But that is of no concern at the protocol\nlevel.  The protocol level is where the uniform interface resides, the\nrequirement (constraint) there is self-descriptive messaging.  If I&#39;m\nusing application/xhtml+xml, then any client (or intermediary that\ncares) knows that a &lt;table&gt; is a table and can parse it as such.  If\nI&#39;m using text/html, then any client (or intermediary that cares) knows\nthat a &lt;table&gt; is a table.  Clients developed to my self-documenting API\nmerely extend or implement known libraries.\n\nIf I want machine-readable tabular data, the state-of-the-art there\nstands as HTML 4.01, which also happens to be the state-of-the-art\nmarkup language for human-readable tabular data.  Why create a new\nmedia type if it in any way needs to incorporate tabular data?  Same\nwith lists.  By constraining a &lt;dl&gt; to have only one &lt;dd&gt; per &lt;dt&gt;\nusing a schema, you have the semantics of a list defining a series of\nname-value pairs.  Or I suppose I could use JSON for name-value pairs.\nIf I need a machine-readable chart instead of a table, then SVG.\n\n&gt;\n&gt; You could make a &quot;smart&quot; client that goes crawling through payload\n&gt; looking for its markers and microformats. That&#39;s fine, but when you\n&gt; say your client accepts &quot;XHTML&quot;, it&#39;s a bit misleading, because it\n&gt; wants XHTML that&#39;s properly formatted, with proper embed extension\n&gt; vocabularies or microformats. Otherwise, it&#39;s just gibberish to the\n&gt; client.\n&gt; \n\nActually, parsing microformats is incredibly difficult, as a specific\nparser needs to be written for each microformat a client supports.\nRDFa solves this problem very cleanly.  When I curl my lease contract,\nI see a Content-Type of application/xhtml+xml, which tells me the XML\ntoolchain is in play.  In the document &lt;head&gt;, there is a &lt;link rel=\n&#39;transformation&#39;/&gt; pointing to a application/xslt+xml resource.\n\nThat&#39;s as far as I care to go into the markup.  I now curl the .xsl\nfile and wash the last representation through it using an XSLT 2.1\ntransformer, XSLT 2 being defined by the media type, and 2.1 being\nintrospected from the .xsl hypertext representation of a GRDDL\ntransformation, which extracts the client number (and other data) from\nthe lease contract&#39;s RDFa markup, specifying XHTML or JSON or SVG\noutput as required.\n\nDocumentation-wise, I describe my API not in terms of URIs, but in\nterms of media types and link relations.  &quot;The lease contract&#39;s XHTML\nincludes a link with the relation of &#39;transformation&#39; to the XSLT\nhypertext you can use to generate a JSON list of name-value pairs\nexposing the RDFa metadata of the calling document.&quot;  Nothing different\nfrom what I&#39;ve inferred via curl + elbow-grease, just formalized.\n\nThe location (URL) of the lease contract may be changed without\nbreaking the API.  Contracts for an interface are written using the\nsame self-documenting hypertext that drives the application -- media\ntypes themselves are _not_ contracts.  URIs are opaque -- they don&#39;t\nneed to be specified as anything other than &quot;whatever an implementation\nof this API says they are&quot;.\n\nThis is all I need to program a custom client using standard libraries\nthat is capable of sorting a collection of links to lease contracts\nbased on attributes of those lease contracts, such as age, or\ntime-to-expire, in ascending or descending order, using name-value\npairs provided in the JSON or XHTML output of a GRDDL transformation.\n\nThis client I&#39;ve coded can evolve independently of the server.  The\nserver can evolve at any time to include new metadata, or upgrade to\nHTML 5, or use WAI-ARIA to add a digital-signature-capture form to the\nlease-contract document, as other clients are also evolving\nindependently.  If I don&#39;t update my client, there&#39;s no reason why the\nAPI described needs to be changed -- there&#39;s always a path to follow\nfrom the document to a metadata view consisting of a &lt;dl&gt; with one\n&lt;dt&gt;client_number&lt;/dt&gt; with a &lt;dd&gt; value that matches a pattern and\ntype described in a schema (an argument against using JSON for a list\nof name-value pairs as GRDDL output, in favor of XHTML).\n\n&gt;\n&gt; &gt; My rule of thumb remains: Don&#39;t create a new media type, when the\n&gt; &gt; technology exists to extend any number of existing media types to\n&gt; &gt; solve the problem. Creating media types is hard, hard work -- if\n&gt; &gt; done properly.\n&gt; \n\nThere&#39;s no need at any step of the way in this lease-contract scenario\nwhere the standard media types used aren&#39;t fine-grained enough to\nspecify to a client, just exactly what to expect.  The nature of\nextensible media types is that they represent the opposite of a\ncontract -- a client can&#39;t tell from the media type exactly which\ncapabilities are needed, because any representation may also be a\ncontainer for other resources, like images in a document, or charts in\nSVG.  Nor can intermediaries grasp the full nature of a representation\nby its media type, no matter how fine-grained and application-specific\nthat media type may be.\n\n&gt; \n&gt; My point is that XHTML simply isn&#39;t specific enough and doesn&#39;t offer\n&gt; enough clarity to a client as to what it is seeing and what to expect.\n&gt;\n\nA client that doesn&#39;t understand RDFa, hasn&#39;t been coded to introspect\nfor GRDDL transformations, isn&#39;t compatible with the forms markup used\nand only understands GET, can still render and style the document\ncleanly, while ignoring the attributes and elements it doesn&#39;t\nunderstand.  The generality provided by the underlying document\nsemantics adhering to XHTML allows a variety of levels of client\nunderstanding.\n\nA client that knows RDFa doesn&#39;t really need to run a GRDDL\ntransformation.  None of this is of interest to intermediaries, simply\nthe fact that this is a defined subset of XML known as XHTML will do.\nThe API is self-documented within the realm of known media types, with\nclarity and specificity, while allowing graceful degradation, without\nsacrificing human readability over the Web.\n\n&gt;\n&gt; If you&#39;re extending a data type and not changing the semantics, then\n&gt; that&#39;s a fine idea. If you are changing the semantics, then telling\n&gt; folks it&#39;s a application/xyz+xml when that&#39;s half truth, or perhaps\n&gt; even wrong (depending on the kind extension) doesn&#39;t really help\n&gt; anyone, does it? Publishing atom feeds where the bulk of your\n&gt; information is in your own namespace, is that really helpful? Is that\n&gt; really using &quot;atom&quot; then? Maybe if you&#39;re leveraging some other atom\n&gt; tool suite to publish the atom and your extensions, then ok. But then\n&gt; you&#39;re using atom as a wrapper to the real meat, which is your actual\n&gt; data -- which isn&#39;t atom at all.\n&gt; \n\nYour data doesn&#39;t have to be Atom at all, or XHTML or HTML, for Atom to\ndo exactly what it is supposed to do, which is provide a fine wrapper\nfor publishing any data online, thanks to its extensibility.  Same with\nXHTML.  There exist many standardized means to extend XHTML, none of\nwhich require a media type other than the extensible application/xhtml\n+xml.  When I see that, I know that whatever else I don&#39;t understand, I\nknow that a &lt;table&gt; is a table and I understand the semantics of a\n&lt;dl&gt;.  I&#39;m not changing any semantics, I&#39;m extending them.  Sometimes,\nas in the case of my GRDDL output above, the raw semantics of the media\ntype will do nicely with the application of a schema or two.\n\nBear in mind, this is in the same spirit as not defining a new HTTP\nmethod for each of your underlying system&#39;s methods.  Apply a uniform\ninterface by adhering to the well-defined semantics of known methods.\nUse well-known media types that allow for extension, with or without\nsub-typing, preferably without.  That&#39;s what makes it easy to decipher\nan API using nothing but curl, plus standard toolchains, over the\nwire.  The specifics of your application belong in the hypertext of a\nknown type, not your brand-new media type.\n\n-Eric\n\n"}}