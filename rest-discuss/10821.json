{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":302633978,"authorName":"Daniel Yokomizo","from":"&quot;Daniel Yokomizo&quot; &lt;daniel.yokomizo@...&gt;","profile":"daniel_yokomiso","replyTo":"SENDER","senderId":"UHtL7upOekhJLNuj68TfPX3TNwk4s799NXPCmSTMgMpzW45lmM9PBCfvGTLlWN-nZMZFEonDRI4VqjcgPt0IWOPeDdOfElNd8uU16DNiuD4BQDJP","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] CSRF attacks in RESTful authenticated web applications","postDate":"1211840120","msgId":10821,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGU1YzZlY2FiMDgwNTI2MTUxNWg4MDM4ZGEzZ2QyNDdjZDg5ZWM3MWQ4MjFAbWFpbC5nbWFpbC5jb20+","inReplyToHeader":"PDQ4M0IxRUJGLjMwMzA5MDNAa29lbG4uZGU+","referencesHeader":"PDQ4M0IxRUJGLjMwMzA5MDNAa29lbG4uZGU+"},"prevInTopic":10820,"nextInTopic":10822,"prevInTime":10820,"nextInTime":10822,"topicId":10818,"numMessagesInTopic":21,"msgSnippet":"On Mon, May 26, 2008 at 5:34 PM, Simon Reinhardt ... CSRF has two components: the attacker being able to name a resource (i.e. the target URI) and the browser","rawEmail":"Return-Path: &lt;daniel.yokomizo@...&gt;\r\nX-Sender: daniel.yokomizo@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 90422 invoked from network); 26 May 2008 22:15:21 -0000\r\nX-Received: from unknown (66.218.67.94)\n  by m52.grp.scd.yahoo.com with QMQP; 26 May 2008 22:15:21 -0000\r\nX-Received: from unknown (HELO wr-out-0506.google.com) (64.233.184.229)\n  by mta15.grp.scd.yahoo.com with SMTP; 26 May 2008 22:15:21 -0000\r\nX-Received: by wr-out-0506.google.com with SMTP id c53so1087362wra.20\n        for &lt;rest-discuss@yahoogroups.com&gt;; Mon, 26 May 2008 15:15:21 -0700 (PDT)\r\nX-Received: by 10.86.25.17 with SMTP id 17mr3367692fgy.50.1211840120165;\n        Mon, 26 May 2008 15:15:20 -0700 (PDT)\r\nX-Received: by 10.86.9.6 with HTTP; Mon, 26 May 2008 15:15:20 -0700 (PDT)\r\nMessage-ID: &lt;e5c6ecab0805261515h8038da3gd247cd89ec71d821@...&gt;\r\nDate: Mon, 26 May 2008 19:15:20 -0300\r\nTo: &quot;Simon Reinhardt&quot; &lt;simon.reinhardt@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nIn-Reply-To: &lt;483B1EBF.3030903@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;483B1EBF.3030903@...&gt;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Daniel Yokomizo&quot; &lt;daniel.yokomizo@...&gt;\r\nSubject: Re: [rest-discuss] CSRF attacks in RESTful authenticated web applications\r\nX-Yahoo-Group-Post: member; u=302633978; y=fnyQstdVTtv0xhBBi7wRYkXbl5BMBm5KmFBKZ52VOrdhHz0dG4nw_Hu7\r\nX-Yahoo-Profile: daniel_yokomiso\r\n\r\nOn Mon, May 26, 2008 at 5:34 PM, Simon Reinhardt\n&lt;simon.reinhardt@...&gt; wrote:\n&gt; Hi,\n&gt;\n&gt; After reading about cross-site request forgery (XSRF/CSRF) attacks and common ways to circumvent them, I wasn&#39;t quite satisfied with how people approach this.\n&gt;\n&gt; To sum it up: A user is authenticated for (&quot;logged into&quot;) a website A in their browser session and the attacker uses that fact to execute a request (there are ways to not only do GET but also POST requests without the user noticing) from a another website B in the same browser session. That request has website A as the target with the result that the attacker can perform actions on that website under the authentication of the user.\n&gt; Web developers circumvent this by adding hidden form fields containing a random token (bound to the session) or just the session ID to the form which is supposed to precede the action. Requests to perform the action will only be accepted if they contain this shared secret. Therefore the token has to be stored with the session on the server.\n&gt; The downsides are obvious: you have server state, handling several parallel tokens for the same action becomes unwieldy and since you have to time-out the tokens after some time for increased security, people can&#39;t just post an open form days later. Also you have to handle web service calls specifically - you don&#39;t want to negotiate shared secrets before service calls, so you have to find out what is a web service call and what a website call (content-type?).\n&gt;\n&gt; It would appear that all this is a cookie-session problem anyway and RESTful websites wouldn&#39;t have that vulnerability since they would use HTTP authentication. But wait: HTTP authentication is also present at any time during the browser session. I don&#39;t think browsers make sure to only send authentication credentials they hold for a website in the current session when the request origins from the website it is for. Maybe they should. But there are just so many vectors for CSRF that I think you always have to anticipate them when developing web applications and as far as I can see RESTful websites are just as vulnerable.\n&gt;\n&gt; So, has anyone put some thought into this from a REST point of view?\n\nCSRF has two components: the attacker being able to name a resource\n(i.e. the target URI) and the browser willing to use ambient authority\n(e.g. cookies, authentication credentials) without the explicit\nconsent of the user (BTW these are well known in the capability\nsecurity community). Using HATEOAS you can avoid the first issue: the\nclient of the app must use the links in the response to navigate to\nthe next states, so the server can generate URIs that are unguessable\n(e.g. GUIDs, cryptography) and the attacker is unable to name a\nresource used in the session. The entry point of the application can\nalso use an unguessable URI, so you just send it out of band and the\nclient use it without problems. If you use a well known entry point\nand rely on ambient authority then the attacker can go from it and\nnavigate to the relevant URIs, so it&#39;s best to use another approach\n(e.g. form based authentication) to authentication if you want a well\nknow entry point (e.g. the root URL of your site). For\ninter-application integration using unguessable URIs is no problem and\nis a very good security mechanism.\n\nOther ways to reduce damage is to use a two-factor authentication\nscheme, so you can use authentication credentials to GET. HEAD,\nOPTIONS and require the client to send alternate credentials in\nanother Header or in the entity body, ensuring that an attacker can&#39;t\ndo much damage, but this can leak confidential information.\n\nCSRF is a both a browser and application security hole, but we (app\ndevs) can only close the application hole. The browser is unsafe and\nwill be for the immediate future, our best choice is too not rely on\nambient authority and (if we want to remain RESTful) use unguessable\nURIs and HATEOAS.\n\n&gt; Regards,\n&gt; Simon\n\nBest regards,\nDaniel Yokomizo.\n\n"}}