{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":289191104,"authorName":"Jan Algermissen","from":"Jan Algermissen &lt;algermissen1971@...&gt;","profile":"algermissen1971","replyTo":"SENDER","senderId":"hYQzf5CFUm4ReEgeuyRwkNDZHfhM-qbtU7gW3mVZ5l97qrZGojrm2-mAI3U6lXnOyN8hR7dYGSXMdQW1vJm6Yh4ELgL5G9_HfdcXDcBb6XQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Re: Service descriptions and legal contracts","postDate":"1257538657","msgId":14012,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ4MDNEQ0EwLTIxMzUtNEU5NC1CMzc4LUVCNDhDQTk3NjI0RUBtYWMuY29tPg==","inReplyToHeader":"PGIwZWJhZmQxMDkxMTA2MTE0MW8xYmVhYWI1MXJmYmI3MDMzZDM2NzQ1MTBkQG1haWwuZ21haWwuY29tPg==","referencesHeader":"PGhkMWM5aitiN2d2QGVHcm91cHMuY29tPiA8Q0M3MzlBNjgtMUJCMS00QzA5LUE3MzUtMUNFNEYzMzE2MDg5QG1hYy5jb20+IDxiMGViYWZkMTA5MTEwNjExNDFvMWJlYWFiNTFyZmJiNzAzM2QzNjc0NTEwZEBtYWlsLmdtYWlsLmNvbT4="},"prevInTopic":14011,"nextInTopic":14013,"prevInTime":14011,"nextInTime":14013,"topicId":13996,"numMessagesInTopic":25,"msgSnippet":"... Ok, yes. I should have made the distinction between the user agent and the program that makes use of it. At least this is my mental model: you have a","rawEmail":"Return-Path: &lt;algermissen1971@...&gt;\r\nX-Sender: algermissen1971@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 97616 invoked from network); 6 Nov 2009 20:18:48 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m4.grp.sp2.yahoo.com with QMQP; 6 Nov 2009 20:18:48 -0000\r\nX-Received: from unknown (HELO asmtpout020.mac.com) (17.148.16.95)\n  by mta2.grp.re1.yahoo.com with SMTP; 6 Nov 2009 20:18:48 -0000\r\nMIME-version: 1.0\r\nContent-transfer-encoding: 7BIT\r\nContent-type: text/plain; charset=US-ASCII; format=flowed; delsp=yes\r\nX-Received: from [192.168.2.102] ([84.144.94.188])\n by asmtp020.mac.com (Sun Java(tm) System Messaging Server 6.3-8.01 (built Dec\n 16 2008; 32bit)) with ESMTPSA id &lt;0KSP00AWUF1E0F00@...&gt; for\n rest-discuss@yahoogroups.com; Fri, 06 Nov 2009 12:17:42 -0800 (PST)\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-id: &lt;4803DCA0-2135-4E94-B378-EB48CA97624E@...&gt;\r\nTo: Andrew Wahbe &lt;andrew.wahbe@...&gt;\r\nIn-reply-to: &lt;b0ebafd10911061141o1beaab51rfbb7033d3674510d@...&gt;\r\nDate: Fri, 06 Nov 2009 21:17:37 +0100\r\nReferences: &lt;hd1c9j+b7gv@...&gt;\n &lt;CC739A68-1BB1-4C09-A735-1CE4F3316089@...&gt;\n &lt;b0ebafd10911061141o1beaab51rfbb7033d3674510d@...&gt;\r\nX-Mailer: Apple Mail (2.936)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jan Algermissen &lt;algermissen1971@...&gt;\r\nSubject: Re: [rest-discuss] Re: Service descriptions and legal contracts\r\nX-Yahoo-Group-Post: member; u=289191104; y=7-b1CyYlwAdxGpX_f4KomBnknuVNFfgBoEpNylzYCOKuDM5mIXQa3cVj\r\nX-Yahoo-Profile: algermissen1971\r\n\r\n\nOn Nov 6, 2009, at 8:41 PM, Andrew Wahbe wrote:\n\n&gt; On Fri, Nov 6, 2009 at 10:58 AM, Jan Algermissen\n&gt; &lt;algermissen1971@...&gt; wrote:\n&gt;&gt;\n&gt;&gt; On Nov 6, 2009, at 3:36 PM, wahbedahbe wrote:\n&gt;&gt;\n&gt;&gt;&gt; --- In rest-discuss@yahoogroups.com, Jan Algermissen  \n&gt;&gt;&gt; &lt;algermissen1971@...&gt;\n&gt;&gt;&gt; wrote:\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt; On Nov 6, 2009, at 6:45 AM, wahbedahbe wrote:\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt;&gt; There are a lot of assumptions here about the limitations of  \n&gt;&gt;&gt;&gt;&gt; machine\n&gt;&gt;&gt;&gt;&gt; to machine RESTful interaction. I have never seen any proof of  \n&gt;&gt;&gt;&gt;&gt; these\n&gt;&gt;&gt;&gt;&gt; limitations. It just seems that because the general REST community\n&gt;&gt;&gt;&gt;&gt; can&#39;t figure out how to design good media types for machine to\n&gt;&gt;&gt;&gt;&gt; machine interaction, the consensus is that it isn&#39;t possible.\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt; I did not say that at all. Of course machine to machine RESTful\n&gt;&gt;&gt;&gt; systems are possible (e.g. AtomPub). I was talking about inevitable\n&gt;&gt;&gt;&gt; assumptions the client has to make that manifest itself in code or\n&gt;&gt;&gt;&gt; configuration of and how to document these such that\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt; - no unnecessary coupling is created by the documentation\n&gt;&gt;&gt;&gt;  (as is by many of the documentations of the so called REST\n&gt;&gt;&gt;&gt;  interfaces on the Web)\n&gt;&gt;&gt;&gt; - the style of documentation will be accepted by e.g.\n&gt;&gt;&gt;&gt;  the legal department\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;&gt; Jan\n&gt;&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Right, but it&#39;s the assumption that these out-of-band contracts  \n&gt;&gt;&gt; are needed\n&gt;&gt;&gt; is what I&#39;m questioning.\n&gt;&gt;\n&gt;&gt; Suppose you are coding a client for service that lets you search  \n&gt;&gt; stuff and\n&gt;&gt; then do something with it (e.g. update). Your client code will  \n&gt;&gt; inevitably\n&gt;&gt; contain the &#39;invocation&#39; of the search (e.g. GET request to search\n&gt;&gt; resource). And this is based on the expectation that the search  \n&gt;&gt; resource\n&gt;&gt; will be there (== being discoverable).\n&gt;\n&gt; Ok so right out of the gate I have issues with this. &quot;Coding a client\n&gt; for a service&quot; seems unRESTful to me. Firefox is not coded for Google,\n&gt; Facebook or Amazon. It is coded for URIs, HTTP and HTML (and HTML&#39;s\n&gt; &quot;friends&quot; CSS, Javascript etc.).\n\nOk, yes. I should have made the distinction between the &#39;user agent&#39;  \nand the program that makes use of it. At least this is my mental  \nmodel: you have a library that implements all the specs that make  \nsense to implement (meaning: not only the ones for this service) and  \nthis piece is equivalent to the browser. Then, you need some piece of  \ncode that uses the user agent to interact with the service (or the Web  \nfor that matter). This piece of code is equivalent to the human being.  \nInside this code (or its configuration) one must manifest some  \nexpectations (e.g. that the search resource is there so the user agent  \ncan carry out the search and hand the result back to the program.\n\nIf you want to get rid of that assumption you&#39;d have to come up with a  \nway for the service to actually drive the client program (like a GUI  \napp is driven by the GUI). However, this does not work because the  \nclient is a state machine on its own and cannot be entirely driven by  \nthe hyper,edia received from the server. At some point there must be  \n&#39;invocations of goals&#39; by the client side program.\n\n\n&gt; Your client will only have code that\n&gt; has a notion of search invocation if it is inherent in the media type\n&gt; (including extensions and relations). But that is not necessary for\n&gt; search to work. The client could be performing a search without\n&gt; &quot;knowing&quot; it, because a combination of the media type, the current\n&gt; representation/state, and the client disposition and/or client side\n&gt; events have caused the search link to be followed. This is what\n&gt; happens when I use my browser to do a Google search. I don&#39;t see why\n&gt; this can&#39;t be the case for media types other than HTML (and it\n&gt; certainly would be for VoiceXML and CCXML).\n\nYes, great model. But what is driving the whole thing? With the  \nbrowser it is the human being that drives the interaction because she  \ne.g. wants to buy a book. In the machine world you need a process that  \ninitiates a goal and this goal includes assumptions.\n\n\n&gt;\n&gt;&gt; If the service does not provide the\n&gt;&gt; search resource anymore the client will break (if you code it to  \n&gt;&gt; expect that\n&gt;&gt; there is a search resource and sudden;y there is none what else  \n&gt;&gt; could the\n&gt;&gt; code do?). Humans can work on a solution for the problem, software  \n&gt;&gt; cannot\n&gt;&gt; (unless we go into AI of some form).\n&gt;\n&gt; I&#39;m not sure what is &quot;broken&quot; here. The service seems broken, but I&#39;m\n&gt; not sure if the client is broken -- you should be able to point it at\n&gt; any other service that supports the client&#39;s media type(s) and it\n&gt; should still work just fine.\n\nYeah - and this is precisely what you cannot utter in a room full with  \nthe guys that assign the budget or care about the company being sued.  \nWould you pay for Google&#39;s API and then, if part of the service  \ndisappears just go of to some other service on the Web?\n\n\n&gt; Or is the service just changed so that\n&gt; the search step is not required anymore? If the service is still\n&gt; accomplishing a useful goal within the bounds of the client&#39;s media\n&gt; type, things still seem ok.\n\nYes, this sort of magic can be coded into the user agent component and  \nthis is what enables the evolvability of the components without the  \nneed for bringing all the devs in a room all the time.\n\n&gt; If the service is now not doing something\n&gt; useful -- well that is a service implementation issue. If it&#39;s still\n&gt; working within the bounds of the media type then it is not a technical\n&gt; issue with the contract between client and service _software_. It is\n&gt; more of an issue between the operator of the client and the operator\n&gt; of the service -- maybe I&#39;m splitting hairs here but it seems to be\n&gt; different than what you are describing. And more importantly doesn&#39;t\n&gt; seem to have any differences in the machine-to-machine vs.\n&gt; human-to-machine contexts. i.e. if Amazon stopped selling books, it\n&gt; would trip up a human too. The solution --  go to a different start\n&gt; URI -- applies in both contexts as well.\n\nRight. But as said above: there are a substantial number of people  \nthat won&#39;t buy into it. And often rightly so because when you assign  \nbudget to something. It is all about documenting the assumptions that  \nmight break. I do not see media types to be the means where this can  \nbe done. Especialy not when a service uses a combination of hypermedia  \nsemantics. Or how would you express that a service pronises to use a  \ncertain Atom extension? You could if you&#39;d define application/myatom  \nand make the extension mandatory but this obviously breaks  \northogonality.\n\n\n&gt; And Firefox is not going to\n&gt; figure out what alternate URI to use just as a machine-driven client\n&gt; will not.\n&gt;\n&gt; If the service started spitting back representations that did not\n&gt; conform to the client&#39;s media type. Then I think you can say that the\n&gt; software contract is broken (especially if the client is setting it&#39;s\n&gt; accept headers properly). But this again equally trips up machine\n&gt; driven and human driven client software.\n\nYes. So, how does a service say what media types the client may safely\nexpect?\n\n\n&gt;\n&gt;&gt;\n&gt;&gt; Technically, this is inevitable and no other, more specialized  \n&gt;&gt; interface\n&gt;&gt; will help you, because if a Web service does not implement some\n&gt;&gt; service.search() anymore the SOAP call will also fail and no WSDL  \n&gt;&gt; will\n&gt;&gt; prevent that. This is just the nature of binding the components at  \n&gt;&gt; runtime\n&gt;&gt; and not at compile time (as you would in a non-networked  \n&gt;&gt; application).\n&gt;&gt;\n&gt;&gt; The problem is at the business level though because the WSDL  \n&gt;&gt; specifies a\n&gt;&gt; contract that defines the search method to be there and if you SOAP  \n&gt;&gt; call\n&gt;&gt; fails, you can take the WSDL and the stack trace, run to your service\n&gt;&gt; provider and say: &quot;Where&#39;s that method you *promised*?&quot;).\n&gt;&gt;\n&gt;\n&gt; Right. So in REST, the software contract is more &quot;client specific&quot;.\n&gt; i.e. the client supports a known media type and the service targets\n&gt; that media type and all clients that support it. So the &quot;missing\n&gt; method&quot; equivalent would be somehow not conforming to the media type\n&gt; supported by the client. And if search capability was something that\n&gt; had to be in every document of that media type then you get the same\n&gt; sort of contract. But often that is not the case (it isn&#39;t the case\n&gt; with HTML and lots of other media types anyways).\n&gt;\n&gt; Instead the service is publishing a URI and saying  &quot;somewhere behind\n&gt; this URI, search is going to happen&quot;.\n\nSo, how does it say that?\n\n&gt; But that is a contract between\n&gt; the client operator and the service operator about the semantics of\n&gt; the service, not the interface.\n\nWell, yes. It is all about how this contract is best established and  \nwritten.\n\n&gt; The WSDL equivalent might be the case\n&gt; where the search method is there but it doesn&#39;t provide search\n&gt; semantics (e.g. it always spits back the same results no matter what\n&gt; the search terms are).\n&gt;\n&gt;\n&gt;&gt; With REST, there is (deliberately) no such contract and the client&#39;s\n&gt;&gt; expectation that there will be a search resource is based on  \n&gt;&gt; observation and\n&gt;&gt; trust and on some cloud-level based knowledge about the overall  \n&gt;&gt; kind of the\n&gt;&gt; interaction.\n&gt;&gt;\n&gt;&gt; From the service owner perspective it is also an interesting  \n&gt;&gt; question, how a\n&gt;&gt; developer would know if he could take away the search resource.  \n&gt;&gt; After all,\n&gt;&gt; there is no contract to look at that would make clear what the client\n&gt;&gt; expectations really are. IOW, if you are in charge of evolving the  \n&gt;&gt; service,\n&gt;&gt; you should have a pretty clear source that tells you what you can  \n&gt;&gt; change and\n&gt;&gt; what you cannot change. This is rather easy on the media type level  \n&gt;&gt; but it\n&gt;&gt; is also the combination of hypermedia sematics in use that matter.  \n&gt;&gt; &quot;Are my\n&gt;&gt; clients &#39;licensed&#39; to assume the presence of that Atom extension or  \n&gt;&gt; are they\n&gt;&gt; not? Well, we never told them we&#39;d never take it away so we can  \n&gt;&gt; drop it at\n&gt;&gt; any time, right?&quot;\n&gt;&gt;\n&gt;&gt; One approach to all this is probably to simply state that a service  \n&gt;&gt; will\n&gt;&gt; never evolve in an incompatible way (e.g. &quot;we&#39;ll never remove  \n&gt;&gt; anything&quot;) and\n&gt;&gt; if it has to be incompatible, there&#39;ll just be a new service.\n&gt;&gt;\n&gt;&gt; Now, I am not trying to be enterprisey and ride the &#39;oh, inside the  \n&gt;&gt; enetrpsi\n&gt;&gt; there are the hard problems&#39; horse, but &#39;follow your nose&#39; just  \n&gt;&gt; does not\n&gt;&gt; provide the specifics that managers and lawyers (usually rightly  \n&gt;&gt; so) demand.\n&gt;&gt;\n&gt;&gt; What is particulary interesting is that IMHO there is the danger  \n&gt;&gt; of, in the\n&gt;&gt; usual attempt to escape this situation, there is far too much  \n&gt;&gt; coupling put\n&gt;&gt; into the descriptive documents and many of REST&#39;s advantages lost  \n&gt;&gt; (see\n&gt;&gt; interface docs for example that list the URIs of the resources to  \n&gt;&gt; use, what\n&gt;&gt; formats to expect and which HTTP return codes - and what they  \n&gt;&gt; mean(!) in the\n&gt;&gt; service context).\n&gt;&gt;\n&gt;&gt; So, balance is really important.\n&gt;&gt;\n&gt;&gt; Jan\n&gt;&gt;\n&gt;\n&gt; So here&#39;s an observation: In the web (and in the VoiceXML/CCXML\n&gt; world), extension support and in general, media type evolution is\n&gt; driven by clients not services. In the machine-driven-REST world, the\n&gt; trend seems to be the opposite. That means service interfaces are\n&gt; &quot;service specific&quot; (e.g. the media type is service-specific or\n&gt; includes service-specific extensions, namespaces or relations). That\n&gt; means coupling. That means that you don&#39;t get the full advantages of\n&gt; REST. If I had to point to a constraint being violated, I&#39;d say it was\n&gt; &quot;Self-Descriptive Messages&quot;. I don&#39;t see how a message can be\n&gt; self-descriptive if it is in a service-specific format. To me that is\n&gt; a key part of using &quot;standard&quot; media types -- the media type exists\n&gt; outside of the context of your service.\n\nYes, that is a very, very good way to see it. When enterprises engage  \nin a REST effort, they should not worry about defining services (but  \nit is what everybody immediately does :-) The should form a central  \nboard (like the IETF) and get their media types sorted out. At least  \nenough to get the project rolling. If you do the types as you need  \nthem for the services you won&#39;t get the generalization level right.  \n(You should of course let the envisioned services inspire your central  \neffort). So, to repeat your very true words:\n\n&gt; &quot;the media type exists outside of the context of your service.&quot;\n\n\n\n&gt; But I know a lot of folks have\n&gt; different interpretations of what &quot;standard&quot; means in the context of\n&gt; REST. The differences are subtle but I think the implications are\n&gt; huge.\n\nYes and yes.\n\nJan\n\n\n&gt;\n&gt; Andrew\n\n--------------------------------------\nJan Algermissen\n\nMail: algermissen@...\nBlog: http://algermissen.blogspot.com/\nHome: http://www.jalgermissen.com\n--------------------------------------\n\n\n\n\n"}}