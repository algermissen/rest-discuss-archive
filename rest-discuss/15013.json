{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":242972596,"authorName":"JÃ¸rn Wildt","from":"=?iso-8859-1?Q?J=F8rn_Wildt?= &lt;jw@...&gt;","profile":"jorn_lind_nielsen","replyTo":"SENDER","senderId":"jjuYkrTQMohKQFgLyZyPaik2kHCMfXbMiRzwCdKUbEastpcRJBCPXLp-S7UYa0cw2bQ5RCll0E4bMG9FhJF9CStxiIIvAGqcgh2NzRvLnR1lrebyg4LXsVI","spamInfo":{"isSpam":false,"reason":"3"},"subject":"Re: [rest-discuss] Re: Thoughts about URLs for a REST driven website","postDate":"1267910119","msgId":15013,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDE5Mzg3ODczMjNBMDQxOTFCNDkwODQwMEQyOEFDMkY5QEpyblBDPg==","inReplyToHeader":"PDIwMTAwMzA2MTEzNjAyLmU4MmMxNGNhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PDIwMTAwMzA0MDQ1MTA3LjgwM2ZlMzMwLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4gPGhtbzhzbis3dXFmQGVHcm91cHMuY29tPiA8MjAxMDAzMDYxMTM2MDIuZTgyYzE0Y2EuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pg=="},"prevInTopic":15012,"nextInTopic":15015,"prevInTime":15012,"nextInTime":15014,"topicId":14978,"numMessagesInTopic":41,"msgSnippet":"Thanks again for a thorough answer. I ll do my best to formulate what I think. Apparently it s not that easy :-) ... Yes! It should be opaque to the client.","rawEmail":"Return-Path: &lt;jw@...&gt;\r\nX-Sender: jw@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 50234 invoked from network); 6 Mar 2010 21:14:45 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m13.grp.re1.yahoo.com with QMQP; 6 Mar 2010 21:14:45 -0000\r\nX-Received: from unknown (HELO smtp1.cybercity.dk) (212.242.43.251)\n  by mta1.grp.re1.yahoo.com with SMTP; 6 Mar 2010 21:14:45 -0000\r\nX-Received: from uf4.cybercity.dk (uf4.cybercity.dk [212.242.42.51])\n\tby smtp1.cybercity.dk (Postfix) with ESMTP id 2487858685D;\n\tSat,  6 Mar 2010 22:17:38 +0100 (CET)\r\nX-Received: from JrnPC (port439.ds1-aroe.adsl.cybercity.dk [212.242.220.134])\n\t(Authenticated sender: dsl164923)\n\tby uf4.cybercity.dk (Postfix) with ESMTPA id 62C2B1328D72;\n\tSat,  6 Mar 2010 22:14:40 +0100 (CET)\r\nMessage-ID: &lt;1938787323A04191B4908400D28AC2F9@JrnPC&gt;\r\nTo: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nCc: &lt;rest-discuss@yahoogroups.com&gt;\r\nReferences: &lt;20100304045107.803fe330.eric@...&gt; &lt;hmo8sn+7uqf@...&gt; &lt;20100306113602.e82c14ca.eric@...&gt;\r\nIn-Reply-To: &lt;20100306113602.e82c14ca.eric@...&gt;\r\nDate: Sat, 6 Mar 2010 22:15:19 +0100\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tformat=flowed;\n\tcharset=&quot;iso-8859-1&quot;;\n\treply-type=original\r\nContent-Transfer-Encoding: 8bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Windows Mail 6.0.6002.18005\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.0.6002.18005\r\nX-eGroups-Msg-Info: 2:3:4:0:0\r\nFrom: =?iso-8859-1?Q?J=F8rn_Wildt?= &lt;jw@...&gt;\r\nSubject: Re: [rest-discuss] Re: Thoughts about URLs for a REST driven website\r\nX-Yahoo-Group-Post: member; u=242972596; y=IXttaAnj7zSe_swnwiE5NH8tiaTB5S37OiuM0Kx7t__siw_3S11poh0IZw0\r\nX-Yahoo-Profile: jorn_lind_nielsen\r\n\r\nThanks again for a thorough answer. I&#39;ll do my best to formulate what I \nthink. Apparently it&#39;s not that easy :-)\n\n&gt; Of course.  Again, so?  REST is a layered architecture.  A client\n&gt; interacts with your front-end, it cannot &quot;see&quot; farther than that.  Your\n&gt; front-end resource knows how to map that request onto the back-end\n&gt; system, but this interaction should be opaque to the client.\n\nYes! It should be opaque to the client. Certainly. One more reason not to \npass the complete URL back to the client. We certainly agree on that (it&#39;s \nnot that I want to pass the full resource URL, quite the opposite, I am just \ntrying to figure out how to avoid it in the most RESTful way).\n\n&gt; You&#39;re obviously misunderstanding\n&gt; something, I&#39;m trying to figure out what, exactly.  I think, perhaps,\n&gt; you&#39;re misinterpreting Roy&#39;s comment, &quot;A REST API should be entered\n&gt; with no prior knowledge beyond the initial URI (bookmark)...&quot;.\n\nYes, this is the constraint I am working with.\n\n&gt; This applies to the client&#39;s interaction with the system.\n\nYes. But in this setup we have two clients. One client is our front-end \nconsuming the back-end API. Another client is the web-browser consuming our \nfront-end. Both consumers should behave RESTful and have as little apriori \nknowledge as possible of the REST system it consumes.\n\n&gt; Whereas, in a decoupled system, the back-end URI allocation can change\n&gt; and the front-end only needs to be reconfigured.\n\nStop. You said &quot;front-end needs to be reconfigured&quot;. This means you have a \nstatic coupling between your front-end and your backend REST API. This is \nwhat I am trying to avoid. Everybody says &quot;Thou shall not have static \ncouplings to the REST API you consume&quot;.\n\nBy passing the complete resource URLs around I can modify my backend \nstructure as much as I want, and I&#39;ll never have to configure or recode \nanything in the front-end.\n\n&gt; Now, imagine the mess updating the /date backend would cause, if all\n&gt; requests looked something like this:\n&gt;\n&gt; http://charger.bisonsystems.net/date?url=http://en.wiski.org/date?iso=\n&gt;\n&gt; See how, by trying to pass the back-end URIs around inside the front-end\n&gt; URIs, the system becomes coupled due to the requirement that the client\n&gt; must &quot;see&quot; beyond the server it&#39;s interacting with\n\nBut URLs are opaque - right? The client, a web-browser, can ignore anything \nthats contained in &quot;?url=...&quot;. The stuff in the dots is just an opqaue \nidentifier to the client. It could be anything. The fact that it is a URL is \nirrelevant to the client. Some blogging system even has complete URLs as \ntheir ATOM identifiers.\n\nLets assume the user makes a search for &quot;peter&quot; on our front-end. This in \nturns makes the front-end forward the keyword &quot;peter&quot; to a published search \nURL in the REST API. The REST API then returns an ATOM entry like below, \ntelling the REST API consumer (our front-end) where it can find the \nresource:\n\n  &lt;entry&gt;\n    &lt;link rel=&quot;self&quot; href=&quot;http://rest.mysite.com/feeds/peter&quot;/&gt;\n  &lt;/entry&gt;\n\nREST is all about hypermedia and following links. So the REST consumer, our \nfront-end, should not care about the content of the URL. It should just \naccept that URL as a resource reference and use it as such.\n\nIf our front-end was a .NET/Java application it would then keep that URL in \nmemory while it presented a selection list to the end-user. When the \nend-user selected the &quot;link&quot;, it would lookup the selection index, find the \nresource URL, fetch it, and present peter&#39;s ATOM content to the end-user.\n\nBut unfortunately our client is a website and we want to present a single \nURL for the end-user to click. A URL which would direct the end-user to a \npage that loads the found resource, formats it using HTML, and return that \nHTML to the end-user. How would that link look? Well, it would have to \ncontain the whole resource reference (and I can already here you scream \n&quot;noooo!&quot;, but read on).\n\nBut, yes, I am totaly aware that the ATOM entry also contains an identifier:\n\n  &lt;entry&gt;\n    &lt;id&gt;peter&lt;/id&gt;\n    &lt;link rel=&quot;self&quot; href=&quot;http://rest.mysite.com/feeds/peter&quot;/&gt;\n  &lt;/entry&gt;\n\nNow, my front-end can decide to get the ID, use it&#39;s apriori knowledge of \nthe back-end URL format, and convert it to the complete URL when needed. But \nfrom a RESTful point of view, what is best - to let the front-end construct \nthe URL based on some configuration of how the REST API behaves, or to just \nfollow the link that the back-end server has created for us?\n\n&gt; Where in REST are you getting the notion that your API can&#39;t know\n&gt; anything about the client?\n&gt; ...\n&gt; Each XHTML representation has a link rel=&#39;alternate&#39;\n\nLets take another example. I want to make a website that shows Flickr \nalbums. I let my user enter search keywords on my website, forward that to \nFlickr, parse the search result, and present it to my end user. Lets also \nassume Flickr uses ATOM for the search result. Now, would Flickr have any \nway to generate an &quot;alternate&quot; link for me? No, certainly not. So again I \ncan only take Flickr&#39;s complete album resource URL and put that into the \nlink for my &quot;show_this_ Flickr album&quot; webpage in my system.\n\nBut I actually got one solution suggested by Sebastian from Open Rasta. See \nhttp://groups.google.com/group/openrasta/browse_thread/thread/f5994b6c7ce231b6\n\nTo avoid the static coupling we need a way for the REST API to announce it&#39;s \nURL formats at runtime. This can be done using HTML forms. Now the front-end \ncan lookup the search form for blogs, decode it, and conclude that the blog \nURL format is http://rest.mybackend.com/feeds?blogname={xxx} where &quot;xxx&quot; is \na query parameter defined with an &lt;input name=&quot;blogname&quot;/&gt; element.\n\nThanks for reading all this through.\n\n/Jï¿½rn\n\n\n"}}