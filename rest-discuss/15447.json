{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"6F8rFFXFwEqQgJzmCPld00EyALdp5uow8stuuCVF0V0cx1FhOpfDLZ9BysJ0alk4NYqVC-lOYYeBDMV3oelh5Oe-ZtF-k94StqR1guIyyw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] PUT/POST content type hints","postDate":"1275286321","msgId":15447,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNTMxMDAxMjAxLjVhNWIxYTU4LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDRCRkFFOUMyLjcwNDA3MDBAc2l0ZXBlbi5jb20+","referencesHeader":"PEFBTkxrVGlseHpTY21NV1A4SndSclF0cTFyRHpOLU5VQzFrMjZyeUU0b2N3VUBtYWlsLmdtYWlsLmNvbT4JPDRCRTg2RjU4LjYwNjAyMDlAc2l0ZXBlbi5jb20+CTwyMDEwMDUxMTA0MzE0Ny5mOTVjYWU1MC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTw0QkZBRTlDMi43MDQwNzAwQHNpdGVwZW4uY29tPg=="},"prevInTopic":15400,"nextInTopic":0,"prevInTime":15446,"nextInTime":15448,"topicId":15322,"numMessagesInTopic":12,"msgSnippet":"(Unreferenced citations in my posts here, as always, come from Roy s thesis.) (Long, lecture-y posts, as always, come about when I feel that fundamental","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 90243 invoked from network); 31 May 2010 06:12:06 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m12.grp.re1.yahoo.com with QMQP; 31 May 2010 06:12:06 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta3.grp.sp2.yahoo.com with SMTP; 31 May 2010 06:12:05 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 348C4509DC;\n\tMon, 31 May 2010 02:12:03 -0400 (EDT)\r\nDate: Mon, 31 May 2010 00:12:01 -0600\r\nTo: Kris Zyp &lt;kris@...&gt;\r\nCc: REST-Discuss Discussion Group &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100531001201.5a5b1a58.eric@...&gt;\r\nIn-Reply-To: &lt;4BFAE9C2.7040700@...&gt;\r\nReferences: &lt;AANLkTilxzScmMWP8JwRrQtq1rDzN-NUC1k26ryE4ocwU@...&gt;\n\t&lt;4BE86F58.6060209@...&gt;\n\t&lt;20100511043147.f95cae50.eric@...&gt;\n\t&lt;4BFAE9C2.7040700@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] PUT/POST content type hints\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\n(Unreferenced citations in my posts here, as always, come from Roy&#39;s\nthesis.)\n\n(Long, lecture-y posts, as always, come about when I feel that\nfundamental violations of Web architecture are being discussed.)\n\nKris Zyp wrote:\n&gt; \n&gt; On 5/11/2010 4:31 AM, Eric J. Bowman wrote:\n&gt; &gt; Kris Zyp wrote:\n&gt; &gt;&gt;\n&gt; &gt;&gt; I believe one should be able to assume that the content type of the\n&gt; &gt;&gt; representation returned from a server from GET for URI is\n&gt; &gt;&gt; acceptable in a PUT request to that server for the same URI.\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; Absolutely not.  The late binding of representation to resource\n&gt; &gt; precludes this assumption.  HTML is capable of providing an\n&gt; &gt; interface to an Atom system.  What media type to PUT or POST to the\n&gt; &gt; system is explicitly provided in the markup, i.e. a\n&gt; &gt; self-documenting interface.\n&gt; &gt;\n&gt; &gt; Assuming that you can PUT or POST HTML to my system because that&#39;s\n&gt; &gt; the media type I sent on GET would not work -- I derive HTML from\n&gt; &gt; Atom, not the other way around.\n&gt; &gt;\n&gt; &gt; A PUT of an HTML document would show an intent to replace the\n&gt; &gt; self-documenting interface provided by the HTML representation, with\n&gt; &gt; some other application state.  HTML is generated by my system, it\n&gt; &gt; is not subject to change via PUT to negotiated resources which\n&gt; &gt; happen to return text/html or application/xhtml+xml on GET with a\n&gt; &gt; Web browser, but happen to return Atom to a feed reader.\n&gt; \n&gt; I certainly agree that receiving a media type from a server does not\n&gt; guarantee that a server can receive that same media type from the\n&gt; client. However, in the absence of knowledge of a different explicit\n&gt; media type preference (from the media type definition) when it comes\n&gt; to negotiating an acceptable type with the server, pretending the all\n&gt; media types are equally likely is as silly as pretending that any\n&gt; language is any equally likely to be understood in response to someone\n&gt; who speaks to you in french.\n&gt;\n\nI don&#39;t pretend that my website output will be understood by someone\nwhose browser indicates that they only know French.  But, I can respond\n406 with the default English variant as entity-body, because it&#39;s the\nbest representation I have.  I &quot;send whatever is most likely to be\noptimal first and then provide a list of alternatives for the client to\nretrieve if the first response is unsatisfactory.&quot;\n\nThe French user&#39;s browser may not know that the user also understands\nthe German variant of my (hypothetical) website, but the French user\nmay recover from the unintelligible English variant by selecting the\nGerman variant, via link rel=&#39;alternate&#39; elements or headers with lang\nattributes presented in browser chrome, or via links displayed within\npage content (the latter being WAI-approved).\n\nDon&#39;t work around REST&#39;s respond-first-recover-later approach by trying\nto first determine the optimal response, by making guesses about what\nthe system isn&#39;t telling you -- just respond to what the system *is*\ntelling you.  In REST, error recovery only occurs _after_ the error,\nas the error response itself may be the mechanism through which such\nrecovery occurs.\n\n(If content is moved to another site, the proper response is a 301\nredirect -- unless that site&#39;s policy forbids deep linking, in which\ncase the link may be displayed as text in the body of a 410 response,\nwith instructions to cut-and-paste.  Regardless of whether conneg is\ninvolved, and if so, regardless as to whether it&#39;s language-based or\nmedia-type-based, errors must be allowed to occur instead of trying to\nhead them off by guessing anything.)\n\nIf there is some absence of knowledge of media type preference, it is\nan error with the coding of the system, or as Roy put it so eloquently,\na case of playing frisbee with your dog backwards.  A resource may\nindicate via an Accept (or Accept-Patch) header, what media types it\nunderstands.  A user agent following its nose may be instructed to send\na POST as multipart/form-data containing text/plain, but determine from\na HEAD request to the target that application/atom+xml is also Accept-ed\n(while also confirming that POST is Allow-ed), and send that instead.\n\nDone properly, REST removes any need to make any guesses about metadata,\nin any situation.  The user agent is always instructed as to what it\ncan do, so any code attempting to infer what to do in the absence of\nsome piece of knowledge is solving the problem backwards, i.e.\nexpecting the dog to throw the frisbee.\n\nIf user agents aren&#39;t being instructed properly, fix the system such\nthat they are, instead of &quot;fixing&quot; the user agents to infer &quot;properly&quot;\naccording to some sniffing algorithm.  Such sniffing algorithms may be\nnecessary in real-world browser development, but are anathema to REST.\n\n&gt;\n&gt; &gt;\n&gt; &gt;&gt;\n&gt; &gt;&gt; When using JSON,\n&gt; &gt;&gt; additional information about acceptable property values can be\n&gt; &gt;&gt; determined from any JSON Schema referenced by the resource. In\n&gt; &gt;&gt; other words, if you GET some resource, and the server responds\n&gt; &gt;&gt; with:\n&gt; &gt;&gt;\n&gt; &gt;&gt; Content-Type: application/my-type+json; profile=my-schema\n&gt; &gt;&gt;\n&gt; &gt;&gt; One could retrieve the schema from the &quot;my-schema&quot; relative URI\n&gt; &gt;&gt; and do a PUT using the application/my-type+json content type with\n&gt; &gt;&gt; the schema information as a guide to what property values are\n&gt; &gt;&gt; acceptable.\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; Sure you can *do* this, it just wouldn&#39;t be REST.  Leaving aside\n&gt; &gt; that the media type identifier definition for JSON doesn&#39;t say\n&gt; &gt; anything about extending it using *+json, the media type definition\n&gt; &gt; for JSON says nothing about HTTP methods.  Where have you provided\n&gt; &gt; a self-documenting interface giving a target URI, method and media\n&gt; &gt; type -- as provided by forms languages having no corollary in JSON,\n&gt; &gt; yet required by REST?\n&gt; &gt;\n&gt; &gt; If you &quot;just know&quot; that you can PUT or DELETE some JSON resource,\n&gt; &gt; it&#39;s no more RESTful than &quot;just knowing&quot; that you can PUT or DELETE\n&gt; &gt; some JPEG.  You&#39;re resorting to unbounded creativity, rather than\n&gt; &gt; using standard media types and link relations which *do* cover HTTP\n&gt; &gt; methods, for any target media type.\n&gt; &gt;\n&gt; \n&gt; RFC2616 sufficiently defines the meaning of PUT and DELETE, a media\n&gt; type does not need to conflate protocol concerns to be RESTful.\n&gt;\n\nAs I&#39;ve said many times, media types don&#39;t redefine or override method\ndefinitions (saying this PUT is actually a PATCH in the presence of\nsuch-and-such media type, is kinjiru).  However, a media type which\nconstrains the scope of *possible* method semantics to a *specific*\nbehavior is not conflating anything.\n\n&quot;\nThe data format of a representation is known as a media type.  A\nrepresentation can be included in a message and processed by the\nrecipient according to the control data of the message and the nature\nof the media type.  Some media types are intended for automated\nprocessing, some are intended to be rendered for viewing by a user, and\na few are capable of both.  Composite media types can be used to enclose\nmultiple representations in a single message.\n&quot;\n\nIn fact, such media types are required for REST systems to process\nrequests, since REST systems rely on the combination of control data\nand &quot;the nature of the media type&quot;.  Stating &quot;see RFC2616&quot; indicates a\nworldview where the nature of the media type is irrelevant to request\nprocessing.  This is (one reason) why we&#39;re so fond of saying HTTP !=\nREST here.\n\nREST is protocol-agnostic.  By introducing a stream transducer to\nautomate name-value-pair handling for SMTP messages to a standard\nlistmail, I can implement an HTML-based REST application using forms&#39;\n@method=&#39;post&#39; @action=&#39;mailto:group@listmail&#39;.  The next application\nsteady-state is displayed when the next response to the thread hits\nthe INBOX. The only over-the-wire protocol used in such a scenario is\nSMTP.\n\nThis is why I consider it an error that HTML defines protocol-specific\nmethod semantics instead of generic method semantics.  But, far from\nconflating protocol concerns, HTML manages to constrain the use of HTTP\nto specific media types for specific methods.  You can send any media\ntype with a POST, it just has to be declared within multipart/form-data.\n\nhttp://www.w3.org/TR/html401/interact/forms.html#h-17.13.1\n\nNotice how removing the string &quot;HTTP&quot; from that section changes it to\nbe inclusive of other protocols like FTP or SMTP which, in practice,\nalready work with HTML forms anyway?  Saying &quot;see RFC2616&quot; tends to\nimply that the media type is not to be transferred over other protocols\n(like XMPP).  Are you sure you want a JSON schema language which\nrestricts JSON to HTTP-only implementations?  This may be fine for Atom\nProtocol, but it&#39;s an odd choice for a schema language.\n\nHTTP, in REST, is an application protocol based on media type, not a\nmedia-type-agnostic transport protocol like FTP.  A system which\nprocesses requests based strictly on the control data (as opposed to\nrequest processing based on the combination of control data + media\ntype), may as well be using FTP.  Most REST claimants are really HTTP-\nRPC, because they&#39;re using HTTP as FTP with caching -- still just a\ntransport protocol.\n\nWhile RESTful interaction is possible over FTP, SMTP or even XMPP, only\nHTTP exists (so far) as a true RESTful application protocol.  That&#39;s why\nit&#39;s entirely appropriate that Atom Protocol chose HTTP method semantics\n(both constraining and defining their behavior, i.e. PUT only replaces\nbut doesn&#39;t create, and DELETE on a media entry also deletes the media\nfile, neither of which changes the semantics of either method) rather\nthan generic semantics; HTTP&#39;s application-protocol capabilities (like\nconditional requests) just aren&#39;t present in other protocols.\n\nUsing HTTP as a transport protocol results in HTTP-RPC implementations,\nlike the sparse-bit array solution Roy hypothesizes, here:\n\n&quot;\nI should also note that the above is not yet fully RESTful, at least\nhow I use the term. All I have done is described the service\ninterfaces, which is no more than any RPC. In order to make it RESTful,\nI would need to add hypertext to introduce and define the service,\ndescribe how to perform the mapping using forms and/or link templates,\nand provide code to combine the visualizations in useful ways. I could\neven go further and define these relationships as a standard, much like\nAtom has standardized a normal set of HTTP relationships with expected\nsemantics, but I have bigger fish to fry right now.\n&quot;\n\nhttp://roy.gbiv.com/untangled/2008/paper-tigers-and-hidden-dragons\n\nSaying &quot;Here&#39;s my data format, use HTTP&quot; is not the same thing as a\nhypertext API which either re-uses or creates media types which\ndelineate generic operations.  Roy is clearly saying that having some\ncollection of GIF images (be they sparse-bit arrays or pictures of your\ndog playing frisbee) you can interact with using GET, PUT and DELETE\nand the http:// URI scheme (i.e. &quot;see RFC2616&quot;) is RPC, _not_ REST.\n\nA Uniform REST Interface has a generic &quot;retrieval operation&quot; which maps\nto &quot;GET&quot; in HTTP, &quot;RECV&quot; in FTP etc.  This operation may also be\nreferred to as &quot;dereferencing a resource.&quot;  So a REST API&#39;s methods are\na function of whatever protocols are specified by its resources&#39; URI\nschemes.  In REST, an API can remain static as protocols evolve -- the\nwaka protocol and the HTTP protocol would accomplish exactly the same\nthing, using different syntax, with waka presumably offering better\ncaching and pipelining that works, but serving the same representations\n(except that URIs will vary by scheme); they can even run in parallel.\n\nIn a RESTful Atom Protocol system, the media type specifies HTTP, not\nFTP, therefore the generic retrieval operation maps to HTTP GET.  The\ndecision to restrict Atom Protocol operations to HTTP was deliberate\nand reasoned.  Whereas HTML 4.01&#39;s form definition is an example of a\nREST mismatch -- I would correct it as follows:\n\n&quot;\nretrieve:  Using the &#39;retrieval&#39; method, the form data set is appended\nto the URI specified by the action attribute (with a question-mark\n(&quot;?&quot;) as separator) and this new URI is sent to the processing agent.\n\nsubmit:  Using the &#39;submission&#39; method, the form data set is appended\nto the URI, or sent in the body of the request, and sent to the\nprocessing agent.\n\nremove:  Using the &#39;removal&#39; method, the URI specified by the action\nattribute is removed by the processing agent.\n&quot;\n\nThis wording is more deferential to the nature of the URI and media\ntype chosen.  The text/html media type (HTML 5 is WIP so I don&#39;t\ninclude it yet) doesn&#39;t restrict itself to the HTTP protocol anywhere\nelse, forms shouldn&#39;t have either.  I would also change the wording\nsuch that application/x-www-form-urlencoded could be used with any\nmethod/operation.  I would alter the wording on idempotency to defer to\nthe protocol method used on submission operations.\n\nMy way, the HTML coder can use &#39;retrieve&#39; plus &#39;application/x-www-form-\nurlencoded&#39; to instruct user agents to append specifically-formatted\nname-value-pair ASCII text to a target URI of any protocol scheme.  The\nover-the-wire method used is determined by the user agent (i.e. GET for\nHTTP, RECV for FTP) depending on the combination of protocol and media\ntype.\n\nHTML coders could instruct user agents to PUT by using &#39;submit&#39; and a\nmedia type that isn&#39;t application/x-www-form-urlencoded or multipart/\nform-data, both of which would signal the user agent to POST, assuming\nHTTP URIs (Atom content may be POSTed within multipart/form-data to\nmaintain some semblance of Atom Protocol).  PATCH is a possible result,\ngiven a delta-only media type (someone really should define one for\nname-value pairs).\n\nOther URI schemes would yield different results, for example there&#39;s no\nPOST in FTP, but there&#39;s also no reason one couldn&#39;t RECV from an FTP\nURI using application/x-www-form-urlencoded (a media type identifier\nnot meant to go over the wire) to instruct the user agent how to format\nthe request (same w/ DELETE).  An FTP request to PUT either media type\nwould be possible, too.\n\nSuch a re-wording of HTML 4.01 would not only remove the REST mismatch,\nbut also describe how most browsers work in practice with GET and POST\nform methods (&#39;get&#39; and &#39;post&#39; values for @method would be deprecated,\nbut not removed, by my proposal) using schemes other than http:, as well\nas those oddball user agents which allow &#39;put&#39; as an HTML 4.01 form\n@method.\n\nThis rather long example (do I write any other kind) illustrates proper\nRESTful media type design, by showing how some minor changes to HTML\n4.01 would result in the text/html media type being capable of\nproviding a hypertext REST API for an Atom Protocol-ish system without\nresorting to scripting, invalid markup or major (HTML 5, Xforms)\nrethinking of forms.\n\nThe key takeaway here, is I&#39;ve just designed an extension to HTML 4.01\nand the text/html media type identifier.  All it does is define three\ngeneric operations for use in @method and specify their behavior in\ncombination with standard media types.  I&#39;ll probably flesh it out as a\nstandalone document, come to think of it. This extension to text/html\nmay be supported natively within browsers, or implemented using XHR\ncode-on-demand to extend the browser&#39;s knowledge of text/html to\nencompass the extension.\n\nI do not need to reference generic or protocol-specific methods,\nexplaining that one combination yields PUT and another yields POST when\nthe protocol is HTTP, or that retrieval operations follow HTTP GET --\nthis common-knowledge coupling is contained within the definitions of\nthe protocols identified by the URI scheme.  For the same reason, you\ncan&#39;t say &quot;see RFC2616&quot; to define form action methods, because this\ndoesn&#39;t instruct the client what to do if the URI scheme is mailto:.\n\nThe media type of whatever hypertext is driving a REST API doesn&#39;t\nredefine or override method definitions (although media types may\ndefine new methods).  Nor, as Roy has said, can it &quot;bind a service to\ndo anything -- it only serves as a guide for interpretation of the\ncurrent state.&quot;  So REST requires a forms language capable of\ninstructing the client how to change state according to the underlying\nAPI (the hypertext constraint), such that client-side assumptions,\nguessing and sniffing don&#39;t factor in.\n\nhttp://www.imc.org/atom-protocol/mail-archive/msg11487.html\n\nIn order for JSON to be such a forms language, it can&#39;t bind a service\nto behave as a WebDAV fileserver by saying &quot;see HTTP&quot; (granted, you&#39;ve\nsaid &quot;see RFC2616&quot; but that&#39;s even more restrictive by saying I can&#39;t\nuse MGET, etc.), it must instead serve as a guide for the user agent to\ninterpret responses.\n\nWhen a browser encounters a form with method GET and media type\napplication/x-www-form-urlencoded, if all the browser developer had to\ngo on was &quot;see RFC2616&quot; then a GET would be made to the target URI,\nwith an urlencoded entity-body and a Content-Type header.  Which, of\ncourse, is nonsensical -- the media type simply instructs the client\nhow to format the URL for the GET request (which certainly isn&#39;t\napparent from reading RFC2616 to determine how to handle this action).\n\nThe text/html media type instructs the client how to convert form\nfields into name-value pairs.  The application/x-www-urlencoded media\ntype instructs the client how to encode the name-value pairs into a URI\nquery segment.  If and only if the protocol is HTTP, does RFC2616 come\ninto play, defining how to send the prepared query URI to the server as\na properly-formatted GET request and interpret the response code.\n\nSo I really can&#39;t emphasize strongly enough that just plugging HTTP\nmethods into a form and relying on the client&#39;s inherent knowledge of\nHTTP to guess what to do, falls short of what&#39;s needed for hypertext\nREST API development.  That your particular project is JSON doesn&#39;t\nmatter.  Any markup language can potentially be made into a hypertext\nmedia type.\n\nBut the only way such a media type is useful in REST is if it\ndelineates the behavior of generic operations, and provides enough\nstructure to distinguish the variant purposes of different URIs and\ndifferent media types.  Some URIs instruct clients how to interpret\nrepresentations (XML namespaces) and aren&#39;t meant for dereferencing,\njust as some media type identifiers are meant to be transmitted as\nheaders, while others are meant as hypertext instructions to the user\nagent (format these name-value pairs as a URI query string).\n\n&gt;\n&gt; &gt;&gt; Discovery of POST actions is completely different than PUT (since\n&gt; &gt;&gt; PUT&#39;s behavior is implied by a GET response). A JSON Schema can\n&gt; &gt;&gt; describe possible POST actions with submission links, including an\n&gt; &gt;&gt; acceptable content type (in the &quot;enctype&quot; property).\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; I don&#39;t see how.  Regardless of schema, there&#39;s simply no mention in\n&gt; &gt; the media type definition of JSON for describing URIs or methods,\n&gt; &gt; i.e. there&#39;s no forms language.  The demo I posted consists of\n&gt; &gt; XHTML steady- states derived from various source representationss\n&gt; &gt; of other media types.  These steady-states (will) provide a\n&gt; &gt; self-documenting API to the underlying Atom-based system.\n&gt; &gt;\n&gt; &gt; The user isn&#39;t trying to discover PUT vs. POST actions.  The user is\n&gt; &gt; trying to drive an application to another steady-state.  The user\n&gt; &gt; agent needs to translate that user goal into HTTP interactions.  If\n&gt; &gt; the user is trying to add a new post, the user agent is instructed\n&gt; &gt; to POST to the domain root.  If the user is trying to add a new\n&gt; &gt; comment, the user agent is instructed to POST to the appropriate\n&gt; &gt; comment thread.  If the user intent is to edit an existing entry,\n&gt; &gt; the user agent is instructed to PUT to the existing URI.  In each\n&gt; &gt; case, the user agent is instructed to use application/atom+xml;\n&gt; &gt; type=entry.\n&gt; &gt;\n&gt; &gt; There&#39;s no RESTful way to instruct any user agent that &quot;this system\n&gt; &gt; uses Atom Protocol&quot; and this may not be inferred by the fact that\n&gt; &gt; the system uses Atom.  All I can do is provide a self-documenting\n&gt; &gt; hypertext API which instructs user agents how to interact with the\n&gt; &gt; system.  This API may or may not conform to Atom Protocol.  Whether\n&gt; &gt; it does or not is less important to REST than its presence.\n&gt; &gt;\n&gt; &gt; None of this is any different for a system based on JSON rather than\n&gt; &gt; Atom.  As a REST system, I could change my Atom backend to a JSON\n&gt; &gt; backend on a whim.  I&#39;m not saying it would be easy, but I am saying\n&gt; &gt; that the application states wouldn&#39;t change.  The HTML would still\n&gt; &gt; present a textarea, changes to that textarea would be submitted to\n&gt; &gt; the same URI, using whatever media type the form says to use -- all\n&gt; &gt; HTML user agents automatically update to the new API.\n&gt; &gt;\n&gt; &gt; If you need to guess what media type to use then you can&#39;t possibly\n&gt; &gt; be using REST.  A REST API will always tell you exactly what media\n&gt; &gt; type to use.  It isn&#39;t implicit in any guessable fashion, it&#39;s\n&gt; &gt; explicit.  If it isn&#39;t explicit, it isn&#39;t REST.  HTML says what\n&gt; &gt; POST does, but only your hypertext can specify media type, if you\n&gt; &gt; lack such hypertext you lack a critical REST constraint.\n&gt;\n&gt; There is certainly nothing wrong with a specifying what media type a\n&gt; server can handle in the media type definition or hypertext (JSON\n&gt; Schema allows for specifying an acceptable media type for requests as\n&gt; well)\n&gt;\n\nWhat media types are acceptable is hard-coded into the user agent for\ngood reason.  This discussion has been had here many times before, that\noverriding that with something like @type inside &lt;a&gt; in an effort to\nget a different variant goes against REST.  It&#39;s playing frisbee with\nyour dog all backwards.  In the case of a negotiated resource, if there\nis need to instruct the client to retrieve a specific variant (override\nconneg), then assign that variant a URI and send that to the client.\n\nAgain, REST isn&#39;t about performing prefetch optimization, it&#39;s about\n&quot;sending whatever is most likely to be optimal first and then provide\na list of alternatives for the client to retrieve if the first response\nis unsatisfactory.&quot;  Web architecture is based on the notion that an\n@type on a link is a hint and only a hint, this goes for JSON too --\nyou can allow for this hint in a schema, but a schema can&#39;t make that\nhint override user agents&#39; hard-coded Accept headers.\n\n&gt;\n&gt; however the dynamic representation/content negotiation\n&gt; principle implies that a server may have capabilities to handle\n&gt; various types that may independently evolve. I know my server software\n&gt; can handle various media types to update resources (JSON, JS, XML,\n&gt; url-encoded, etc.).\n&gt; \n\nOf course.  For any given request, I respond with the interface that&#39;s\nmost likely to be optimal, first.  An Atom Protocol client will get raw\nAtom and be able to interoperate with the system somewhat on that level,\nbut the user can always choose the rel=&#39;alternate&#39; HTML variant and get\nfeatures (like PATCH-based social tagging) Atom Protocol clients can&#39;t\nbe instructed to use.\n\nOr, the client is a browser supporting XForms, so it gets a full-blown\nREST app that implements Atom Protocol and any additional features\n(like PATCH-based social tagging).  Otherwise, the browser gets an HTML\n4.01 almost-REST API that doesn&#39;t quite implement Atom Protocol (no\nPUT) or any additional features.  User agents may introspect hypertext\nin the form of HTTP Accept, Allow and Alternates headers, link elements\nand/or link headers, etc. to determine alternative courses of action to\npresent to the user.\n\nOr, the user is presented with the information needed to decide to\nswitch to a user agent with Xforms capability, to enable full\ninteraction with the underlying API.  Or, I implement my HTML 4.01\nforms extension using XHR code-on-demand, providing a full-blown REST\nAPI that doesn&#39;t exactly follow Atom Protocol but yields the same\nresults and has all the additional features -- in which case I don&#39;t\ncare that nobody uses Xforms-enabled browsers or Atom Protocol clients.\n\nIf a user agent gets the wrong variant, it won&#39;t be a fatal error where\nthe user agent can&#39;t interact with the site.  A non-xforms browser\ncan&#39;t possibly be triggered to use Xforms (this isn&#39;t a conneg issue),\na browser can&#39;t possibly get the raw Atom unless linked to it\nexplicitly, and the worst that can happen is a non-js browser will only\nbe able to use GET and POST (not-quite-REST as PUT is tunneled over\nPOST in such cases, not-quite-Atom Protocol because Atom is wrapped in\nmultipart/form-data).  Standard graceful degradation, this.\n\nSo I don&#39;t understand what problem you&#39;re trying to solve by trying to\nfigure that all out _before_ receiving an initial representation.  It&#39;s\na Sisyphean task -- by the time some third party figures out how to do\nthat for my system, I&#39;ve changed the interfaces and their client breaks,\nwhereas if they&#39;d have followed my hypertext their client would have\njust self-updated.  The same would go for any REST system, there&#39;s\nsimply no need to train your dog to throw the frisbee, or define media\ntypes to support it.\n\nUsing @type on links in HTML is only meant as a hint, because some\nresources are negotiated.  Where resources aren&#39;t negotiated, there&#39;s\nno excuse for this hint to be wrong (I call those unflagged 500 errors).\nIts presence allows HTML code to be considered a self-documenting API.\nWithout that hint, the resource must be dereferenced to determine its\nnature.  That&#39;s self-descriptive messaging, but without @type inside\nHTML (or such provision in some other markup language) there&#39;s no way\nto self-document the API in application steady-states.\n\nUnder no circumstances is hypertext allowed to change the browser&#39;s\nAccept header.  This is a case where the real world is actually within\nREST&#39;s constraints (layered system, in this case), I can&#39;t think of a\nsituation where a server is allowed to dictate to a client what media\ntype that client should Accept.  I know the Javascript community would\nlike to do away with this, but I&#39;m afraid it&#39;s a fundamental aspect of\nWeb architecture to which the &quot;if it ain&#39;t broke, don&#39;t fix it&quot; rule\nmust apply.\n\n-Eric\n\n"}}