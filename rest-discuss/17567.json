{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":119533972,"authorName":"Bryan Taylor","from":"Bryan Taylor &lt;bryan_w_taylor@...&gt;","profile":"bryan_w_taylor","replyTo":"SENDER","senderId":"8-d02JxieGYUn-UW76OuJzvYq2z4JflLUGjzwAYD_5R5z4awyF-WmqeLmw6g3ePG5anG9krqvV9BvxVqZ4e4QATff9vr_PmpbetBLa2s","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Paging Atom Feeds for Business Events","postDate":"1307422549","msgId":17567,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDY4MzQwMS4yODkyNS5xbUB3ZWIxMTA3MTYubWFpbC5ncTEueWFob28uY29tPg=="},"prevInTopic":0,"nextInTopic":17569,"prevInTime":17566,"nextInTime":17568,"topicId":17567,"numMessagesInTopic":5,"msgSnippet":"At my company, we are trying to find RESTful solutions to replace business eventing techniques. I wanted to describe our approach and the thought process to","rawEmail":"Return-Path: &lt;bryan_w_taylor@...&gt;\r\nX-Sender: bryan_w_taylor@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 40864 invoked from network); 7 Jun 2011 04:56:21 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m1.grp.sp2.yahoo.com with QMQP; 7 Jun 2011 04:56:21 -0000\r\nX-Received: from unknown (HELO nm16-vm2.bullet.mail.ne1.yahoo.com) (98.138.91.92)\n  by mta2.grp.sp2.yahoo.com with SMTP; 7 Jun 2011 04:56:20 -0000\r\nX-Received: from [98.138.90.55] by nm16.bullet.mail.ne1.yahoo.com with NNFMP; 07 Jun 2011 04:56:20 -0000\r\nX-Received: from [98.138.89.160] by tm8.bullet.mail.ne1.yahoo.com with NNFMP; 07 Jun 2011 04:56:20 -0000\r\nX-Received: from [127.0.0.1] by omp1016.mail.ne1.yahoo.com with NNFMP; 07 Jun 2011 04:55:50 -0000\r\nX-Yahoo-Newman-Property: ymail-3\r\nX-Yahoo-Newman-Id: 427524.46522.bm@...\r\nX-Received: (qmail 13795 invoked by uid 60001); 7 Jun 2011 04:55:49 -0000\r\nMessage-ID: &lt;683401.28925.qm@...&gt;\r\nX-YMail-OSG: UOVQV1UVM1lj1U_NibYguD7XnmutjLbsON6zB6S8sY292nF\n 9Kj8KK5ItqVt3luZHENJTeCzkoWybCllsioFjqr_fZrJpFaFZSBg7sW8ic0p\n i7.pXXMuqyGaLF5yD9y9L.jRFUh6Zcw.kgwHLJWw0F09d03O1HTZsBTbjj0e\n tLHFbsTt7S7X8dkMBIkVN48RdGmh.fHdR1h24L2Jl5BQeAK8N4bHrsfMQJx2\n qhtf.6rzskxWcqOTdXreroICceYspvXH5NAc4bFS6e9eiLUuTyl29Q8ReuDa\n QCwM7Agjd.9TfgszTINCcGmzf.YS7N1V80j.gOWpfSn2VIOlEyvLWqokWcFZ\n nxWyFpH6feKKOxESPiU97g.Jsich8xCSUD5gl7pUej_gedm0cIyT_Nw2YNBj\n OxUKo9RYmJ7om\r\nX-Received: from [99.5.220.86] by web110716.mail.gq1.yahoo.com via HTTP; Mon, 06 Jun 2011 21:55:49 PDT\r\nX-Mailer: YahooMailRC/570 YahooMailWebService/0.8.111.304355\r\nDate: Mon, 6 Jun 2011 21:55:49 -0700 (PDT)\r\nTo: rest-discuss@yahoogroups.com\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=us-ascii\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Bryan Taylor &lt;bryan_w_taylor@...&gt;\r\nSubject: Paging Atom Feeds for Business Events\r\nX-Yahoo-Group-Post: member; u=119533972; y=1DXPvvNb3_8Hag_oaTaVgbckVhVoWwW6oare9z8G9aUvRgoIV4Q1HY8\r\nX-Yahoo-Profile: bryan_w_taylor\r\n\r\nAt my company, we are trying to find RESTful solutions to replace business \neventing techniques. I wanted to describe our approach and the thought process \nto get there and get feedback from the group.\n\nWe&#39;ve focussed on using atom and/or atompub for this, but I think the issues I&#39;m \nabout to describe would be the same if we rolled our own collection mechanism. \nBasically, we take some entity in our system, typically held in a table and when \nthere is an insert or update (we only do logical deletes) we copy the record to \nan event table and add a event id for a new primary key populated with an \nascending sequence number. We developed a media type to represent the entity, \nand we reuse it to represent entity events as well. We build our atom feeds out \nof the entity events, so that our atom entries publish changes to the underlying \nentities. This makes our atom entries immutable and our collections \nappend-only. \n\nWe realized pretty quickly that we needed a paging solution. Fortunately RFC \n5005 describes several strategies to use (paged feeds and archived feeds). Both \nare based on using semantic links with named relations to navigate through the \npages. The paged strategy from RFC 5005 uses &quot;next&quot;, &quot;previous&quot;, &quot;first&quot;, and \n&quot;last&quot; links, though it doesn&#39;t imply how the entries are ordered. The archived \nstrategy uses a &quot;subscription&quot; page for the most recent items, and archived \npages that are navigated by &quot;previous-archive&quot;, &quot;next-archive&quot;, and &quot;current&quot;, \nwhere &quot;next-archive&quot; moves to older entries. AtomPub gives the collection itself \na resource, and essentially calls for a paged feed with the &quot;first&quot; page the \nnewest entries.\n\nAt first we tried to give clients a standardized URI template for the pages, but \nas we came to understand HATEOAS better, we realized the RESTful way was to have \nthe clients treat the links as opaque and instead rely on the link relations. We \ndidn&#39;t need to give clients a formula to understand for how to construct page \nlinks because we expect them to always unroll the linked list of pages by \nstarting at the entry point and following link relations. I recall with fondness \nhow this was a major &quot;Aha&quot; moment for me when I understood very clearly how much \nbetter this was than the SOAP style solution. \n\nHowever, our servers still had to come up with URI schemes that allow them to \nunderstand what was requested. People tried several mechanisms. The first try \nwas the ?page=$pagenumber way. I think this basically fails (it works for \nlabeling static archives only), because the meaning of &quot;page=3&quot; isn&#39;t stateless \nwhen your first page shows the most recent entries. There&#39;s a nice edge case \nwhere we view entries 1-100 on ?page=1 and if exactly 100 entries arrive as we \nstare at it, then when we resolve ?page=2, then surprise, we get the same \nentries again. Then people tried offset and pagesize parameters, but again the \noffset breaks when we do things the atom way and order entries in descending \nedit date order. The same pathological case shows how this fails too.\n\nFinally, we settled on the &quot;mark method&quot; for paging, where we construct a &quot;next&quot; \npage by using a ?before=$oldest parameter where $oldest is the unique key value \nfor the oldest entry on the page we just showed. Similarly, &quot;previous&quot; pages use \na ?after=$newest parameter where $newest is the newest entry on the page. The \n&quot;first&quot; case is the collection URI with no parameters. To construct the entry \nset, we build a SQL statements like:\n  rel=&quot;next&quot; link:      SELECT * FROM entity_events WHERE event_id &lt; $oldest \nORDER BY event_id LIMIT $pagesize\n  rel=&quot;previous&quot; link:  SELECT * FROM entity_events WHERE event_id &gt; $newest \nORDER BY event_id LIMIT $pagesize\n  rel=&quot;first&quot; link:     SELECT * FROM entity_events ORDER BY event_id DESC LIMIT \n$pagesize\nAs long as event_id is indexed, this SQL is very efficient. Some DBs use \ndifferent syntax instead of LIMIT. For each row, we might go ahead and \npre-calculate the representation fragment, and then we can build pages super \nfast.\n\nAn interesting consequence of this mechanism: first-&gt;previous is actually \nuseful, because events may arrive after the server sends the entry point \nrepresentation. If none have, this will be an empty page with only the first \nlink. This may seems strange compared to the traditional mechanisms of polling \nthe fixed &quot;first&quot; URI of the collection&#39;s entry point. That still works with the \nsame semantics. But repeated polling of previous links gives clients a way to \nget guaranteed in-order delivery. It complicates the server&#39;s caching picture \nsomewhat, but it&#39;s O(1) to force the eviction and freshening of the URIs in the \nlast $pagesize entries. By the way, if you don&#39;t support first-&gt;previous, a \nclever client can poll on first-&gt;next-&gt;previous until events arrive, it adds the \nprevious link, and it&#39;s etag changes. So you can&#39;t stop clients from trying this \ngame. With blogs, clients probably only care about &quot;the latest&quot; so polling \nlatest changes is reasonable. Often in business eventing situations, we need to \nwatch all resource state transitions and react to certain transitions, which \nmight be skipped over if multiple updates happen in quick succession. \n\nI&#39;m curious to hear what others have done. Feedback welcome.\n\n"}}