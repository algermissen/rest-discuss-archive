{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":86585728,"authorName":"Eric Johnson","from":"Eric Johnson &lt;eric@...&gt;","profile":"eric_at_tibco","replyTo":"SENDER","senderId":"quwjb_G3ebjvi_M1_t4hYE6DNXPIdz3Fivp6z5Uu6TQRWkdwCdiOW7APJQJBpw4mLlwN4Im8VlJwfkCHA0fBCPxeCAU","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] RESTful way to pop first item in a queue","postDate":"1281037101","msgId":16151,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDRDNUIxMzJELjkwMTA3MDlAdGliY28uY29tPg==","inReplyToHeader":"PDEyODEwMzY0NzQuMjkxNy4zMDQuY2FtZWxAYmFja3BhY2s+","referencesHeader":"PDEyODEwMzQ3NDguMjkxNy4zMDMuY2FtZWxAYmFja3BhY2s+CSA8NEM1QjBDRTEuMjA0MDkwOUB0aWJjby5jb20+IDwxMjgxMDM2NDc0LjI5MTcuMzA0LmNhbWVsQGJhY2twYWNrPg=="},"prevInTopic":16150,"nextInTopic":16152,"prevInTime":16150,"nextInTime":16152,"topicId":16148,"numMessagesInTopic":46,"msgSnippet":"Well, you did ask, in your scenario, what happens if the client fails. If you introduce the notion of temporary ownership, then the GET operation can be","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 57427 invoked from network); 5 Aug 2010 19:38:13 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m7.grp.sp2.yahoo.com with QMQP; 5 Aug 2010 19:38:13 -0000\r\nX-Received: from unknown (HELO mx1-app.tibco.com) (63.100.100.142)\n  by mta1.grp.sp2.yahoo.com with SMTP; 5 Aug 2010 19:38:13 -0000\r\nX-IronPort-AV: E=Sophos;i=&quot;4.55,324,1278313200&quot;; \n   d=&quot;scan&#39;208,217&quot;;a=&quot;14389506&quot;\r\nX-Received: from tibco-5.tibco.com (HELO na-pa-fe01.na.tibco.com) ([63.100.100.5])\n  by mx1-app.tibco.com with ESMTP; 05 Aug 2010 12:38:13 -0700\r\nX-Received: from koosh.na.tibco.com ([10.98.32.25]) by na-pa-fe01.na.tibco.com with Microsoft SMTPSVC(6.0.3790.3959);\n\t Thu, 5 Aug 2010 12:38:12 -0700\r\nMessage-ID: &lt;4C5B132D.9010709@...&gt;\r\nDate: Thu, 05 Aug 2010 12:38:21 -0700\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.2.7) Gecko/20100726 Thunderbird/3.1.1\r\nMIME-Version: 1.0\r\nTo: juergen.brendel@...\r\nCc: rest-discuss@yahoogroups.com\r\nReferences: &lt;1281034748.2917.303.camel@backpack&gt;\t &lt;4C5B0CE1.2040909@...&gt; &lt;1281036474.2917.304.camel@backpack&gt;\r\nIn-Reply-To: &lt;1281036474.2917.304.camel@backpack&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------010801070903030904050706&quot;\r\nReturn-Path: eric@...\r\nX-OriginalArrivalTime: 05 Aug 2010 19:38:12.0574 (UTC) FILETIME=[BDB6BFE0:01CB34D5]\r\nX-TM-AS-Product-Ver: SMEX-10.0.0.1412-6.500.1024-17550.007\r\nX-TM-AS-Result: No--45.174100-8.000000-31\r\nX-TM-AS-User-Approved-Sender: No\r\nX-TM-AS-User-Blocked-Sender: No\r\nFrom: Eric Johnson &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] RESTful way to pop first item in a queue\r\nX-Yahoo-Group-Post: member; u=86585728; y=lMbNaBedPyeZxI36jX8QQNZLeQcW5pSfsqzICtu-vFifAH4ICFcUFQ\r\nX-Yahoo-Profile: eric_at_tibco\r\n\r\n\r\n--------------010801070903030904050706\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\n\r\n Well, you did ask, in your scenario, what happens if the client fails.\n\nIf you introduce the notion of temporary ownership, then the &quot;GET&quot;\noperation can be idempotent, and further you don&#39;t have to wonder what\nhappens if the client (temporarily) fails.  In case of a permanent\nfailure, you can simply set a timeout value.  That does get tricky, though.\n\nWithout more detail on your scenario - what end is the queue serving:\nassigning a work task to the next available person, or queuing up\ndocuments for an automated process to consume?  What&#39;s the cost of\nprocessing the same resource twice?  What&#39;s the cost of dropping it? \nHow quickly must it be processed?\n\nWithout those answers, it seems like it will be hard to reflect the\nright &quot;state&quot; on the server.\n\n-Eric.\n\nOn 08/05/2010 12:27 PM, Juergen Brendel wrote:\n&gt;  \n&gt;\n&gt;\n&gt;\n&gt; There is no concept of ownership of the items. Assume a bunch of\n&gt; &#39;clients&#39; that pop the next item to be processed. It doesn&#39;t matter who\n&gt; of them gets which item, it&#39;s just that one item must be seen by exactly\n&gt; one client only.\n&gt;\n&gt; Items are also added to the queue on the other end, so when an item is\n&gt; given to a client, it should actually be removed from the queue at that\n&gt; moment.\n&gt;\n&gt; Authentication is not an issue for this.\n&gt;\n&gt; On Thu, 2010-08-05 at 12:11 -0700, Eric Johnson wrote:\n&gt; &gt; Your scenario posits multiple consumers. How does the server-side\n&gt; &gt; distinguish those consumers?\n&gt; &gt;\n&gt; &gt; Are you doing bi-directional SSL authentication, HTTP-Basic, or just\n&gt; &gt; giving each consumer their own URL?\n&gt; &gt;\n&gt; &gt; In any case, &quot;GET&quot; can be idempotent on a particular URL if you define\n&gt; &gt; the URL as:\n&gt; &gt;\n&gt; &gt; &quot;get resource already assigned to me, or if none, the next queued\n&gt; &gt; resource available.&quot; Until the particular client then deletes (or\n&gt; &gt; updates state to reflect that it has been consumed), the server will\n&gt; &gt; simply give the same response each time the consumer asks.\n&gt; &gt;\n&gt; &gt; -Eric.\n&gt; &gt;\n&gt; &gt; On 08/05/2010 11:59 AM, Juergen Brendel wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hello!\n&gt; &gt; &gt;\n&gt; &gt; &gt; Let&#39;s say I have a queue resource: /foo\n&gt; &gt; &gt;\n&gt; &gt; &gt; I can POST new entries into the queue. I can even refer to\n&gt; &gt; &gt; individual\n&gt; &gt; &gt; entries within the queue: /foo/&lt;id&gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; But how do I pop the next entry? How do I construct a single request\n&gt; &gt; &gt; that gets me the next/first entry but also removes the entry at the\n&gt; &gt; &gt; same\n&gt; &gt; &gt; time?\n&gt; &gt; &gt;\n&gt; &gt; &gt; Maybe I can implement a special resource /foo/next, which always\n&gt; &gt; &gt; refers\n&gt; &gt; &gt; to the next entry in the queue. But clearly, I can&#39;t use GET to pop\n&gt; &gt; &gt; the\n&gt; &gt; &gt; entry, since that would not be idempotent.\n&gt; &gt; &gt;\n&gt; &gt; &gt; The queue has multiple consumers, so the &#39;pop&#39; operation should be\n&gt; &gt; &gt; atomic. This seems to rule out the possibility of doing a GET to\n&gt; &gt; &gt; retrieve the latest element, followed by a DELETE to remove it.\n&gt; &gt; &gt; Someone\n&gt; &gt; &gt; else could have gotten the &#39;latest&#39; element in the meantime, thus\n&gt; &gt; &gt; causing the same element to be consumed twice.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Maybe I can cause a &#39;move&#39;, where a single request causes the next\n&gt; &gt; &gt; element to be renamed to a unique ID, which is then returned to the\n&gt; &gt; &gt; client, who then is the only one who has a handle on that object.\n&gt; &gt; &gt; The\n&gt; &gt; &gt; client can then work with the resource. But the question now is:\n&gt; &gt; &gt;\n&gt; &gt; &gt; a) What happens when the client fails before it can delete the\n&gt; &gt; &gt; resource?\n&gt; &gt; &gt; b) What is the best way to &#39;move&#39; an item in that way?\n&gt; &gt; &gt;\n&gt; &gt; &gt; Juergen\n&gt; &gt; &gt;\n&gt; &gt; &gt; --\n&gt; &gt; &gt; Juergen Brendel\n&gt; &gt; &gt; http://restx.mulesoft.org\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt;\n&gt; -- \n&gt; Juergen Brendel\n&gt; Architect, MuleSoft Inc.\n&gt; http://mulesoft.com\n&gt;\n&gt; \n\r\n--------------010801070903030904050706\r\nContent-Type: text/html; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta content=&quot;text/html; charset=UTF-8&quot; http-equiv=&quot;Content-Type&quot;&gt;\n  &lt;/head&gt;\n  &lt;body text=&quot;#000000&quot; bgcolor=&quot;#ffffff&quot;&gt;\n    Well, you did ask, in your scenario, what happens if the client\n    fails.&lt;br&gt;\n    &lt;br&gt;\n    If you introduce the notion of temporary ownership, then the &quot;GET&quot;\n    operation can be idempotent, and further you don&#39;t have to wonder\n    what happens if the client (temporarily) fails.  In case of a\n    permanent failure, you can simply set a timeout value.  That does\n    get tricky, though.&lt;br&gt;\n    &lt;br&gt;\n    Without more detail on your scenario - what end is the queue\n    serving: assigning a work task to the next available person, or\n    queuing up documents for an automated process to consume?  What&#39;s\n    the cost of processing the same resource twice?  What&#39;s the cost of\n    dropping it?  How quickly must it be processed?&lt;br&gt;\n    &lt;br&gt;\n    Without those answers, it seems like it will be hard to reflect the\n    right &quot;state&quot; on the server.&lt;br&gt;\n    &lt;br&gt;\n    -Eric.&lt;br&gt;\n    &lt;br&gt;\n    On 08/05/2010 12:27 PM, Juergen Brendel wrote:\n    &lt;blockquote cite=&quot;mid:1281036474.2917.304.camel@backpack&quot;\n      type=&quot;cite&quot;&gt;\n      &lt;span style=&quot;display: none;&quot;&gt; &lt;/span&gt;\n      \n          &lt;div id=&quot;ygrp-text&quot;&gt;\n            &lt;p&gt;&lt;br&gt;\n              &lt;br&gt;\n              There is no concept of ownership of the items. Assume a\n              bunch of&lt;br&gt;\n              &#39;clients&#39; that pop the next item to be processed. It\n              doesn&#39;t matter who&lt;br&gt;\n              of them gets which item, it&#39;s just that one item must be\n              seen by exactly&lt;br&gt;\n              one client only.&lt;br&gt;\n              &lt;br&gt;\n              Items are also added to the queue on the other end, so\n              when an item is&lt;br&gt;\n              given to a client, it should actually be removed from the\n              queue at that&lt;br&gt;\n              moment.&lt;br&gt;\n              &lt;br&gt;\n              Authentication is not an issue for this.&lt;br&gt;\n              &lt;br&gt;\n              On Thu, 2010-08-05 at 12:11 -0700, Eric Johnson wrote:&lt;br&gt;\n              &gt; Your scenario posits multiple consumers. How does the\n              server-side&lt;br&gt;\n              &gt; distinguish those consumers?&lt;br&gt;\n              &gt; &lt;br&gt;\n              &gt; Are you doing bi-directional SSL authentication,\n              HTTP-Basic, or just&lt;br&gt;\n              &gt; giving each consumer their own URL?&lt;br&gt;\n              &gt; &lt;br&gt;\n              &gt; In any case, &quot;GET&quot; can be idempotent on a particular\n              URL if you define&lt;br&gt;\n              &gt; the URL as:&lt;br&gt;\n              &gt; &lt;br&gt;\n              &gt; &quot;get resource already assigned to me, or if none, the\n              next queued&lt;br&gt;\n              &gt; resource available.&quot; Until the particular client then\n              deletes (or&lt;br&gt;\n              &gt; updates state to reflect that it has been consumed),\n              the server will&lt;br&gt;\n              &gt; simply give the same response each time the consumer\n              asks.&lt;br&gt;\n              &gt; &lt;br&gt;\n              &gt; -Eric.&lt;br&gt;\n              &gt; &lt;br&gt;\n              &gt; On 08/05/2010 11:59 AM, Juergen Brendel wrote: &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; Hello!&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; Let&#39;s say I have a queue resource: /foo&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; I can POST new entries into the queue. I can\n              even refer to&lt;br&gt;\n              &gt; &gt; individual&lt;br&gt;\n              &gt; &gt; entries within the queue: /foo/&lt;id&gt;&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; But how do I pop the next entry? How do I\n              construct a single request&lt;br&gt;\n              &gt; &gt; that gets me the next/first entry but also\n              removes the entry at the&lt;br&gt;\n              &gt; &gt; same&lt;br&gt;\n              &gt; &gt; time?&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; Maybe I can implement a special resource\n              /foo/next, which always&lt;br&gt;\n              &gt; &gt; refers&lt;br&gt;\n              &gt; &gt; to the next entry in the queue. But clearly, I\n              can&#39;t use GET to pop&lt;br&gt;\n              &gt; &gt; the&lt;br&gt;\n              &gt; &gt; entry, since that would not be idempotent.&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; The queue has multiple consumers, so the &#39;pop&#39;\n              operation should be&lt;br&gt;\n              &gt; &gt; atomic. This seems to rule out the possibility\n              of doing a GET to&lt;br&gt;\n              &gt; &gt; retrieve the latest element, followed by a\n              DELETE to remove it.&lt;br&gt;\n              &gt; &gt; Someone&lt;br&gt;\n              &gt; &gt; else could have gotten the &#39;latest&#39; element in\n              the meantime, thus&lt;br&gt;\n              &gt; &gt; causing the same element to be consumed twice.&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; Maybe I can cause a &#39;move&#39;, where a single\n              request causes the next&lt;br&gt;\n              &gt; &gt; element to be renamed to a unique ID, which is\n              then returned to the&lt;br&gt;\n              &gt; &gt; client, who then is the only one who has a\n              handle on that object.&lt;br&gt;\n              &gt; &gt; The&lt;br&gt;\n              &gt; &gt; client can then work with the resource. But the\n              question now is:&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; a) What happens when the client fails before it\n              can delete the&lt;br&gt;\n              &gt; &gt; resource?&lt;br&gt;\n              &gt; &gt; b) What is the best way to &#39;move&#39; an item in\n              that way?&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; Juergen&lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; -- &lt;br&gt;\n              &gt; &gt; Juergen Brendel&lt;br&gt;\n              &gt; &gt; &lt;a moz-do-not-send=&quot;true&quot;\n                href=&quot;http://restx.mulesoft.org&quot;&gt;http://restx.mulesoft.org&lt;/a&gt;\n              &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &gt; &gt; &lt;br&gt;\n              &lt;br&gt;\n              -- &lt;br&gt;\n              Juergen Brendel&lt;br&gt;\n              Architect, MuleSoft Inc.&lt;br&gt;\n              &lt;a moz-do-not-send=&quot;true&quot; href=&quot;http://mulesoft.com&quot;&gt;http://mulesoft.com&lt;/a&gt;\n              &lt;br&gt;\n              &lt;br&gt;\n            &lt;/p&gt;\n          &lt;/div&gt;\n          \n      \n      &lt;!-- end group email --&gt;\n    &lt;/blockquote&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------010801070903030904050706--\r\n\n"}}