{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":237604743,"authorName":"Bill de hOra","from":"Bill de hOra &lt;bill@...&gt;","profile":"bdehora","replyTo":"SENDER","senderId":"pYN9LWkRXLQF9aFZi_lxVBIkmaiwhKjkWB_2sL_t0y8eoWkqzwmi7n62-MXVpwhUMvGLw-GxQWRodClpX-kn1_okLvYX","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: The XML Semantic Web","postDate":"1172783214","msgId":8033,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ1RTc0MDZFLjgwMTAzMDFAZGVob3JhLm5ldD4=","inReplyToHeader":"PDExNzI3NTQ5NjQuNDczOC40MC5jYW1lbEBsb2NhbGhvc3QubG9jYWxkb21haW4+","referencesHeader":"PDExNzE5NjkxNzYuMjA3LjI3NTcyLm0xNkB5YWhvb2dyb3Vwcy5jb20+CSA8NDVEQUQyNjIuMjM4Ny4zRUFBNjg3QGFuZHJ6ZWouY2hhZXJvbi5jb20+CSA8MTE3MjAwNTEwMC4xMjIwMi4xMC5jYW1lbEBsb2NhbGhvc3QubG9jYWxkb21haW4+CSA8NDVEQjdDRTUuNTA1MDFAZGVob3JhLm5ldD4JIDw5Mjc0NDFiMzA3MDIyMDE4MTB1NDQ3Yjk4OWZzYjZlMjBhMGI3MzQ4MmEwNEBtYWlsLmdtYWlsLmNvbT4JIDw0NURDMTMzRi4xMDIwMDA1QGRlaG9yYS5uZXQ+CSA8MTE3MjI2Nzc3MS40NzU1LjYxLmNhbWVsQGxvY2FsaG9zdC5sb2NhbGRvbWFpbj4JIDw0NUUwODZCNy43MDUwODA3QGRlaG9yYS5uZXQ+CSA8OWRjNzhkN2IwNzAyMjUwOTAzeDI3ZTUwMmI3bmRhZjRhMTM1ODlmODFjOTJAbWFpbC5nbWFpbC5jb20+CSA8MWYyZWQ1Y2QwNzAyMjUxMjUzcjE2ZWY1ZGUxeDg5NjNjMzMyNGRhMTk5ZTVAbWFpbC5nbWFpbC5jb20+IDwxMTcyNzU0OTY0LjQ3MzguNDAuY2FtZWxAbG9jYWxob3N0LmxvY2FsZG9tYWluPg=="},"prevInTopic":8032,"nextInTopic":8047,"prevInTime":8032,"nextInTime":8034,"topicId":7927,"numMessagesInTopic":81,"msgSnippet":"... Maybe you do; but I think what I ve said is objectively true. ... RDF: check, but also at a higher level than parsing; RDF s notion of mI extends into","rawEmail":"Return-Path: &lt;bill@...&gt;\r\nX-Sender: bill@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 17600 invoked from network); 1 Mar 2007 21:07:03 -0000\r\nReceived: from unknown (66.218.66.71)\n  by m41.grp.scd.yahoo.com with QMQP; 1 Mar 2007 21:07:03 -0000\r\nReceived: from unknown (HELO chilco.textdrive.com) (207.7.108.242)\n  by mta13.grp.scd.yahoo.com with SMTP; 1 Mar 2007 21:07:03 -0000\r\nReceived: from [192.168.2.180] (83-70-217-117.b-ras1.prp.dublin.eircom.net [83.70.217.117])\n\tby chilco.textdrive.com (Postfix) with ESMTP id AE62BDD052\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Thu,  1 Mar 2007 21:06:57 +0000 (UTC)\r\nMessage-ID: &lt;45E7406E.8010301@...&gt;\r\nDate: Thu, 01 Mar 2007 21:06:54 +0000\r\nUser-Agent: Thunderbird 1.5.0.9 (X11/20070103)\r\nMIME-Version: 1.0\r\nTo: rest-discuss@yahoogroups.com\r\nReferences: &lt;1171969176.207.27572.m16@yahoogroups.com&gt;\t &lt;45DAD262.2387.3EAA687@...&gt;\t &lt;1172005100.12202.10.camel@...&gt;\t &lt;45DB7CE5.50501@...&gt;\t &lt;927441b30702201810u447b989fsb6e20a0b73482a04@...&gt;\t &lt;45DC133F.1020005@...&gt;\t &lt;1172267771.4755.61.camel@...&gt;\t &lt;45E086B7.7050807@...&gt;\t &lt;9dc78d7b0702250903x27e502b7ndaf4a13589f81c92@...&gt;\t &lt;1f2ed5cd0702251253r16ef5de1x8963c3324da199e5@...&gt; &lt;1172754964.4738.40.camel@...&gt;\r\nIn-Reply-To: &lt;1172754964.4738.40.camel@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Bill de hOra &lt;bill@...&gt;\r\nSubject: Re: [rest-discuss] Re: The XML Semantic Web\r\nX-Yahoo-Group-Post: member; u=237604743; y=pPHyv4jcUUUr2WA2M25Ln5nVhjwKZkxjiZXEz_Q_f7ZK4w\r\nX-Yahoo-Profile: bdehora\r\n\r\nBenjamin Carlyle wrote:\n\n&gt; On Sat, 2007-02-24 at 18:40 +0000, Bill de hOra wrote: \n&gt;&gt; Benjamin Carlyle wrote:\n&gt;&gt;&gt; As I will point out later in the document, I\n&gt;&gt;&gt; don&#39;t think RDF is as conducive to good vocabulary evolution as\n&gt;&gt; XML. \n&gt;&gt; XML isn&#39;t conducive to vocabulary evolution either. This is very\n&gt;&gt; strange \n&gt;&gt; juxtaposition. Most XML vocabulairies I&#39;ve seen that declare an \n&gt;&gt; extensibility based end up defining a subset of what RDF defines.\n&gt; \n&gt; I think the evidence says otherwise. \n\nMaybe you do; but I think what I&#39;ve said is objectively true.\n\n\n&gt; We have html and other formats to\n&gt; demonstrate that the basic approach behind good XML development works.\n&gt; The important rules seem to be:\n&gt; * Use must-ignore semantics for anything that is not understood\n\nRDF: check, but also at a higher level than parsing; RDF&#39;s notion of mI \nextends into querying for example.\n\n&gt; * Don&#39;t define new namespaces for extensions, so the extensions can one\n&gt; day be merged back into the base document type\n\nRDF says to define new nouns and relations if you need them. But so does \nXML+xmlns in practice. Atom&#39;s foreign markup policy is arguably different.\n\n\n&gt; * Attack a specific problem space, align communities behind the common\n&gt; brand-name, and hammer things out until it all interoperates\n\nFor the XML family, this is written down, where? Look now at what&#39;s \ngoing with HTML5; the markup community (well, people like hixie) have \nrealised that how HTML is actually processed is not documented. Not \nanywhere. The point I&#39;m making is that XML doesn&#39;t begin to address \nthese issues because XML does not provide a processing model worth \ntalking about (which is equally a feature).\n\n&gt; \n&gt;&gt;&gt; RSS was defined in terms of RDF so that it\n&gt;&gt;&gt; could be easily aggregated. However, aggregation did not happen at\n&gt;&gt; the\n&gt;&gt;&gt; RDF level in practice. Instead, RSS was aggregated at a higher\n&gt;&gt; level.\n&gt;&gt; But you don&#39;t say why that was. Why was that?\n&gt; \n&gt; I would guess: Because it wasn&#39;t useful. Because the graph structure is\n&gt; too low-level to meet application-specific data integration requirements\n&gt; automatically. Do you have any alternative thoughts on that?\n\nI probably agree it wasn&#39;t useful, but I don&#39;t know what that has to do \nwith &#39;low-level&#39; - Atom is &#39;low-level&#39; compared to RSS1.0 on almost any \naxis (except the encoding of content). I&#39;d tend assume RSS1.0 isn&#39;t \ntreated as RDF because people don&#39;t need or want what RDF can provide.\n\n[Fwiw, most RSS files get treated as dictionaries not trees, the &#39;tree&#39; \nis a surface feature of the XML. Atom is deliberately designed that way.]\n\n&gt; \n&gt;&gt;&gt; Must-ignore semantics mean that a document with additional elements\n&gt;&gt; will\n&gt;&gt;&gt; be ignored by old implementations. \n&gt;&gt; mI in my mind is about having having a trailing &quot;else&quot; in the code\n&gt;&gt; that \n&gt;&gt; logs to disk instead of throwing an exception. It&#39;s a sensible \n&gt;&gt; programmatic default.\n&gt; \n&gt; The evidence seems to suggest that mI is critical to long-term evolution\n&gt; of documents. It is about handling messages from the future and from the\n&gt; past: Only require information if you need it to function. Ignore what\n&gt; you don&#39;t understand.\n\nI think we&#39;re agreeing with each other (I see sensible programmatic \ndefaults as critical to long term evolution of software).  But I think \nyou need to play around with RDF some more; technically it&#39;s way ahead \nof what mI gives you. This is not a wild claim, nor sure you think I&#39;m \nsaying mI isn&#39;t an optimal default for XML work.\n\n\n&gt;&gt;&gt; RDF isn&#39;t really as flexible. \n&gt;&gt; I can&#39;t agree. RDF&#39;s handling of unknown triples is far more flexible \n&gt;&gt; than mI.\n&gt; \n&gt; Could you provide some examples of this?\n\nSure. For dataloading I can accept FOAF, RSS1.0, SKOS and OWL formats \nwithout adapting the content on the way in - it will just load. I can \nadd SKOS extensions to a - FOAF file. I can add RSS1.0 to DOAP or DOAP \nto RSS1.0.\n\nWith XML I have think about attributes v elements, namespace pollution, \nprocessing policies, empty/not-present, inclusion, entities, ids, \nrestrictions/orderings that result from DTDs. All entirely incidental to \nthe information and all varying along the toolchain. I can barely embed \nXML in XML without defining a policy as to how that&#39;s going to compose.\n\nAnd with XML, I need to handle each format differently.\n\nWhat I can&#39;t do with RDF are the following:\n\n  - keep a track of which facts/triples came from where\n  - keep a track of data versioned over time\n\nbut neither can XML or RDBMSes out of the box.\n\nThere are also problems with the level of flexibility RDF gives you when \nit comes to getting data back out, but I&#39;ll keep that discussion down to \na link which alludes to the issues I&#39;ve seen:\n\nhttp://www.dehora.net/journal/2007/02/off_by_one.html\n\n[Please note for both RDF and XML, I&#39;m not saying these are problems; \nthey&#39;re more like costs of doing business/barriers to entry. There&#39;s no \nperfect language.]\n\n\n\n&gt; One voice in the room asked why he should care about uniform methods,\n&gt; when the component that recieves a message still has to understand the\n&gt; whole thing. He didn&#39;t see the point of using a uniform method vs an ad\n&gt; hoc method when the whole message still had to be understood in a very\n&gt; specific way... and the thing is that in a static architecture he is\n&gt; exactly right. \n\nNo, he&#39;d still be wrong. What WS types don&#39;t always appreciate is that \nREST types make a distinction between the application layer \n(connector/interface semantics) and everything above that (processing \nabout the world that is the case).\n\nEnterprise and Internet types basically do not have a shared definition \nof what &#39;application&#39; implies. It doesn&#39;t help that REST types speak in \ntongues a lot of time about &#39;implementation details&#39; and &#39;engines of \napplication state&#39;.\n\n[In a spurious analogy, I see developers and release managers as doing \nmuch the same thing when they talk about &#39;configuration&#39;.]\n\n\n&gt; The goal of application-to-application integration is to constrain the\n&gt; kinds of message that are sent around an architecture so that the\n&gt; messages can be understood wherever they arrive. \n\nAs an aside - I think I know what you&#39;re saying, but I don&#39;t think I \nagree. I see application protocols as largely solving an economic \nproblem with distributed systems. Keeping connectors logically separate \nand having uniform  *interface* semantics solves the same problem screw \nthreads, and containers, and plug sockets do. They push variation into a \nbetter place for markets to deal with.\n\n\n&gt; Whenever the data\n&gt; schemas of two components line up, I should be able to configure them to\n&gt; talk to have specific kinds of interactions with each other. I might\n&gt; want them to have the GET interaction, or the PUT, or the SUBSCRIBE. The\n&gt; thing is that uniform methods are just an underpinning for uniform\n&gt; interactions, and that uniform data is still required.\n\nI &#39;m having difficulty believing you agree this a good thing, but that a \nuniform model of data isn&#39;t. RDF does exactly this for data interchange, \nin a way that media types simply can&#39;t provide. For starters, media \ntypes are extrinsic to the data.\n\n\n&gt; It just provides a\n&gt; uniform way of creating different data types. \n\nRDF doesn&#39;t have an expressive enough type system to do that.\n\n\n&gt; Uniform data only comes\n&gt; about with RDF when you add vocabulary to it. \n\nI disagree. Uniformity in RDF comes about through its model theory and \nthe consequent processing/inference that allows.\n\n\n&gt; Uniform data only comes\n&gt; about with XML when you add both vocabulary and structure to it.\n\nYou also need to provide policies for versioning, extension, etc.  In \ngeneral you need to state processing models and lay down best practices \nfor XML based formats. One of the problems with XML based formats is \nthat people don&#39;t tend to write down what these are, and agreement needs \nto be assumed into tools over a series of iterations (&quot;hammering things \nout&quot; as you put it).\n\nThis the the kind of lack of attention to detail which has almost killed \noff WS-. Even if the Web/REST didn&#39;t exist as an alternatives, SOAP/WS-* \nexhibits massive variance in *implementations*, not just at the \ninterface boundaries. Whereas the very definition and essence of RDF is \nin its processing model.\n\nThe graph/tree thing is a red-herring.\n\n\n&gt; It is necessary to prove that RDF facilitates better ways of\n&gt; constructing uniform kinds of data than XML does. RDF&#39;s uniform\n&gt; structure is not in and of itself a clear win for REST.\n\nI&#39;m sorry, but I think your conclusions only follow because your \ntechnical notions of what RDF is are misguided. Claiming that XML and \nRDF have equivalent expressive power is very strange to me, unless &quot;XML&quot; \nmeans &quot;XML, it&#39;s family of specs,  every useful XML based format, and \nall the open source code ever written to handle those formats&quot; (which \nI&#39;ve had to argue over before, more than once).\n\nI see RDF&#39;s limited adoption as largely a social matter, and in part due \nto it not fitting in well with the current computing landscape. We \n_build_ very large distributed software systems much the same way \ntermites build their homes. RDF is a bit like giving termites dinky toy \nJCBs.\n\nI&#39;ll finish with one point (if you to dispute what I&#39;ve said here, go \nfor it). RDF is simple in the way mathematics is simple, it&#39;s not simple \nthe way really simple syndication is simple. It requires effort to \nunderstand why it could be valuable, effort to get past cargo-cult \nnotions about data interchange issues, effort to understand why \ntechnologies like RDF don&#39;t get deployed (there&#39;s a very clear history \nof this), and still more effort to maintain any kind of precision and \nclarity when talking about it. Being precise about data modeling is \nboring; text encoding issues and OSS licences are a joke a minute by \ncomparison.\n\ncheers\nBill\n\n"}}