{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":343278744,"authorName":"Subbu Allamaraju","from":"Subbu Allamaraju &lt;subbu@...&gt;","profile":"sallamar","replyTo":"SENDER","senderId":"wpVFbHWlh-cssqApMVx3ar0_zW11PCru1T2nlbKWV0yk7Hcofs_pf3BjZKKa3c7gqbs-oLwy8l7KtFkCrX_iEv0a6lCJKLwPpw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Good examples of REST implementations","postDate":"1261265393","msgId":14244,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDBDOTAwQzc3LTIzQTAtNDZGQS04NEZGLTc0QjAwNUE1RDgxMkBzdWJidS5vcmc+","inReplyToHeader":"PDIwMDkxMjE5MTMwODQxLmU3MWRkNzc5LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PGhlbXBjaCszbGRuQGVHcm91cHMuY29tPiA8OUI4OTYwM0QtQTI4Mi00ODUwLUFDRkUtRjEyRjNBOTEwMzhEQGJibGZpc2gubmV0PiA8ZWM4NjEzYTgwOTEyMTEwMjA5cjcwNGMwNjNhazM4MGNmYjQxYzVjZTY3MjNAbWFpbC5nbWFpbC5jb20+IDwyMDA5MTIxNTAxNTcwMS4xOWJjM2IxMy5lcmljQGJpc29uc3lzdGVtcy5uZXQ+IDxCMDNBRkFDMS1ENUFFLTQ0REEtODc1Qy0yQjk5RDA1NkQwRDBAc3ViYnUub3JnPiA8MjAwOTEyMTkxMzA4NDEuZTcxZGQ3NzkuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pg=="},"prevInTopic":14242,"nextInTopic":14246,"prevInTime":14243,"nextInTime":14245,"topicId":14060,"numMessagesInTopic":20,"msgSnippet":"An application, and not the architectural style, decides what properties it needs. This is a matter of tradeoffs. I have not understood REST as an","rawEmail":"Return-Path: &lt;subbu@...&gt;\r\nX-Sender: subbu@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 34176 invoked from network); 19 Dec 2009 23:30:18 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m5.grp.sp2.yahoo.com with QMQP; 19 Dec 2009 23:30:18 -0000\r\nX-Received: from unknown (HELO mail-yw0-f189.google.com) (209.85.211.189)\n  by mta3.grp.re1.yahoo.com with SMTP; 19 Dec 2009 23:30:18 -0000\r\nX-Received: by ywh27 with SMTP id 27so4200469ywh.1\n        for &lt;rest-discuss@yahoogroups.com&gt;; Sat, 19 Dec 2009 15:30:17 -0800 (PST)\r\nX-Received: by 10.101.149.28 with SMTP id b28mr8945713ano.85.1261265417744;\n        Sat, 19 Dec 2009 15:30:17 -0800 (PST)\r\nReturn-Path: &lt;subbu@...&gt;\r\nX-Received: from ?192.168.0.196? (c-71-231-199-80.hsd1.or.comcast.net [71.231.199.80])\n        by mx.google.com with ESMTPS id 15sm1648716gxk.8.2009.12.19.15.30.15\n        (version=SSLv3 cipher=RC4-MD5);\n        Sat, 19 Dec 2009 15:30:16 -0800 (PST)\r\nMime-Version: 1.0 (Apple Message framework v1077)\r\nContent-Type: text/plain; charset=windows-1252\r\nIn-Reply-To: &lt;20091219130841.e71dd779.eric@...&gt;\r\nDate: Sat, 19 Dec 2009 15:29:53 -0800\r\nCc: Ian Davis &lt;lists@...&gt;,\n swschilke &lt;steffen.schilke@...&gt;,\n rest-discuss@yahoogroups.com,\n Story Henry &lt;henry.story@...&gt;\r\nContent-Transfer-Encoding: quoted-printable\r\nMessage-Id: &lt;0C900C77-23A0-46FA-84FF-74B005A5D812@...&gt;\r\nReferences: &lt;hempch+3ldn@...&gt; &lt;9B89603D-A282-4850-ACFE-F12F3A91038D@...&gt; &lt;ec8613a80912110209r704c063ak380cfb41c5ce6723@...&gt; &lt;20091215015701.19bc3b13.eric@...&gt; &lt;B03AFAC1-D5AE-44DA-875C-2B99D056D0D0@...&gt; &lt;20091219130841.e71dd779.eric@...&gt;\r\nTo: Eric J. Bowman &lt;eric@...&gt;\r\nX-Mailer: Apple Mail (2.1077)\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Subbu Allamaraju &lt;subbu@...&gt;\r\nSubject: Re: [rest-discuss] Good examples of REST implementations\r\nX-Yahoo-Group-Post: member; u=343278744; y=FhxXLPfJtOzlVuCbAh3XT9IPeR1Pajv3368ZXoSn8QoZVoM\r\nX-Yahoo-Profile: sallamar\r\n\r\nAn application, and not the architectural style, decides what properties it=\r\n needs. This is a matter of tradeoffs. I have not understood REST as an all=\r\n-or-nothing style. It is a set of constraints, and conscious relaxation is =\r\nokay.\n\nMy 2 cents.\n\nSubbu\n\nOn Dec 19, 2009, at 12:08 PM, Eric J. Bowman wro=\r\nte:\n\n&gt; Subbu Allamaraju wrote:\n&gt;&gt; \n&gt;&gt; IMHO, Roy&#39;s post below must be taken =\r\nwith a bit of reality mixed.\n&gt;&gt; Like most things in software, it is not an =\r\nabsolute standard to\n&gt;&gt; measure &quot;goodness&quot; of RESTful web services.\n&gt;&gt; \n&gt; \n=\r\n&gt; I think, as the hypertext constraint is a critical part of the REST\n&gt; arc=\r\nhitectural style, any system that falls short in this area can&#39;t be\n&gt; calle=\r\nd REST at all.  The result is a different architectural style\n&gt; altogether.=\r\n  Someone needs to name this style (preferably a name that&#39;s\n&gt; buzzword-wor=\r\nthy) and analyze it in terms of networked software\n&gt; architecture, just lik=\r\ne REST is.  The result would enable a comparison\n&gt; chart to be made which l=\r\nays out exactly what the differences are, in\n&gt; terms of constraints and des=\r\nirable properties.\n&gt; \n&gt; If a project can live without the desirable propert=\r\nies induced by REST,\n&gt; then perhaps this other architectural style is appro=\r\npriate for it.  But,\n&gt; such a project should not call itself REST, because =\r\nthat would imply\n&gt; desirable properties exist on that system, when this can=\r\n&#39;t be proven\n&gt; due to the obvious lack of some constraint or other.  I real=\r\nly would\n&gt; like to see this hypertext-constraint-less, but otherwise RESTfu=\r\nl,\n&gt; architectural style formalized for the plethora of REST claimants that=\r\n\n&gt; are actually using this other style out in the wild.\n&gt; \n&gt; The most impor=\r\ntant takeaways from Roy&#39;s post I linked to:\n&gt; \n&gt; &quot;\n&gt; A REST API should spen=\r\nd almost all of its descriptive effort in\n&gt; defining the media type(s) used=\r\n for representing resources and driving\n&gt; application state, or in defining=\r\n extended relation names and/or\n&gt; hypertext-enabled mark-up for existing st=\r\nandard media types. Any effort\n&gt; spent describing what methods to use on wh=\r\nat URIs of interest should be\n&gt; entirely defined within the scope of the pr=\r\nocessing rules for a media\n&gt; type... A REST API must not define fixed resou=\r\nrce names or hierarchies\n&gt; (an obvious coupling of client and server).\n&gt; &quot;\n=\r\n&gt; \n&gt; I&#39;ll describe this further, down below in my example.\n&gt; \n&gt;&gt; \n&gt;&gt; Most p=\r\nublicly visible web services are meant for mashing up data.\n&gt;&gt; Communicatin=\r\ng URIs in representations is one thing, but using them to\n&gt;&gt; drive applicat=\r\nion flow is an entirely different beast. Most mashup\n&gt;&gt; scenarios require f=\r\nair bit of control on the flow. Take Flickr for\n&gt;&gt; example. Even if it is f=\r\nixed to use HTTP correctly, making it\n&gt;&gt; hypermedia driven for application =\r\nflow does not get Flickr very far.\n&gt;&gt; \n&gt; \n&gt; Agreed.  REST is not the soluti=\r\non to all problems.  Neither is HTTP.\n&gt; The Web, and the Internet itself, a=\r\nre constantly evolving new\n&gt; architectural styles.  Take RFC 5694, for inst=\r\nance.  P2P is now gaining\n&gt; some formalization as a networked-software arch=\r\nitectural style.  This\n&gt; sort of formalization should also be applied to th=\r\ne plethora of\n&gt; non-REST APIs out there that wouldn&#39;t be better off as REST=\r\n, so there&#39;s\n&gt; some common architectural ground rather than everyone just w=\r\ninging it.\n&gt; \n&gt;&gt; \n&gt;&gt; Of course, using hypermedia to drive application flow =\r\nmakes sense\n&gt;&gt; when the server can control the flow.\n&gt;&gt; \n&gt; \n&gt; Exactly.  Let=\r\n&#39;s take a look at part of Talis&#39; API:\n&gt; \n&gt; http://n2.talis.com/wiki/Content=\r\nbox\n&gt; http://n2.talis.com/wiki/Text_Search_Syntax\n&gt; \n&gt; They&#39;ve spent all th=\r\neir effort in describing what methods to use on\n&gt; what URIs of interest, no=\r\nne of which are in-scope for RSS, while\n&gt; defining fixed resource names and=\r\n hierarchies.  There&#39;s no sense of\n&gt; what the Contentbox resource is...  Th=\r\ne documentation defines\n&gt; the /items resource as containing a list of conte=\r\nnt items.  But the\n&gt; protocol returns a search form if /items is dereferenc=\r\ned, not a list of\n&gt; contents.  The overall result is an ad-hoc XML-RPC inte=\r\nrface to a media\n&gt; type obsoleted by Atom (which has a corresponding protoc=\r\nol so you don&#39;t\n&gt; have to make up one of your own, as this API does).\n&gt; \n&gt; =\r\nI&#39;m being harsh, though.  Throw out all the query stuff and the\n&gt; protocol =\r\nstuff, and focus on the &quot;Platonic Ideal&quot; of the resource type\n&gt; identified =\r\nas &quot;Contentbox&quot; and there&#39;s plenty to work with in terms of\n&gt; making it int=\r\no a REST resource. But first, a note on resource types,\n&gt; another valuable =\r\ntakeaway from Roy&#39;s post, in light of ongoing debate\n&gt; on this list around =\r\nthe issue:\n&gt; \n&gt; &quot;\n&gt; A REST API should never have &quot;typed&quot; resources that are=\r\n significant to\n&gt; the client. Specification authors may use resource types =\r\nfor describing\n&gt; server implementation behind the interface, but those type=\r\ns must be\n&gt; irrelevant and invisible to the client. The only types that are=\r\n\n&gt; significant to a client are the current representation=92s media type an=\r\nd\n&gt; standardized relation names.\n&gt; &quot;\n&gt; \n&gt; It&#39;s perfectly legit to refer to =\r\ndifferent resource types in this\n&gt; application with different names.  For e=\r\nxample, Contentbox and Metabox\n&gt; make fine resource type names, but will ul=\r\ntimately be defined as\n&gt; different media types, which is the only concern t=\r\nhe client has.  (Don&#39;t\n&gt; try to somehow couple client behavior to the abstr=\r\nact notion of\n&gt; &quot;Contentbox&quot; or &quot;Metabox&quot;, just use them to describe your A=\r\nPI for human\n&gt; consumption.)  If, instead of beginning by defining a URI al=\r\nlocation\n&gt; scheme, this REST API&#39;s designers had followed a disciplined RES=\r\nT\n&gt; approach, the first thing they would have done with Contentbox would&#39;ve=\r\n\n&gt; been to define how it conceptually fits within their system.\n&gt; \n&gt; There&#39;=\r\ns nothing special about it, it&#39;s easy to grasp, it&#39;s an index for\n&gt; a flat-=\r\nfile media collection, plus a search interface. Whatever its\n&gt; directory na=\r\nme, producing a list of its contents is as easy as using\n&gt; &quot;Options: Direct=\r\nories&quot; in Apache. That isn&#39;t quite what we want,\n&gt; though.  There is a dual=\r\nity to the Contentbox resource: first, we want\n&gt; it to list all contents as=\r\n per the underlying filesystem; second, we\n&gt; want it to provide a metadata-=\r\ndriven search interface to the media\n&gt; files.  So I see two Contentbox reso=\r\nurce subtypes: Contentbox-search and\n&gt; Contentbox-index. I could combine th=\r\ne two into a single index-and-search\n&gt; resource, but I&#39;m not making that de=\r\nsign choice, for reasons having\n&gt; nothing to do with REST, though.\n&gt; \n&gt; The=\r\n next step is to figure out what media types we want to apply to\n&gt; Contentb=\r\nox.  So we dip into our handy REST toolbox and find that most\n&gt; features we=\r\n want, like pagination and editing, already exist as defined\n&gt; standards --=\r\n Atom and Atom Protocol, plus standard extensions like\n&gt; OpenSearch.  Pagin=\r\nation and search-syntax media-type extensions\n&gt; definitely have a say in th=\r\ne URI allocation scheme, which is why we\n&gt; don&#39;t start there, we start by d=\r\nefining which media types to use, plus\n&gt; identifying what our resources are=\r\n.\n&gt; \n&gt; Let&#39;s start with Contentbox-index.  This is a paginated list of file=\r\ns,\n&gt; which can be presented in either XHTML or as an Atom Feed of Atom medi=\r\na\n&gt; entries.  The Atom Protocol service document identifies Contentbox-\n&gt; i=\r\nndex as an Atom Protocol collection.  Here&#39;s where we throw out this\n&gt; port=\r\nion of the n2 API:\n&gt; \n&gt; http://n2.talis.com/wiki/Contentbox#Request_Paramet=\r\ners\n&gt; \n&gt; The &quot;query&quot; parameter applies to Contentbox-search, more about tha=\r\nt\n&gt; later. The &quot;max&quot; and &quot;offset&quot; parameters, which create a cache-defeatin=\r\ng\n&gt; &quot;sliding door&quot; are tossed in favor of individually-numbered (in the\n&gt; U=\r\nRI) pages of predetermined length, which implement pagination as per\n&gt; RFC =\r\n5005.  The &quot;sort&quot; parameter is tossed, that&#39;s a client-side behavior\n&gt; that=\r\n doesn&#39;t belong in the URI (except perhaps in Contentbox-search).\n&gt; The xsl=\r\n parameter implements transformation in a bass-ackwards fashion,\n&gt; and the =\r\ndesired output Content-Type doesn&#39;t belong in the URL.  To do\n&gt; so, instead=\r\n of honoring the Accept header, is a violation of:\n&gt; \n&gt; http://www.w3.org/2=\r\n001/tag/doc/mime-respect.html\n&gt; \n&gt; The output Content-Type is what the auth=\r\nor/server intends, as coded in\n&gt; the XSLT document.  What&#39;s needed here, is=\r\n some Content Negotiation.\n&gt; At this point, it should be obvious that the U=\r\nRL of a Contentbox is\n&gt; irrelevant in a REST API, so instead of coupling it=\r\n to /{storename}/\n&gt; items and limiting a store to one Contentbox, it should=\r\n be up to the\n&gt; user to name it /{storename}/foo/ or /{storename}/bar/ or e=\r\nven \n&gt; /{storename}/foo/bar/, or all three.  I&#39;ll use /{storename}/items/ w=\r\nith\n&gt; the trailing-slash for this example.\n&gt; \n&gt; For the Contentbox-index re=\r\nsource, we want paginated output in either\n&gt; XHTML or Atom depending on cli=\r\nent preference.  With conneg, this gives\n&gt; us a URI allocation scheme like =\r\nso:\n&gt; \n&gt; /{storename}/items/\n&gt; /{storename}/items/;page=3D2\n&gt; /{storename}/=\r\nitems/;page=3D3\n&gt; \n&gt; Etc.  The server responds with a Vary: Accept header, =\r\nwith Content-\n&gt; Location headers like so:\n&gt; \n&gt; /{storename}/items/index.htm=\r\nl\n&gt; /{storename}/items/index.atom\n&gt; /{storename}/items/index.html;page=3D2\n=\r\n&gt; /{storename}/items/index.atom;page=3D2\n&gt; /{storename}/items/index.html;pa=\r\nge=3D3\n&gt; /{storename}/items/index.atom;page=3D3\n&gt; \n&gt; This makes every repre=\r\nsentation a resource in its own right.  The\n&gt; Content-Location, Alternates =\r\nand Vary headers make conneg visible, so\n&gt; even without documentation, the =\r\nself-descriptive messaging reveals that\n&gt; it&#39;s possible to bypass content n=\r\negotiation and directly request Atom or\n&gt; XHTML based on filename extension=\r\n.  This is a logical approach; putting\n&gt; the MIME type (or a token like &#39;at=\r\nom&#39; or &#39;html&#39;) in a query string is\n&gt; not.\n&gt; \n&gt; The XHTML output is simply =\r\ntransformed from the Atom using XSLT.  If\n&gt; someone wants their own XSLT ou=\r\ntput, there are Web services out there\n&gt; which allow the input of a source =\r\nURL (the .atom resource directly) and\n&gt; a stylesheet URL, this doesn&#39;t belo=\r\nng in the Contentbox request URIs.\n&gt; The XHTML variant can include a form w=\r\nhich links to such a service and\n&gt; runs its Atom alternate through a user-s=\r\npecified stylesheet, i.e. we\n&gt; can apply the hypertext constraint to this f=\r\neature.\n&gt; \n&gt; Instead of starting with resource identification, media type a=\r\nnd link\n&gt; relation selection before getting to URIs, the designers of the n=\r\n2 API\n&gt; picked a bookmark URI (/items) and added a bunch of features to it\n=\r\n&gt; through the query string.  Had they followed a disciplined REST\n&gt; approac=\r\nh, I doubt that they would have wound up identifying Contentbox\n&gt; as a plet=\r\nhora of resources, i.e. each sort key creates two new resource\n&gt; subtypes, =\r\none for ascending, the other for descending, etc.\n&gt; \n&gt; At some point, seein=\r\ng the number of semantically-identical first-class\n&gt; resources, and attempt=\r\ning to define a URI allocation scheme for them,\n&gt; would have revealed itsel=\r\nf as a problem.  This problem does not reveal\n&gt; itself when a URI is define=\r\nd, and a sort feature is added in the query\n&gt; string, because there is no s=\r\nense of what the Contentbox resource *is*\n&gt; using that approach.  A discipl=\r\nined approach here leads to an order of\n&gt; magnitude fewer URIs for the serv=\r\ner to manage, while vastly increasing\n&gt; cache efficiency (once again explod=\r\ning the myth that REST creates &quot;too\n&gt; many URLs&quot;).\n&gt; \n&gt; On to Contentbox-se=\r\narch.  Again, /{storename}/items should be able to\n&gt; use any name not reser=\r\nved by the system, instead of just /items.  But\n&gt; the idea is the same -- w=\r\ne want to search the -index of the same\n&gt; Contentbox&#39;s metadata, and return=\r\n a representation in either XHTML or\n&gt; Atom depending on client preference,=\r\n listing the links to the contained\n&gt; resources.  The query syntax used is =\r\nstandardized by using OpenSearch.\n&gt; \n&gt; /{storename}/items\n&gt; /{storename}/it=\r\nems.html\n&gt; /{storename}/items.atom\n&gt; \n&gt; /{storename}/items?q=3D{searchTerms=\r\n}\n&gt; /{storename}/items.html?q=3D{searchTerms}\n&gt; /{storename}/items.atom?q=\r\n=3D{searchTerms}\n&gt; \n&gt; /{storename}/items?q=3D{searchTerms}&p=3D{startPage?}=\r\n\n&gt; /{storename}/items.html?q=3D{searchTerms}&p=3D{startPage?}\n&gt; /{storename=\r\n}/items.atom?q=3D{searchTerms}&p=3D{startPage?}\n&gt; \n&gt; I&#39;m aware that OpenSea=\r\nrch allows output format to be specified as part\n&gt; of the query string, but=\r\n I still believe supported output formats\n&gt; should be differentiated in the=\r\n Path to support content negotiation,\n&gt; while also enabling conneg to be cl=\r\neanly bypassed.  Once again, the\n&gt; XHTML output is transformed from the Ato=\r\nm, using XSLT on the server.\n&gt; \n&gt; If sort order is enabled in the URIs, it =\r\nshould only be on Contentbox-\n&gt; search, and should be worked out as a propo=\r\nsed extension to OpenSearch\n&gt; (if there isn&#39;t already such a beast).  For C=\r\nontentbox-index, page-by-\n&gt; page client-based sorting should do.  If that&#39;s=\r\n too fine-grained, the\n&gt; user has the option of using Contentbox-search ins=\r\ntead.  Two interfaces\n&gt; to one filesystem; I like it.\n&gt; \n&gt; So there&#39;s a RES=\r\nTful re-work of n2&#39;s Contentbox API, no hard feelings I\n&gt; hope.  In a nutsh=\r\nell, my advice here is &quot;Just Use Atom (tm).&quot;  By\n&gt; starting with the concep=\r\ntual visualization of the Contentbox resource\n&gt; type and discovering its su=\r\nbtypes, followed by the selection of standard\n&gt; methods, media types / exte=\r\nnsions, and link relations (first, last,\n&gt; prev, next, edit, alternate, etc=\r\n.), before even _thinking_ about URI\n&gt; allocation schemes, a disciplined ap=\r\nproach to REST is being followed.\n&gt; \n&gt; What I&#39;ve described here can be fles=\r\nhed out into an API which doesn&#39;t\n&gt; define fixed resource names or hierarch=\r\nies.  Resource interfaces are\n&gt; generic, not object-centric.  Interaction i=\r\ns driven by hypertext, not\n&gt; out-of-band information.  Interaction is clean=\r\nly separated from\n&gt; identification.  The API may be cleanly documented by d=\r\nescribing the\n&gt; Contentbox resource in terms of media types and link relati=\r\nons --\n&gt; methods don&#39;t bear mentioning as their use is entirely defined wit=\r\nhin\n&gt; the processing rules of the media types. Any server written to it wou=\r\nld\n&gt; have the freedom to manage its own namespace.  The whole thing is base=\r\nd\n&gt; on selecting the standard media types best suited to the task at hand.\n=\r\n&gt; &quot;Contentbox&quot; as a resource-type is irrelevant and invisible to the\n&gt; clie=\r\nnt, as are its -search and -index sub-resources.\n&gt; \n&gt; I may be long-winded,=\r\n but I hope I&#39;ve come around full-circle back to\n&gt; my original point of, &quot;G=\r\no read Roy&#39;s post on &#39;REST APIs must be\n&gt; hypertext-driven&#39; as it explains =\r\nexactly where this API goes wrong.&quot;\n&gt; The result of following his advice in=\r\n my example here is a state-of-the-\n&gt; art, pragmatic solution to the proble=\r\nm at hand, which may be widely\n&gt; understood by implementers right out of th=\r\ne starting gate -- without any\n&gt; murmurs from this list about not being &quot;Ro=\r\ny Fielding&#39;s REST&quot;...\n&gt; \n&gt; -Eric\n\n\n"}}