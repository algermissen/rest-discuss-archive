{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":69164307,"authorName":"mike amundsen","from":"mike amundsen &lt;mamund@...&gt;","profile":"mamund","replyTo":"SENDER","senderId":"8w81NuiiyvM9mPdEn9joZ8TlQ5IR_nWtuYvM_j-KOm0oIhVhE8QbF3zdF8cohh04yDR-XWvdP602p1x0CkeQIiwdwAwf5iw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Link relations [was: A media type for case files, dossiers and documents]","postDate":"1291370926","msgId":17011,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEFBTkxrVGltSGZXUVBzVURNLTUtOWt5RzhtRkNXPXM4S3R1Zzk5dnNNMHdhZUBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PDEwODA4MS42MDg0NC5xbUB3ZWI1NTkwMS5tYWlsLnJlMy55YWhvby5jb20+","referencesHeader":"PDIwMTAxMjAyMjMzMjU1LmQ1NWJhZTkzLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDEwODA4MS42MDg0NC5xbUB3ZWI1NTkwMS5tYWlsLnJlMy55YWhvby5jb20+"},"prevInTopic":17010,"nextInTopic":17012,"prevInTime":17010,"nextInTime":17012,"topicId":16947,"numMessagesInTopic":88,"msgSnippet":"Kevin: I ve been doing quite a bit of work in the area of making decisions on how to code clients for Internet apps. Your comments about how XHTML seems ","rawEmail":"Return-Path: &lt;mca@...&gt;\r\nX-Sender: mca@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 4424 invoked from network); 3 Dec 2010 10:08:47 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m16.grp.re1.yahoo.com with QMQP; 3 Dec 2010 10:08:47 -0000\r\nX-Received: from unknown (HELO mail-fx0-f44.google.com) (209.85.161.44)\n  by mta2.grp.re1.yahoo.com with SMTP; 3 Dec 2010 10:08:47 -0000\r\nX-Received: by fxm9 with SMTP id 9so7584274fxm.17\n        for &lt;rest-discuss@yahoogroups.com&gt;; Fri, 03 Dec 2010 02:08:46 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.223.100.4 with SMTP id w4mr1090039fan.26.1291370926556; Fri,\n 03 Dec 2010 02:08:46 -0800 (PST)\r\nX-Received: by 10.223.122.77 with HTTP; Fri, 3 Dec 2010 02:08:46 -0800 (PST)\r\nIn-Reply-To: &lt;108081.60844.qm@...&gt;\r\nReferences: &lt;20101202233255.d55bae93.eric@...&gt;\n\t&lt;108081.60844.qm@...&gt;\r\nDate: Fri, 3 Dec 2010 05:08:46 -0500\r\nX-Google-Sender-Auth: Dv_rYXa3GbEDUD8dakgaPhV15Bc\r\nMessage-ID: &lt;AANLkTimHfWQPsUDM-5-9kyG8mFCW=s8Ktug99vsM0wae@...&gt;\r\nTo: Kevin Duffey &lt;andjarnic@...&gt;\r\nCc: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;, \n\tRest Discussion List &lt;rest-discuss@yahoogroups.com&gt;, juergen.brendel@...\r\nContent-Type: multipart/alternative; boundary=20cf30433e3259c72a04967eb9f7\r\nFrom: mike amundsen &lt;mamund@...&gt;\r\nSubject: Re: [rest-discuss] Link relations [was: A media type for case files,\n dossiers and documents]\r\nX-Yahoo-Group-Post: member; u=69164307; y=w_nlyBlweyD_q9_qClxE1eoIKoORbkB-XkyRXwN6ZNfW\r\nX-Yahoo-Profile: mamund\r\n\r\n\r\n--20cf30433e3259c72a04967eb9f7\r\nContent-Type: text/plain; charset=ISO-8859-1\r\n\r\nKevin:\n\nI&#39;ve been doing quite a bit of work in the area of making decisions on how\nto code clients for Internet apps. Your comments about how XHTML seems\ninappropriate remind me of a set of decisions we all make (consciously or\nnot) about implementing solutions for Internet apps. Here&#39;s a peek into one\naspect of my current thinking on this. Hopefully it hits some of teh points\nto raise and provides some ideas on how you can approach your\ndecision-making.\n\nNOTE: I cover some of this in a talk and the slides (and C# code) for that\ntalk are here:http://amundsen.com/talks/#beyond-web20\n\nCONSIDERATIONS\nWhen coding clients for application-level protocols (HTTP) over distributed\nnetworks (i.e. the &quot;Web&quot;), these things (among others) must be taken into\naccount:\n1 - how does the client know all the addresses (URIs) that will be needed to\nexecute operations?\n2 - how does the client know how to properly construct specific requests\n(searches, filters, etc.) to send to the addresses?\n3 - how does the client &quot;understand&quot; the responses returned from those\nrequests?\n4 - how does the client know the order in which these actions\n(requests/responses) must take place (you can&#39;t create a new order until you\ncreate a new customer, you can&#39;t register more than ten pending orders per\nday, etc.).\n\nYou have two general approaches:\n- code these details into the client (non-hypermedia) and re-code the client\nwhen the details change or;\n- code these details into the message (hypermedia) and reformat the message\nwhen the details change.\n\nA NON-HYPERMEDIA APPROACH:\n1 - When coding the client application programmers will get a long list of\nURIs (from documentation) and hard-code them into the client application or\nencode the URI list in some static config file, etc. and make that available\nto the client code. It&#39;s possible that some URI construction rules can be\nused instead of a static list. Then programmers write code that knows how to\nexecute the construction rules at runtime based on the state of the client,\netc. The client application will also have some rules in code in order to\nassociate each fixed/constructed URI w/ some &quot;action&quot; (get a user record,\nsearch for users added last week, add a new user, etc.) and the client code\nwill select the proper address at runtime based on the state of the client,\netc.\n\n2 - When sending requests from the client to the server (the &quot;actions&quot;\nmentioned in #1 above), programmers will write code that knows the format\ndetails of the message (XML, JSON, CSV, etc), the layout details (XML\nelements named &quot;email&quot;, &quot;hat-size&quot;, etc.), which elements are required,\noptional, etc. Programmers will write code that, at runtime, associates\nclient state with each of these &quot;fields&quot;, populates the structures and sends\nthem to the proper URI (from #1).\n\n3 - When receiving responses, client applications know, ahead of time, what\nto format expect (XML, JSON, etc.), the exact layout of each response\n(elements and attributes, etc.), and how to render them visually for humans\n(or arrange the data returned in the proper memory &quot;slots&quot; for M2M apps).\n\n4 - The client application will have all the rules for application flow hard\ncoded. It will &quot;know&quot; that customers cannot have more than ten pending\norders or that order detail lines can&#39;t be sent to the server before an\norder document is created, etc.\n\nWhen using the this approach, changing any of those items over time (new\naddresses for new requests that return new responses in a\nnew application-flow order) will require re-coding the client and\nre-deploying that new code to replace all the existing &quot;old&quot; client code.\n\nA HYPERMEDIA-DRIVEN APPROACH\nUsing Fielding&#39;s REST style as a guide (&quot;hypermedia as the engine of\napplication state&quot;):\n1 - The goal is to reduce the number of addresses to the fewest reasonably\npossible. One pre-established address is a nice goal - the &quot;starting&quot;\naddress. After that, all other addresses are expected to come in the\nresponses. XHTML has a built-in element for this data - the anchor (&lt;a ...\n/&gt;) tag.\n\n2 - The information about what fields to use when crafting a request are\ncontained in the responses to requests, not hard-coded in the client\napplication. XHTML has built-in elements for this, too. FORMs w/ INPUT,\nSELECT, and TEXTAREA elements. Clients know ahead of time how to handle each\nof these elements; they are universal for all types of requests (for users,\ncustomers, stores, orders, etc.). Also, the FORM element has the associated\nURI for this action when the client receives the response so there is no\nneed to hard-code any other URIs in the client, either.\n\n3 - The information about what fields & layouts to expect in responses and\nhow to &quot;render&quot; them is also included in XHTML. Like the FORM elements,\nresponse elements are generic and of a limited set. Clients to do not need\nto know a set of specific data elements (&lt;email /&gt;, &lt;hat-size /&gt;, etc.) and\nwhen to expect them and how to render them. Instead, client code is written\nto know how to render the generic set of elements (DL, DT, DD, DIV, SPAN,\nTABLE, etc) in a response.\n\n4 - The responses carry the &quot;next possible steps&quot; for the application flow.\nXHTML elements such as &lt;a /&gt; and &lt;form /&gt; will appear when it&#39;s appropriate\n(the response to create order will have links/controls to create order\nlines, once ten pending orders are created for a customer, the response will\nno longer in include a &quot;create pending order&quot; link, etc.).\n\nWhen using the second approach, new addresses for new requests that return\nnew responses w/ new app-flow details will not require changing the client\ncode. Because all that information is included in the responses; the media\ntype (XHTML) has &quot;affordances&quot; for carrying that application control\ninformation (&lt;a /&gt;, &lt;form /&gt;, etc.) within the responses.  XHTML has an\nadvantage due to it&#39;s built-in hypermedia controls. XML and JSON do not have\nthese.\n\nCHOOSING WHICH APPROACH TO USE\nNow, it may turn out that you are creating an application that:\n1) has only one address\n2) has only one request format\n3) has only one response format\n4) has only one possible application flow\n\nIf that&#39;s the case, you don&#39;t need the advantages that a hypermedia-driven\nimplementation affords; all that work may be overkill and waste. Using a\nnon-hypermedia format (e.g. CSV, XML, JSON, etc.) and hard-coding the\ndetails in the client will work much better with less overall effort.\n\nOr, you may have a small set of addresses, or a small set of request\nformats, or a small set of response formats, or a small set of app-flows.\nNow you need to think a bit more on whether your varying set of addresses,\nrequest and response formats, and app-flows are numerous enough to make it\nworth while to adopt a hypermedia-driven implementation or stick to\nhard-coding clients.\n\nOr you may have an application where, even w/ a wide range of address,\nrequests, responses, and app-flows, these values hardly change over the life\nof the application (days, weeks, years, etc.). Does it make sense to use a\nhypermedia-driven implementation if the formats never change?\n\nOr you may be the only one writing the client. Just like it&#39;s often more\neffort to document a simple app than build it, using a hypermedia-driven\nimplementation in order to never change the code that you yourself could\nwrite more quickly and efficiently anyway may be too much effort for the\nreturn.\n\nSo,,,\n_When_ you choose one approach over the other is entirely up to you based on\nyour particular constraints (time, money, complexity of the app, variance of\nthe app over time, etc.). But if you _do_ choose a hypermedia-driven\napproach,you&#39;ll want to use an existing hypermedia type (XHTML) or design\nand implement your own custom hypermedia type.\n\nHope that ramble helps.\n\nmca\nhttp://amundsen.com/blog/\nhttp://twitter.com@mamund\nhttp://mamund.com/foaf.rdf#me\n\n\n#RESTFest 2010\nhttp://rest-fest.googlecode.com\n\n\n\nOn Fri, Dec 3, 2010 at 02:54, Kevin Duffey &lt;andjarnic@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; I get everything you are saying..finally thanks to a few of you that set me\n&gt; clear on this whole media-type issue.\n&gt;\n&gt; I am however having a hard time thinking about telling clients that they\n&gt; basically need to parse html to use my API. I much rather say &quot;for /orders,\n&gt; you get this chunk of xml back with these potential elements.. parse it to\n&gt; get the data you need&quot;. Or in JSON. As I use Java/JAX-RS with Jersey, it\n&gt; handles automatically turning my objects into either xml or json, whatever\n&gt; the Accept header specifies. Anyway, for my own learning, it is good to know\n&gt; what you said, and it does make sense. However, it seems odd to me to return\n&gt; things in HTML as opposed to xml or json, when it&#39;s just chunks.. that is, a\n&gt; user places 100 orders over 3 months, then comes in and asks to see a\n&gt; history of orders. I return an xml chunk with their 100 orders and related\n&gt; info. That seems perfectly fine to provide in xml or json, allowing any\n&gt; client to parse the response as they see fit. I would obviously have some\n&gt; sort of api doc that would explain the response.\n&gt;\n&gt; I guess what I am grappling with is that for the most part, I would suspect\n&gt; most services like the one I am messing around with to learn, would be used\n&gt; by specific clients, not anyone and everyone out on the web. More so, I\n&gt; don&#39;t see anyone needing to use my particular bits of data I return for\n&gt; their own use.. that is, if I were to register a media type that represents\n&gt; a generic ordering document, that might make sense, but in my case, if I am\n&gt; building up a REST api for my specific little service, it doesn&#39;t seem like\n&gt; returning HTML would make any more sense than returning xml or json. I\n&gt; certainly can see if I was building my own web site, where I have some\n&gt; javascript make ajax requests and I return a chunk of HTML instead of XML or\n&gt; JSON, so that my own site consuming my API can benefit from having HTML\n&gt; directly, rather than xml or json then have to build up the html on the fly\n&gt; in the browser. But for say a mobile app that had a native client that\n&gt; allowed a user to log in and pull up their recent orders, a chunk of XML\n&gt; would fit well. HTML seems more difficult to have to parse and deal with..\n&gt; at least the way I think. Again, if I were going to display it in a\n&gt; browser..maybe it&#39;s fine, but if I wanted to do something with the data\n&gt; before displaying it or maybe it&#39;s not a web browser at all, html seems out\n&gt; of place. That&#39;s just my opinion tho from the bits I&#39;ve learned the past few\n&gt; days.\n&gt;\n&gt;\n&gt;\n&gt; --- On *Thu, 12/2/10, Eric J. Bowman &lt;eric@...&gt;* wrote:\n&gt;\n&gt;\n&gt; From: Eric J. Bowman &lt;eric@...&gt;\n&gt; Subject: Re: [rest-discuss] Link relations [was: A media type for case\n&gt; files, dossiers and documents]\n&gt; To: &quot;Kevin Duffey&quot; &lt;andjarnic@...&gt;\n&gt; Cc: &quot;Rest Discussion List&quot; &lt;rest-discuss@yahoogroups.com&gt;,\n&gt; juergen.brendel@...\n&gt; Date: Thursday, December 2, 2010, 10:32 PM\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; Kevin Duffey wrote:\n&gt; &gt;\n&gt; &gt; Valid point. I am not sure what media type would fit then. I am\n&gt; &gt; trying to follow the HATEOS design, I have an entry point that\n&gt; &gt; returns some links based on credentials, from there a client would\n&gt; &gt; use those to make calls to any of my resources, and each response\n&gt; &gt; would return a relevant chunk of XML or JSON with links for each\n&gt; &gt; resource accessible at that point (for example GET /orders/id would\n&gt; &gt; return a specific order along with one or more links that can be used\n&gt; &gt; to operate on the order).\n&gt; &gt;\n&gt;\n&gt; I&#39;ve never seen an order-processing system that couldn&#39;t be modeled as\n&gt; HTML. In fact, I&#39;ve rarely seen an order-processing system that wasn&#39;t\n&gt; HTML. In OOP terminology, the goal is to distribute not your objects,\n&gt; but your object interfaces. REST says, make those object interfaces\n&gt; uniform. Which means participants have a network-based shared\n&gt; understanding of your state transitions (links, forms), IOW, a self-\n&gt; documenting API.\n&gt;\n&gt; It&#39;s perfectly acceptable to model your data as JSON or as XML (bearing\n&gt; in mind that schemas are an orthogonal concern). The trick is to\n&gt; create an HTML interface for either JSON or XML data, which instructs\n&gt; user-agents how to interact with that data. I&#39;d choose either JSON or\n&gt; XML, instead of trying to do both, depending on whether you&#39;re more\n&gt; comfortable transforming that data into HTML using Javascript or XSLT.\n&gt;\n&gt; &gt;\n&gt; &gt; So if I use application/xml, my API would not be considered truly\n&gt; &gt; RESTful?\n&gt; &gt;\n&gt;\n&gt; No, not if you&#39;re using application/xml as the hypertext engine driving\n&gt; application state. If it&#39;s just a snippet of XML which gets read by,\n&gt; say, an HTML front-end driving application state, then it&#39;s OK because\n&gt; the processing model (parse as XML, handling XInclude/XLink/rdf:about)\n&gt; is adequate to the task. If that XML snippet contains URIs the user is\n&gt; supposed to click on to transition the application to the next steady-\n&gt; state (which aren&#39;t XLinks), well, that&#39;s what &lt;a&gt; and atom:link are\n&gt; for, there&#39;s no corollary in application/xml (besides XLink).\n&gt;\n&gt; Also, most order forms are simply tabular data, the semantics of which\n&gt; don&#39;t exist in application/xml like they do in application/xhtml+xml or\n&gt; text/html with &lt;table&gt;. Same with lists, same with forms.\n&gt;\n&gt; &gt;\n&gt; &gt; So now I&#39;ll ask, what media type I could possibly use with my own\n&gt; &gt; xml/json structure? It almost sounds like you&#39;re saying I shouldn&#39;t\n&gt; &gt; be returning my own made up structure, that I should instead use an\n&gt; &gt; existing media type, like one with xhtml or something. Is there a\n&gt; &gt; media type that allows for any sort of specific format to a domain to\n&gt; &gt; be returned? Or does that now fall into a case where I should create\n&gt; &gt; my own media type and register it with IANA?\n&gt; &gt;\n&gt;\n&gt; It falls into a case where you should refactor. You have tabular data,\n&gt; so you need to choose a data type which expresses such semantics (i.e.\n&gt; HTML, or DocBook). The whole point of media types is that they are\n&gt; _not_ domain-specific, but rather, represent a shared understanding of\n&gt; a processing model at the network (IP) layer. This is the fundamental\n&gt; tradeoff of the style:\n&gt;\n&gt; &quot;[A] uniform interface degrades efficiency, since information is\n&gt; transferred in a standardized form rather than one which is specific to\n&gt; an application&#39;s needs.&quot;\n&gt;\n&gt; An order consists of item numbers, descriptions, quantity, unit price\n&gt; and total price. You *could* re-invent the &lt;table&gt; wheel and register\n&gt; it as a new media type, but it&#39;s more scalable (maintainable, portable)\n&gt; to re-use HTML even if it isn&#39;t a precise fit. If you create a new\n&gt; media type, then you need to distribute a custom user-agent. When you\n&gt; upgrade your API, you must simultaneously update that user-agent.\n&gt;\n&gt; The success of the Web is due to the common user-agent. What I really\n&gt; don&#39;t want, is for any system I interact with to require me to install\n&gt; yet another piece of software, and keep it up-to-date. That&#39;s coupling.\n&gt; So much easier for everyone concerned, to target the browser. That way,\n&gt; I only need to install and maintain one user-agent regardless of how\n&gt; many different systems I interact with. Such decoupling allows clients\n&gt; and servers to evolve independently. So there is a cost associated\n&gt; with the minting of new media types -- coupling -- unless and until the\n&gt; new media type achieves significant uptake.\n&gt;\n&gt; -Eric\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; \n\r\n--20cf30433e3259c72a04967eb9f7\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;div&gt;Kevin:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I&#39;ve been doing quite a bit of wor=\r\nk in the area of making decisions on how to code clients for Internet apps.=\r\n Your comments about how XHTML seems inappropriate remind me of a set of de=\r\ncisions we all make (consciously=A0or not) about implementing solutions for=\r\n Internet apps. Here&#39;s a peek into one aspect of my current thinking on=\r\n this. Hopefully it hits some of teh points to raise and provides some idea=\r\ns on how you can approach your decision-making.&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;N=\r\nOTE: I cover some of this in a talk and the slides (and C# code) for that t=\r\nalk are here:&lt;a href=3D&quot;http://amundsen.com/talks/#beyond-web20&quot;&gt;http://amu=\r\nndsen.com/talks/#beyond-web20&lt;/a&gt;=A0=A0&lt;/div&gt;&lt;meta http-equiv=3D&quot;content-ty=\r\npe&quot; content=3D&quot;text/html; charset=3Dutf-8&quot;&gt;&lt;div&gt;\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;CONSIDERATI=\r\nONS&lt;/div&gt;&lt;div&gt;When coding clients for application-level protocols (HTTP) ov=\r\ner distributed networks (i.e. the &quot;Web&quot;), these things (among oth=\r\ners) must be taken into account:&lt;/div&gt;\n&lt;div&gt;1 - how does the client know al=\r\nl the addresses (URIs) that will be needed to execute operations? =A0&lt;/div&gt;=\r\n&lt;div&gt;2 - how does the client know how to properly construct specific reques=\r\nts (searches, filters, etc.) to send to the addresses?&lt;/div&gt;\n\n&lt;div&gt;3 - how =\r\ndoes the client &quot;understand&quot; the responses returned from those re=\r\nquests?&lt;/div&gt;&lt;div&gt;4 - how does the client know the order in which these act=\r\nions (requests/responses) must take place (you can&#39;t create a new order=\r\n until you create a new customer, you can&#39;t register more than ten pend=\r\ning orders per day, etc.).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;You have two gen=\r\neral approaches:=A0&lt;/div&gt;&lt;div&gt;- code these details into the client (non-hyp=\r\nermedia) and re-code the client when the details change or;&lt;/div&gt;\n&lt;div&gt;- co=\r\nde these details into the message (hypermedia) and reformat the message whe=\r\nn the details change.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;A NON-HYPERMEDIA APPRO=\r\nACH:&lt;/div&gt;&lt;div&gt;1 - When coding the client application programmers will get =\r\na long list of URIs (from documentation) and hard-code them into the client=\r\n application or encode the URI list in some static config file, etc. and ma=\r\nke that available to the client code. It&#39;s possible that some URI const=\r\nruction rules can be used instead of a static list. Then programmers write =\r\ncode that knows how to execute the construction rules at runtime based on t=\r\nhe state of the client, etc. The client application will also have some rul=\r\nes in code in order to associate each fixed/constructed URI w/ some &quot;a=\r\nction&quot; (get a user record, search for users added last week, add a new=\r\n user, etc.) and the client code will select the proper address at runtime =\r\nbased on the state of the client, etc.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - When =\r\nsending requests from the client to the server (the &quot;actions&quot; men=\r\ntioned in #1 above), programmers will write code that knows the format deta=\r\nils of the message (XML, JSON, CSV, etc), the layout details (XML elements =\r\nnamed &quot;email&quot;, &quot;hat-size&quot;, etc.), which elements are re=\r\nquired, optional, etc. Programmers will write code that, at runtime, associ=\r\nates client state with each of these &quot;fields&quot;, populates the stru=\r\nctures and sends them to the proper URI (from #1).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;d=\r\niv&gt;3 - When=A0receiving=A0responses, client applications know, ahead of tim=\r\ne, what to format expect (XML, JSON, etc.), the exact layout of each respon=\r\nse (elements and attributes, etc.), and how to render them visually for hum=\r\nans (or arrange the data returned in the proper memory &quot;slots&quot; fo=\r\nr M2M apps).=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4 - The client application will =\r\nhave all the rules for application flow hard coded. It will &quot;know&quot=\r\n; that customers cannot have more than ten pending orders or that order det=\r\nail lines can&#39;t be sent to the server before an order document is creat=\r\ned, etc.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;When using the this approach, changing =\r\nany of those items over time (new addresses for new requests that return ne=\r\nw responses in a new=A0application-flow order) will require re-coding the c=\r\nlient and re-deploying that new code to replace all the existing &quot;old&=\r\nquot; client code.&lt;/div&gt;\n\n&lt;div&gt;=A0&lt;/div&gt;&lt;div&gt;A HYPERMEDIA-DRIVEN APPROACH&lt;/=\r\ndiv&gt;&lt;div&gt;Using Fielding&#39;s REST style as a guide (&quot;hypermedia as th=\r\ne engine of application state&quot;):&lt;/div&gt;&lt;div&gt;1 - The goal is to reduce t=\r\nhe number of addresses to the fewest reasonably possible. One pre-establish=\r\ned address is a nice goal - the &quot;starting&quot; address. After that, a=\r\nll other addresses are expected to come in the responses. XHTML has a built=\r\n-in element for this data - the anchor (&lt;a ... /&gt;) tag.=A0&lt;/div&gt;\n\n&lt;di=\r\nv&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - The information about what fields to use when crafting=\r\n a request are contained in the responses to requests, not hard-coded in th=\r\ne client application. XHTML has built-in elements for this, too. FORMs w/ I=\r\nNPUT, SELECT, and TEXTAREA elements. Clients know ahead of time how to hand=\r\nle each of these elements; they are universal for all types of requests (fo=\r\nr users, customers, stores, orders, etc.). Also, the FORM element has the a=\r\nssociated URI for this action when the client=A0receives=A0the response so =\r\nthere is no need to hard-code any other URIs in the client, either.&lt;/div&gt;\n\n=\r\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3 - The information about what fields &amp; layouts to =\r\nexpect in responses and how to &quot;render&quot; them is also included in =\r\nXHTML. Like the FORM elements, response elements are generic and of a limit=\r\ned set. Clients to do not need to know a set of specific data elements (&lt=\r\n;email /&gt;, &lt;hat-size /&gt;, etc.) and when to expect them and how to =\r\nrender them. Instead, client code is written to know how to render the gene=\r\nric set of elements (DL, DT, DD, DIV, SPAN, TABLE, etc) in a response.&lt;/div=\r\n&gt;\n\n&lt;div&gt;=A0&lt;/div&gt;&lt;div&gt;4 - The responses carry the &quot;next possible steps=\r\n&quot; for the application flow. XHTML elements such as &lt;a /&gt; and &lt=\r\n;form /&gt; will appear when it&#39;s appropriate (the response to create o=\r\nrder will have links/controls to create order lines, once ten pending order=\r\ns are created for a customer, the response will no longer in include a &quo=\r\nt;create pending order&quot; link, etc.).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;When u=\r\nsing the second approach, new addresses for new requests that return new re=\r\nsponses w/ new app-flow=A0details=A0will not require changing the client co=\r\nde. Because all that information is included in the responses; the media ty=\r\npe (XHTML) has &quot;affordances&quot; for carrying that application contro=\r\nl information (&lt;a /&gt;, &lt;form /&gt;, etc.) within the responses. =A0=\r\nXHTML has an advantage due to it&#39;s built-in hypermedia controls. XML an=\r\nd JSON do not have these.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CHOOSING WHICH APPR=\r\nOACH TO USE&lt;/div&gt;&lt;div&gt;Now, it may turn out that you are creating an=A0appli=\r\ncation=A0that:&lt;/div&gt;&lt;div&gt;1) has only one address&lt;/div&gt;&lt;div&gt;2) has only one =\r\nrequest format&lt;/div&gt;&lt;div&gt;3) has only one response format&lt;/div&gt;\n&lt;div&gt;4) has =\r\nonly one possible application flow&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If that&#39;s =\r\nthe case, you don&#39;t need the advantages that a hypermedia-driven implem=\r\nentation affords; all that work may be overkill and waste. Using a non-hype=\r\nrmedia format (e.g. CSV, XML, JSON, etc.) and hard-coding the details in th=\r\ne client will work much better with less overall effort.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/=\r\ndiv&gt;&lt;div&gt;Or, you may have a small set of addresses, or a small set of reque=\r\nst formats, or a small set of response formats, or a small set of app-flows=\r\n. Now you need to think a bit more on whether your varying set of addresses=\r\n, request and response formats, and app-flows are numerous enough to make i=\r\nt worth while to adopt a hypermedia-driven implementation or stick to hard-=\r\ncoding clients.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or you may have an application w=\r\nhere, even w/ a wide range of address, requests, responses, and app-flows, =\r\nthese values hardly change over the life of the application (days, weeks, y=\r\nears, etc.). Does it make sense to use a hypermedia-driven implementation i=\r\nf the formats never change?&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or you may be the on=\r\nly one writing the client. Just like it&#39;s often more effort to document=\r\n a simple app than build it, using a hypermedia-driven implementation in or=\r\nder to never change the code that you yourself could write more quickly and=\r\n efficiently anyway may be too much effort for the return.&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;=\r\n/div&gt;&lt;div&gt;So,,,&lt;/div&gt;&lt;div&gt;_When_ you choose one approach over the other is =\r\nentirely up to you based on your particular constraints (time, money, compl=\r\nexity of the app, variance of the app over time, etc.). But if you _do_ cho=\r\nose a hypermedia-driven approach,you&#39;ll want to use an existing hyperme=\r\ndia type (XHTML) or design and implement your own custom hypermedia type.&lt;/=\r\ndiv&gt;\n&lt;div&gt;=A0=A0=A0&lt;/div&gt;&lt;div&gt;Hope that ramble helps.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;=\r\ndiv&gt;\nmca&lt;/div&gt;&lt;div&gt;&lt;a href=3D&quot;http://amundsen.com/blog/&quot; target=3D&quot;_blank&quot;&gt;=\r\nhttp://amundsen.com/blog/&lt;/a&gt;&lt;br&gt;&lt;a href=3D&quot;http://twitter.com&quot; target=3D&quot;_=\r\nblank&quot;&gt;http://twitter.com&lt;/a&gt;@mamund&lt;br&gt;&lt;a href=3D&quot;http://mamund.com/foaf.r=\r\ndf#me&quot; target=3D&quot;_blank&quot;&gt;http://mamund.com/foaf.rdf#me&lt;/a&gt;&lt;br&gt;\n\n&lt;br&gt;&lt;br&gt;#RE=\r\nSTFest 2010 &lt;br&gt;&lt;a href=3D&quot;http://rest-fest.googlecode.com&quot; target=3D&quot;_blan=\r\nk&quot;&gt;http://rest-fest.googlecode.com&lt;/a&gt;&lt;br&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;&lt;div class=3D&quot;gmail_=\r\nquote&quot;&gt;On Fri, Dec 3, 2010 at 02:54, Kevin Duffey &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a =\r\nhref=3D&quot;mailto:andjarnic@...&quot; target=3D&quot;_blank&quot;&gt;andjarnic@...&lt;/=\r\na&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; style=3D&quot;margin:0=\r\n 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex&quot;&gt;\n\n\n\n\n\n\n\n\n        \n\n\n=\r\n\n\n&lt;div&gt;\n\n\n\n\n\n&lt;br&gt;&lt;br&gt;\n\n\n\n\n&lt;table cellspacing=3D&quot;0&quot; cellpadding=3D&quot;0&quot; border=\r\n=3D&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=3D&quot;top&quot; style=3D&quot;font:inherit&quot;&gt;I get everythin=\r\ng you are saying..finally thanks to a few of you that set me clear on this =\r\nwhole media-type issue. &lt;br&gt;&lt;br&gt;\n\nI am however having a hard time thinking =\r\nabout telling clients that they basically need to parse html to use my API.=\r\n I much rather say &quot;for /orders, you get this chunk of xml back with t=\r\nhese potential elements.. parse it to get the data you need&quot;. Or in JS=\r\nON. As I use Java/JAX-RS with Jersey, it handles automatically turning my o=\r\nbjects into either xml or json, whatever the Accept header specifies. Anywa=\r\ny, for my own learning, it is good to know what you said, and it does make =\r\nsense. However, it seems odd to me to return things in HTML as opposed to x=\r\nml or json, when it&#39;s just chunks.. that is, a user places 100 orders o=\r\nver 3 months, then comes in and asks to see a history of orders. I return a=\r\nn xml chunk with their 100 orders and related\n info. That seems perfectly f=\r\nine to provide in xml or json, allowing any client to parse the response as=\r\n they see fit. I would obviously have some sort of api doc that would expla=\r\nin the response. &lt;br&gt;&lt;br&gt;I guess what I am grappling with is that for the m=\r\nost part, I would suspect most services like the one I am messing around wi=\r\nth to learn, would be used by specific clients, not anyone and everyone out=\r\n on the web. More so, I don&#39;t see anyone needing to use my particular b=\r\nits of data I return for their own use.. that is, if I were to register a m=\r\nedia type that represents a generic ordering document, that might make sens=\r\ne, but in my case, if I am building up a REST api for my specific little se=\r\nrvice, it doesn&#39;t seem like returning HTML would make any more sense th=\r\nan returning xml or json. I certainly can see if I was building my own web =\r\nsite, where I have some javascript make ajax requests and I return a chunk =\r\nof HTML instead of XML or JSON, so that my own\n site consuming my API can b=\r\nenefit from having HTML directly, rather than xml or json then have to buil=\r\nd up the html on the fly in the browser. But for say a mobile app that had =\r\na native client that allowed a user to log in and pull up their recent orde=\r\nrs, a chunk of XML would fit well. HTML seems more difficult to have to par=\r\nse and deal with.. at least the way I think. Again, if I were going to disp=\r\nlay it in a browser..maybe it&#39;s fine, but if I wanted to do something w=\r\nith the data before displaying it or maybe it&#39;s not a web browser at al=\r\nl, html seems out of place. That&#39;s just my opinion tho from the bits I&=\r\n#39;ve learned the past few days.&lt;div&gt;\n\n&lt;br&gt;&lt;br&gt;&lt;br&gt;--- On &lt;b&gt;Thu, 12/2/10,=\r\n Eric J. Bowman &lt;i&gt;&lt;&lt;a href=3D&quot;mailto:eric@...&quot; target=3D&quot;_=\r\nblank&quot;&gt;eric@...&lt;/a&gt;&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;br&gt;&lt;/div&gt;&lt;blockquote st=\r\nyle=3D&quot;border-left:2px solid rgb(16, 16, 255);margin-left:5px;padding-left:=\r\n5px&quot;&gt;\n\n&lt;div&gt;&lt;br&gt;From: Eric J. Bowman &lt;&lt;a href=3D&quot;mailto:eric@bisonsystem=\r\ns.net&quot; target=3D&quot;_blank&quot;&gt;eric@...&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Subjec=\r\nt: Re: [rest-discuss] Link relations [was: A media type for\n case files, do=\r\nssiers and documents]&lt;br&gt;&lt;/div&gt;&lt;div&gt;To: &quot;Kevin Duffey&quot; &lt;&lt;a hre=\r\nf=3D&quot;mailto:andjarnic@...&quot; target=3D&quot;_blank&quot;&gt;andjarnic@...&lt;/a&gt;&=\r\ngt;&lt;br&gt;&lt;/div&gt;Cc: &quot;Rest Discussion List&quot; &lt;&lt;a href=3D&quot;mailto:res=\r\nt-discuss@yahoogroups.com&quot; target=3D&quot;_blank&quot;&gt;rest-discuss@yahoogroups.com&lt;/=\r\na&gt;&gt;, &lt;a href=3D&quot;mailto:juergen.brendel@...&quot; target=3D&quot;_blank&quot;&gt;j=\r\nuergen.brendel@...&lt;/a&gt;&lt;br&gt;\n\nDate: Thursday, December 2, 2010, 10:3=\r\n2 PM&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;\n\n\n\n\n\n&lt;span&gt;=A0&lt;/span&gt;\n\n\n\n    &lt;div&gt;\n =\r\n     \n      \n      &lt;p&gt;Kevin Duffey wrote:&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Valid point. I=\r\n am not sure what media type would fit then. I am&lt;br&gt;\n&gt; trying to follow=\r\n the HATEOS design, I have an entry point that&lt;br&gt;\n&gt; returns some links =\r\nbased on credentials, from there a client would&lt;br&gt;\n&gt; use those to make =\r\ncalls to any of my resources, and each response&lt;br&gt;\n&gt; would return a rel=\r\nevant chunk of XML or JSON with links for each&lt;br&gt;\n&gt; resource accessible=\r\n at that point (for example GET /orders/id would&lt;br&gt;\n&gt; return a specific=\r\n order along with one or more links that can be used&lt;br&gt;\n&gt; to operate on=\r\n the order). &lt;br&gt;\n&gt;&lt;br&gt;\n&lt;br&gt;\nI&#39;ve never seen an order-processing sys=\r\ntem that couldn&#39;t be modeled as&lt;br&gt;\nHTML.  In fact, I&#39;ve rarely see=\r\nn an order-processing system that wasn&#39;t&lt;br&gt;\nHTML.  In OOP terminology,=\r\n the goal is to distribute not your objects,&lt;br&gt;\nbut your object interfaces=\r\n.  REST says, make those object interfaces&lt;br&gt;\nuniform.  Which means partic=\r\nipants have a network-based shared&lt;br&gt;\nunderstanding of your state transiti=\r\nons (links, forms), IOW, a self-&lt;br&gt;\ndocumenting API.&lt;br&gt;\n&lt;br&gt;\nIt&#39;s per=\r\nfectly acceptable to model your data as JSON or as XML (bearing&lt;br&gt;\nin mind=\r\n that schemas are an orthogonal concern).  The trick is to&lt;br&gt;\ncreate an HT=\r\nML interface for either JSON or XML data, which instructs&lt;br&gt;\nuser-agents h=\r\now to interact with that data.  I&#39;d choose either JSON or&lt;br&gt;\nXML, inst=\r\nead of trying to do both, depending on whether you&#39;re more&lt;br&gt;\ncomforta=\r\nble transforming that data into HTML using Javascript or XSLT.&lt;br&gt;\n&lt;br&gt;\n&gt=\r\n; &lt;br&gt;\n&gt; So if I use application/xml, my API would not be considered tru=\r\nly&lt;br&gt;\n&gt; RESTful? &lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nNo, not if you&#39;re using applic=\r\nation/xml as the hypertext engine driving&lt;br&gt;\napplication state.  If it&#39=\r\n;s just a snippet of XML which gets read by,&lt;br&gt;\nsay, an HTML front-end dri=\r\nving application state, then it&#39;s OK because&lt;br&gt;\nthe processing model (=\r\nparse as XML, handling XInclude/XLink/rdf:about)&lt;br&gt;\nis adequate to the tas=\r\nk.  If that XML snippet contains URIs the user is&lt;br&gt;\nsupposed to click on =\r\nto transition the application to the next steady-&lt;br&gt;\nstate (which aren&#39=\r\n;t XLinks), well, that&#39;s what &lt;a&gt; and atom:link are&lt;br&gt;\nfor, ther=\r\ne&#39;s no corollary in application/xml (besides XLink).&lt;br&gt;\n&lt;br&gt;\nAlso, mos=\r\nt order forms are simply tabular data, the semantics of which&lt;br&gt;\ndon&#39;t=\r\n exist in application/xml like they do in application/xhtml+xml or&lt;br&gt;\ntext=\r\n/html with &lt;table&gt;.  Same with lists, same with forms.&lt;br&gt;\n&lt;br&gt;\n&gt;&lt;=\r\nbr&gt;\n&gt; So now I&#39;ll ask, what media type I could possibly use with my =\r\nown&lt;br&gt;\n&gt; xml/json structure? It almost sounds like you&#39;re saying I =\r\nshouldn&#39;t&lt;br&gt;\n&gt; be returning my own made up structure, that I should=\r\n instead use an&lt;br&gt;\n&gt; existing media type, like one with xhtml or someth=\r\ning. Is there a&lt;br&gt;\n&gt; media type that allows for any sort of specific fo=\r\nrmat to a domain to&lt;br&gt;\n&gt; be returned? Or does that now fall into a case=\r\n where I should create&lt;br&gt;\n&gt; my own media type and register it with IANA=\r\n?&lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nIt falls into a case where you should refactor.  You h=\r\nave tabular data,&lt;br&gt;\nso you need to choose a data type which expresses suc=\r\nh semantics (i.e.&lt;br&gt;\nHTML, or DocBook).  The whole point of media types is=\r\n that they are&lt;br&gt;\n_not_ domain-specific, but rather, represent a shared un=\r\nderstanding of&lt;br&gt;\na processing model at the network (IP) layer.  This is t=\r\nhe fundamental&lt;br&gt;\ntradeoff of the style:&lt;br&gt;\n&lt;br&gt;\n&quot;[A] uniform interf=\r\nace degrades efficiency, since information is&lt;br&gt;\ntransferred in a standard=\r\nized form rather than one which is specific to&lt;br&gt;\nan application&#39;s nee=\r\nds.&quot;&lt;br&gt;\n&lt;br&gt;\nAn order consists of item numbers, descriptions, quantit=\r\ny, unit price&lt;br&gt;\nand total price.  You *could* re-invent the &lt;table&gt;=\r\n wheel and register&lt;br&gt;\nit as a new media type, but it&#39;s more scalable =\r\n(maintainable, portable)&lt;br&gt;\nto re-use HTML even if it isn&#39;t a precise =\r\nfit.  If you create a new&lt;br&gt;\nmedia type, then you need to distribute a cus=\r\ntom user-agent.  When you&lt;br&gt;\nupgrade your API, you must simultaneously upd=\r\nate that user-agent.&lt;br&gt;\n&lt;br&gt;\nThe success of the Web is due to the common u=\r\nser-agent.  What I really&lt;br&gt;\ndon&#39;t want, is for any system I interact =\r\nwith to require me to install&lt;br&gt;\nyet another piece of software, and keep i=\r\nt up-to-date.  That&#39;s coupling.&lt;br&gt;\nSo much easier for everyone concern=\r\ned, to target the browser.  That way,&lt;br&gt;\nI only need to install and mainta=\r\nin one user-agent regardless of how&lt;br&gt;\nmany different systems I interact w=\r\nith.  Such decoupling allows clients&lt;br&gt;\nand servers to evolve independentl=\r\ny.  So there is a cost associated&lt;br&gt;\nwith the minting of new media types -=\r\n- coupling -- unless and until the&lt;br&gt;\nnew media type achieves significant =\r\nuptake.&lt;br&gt;\n&lt;br&gt;\n-Eric&lt;br&gt;\n&lt;/p&gt;\n\n    &lt;/div&gt;\n     \n\n\n\n \n\n\n&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;=\r\n&lt;/blockquote&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;\n\n\n\n\n\n\n\n      \n\n\n\n\n\n&lt;br&gt;\n\n    \n =\r\n   \n&lt;br&gt;\n\n\n\n\n&lt;div width=3D&quot;1&quot; style=3D&quot;color:white;clear:both&quot;&gt;&lt;/div&gt;\n\n\n\n&lt;/=\r\nblockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;\n\r\n--20cf30433e3259c72a04967eb9f7--\r\n\n"}}