{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":198693287,"authorName":"Bill Venners","from":"Bill Venners &lt;bv-svp@...&gt;","profile":"billvenners","replyTo":"SENDER","senderId":"3-DRqaz6OXmQn73AGf0i1Tr7c5jLb70UV6p0htLb-2qNiYem3gJFT6ZD6_LprUIqomtzNWNH8GU9U90eEFORngrYyBSRvjE","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Avoiding re-POSTs","postDate":"1144966955","msgId":5925,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDU5RURFQzhCLUMzQzItNDFBNi05MEFBLUJCQkU3RTJDOUJGMUBhcnRpbWEuY29tPg==","inReplyToHeader":"PDQ0M0VDNDBCLjkwOTAzMDNAdmVpY29uLmNvbT4=","referencesHeader":"PDQ0M0VDNDBCLjkwOTAzMDNAdmVpY29uLmNvbT4="},"prevInTopic":5923,"nextInTopic":5927,"prevInTime":5924,"nextInTime":5926,"topicId":5923,"numMessagesInTopic":16,"msgSnippet":"Hi Lyle, ... That s a great question. I have pondered the double-post issue, and one thing I did recently was look it up in the Core J2EE patterns book, where","rawEmail":"Return-Path: &lt;bv-svp@...&gt;\r\nX-Sender: bv-svp@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 28997 invoked from network); 13 Apr 2006 22:22:38 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m11.grp.scd.yahoo.com with QMQP; 13 Apr 2006 22:22:38 -0000\r\nReceived: from unknown (HELO svcstsnq08.hotspot.t-mobile.com) (66.94.9.112)\n  by mta4.grp.scd.yahoo.com with SMTP; 13 Apr 2006 22:22:38 -0000\r\nReceived: from [10.253.213.162] (162.213.253.10.in-addr.arpa [10.253.213.162])\n\tby svcstsnq08.hotspot.t-mobile.com (8.12.10+Sun/8.12.10) with ESMTP id k3DMLwoK025142;\n\tThu, 13 Apr 2006 15:21:59 -0700 (PDT)\r\nIn-Reply-To: &lt;443EC40B.9090303@...&gt;\r\nReferences: &lt;443EC40B.9090303@...&gt;\r\nMime-Version: 1.0 (Apple Message framework v746.3)\r\nContent-Type: text/plain; charset=US-ASCII; delsp=yes; format=flowed\r\nMessage-Id: &lt;59EDEC8B-C3C2-41A6-90AA-BBBE7E2C9BF1@...&gt;\r\nCc: REST Discuss &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Transfer-Encoding: 7bit\r\nDate: Thu, 13 Apr 2006 15:22:35 -0700\r\nTo: Lyle Kopnicky &lt;lyle@...&gt;\r\nX-Mailer: Apple Mail (2.746.3)\r\nX-Proofpoint-Spam-Details: rule=notspam policy=default score=0 mlx=0 adultscore=0 adjust=0 reason=mlx engine=3.1.0-06041100 definitions=3.0.0-06041315\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: Bill Venners &lt;bv-svp@...&gt;\r\nSubject: Re: [rest-discuss] Avoiding re-POSTs\r\nX-Yahoo-Group-Post: member; u=198693287; y=jx8n-FOVTSSAcjuJXHVbOkA9Y4Nb_uSWx6lvpFM_160fGAt82Tw\r\nX-Yahoo-Profile: billvenners\r\n\r\nHi Lyle,\n\n&gt; That sounds great, but it seems to clash with REST.  What was before a\n&gt; transitory response to a POST request now becomes a separate resource\n&gt; available via GET.  Will it be cached?  How long must it stay  \n&gt; available?\n&gt;\n&gt; My question is, what is the REST way to address the problem?\n&gt;\nThat&#39;s a great question. I have pondered the double-post issue, and  \none thing I did recently was look it up in the Core J2EE patterns  \nbook, where I remembered seeing a pattern mentioned. They suggest  \nusing what they call a &quot;deja vu token,&quot; which is a number you keep in  \nthe user session and add to each form as a hidden field as it goes  \nout the door via GET. Each time you receive a POST for that URI, you  \nincrement the number. So you can recognize in this way that a POST is  \nnot fresh, so long as the second POST makes its way to the same  \nserver, or so long as the user session is replicated. This is an  \nunRESTful approach because it relies on the user session.\n\nI do believe in doing redirect to GET after POST, for the usability  \nissue you described, and yet in this too most people currently use  \nthe session to store the state. Ruby on Rails, for example, has  \nsomething called a &quot;flash,&quot; which is session state that gets  \nautomatically cleared on the next request. If you post a form and  \nvalidation on the server finds an error, it sticks the state in the  \nflash and sends a redirect to the same URI. When that redirect GET  \nrequest comes in, the flash is checked and the state is used to fill  \nin the form with what you had entered plus an error message. This is  \nalso unRESTful, per my understanding of REST, because the validation  \nerror state is not represented via a unique URI.\n\nWhat we&#39;ve been considering doing in Artima&#39;s new architecture is  \nusing something we&#39;ve taken to calling diamonds. Whereas a flash only  \nlasts for one request, diamonds are forever. What I&#39;m imagining doing  \nis sticking the state in a write-behind cache, including information  \non which user the data is for. I&#39;ll get back an diamond identifier,  \nwhich I&#39;ll include in the redirect URI as an opaque token. So if the  \nPOST is to:\n\nhttp://lejava.artima.com/account/new\n\nThe GET redirect might be to something like (where z is the opaque  \ntoken that identifies the diamond):\n\nhttp://lejava.artima.com/account/new?z=42d152x2d5qd\n\nOnly the user who did the POST will be able to access that URI,  \nbecause the diamond includes the user as part of its data, and we&#39;ll  \ndo an auth check. If they have to POST a few times in a row to  \ncorrect all the errors, then back up, they&#39;ll actually see the  \ncorrect state for each step of their interaction with the form,  \nbecause each step in the conversation has its own URI.\n\nI am thinking of using a write-behind cache to store the diamond (a  \nwrite-behind cache is one that asynchronously persists itself to a  \nbacking store), because I would prefer to have the fault tolerance in  \ngeneral. If a server crashes, 99.99...% of the time I&#39;d like the user  \nto be able to continue. I expect most experienced J2EE folks would  \ntell me it is dumb to put conversational state (which is what these  \ndiamonds are) in the database. But if you want to distribute that  \nstate across a cluster, and 99.99% of the time the information will  \nonly ever be needed on one server, I think sticking the  \nconversational state asynchronously in *a* database is a reasonable  \nway to try and distribute it. The other way is to make the diamond  \ncache itself distributed. That might be OK, except you run into a  \nscaling issue of how much memory will the diamonds be occupying. In  \nthe database approach, if a server crashes after a redirect to GET,  \nthe load balancer could send that GET to a different server, and on  \ndiscovering that diamond is not in its local cache, could go to the  \ndiamond database to find it, and 99.99...% of the time it will be there.\n\nAs far as how long to keep the state, that I think depends on the  \napplication. Regardless of where you keep the state, if you select it  \nvia a unique URI rather than pulling it out of a user session, I  \nthink you&#39;re being RESTful. You could store along with the diamond an  \nexpiration time, and have a reaper come through and expire it. So  \nsome of the diamonds could actually be glass, which won&#39;t last  \nforever. I believe it isn&#39;t unRESTful that resources go away after a  \nwhile.\n\nLastly, two more RESTful ways I&#39;ve considered for recognizing a  \ndouble-POST is 1) associating a deja vu token with the resource being  \nupdate rather than the user session and 2) analyzing the contents of  \nthe post for duplication with a previous one. For example, if you are  \nposting a message to a discussion forum topic, the updated resource  \nis the topic. If you include a unique deja vu token in a hidden field  \nof each form, and then store that token in the database alongside the  \nmessage, you can recognize duplicate posts by looking up the token  \nthat came in with the current post in the database. If it is there,  \nthen that post came in before. The trouble with this approach is that  \nthe user may have backed up, then changed the form and posted again.  \nThat&#39;s not really a duplicate post. So the other way I&#39;ve considered  \ndoing it is simply searching the updated item for the contents of the  \npost. Most likely, the same user would not want to post the exact  \nsame message to a forum topic twice.\n\nWe really do have this double post problem in forums occasionally  \ncurrently on Artima, and I don&#39;t presently have a solution, just  \nthese untested ideas. Like Lyle, I welcome suggestions on other ways  \nto deal with duplicate posts.\n\nThanks.\n\nBill\n----\nBill Venners\nEditor-in-Chief\nArtima Developer\nhttp://www.artima.com\n\n\n"}}