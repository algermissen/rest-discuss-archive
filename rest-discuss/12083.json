{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":383005568,"authorName":"scameron02","from":"&quot;scameron02&quot; &lt;scott.cameron@...&gt;","profile":"scameron02","replyTo":"SENDER","senderId":"FLlF_XE8U58SOfKlh9GoyZBLffEwwXAQcb_f3-OPAxrPEjtYopKb-fkecUnrhmv_hzNOArzM8ogr9f2J_8HD4Xg0LX_BxFqMDxII","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: RESTful URLs?","postDate":"1233784416","msgId":12083,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGdtZDJwMCtzdGVkQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDIwMDkwMjAzMjIzNDQzLkdBNzE2NkBrbGFuZ3JhdW0ucGxhc21hc3R1cm0ub3JnPg=="},"prevInTopic":12082,"nextInTopic":12084,"prevInTime":12082,"nextInTime":12084,"topicId":12048,"numMessagesInTopic":54,"msgSnippet":"... This is where I get a little bit stuck when I think about the hypermedia constraint of REST.  At some point it seems that a transition needs to be made","rawEmail":"Return-Path: &lt;scott.cameron@...&gt;\r\nX-Sender: scott.cameron@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 25046 invoked from network); 4 Feb 2009 21:53:38 -0000\r\nX-Received: from unknown (66.218.67.95)\n  by m48.grp.scd.yahoo.com with QMQP; 4 Feb 2009 21:53:38 -0000\r\nX-Received: from unknown (HELO n13d.bullet.sp1.yahoo.com) (69.147.64.236)\n  by mta16.grp.scd.yahoo.com with SMTP; 4 Feb 2009 21:53:38 -0000\r\nX-Received: from [69.147.65.148] by n13.bullet.sp1.yahoo.com with NNFMP; 04 Feb 2009 21:53:38 -0000\r\nX-Received: from [66.218.66.77] by t11.bullet.mail.sp1.yahoo.com with NNFMP; 04 Feb 2009 21:53:38 -0000\r\nDate: Wed, 04 Feb 2009 21:53:36 -0000\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-ID: &lt;gmd2p0+sted@...&gt;\r\nIn-Reply-To: &lt;20090203223443.GA7166@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative; boundary=&quot;3-1316160060-6265203529=:1&quot;\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;scameron02&quot; &lt;scott.cameron@...&gt;\r\nSubject: Re: RESTful URLs?\r\nX-Yahoo-Group-Post: member; u=383005568; y=tMDpL0jfO1GekAySTGY5swHok9bMbruI2KLhkzkPJllQzQjPGw\r\nX-Yahoo-Profile: scameron02\r\n\r\n\r\n--3-1316160060-6265203529=:1\r\nContent-Type: text/plain; charset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n\n--- In rest-discuss@yahoogroups.com, Aristotle Pagaltzis &lt;pagaltzis@...&gt;\nw=\r\nrote:\n&gt;\n&gt; &gt; It seems to me that in cases like this this there will have to\n=\r\n&gt; &gt; be a deterministic, programmatic method of producing URIs based\n&gt; &gt; on =\r\nsome kind of template or documentation or something else.\n&gt;\n&gt; Exactly. But =\r\nthe template must be provided by the server in\n&gt; hypermedia, not hardwired =\r\ninto the client on a per-app basis.\n&gt;\n\nThis is where I get a little bit stu=\r\nck when I think about the hypermedia\nconstraint of REST.  At some point it =\r\nseems that a transition needs to\nbe made between the world of machine-disco=\r\nvered application interaction\nand the world of human-discovered application=\r\n interaction.  At some\nlevel there will be an agreement made between the se=\r\nrver application\nwriters and the client application writers that tells the =\r\nclient guys\nwhat they need to hardcode into their apps.  That is, which asp=\r\nects of\nthe interface are guaranteed to never change.\n\nOne option for doing=\r\n this is a documented URI schema.  In REST, this is\nconsidered bad because =\r\nclients should be interacting with hypermedia,\nnot constructing URIs based =\r\non promises from the server.\n\nThe other option (the one prescribed by REST)=\r\n is hypermedia.  OK, so you\nreturn a set of hyperlinks or some kind of form=\r\n to the client.  The use\nof well-known hyperlink tags and standard form voc=\r\nabularies provides a\nhigher level of machine-discoverable semantics.  For e=\r\nxample, my app\nknows it=E2=80=99s safe to do a GET on a hyperlink.  And it =\r\nknows that,\nsay, the form is asking for an input selection of one of the fo=\r\nllowing 3\nchoices.  But what does this really mean?  How does my applicatio=\r\nn\ndistinguish between one hyperlink and another hyperlink?  The one tagged\n=\r\n=E2=80=9Cparents=E2=80=9D probably returns the current resource=E2=80=99s\np=\r\narent resources and the one tagged =E2=80=9Cchildren=E2=80=9D returns its\nc=\r\nhildren.  But aren=E2=80=99t we back to hardcoding knowledge into the\nappli=\r\ncation about what =E2=80=9Cparents=E2=80=9D and\n=E2=80=9Cchildren=E2=80=9D =\r\nactually mean?  If the server  ever changes\nthis meaning, my application br=\r\neaks.  The same goes for content (as\nopposed to the structure) of the forms=\r\n.\n\nI think that the answer comes down to well-known representation formats.=\r\n\nThe semantics hardcoded into client application should be based on\nmetadat=\r\na that is not determined by the server but rather by an agreed\nupon, standa=\r\nrdized format that is guaranteed to never change.  As long\nas the server im=\r\nplements the format correctly, everybody is\nautomatically in agreement.  Bu=\r\nt =E2=80&quot; taking forms as a specific\nexample --  there still seems to be mi=\r\nssing information.  The form\nstructure may be standardized, but the semanti=\r\ncs associated with the\ncontent of a specific form instance will be speciali=\r\nzed for each\napplication.  Aren=E2=80=99t we back, then, to hard-coding sem=\r\nantics into\nthe client based on documentation from the server?\n\nIn this cas=\r\ne, how much difference is there between documenting the\nsemantics of a tran=\r\nsparent URI schema or documenting the semantics of a\nspecific form instance=\r\n (assuming the form is used to drive a program).\n\nI=E2=80=99m not trying to=\r\n be argumentative here... the hypermedia\nconstraint of REST is something th=\r\nat I=E2=80=99m finding the most\ndifficult of all the core principles to und=\r\nerstand in practical terms. \nI=E2=80=99m very interested in your take on th=\r\nis topic.\n\nThanks,\nscott\n\n\r\n--3-1316160060-6265203529=:1\r\nContent-Type: text/html; charset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;font face=3D&quot;georgia&quot;&gt;&lt;br&gt;--- In rest-discuss@yahoogroups.com, Aristotle P=\r\nagaltzis &lt;pagaltzis@...&gt; wrote:&lt;br&gt;&gt; &lt;br&gt;&gt; &gt; It seems to me =\r\nthat in cases like this this there will have to&lt;br&gt;&gt; &gt; be a determini=\r\nstic, programmatic method of producing URIs based&lt;br&gt;&gt; &gt; on some kind=\r\n of template or documentation or something else.&lt;br&gt;&gt; &lt;br&gt;&gt; Exactly. =\r\nBut the template must be provided by the server in&lt;br&gt;&gt; hypermedia, not =\r\nhardwired into the client on a per-app basis.&lt;br&gt;&gt; &lt;br&gt;&lt;br&gt;This is where=\r\n I get a little bit stuck when I think about the hypermedia constraint of R=\r\nEST.&nbsp; At some point it seems that a transition needs to be made betwee=\r\nn the world of machine-discovered application interaction and the world of =\r\nhuman-discovered application interaction.&nbsp; At some level there will be=\r\n an agreement made between the server application writers and the client ap=\r\nplication writers that tells the client guys what they need to hardcode int=\r\no their apps.&nbsp; That is, which aspects of the interface are guaranteed =\r\nto never change.&lt;br&gt;&lt;br&gt;One option for doing this is a documented URI schem=\r\na.&nbsp; In REST, this is considered bad because clients should be interact=\r\ning with hypermedia, not constructing URIs based on promises from the serve=\r\nr.&lt;br&gt;&lt;br&gt;The other option (the one prescribed by REST) is hypermedia.&nbsp=\r\n; OK, so you return a set of hyperlinks or some kind of form to the client.=\r\n&nbsp; The use of well-known hyperlink tags and standard form vocabularies =\r\nprovides a higher level of machine-discoverable semantics.&nbsp; For exampl=\r\ne, my app knows it=E2=80=99s safe to do a GET on a hyperlink.&nbsp; And it =\r\nknows that, say, the form is asking for an input selection of one of the fo=\r\nllowing 3 choices.&nbsp; But what does this really mean?&nbsp; How does my =\r\napplication distinguish between one hyperlink and another hyperlink?&nbsp; =\r\nThe one tagged =E2=80=9Cparents=E2=80=9D probably returns the current resou=\r\nrce=E2=80=99s parent resources and the one tagged =E2=80=9Cchildren=E2=80=\r\n=9D returns its children.&nbsp; But aren=E2=80=99t we back to hardcoding kn=\r\nowledge into the application about what =E2=80=9Cparents=E2=80=9D and =E2=\r\n=80=9Cchildren=E2=80=9D actually mean?&nbsp; If the server&nbsp; ever chang=\r\nes this meaning, my application breaks.&nbsp; The same goes for content (as=\r\n opposed to the structure) of the forms.&lt;br&gt;&lt;br&gt;I think that the answer com=\r\nes down to well-known representation formats.&nbsp; The semantics hardcoded=\r\n into client application should be based on metadata that is not determined=\r\n by the server but rather by an agreed upon, standardized format that is gu=\r\naranteed to never change.&nbsp; As long as the server implements the format=\r\n correctly, everybody is automatically in agreement.&nbsp; But =E2=80&quot; taki=\r\nng forms as a specific example --&nbsp; there still seems to be missing inf=\r\normation.&nbsp; The form structure may be standardized, but the semantics a=\r\nssociated with the content of a specific form instance will be specialized =\r\nfor each application.&nbsp; Aren=E2=80=99t we back, then, to hard-coding se=\r\nmantics into the client based on documentation from the server?&lt;br&gt;&lt;br&gt;In t=\r\nhis case, how much difference is there between documenting the semantics of=\r\n a transparent URI schema or documenting the semantics of a specific form i=\r\nnstance (assuming the form is used to drive a program).&lt;br&gt;&lt;br&gt;I=E2=80=99m =\r\nnot trying to be argumentative here... the hypermedia constraint of REST is=\r\n something that I=E2=80=99m finding the most difficult of all the core prin=\r\nciples to understand in practical terms.&nbsp; I=E2=80=99m very interested =\r\nin your take on this topic.&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;scott&lt;br&gt;&lt;/font&gt;\n\r\n--3-1316160060-6265203529=:1--\r\n\n"}}