{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":175757792,"authorName":"Roy T. Fielding","from":"&quot;Roy T. Fielding&quot; &lt;fielding@...&gt;","profile":"roy_fielding","replyTo":"SENDER","senderId":"rCxXYWsAyLCzt3NFId_4DuuLHiy9spYND_H6oVG8y1gCocC2OV0ZWbZXyuVlc4xbplznHFEBpkXdvze5RCG4953IiqmMp74DjkYAsw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Dynamic Evolvability","postDate":"1165309654","msgId":7197,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDEzNzgzMTlCLTBDMDEtNENBMS1CQjgyLTE5NEM1MjYzOUVEQUBnYml2LmNvbT4=","inReplyToHeader":"PDAyNjgwMWM3MTgyZiQyNzcxZDZkMCQ2NjAxYThjMEBhbWVyLmJlYS5jb20+","referencesHeader":"PDAyNjgwMWM3MTgyZiQyNzcxZDZkMCQ2NjAxYThjMEBhbWVyLmJlYS5jb20+"},"prevInTopic":7196,"nextInTopic":7200,"prevInTime":7196,"nextInTime":7198,"topicId":7194,"numMessagesInTopic":6,"msgSnippet":"... Er, sometimes they do, yes, and other times they are just a checkbox on a marketing pamphlet.  I have yet to see an instance of one vendor s server be","rawEmail":"Return-Path: &lt;fielding@...&gt;\r\nX-Sender: fielding@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 43011 invoked from network); 5 Dec 2006 09:07:43 -0000\r\nReceived: from unknown (66.218.67.33)\n  by m36.grp.scd.yahoo.com with QMQP; 5 Dec 2006 09:07:43 -0000\r\nReceived: from unknown (HELO fed1rmmtao06.cox.net) (68.230.241.33)\n  by mta7.grp.scd.yahoo.com with SMTP; 5 Dec 2006 09:07:43 -0000\r\nReceived: from fed1rmimpo01.cox.net ([70.169.32.71])\n          by fed1rmmtao06.cox.net\n          (InterMail vM.6.01.06.03 201-2131-130-104-20060516) with ESMTP\n          id &lt;20061205090738.NHEA5465.fed1rmmtao06.cox.net@...&gt;;\n          Tue, 5 Dec 2006 04:07:38 -0500\r\nReceived: from [192.168.0.133] ([70.187.176.185])\n\tby fed1rmimpo01.cox.net with bizsmtp\n\tid ux731V00640NznJ0000000; Tue, 05 Dec 2006 04:07:03 -0500\r\nIn-Reply-To: &lt;026801c7182f$2771d6d0$6601a8c0@...&gt;\r\nReferences: &lt;026801c7182f$2771d6d0$6601a8c0@...&gt;\r\nMime-Version: 1.0 (Apple Message framework v752.2)\r\nContent-Type: text/plain; charset=US-ASCII; delsp=yes; format=flowed\r\nMessage-Id: &lt;1378319B-0C01-4CA1-BB82-194C52639EDA@...&gt;\r\nCc: &quot;&#39;Jan Algermissen&#39;&quot; &lt;algermissen1971@...&gt;,\n  &lt;rest-discuss@yahoogroups.com&gt;\r\nContent-Transfer-Encoding: 7bit\r\nDate: Tue, 5 Dec 2006 01:07:34 -0800\r\nTo: &lt;orchard@...&gt;\r\nX-Mailer: Apple Mail (2.752.2)\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: &quot;Roy T. Fielding&quot; &lt;fielding@...&gt;\r\nSubject: Re: [rest-discuss] Dynamic Evolvability\r\nX-Yahoo-Group-Post: member; u=175757792; y=7EumcgKhWmqHzS91_4FTrxHk8SFfXtzJY2ic2kxEs2XIpn_ScOZ0\r\nX-Yahoo-Profile: roy_fielding\r\n\r\nOn Dec 4, 2006, at 9:35 PM, Dave Orchard wrote:\n\n&gt; Roy asks about a stateful server evolving when the new server has  \n&gt; no idea\n&gt; what stage the client is at.  This is a great question, but most  \n&gt; stateful\n&gt; servers today do the right thing.  They provide for the old version  \n&gt; and the\n&gt; new version, with a mapping between them.  Thus stateful server  \n&gt; evolution is\n&gt; fine if the server has been built for evolution, and most of the  \n&gt; &quot;real&quot;\n&gt; systems do.   Heck, we do side-by-side deployment too with a ton of\n&gt; variables to control how to direct.\n\nEr, sometimes they do, yes, and other times they are just a checkbox\non a marketing pamphlet.  I have yet to see an instance of one\nvendor&#39;s server be replaced with a different vendor&#39;s server and\nnot have the whole house of cards collapse.  That is, except on\nthe Web, which handles that change without any problem whatsoever\nif the identifiers do not change.\n\nIn any case, the kind of evolution you are talking about there is\nvery restricted and well planned.  The statefulness, for example, has\nto be limited to session tickets or pointers to back-end systems\nthat remain available during the process, and a bunch of money has\nto be thrown at the system to make even that possible.\n\nThe kind of evolution I was talking about includes both small-scale\nplanned evolution on the server and the wild whack-a-mole style of\nevolution that happens when one company absorbs another or an entire\nservice shifts from a centralized architecture to edge-based Akamai.\n\nThe important thing is not just that stateful-client architecture\nis evolvable, but that it is evolvable for free.  We can indeed\ndeploy an evolvable stateful system, but only if it is planned and\nbudgeted as such by the likes of Bill Gates.  A poor snot-nose\ngrad student doesn&#39;t have that option, so in order for the vast\nmultitude of services to be evolvable the solution has to be cheap\nand on by default.  That is what we hope for when we architect the\nsystem for independent evolvability across multiple organizations.\n\n&gt; Properly built stateful servers are often higher user-perceived  \n&gt; performance\n&gt; in versioning when the server side state is migrated to a new  \n&gt; version in\n&gt; between client requests, rather than at run-time as the client  \n&gt; request with\n&gt; the old state comes in.\n&gt;\n&gt; The question can be turned around a bit, and consider what happens  \n&gt; when a\n&gt; stateful client is replaced in the middle of a conversation with a  \n&gt; server by\n&gt; a new client which is just like the old one but has no idea what  \n&gt; state the\n&gt; server is within its application.\n\nA better example is a user operating on the same server with two  \ndifferent\nclients (e.g., desktop and blackberry) and expecting the state on both\nto remain synchronized.  That is much easier to implement with a  \nstateful\nserver and that may be the more appropriate architecture to choose after\nconsidering all of the other requirements.  Yep, there are lots of  \ntradeoffs.\nLikewise, real-time monitoring systems are usually better architected\nas a distributed object or event-based system, with only the management\nconsole projecting a simpler interface.\n\n&gt; I think the question of location of client vs server state and\n&gt; versioning/evolvability is a very complicated decision, and some of  \n&gt; the\n&gt; factors include how much the client is &quot;trusted&quot;, how much\n&gt; time/processing/resource usage is on the client vs the server, the  \n&gt; data set\n&gt; between the two, etc.\n\nAnd let&#39;s not forget the question of how much money you are willing\nto spend on server complexity to make up for the other trade-offs.\n\n&gt; The Web works in many ways because the time on the\n&gt; client is long compared to on the server (sub x second response  \n&gt; time for\n&gt; those humans), the client can go away at any time (ie not trusted  \n&gt; to do\n&gt; garbage collection properly), and the data sets are small  \n&gt; (typically you\n&gt; just need to handle the amount of data that the client has entered to\n&gt; reconstruct the state).  The more you change those (and other)  \n&gt; factors, the\n&gt; more you lean towards server-side state.  There&#39;s trade-offs in  \n&gt; network\n&gt; performance, user-perceived performance, and other network and  \n&gt; application\n&gt; properties that get adjusted.  There&#39;s just no way that large data  \n&gt; sets on\n&gt; the server communicating a small data set to well behaved (from a gcol\n&gt; perspective) clients where the server does most of the computing  \n&gt; are going\n&gt; to be made client-side stateful.\n\nYeah, that&#39;s why stored procedures exist, and also why one thing a\nresource can be is (effectively) a stored procedure.  But it&#39;s also\ninteresting to consider other architectures that have more flexibility,\nsuch as mobile code.\n\nIt is core to the Web design principles that the clients cannot be\ntrusted, but that certainly isn&#39;t true of every system.  Most times.\nPostscript printing, for example, is an excellent case study in the\nuse of mostly-safe mobile code to enable independent evolution of\nprinting applications from printer hardware.\n\n&gt; To paraphrase somebody, you&#39;ve got to do the analysis for yourself and\n&gt; figure out which architectural style makes sense given your  \n&gt; applications\n&gt; requirements.\n\nYep, that&#39;s the key.  And there is usually more than one valid\narchitecture for any given application, with both positive and\nnegative trade-offs in the short term and long.  In the end, though,\nsimplicity usually works better.\n\n....Roy\n\n\n"}}