{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":40455398,"authorName":"Julian Reschke","from":"Julian Reschke &lt;julian.reschke@...&gt;","profile":"JulianReschke","replyTo":"SENDER","senderId":"hXJygCxpO9WgNk9SxYtIfT1YfKVFwF7QuFsostPyg-yfoj2nfDscBZQhCzMTQZUooHX0DVG1jYUfvVt8QLxt9zq3OfedaGQFKrubQE8","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: Fun with DELETE","postDate":"1184312780","msgId":9466,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ2OTcyRENDLjgwNzAwMDZAZ214LmRlPg==","inReplyToHeader":"PFc3ODM3MjE5NzgxMjg0NjcxMTg0MjgyMTcyQG1haWwubWFpbHNuYXJlLm5ldD4=","referencesHeader":"PFc3ODM3MjE5NzgxMjg0NjcxMTg0MjgyMTcyQG1haWwubWFpbHNuYXJlLm5ldD4="},"prevInTopic":9463,"nextInTopic":9471,"prevInTime":9465,"nextInTime":9467,"topicId":8604,"numMessagesInTopic":107,"msgSnippet":"... It just doesn t make sense to accept a DELETE, and subsequently return 404 or 410, and to still claim that there is an representation (with that etag)","rawEmail":"Return-Path: &lt;julian.reschke@...&gt;\r\nX-Sender: julian.reschke@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 47094 invoked from network); 13 Jul 2007 07:46:36 -0000\r\nReceived: from unknown (66.218.66.70)\n  by m57.grp.scd.yahoo.com with QMQP; 13 Jul 2007 07:46:36 -0000\r\nReceived: from unknown (HELO mail.gmx.net) (213.165.64.20)\n  by mta12.grp.scd.yahoo.com with SMTP; 13 Jul 2007 07:46:35 -0000\r\nReceived: (qmail invoked by alias); 13 Jul 2007 07:46:21 -0000\r\nReceived: from p508F84C5.dip0.t-ipconnect.de (EHLO [192.168.178.22]) [80.143.132.197]\n  by mail.gmx.net (mp047) with SMTP; 13 Jul 2007 09:46:21 +0200\r\nX-Authenticated: #1915285\r\nX-Provags-ID: V01U2FsdGVkX1+jlhx+0BWjck59+zTVFsVHfy98N/BK9KA+3GLhK4\n\t99vPbmDeno3aTo\r\nMessage-ID: &lt;46972DCC.8070006@...&gt;\r\nDate: Fri, 13 Jul 2007 09:46:20 +0200\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.0.4) Gecko/20060516 Thunderbird/1.5.0.4 Mnenhy/0.7.4.666\r\nMIME-Version: 1.0\r\nTo: eric@...\r\nCc: rest-discuss@yahoogroups.com\r\nReferences: &lt;W7837219781284671184282172@...&gt;\r\nIn-Reply-To: &lt;W7837219781284671184282172@...&gt;\r\nContent-Type: text/plain; charset=UTF-8; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Y-GMX-Trusted: 0\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Julian Reschke &lt;julian.reschke@...&gt;\r\nSubject: Re: [rest-discuss] Re: Fun with DELETE\r\nX-Yahoo-Group-Post: member; u=40455398; y=pcM_iY-gsVY1VBL2kTngc1BNJZqzFUouw8qoaOIz5y1jr5qNdqOUSw\r\nX-Yahoo-Profile: JulianReschke\r\n\r\nEric J. Bowman wrote:\n&gt; ...\n&gt; So I still do not see where any restriction exists, which says that if I\n&gt; request a resource that&#39;s nonexistent the 410 response can&#39;t have an ETag,\n&gt; or how that ETag does not pertain to the requested variant -- or how\n&gt; doing so causes any problems for any clients or intermediaries.\n&gt; ...\n\nIt just doesn&#39;t make sense to accept a DELETE, and subsequently return \n404 or 410, and to still claim that there is an representation (with \nthat etag) mapped to that URI. The point of a DELETE is to remove that \nmapping, and the point of 404/410 is so that the server can signal that \nthere are no representations left mapped to that URI.\n\n&gt; The purpose of the spec is to allow interoperability. If my\n&gt; implementation does not cause interoperability problems then I don&#39;t see\n&gt; where the spec has been violated, or needs to be changed to disallow\n&gt; what I have implemented.\n\nThe same can be said about SOAP (I guess), so would you defend SOAP as well?\n\n&gt;  &gt;&gt; RFC 2616 doesn&#39;t specifically state that ETags may be used on 4xx\n&gt;  &gt;&gt; responses, then doing so goes against spec? Well, I disagree.\n&gt;  &gt;\n&gt;  &gt;They don&#39;t make sense upon 404/410 because of their definition.\n&gt;  &gt;\n&gt; \n&gt; They don&#39;t make sense *to you* because of their definition, but it\n&gt; makes sense *to me* as I see nothing in those definitions which\n&gt; precludes doing what I am doing.\n\n&lt;http://greenbytes.de/tech/webdav/rfc2616.html#rfc.section.10.4.5&gt;:\n\n&quot;10.4.5 404 Not Found\n\nThe server has not found anything matching the Request-URI....&quot;\n\nIt seems that you say that:\n\n- there&#39;s nothing here,\n\n- but it has a representation,\n\n- but if you ask for it, I&#39;ll not send it to you.\n\nSorry, doesn&#39;t compute.\n\n&gt;  &gt;&gt; I&#39;m using HTTP machinery in a way nobody has tried before, this is not\n&gt;  &gt;&gt; the same thing as &quot;inventing a new protocol&quot; nor is it &quot;against&quot; RFC\n&gt;  &gt;&gt; 2616. If it were a &quot;bad thing&quot; to send an ETag with a 410 response\n&gt;  &gt;&gt; then the spec would say so. If the spec had to specifically account\n&gt;  &gt;\n&gt;  &gt;No, that&#39;s not how specs are written. But maybe now we&#39;ll have to put it\n&gt;  &gt;into RFC2616bis :-)\n&gt;  &gt;\n&gt; \n&gt; OK, but only if you can justify why this restriction is needed despite\n&gt; the fact that no interoperability problems result if it is not met.\n\nI do not believe there&#39;ll be no interop problem. But besides that, the \nsame could be said about a protocol that tunnels everything through \nPOST, right?\n\n&gt;  &gt;Returning it with a 404/410 does not make sense, and that&#39;s why the spec\n&gt;  &gt;doesn&#39;t *need* to say it.\n&gt;  &gt;\n&gt; \n&gt; Or, from my point of view, the spec doesn&#39;t preclude this because it\n&gt; doesn&#39;t make any sense to impose such a restriction, which is why the\n&gt; spec doesn&#39;t *need* to say it.\n\nOK, go on ignoring the definitions on 404 and 410.\n\n&gt;  &gt;It wouldn&#39;t. But a generic client never ever will send a DELETE request\n&gt;  &gt;to something it already successfully deleted.\n&gt;  &gt;\n&gt; \n&gt; Well, curl is a pretty generic client, and it has no problem with\n&gt; sending a DELETE request anywhere. If this restriction existed, wouldn&#39;t\n&gt; the client first have to do a HEAD request to make sure the resource\n&gt; wasn&#39;t already deleted, before sending a DELETE? Funny, I don&#39;t see\n&gt; that in the spec...\n\nOh well. That&#39;s when you invoke curl *twice*, and the second \ninstantiation has no knowledge about what happened before.\n\nThings may look entirely different if you&#39;re using a HTTP stack that \ndoes have such a kind of memory.\n\n&gt; Try it for yourself. Set up a 410 response, then DELETE it using curl\n&gt; or any other HTTP client capable of a DELETE, then try telling me your\n&gt; server is not seeing that request? The only thing a client is allowed\n&gt; to do after a successful DELETE is mark a cache entry stale, and\n&gt; remove a bookmark, but not any assumptions beyond that -- especially\n&gt; refusing to honor the user&#39;s request for any reason beyond auth failure.\n\nSo an HTTP stack that internally implements a cache and does not forward \na GET request to the origin server when it already has the answer is \nbroken? If you really think so, I&#39;d recommend that your review the XHR \nworking draft \n(&lt;http://dev.w3.org/cvsweb/~checkout~/2006/webapi/XMLHttpRequest/Overview.html&gt;).\n\n&gt; If you have a client that refuses to send a DELETE request to a resource\n&gt; it knows responds 410 Gone, then you are not using a generic client, as\n&gt; that client is making assumptions beyond what the spec allows as to the\n&gt; permanence of a 410 response. If a 410 can be &quot;unmarked&quot; and changed to\n\nSorry? &lt;http://greenbytes.de/tech/webdav/rfc2616.html#rfc.section.10.4.11&gt;:\n\n&quot;10.4.11 410 Gone\n\nThe requested resource is no longer available at the server and no \nforwarding address is known. This condition is expected to be considered \npermanent....&quot;\n\n&gt; a 404, and there&#39;s nothing wrong with changing a 404 to a 200 by defining\n&gt; a resource, then it is completely wrong behavior for a client to assume\n&gt; permanence of a 410 response which is not written into the spec anywhere.\n\nUnless it is, see above.\n\n&gt;  &gt;So what if there is a proxy that doesn&#39;t even forward the second DELETE\n&gt;  &gt;because it already knows about the previous DELETE? Or if the\n&gt;  &gt;XmlHttpRequest object follows the spec and assumes that if a GET/HEAD on\n&gt;  &gt;a resource once returned a 410, it doesn&#39;t make sense to access that URI\n&gt;  &gt;again?\n&gt;  &gt;\n&gt; \n&gt; Julian, that behavior is simply not in the spec. There is nothing about\n&gt; RFC 2616 which states that a request resulting in a 410 response can&#39;t\n&gt; be repeated, not even a SHOULD NOT, any more than it says that about a\n&gt; 404 response. If the spec allows me to change a 410 into a 404 then\n\nThere&#39;s no point in forbidding it. You may want to repeat it as often as \nyou want. But that you are allowed to do that doesn&#39;t mean it makes sense.\n\n&gt; why would the spec also forbid clients from ever attempting to access a\n&gt; resource once a 410 has been received? That would be contradictory,\n&gt; thankfully that&#39;s not what RFC 2616 says.\n\nIt doesn&#39;t forbid clients to do that. It just says that once a server \nsaid &quot;410&quot; once, clients can assume they don&#39;t need to.\n\n&gt; As to intermediaries, I only see one action allowed in response to a\n&gt; successful DELETE request passing through that intermediary -- marking\n&gt; any preexisting cache entry for that resource as stale. If some\n&gt; intermediary misbehaves because it is disobeying the spec, there&#39;s\n&gt; really nothing I can do about it besides hope it isn&#39;t on the path\n&gt; between me and my server. It would definitely be an error for a proxy\n&gt; to refuse to forward any DELETE request. Please cite your reference\n&gt; for this.\n\nAs others have pointed out, the spec clearly says that a 410 response is \ncache able unless marked otherwise: \n&lt;http://greenbytes.de/tech/webdav/rfc2616.html#rfc.section.13.4.p.4&gt;:\n\n&quot;A response received with a status code of 200, 203, 206, 300, 301 or \n410 MAY be stored by a cache and used in reply to a subsequent request, \nsubject to the expiration mechanism, unless a cache-control directive \nprohibits caching.&quot;\n\nBest regards, Julian\n\n"}}