{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":338780200,"authorName":"Kris Zyp","from":"Kris Zyp &lt;kris@...&gt;","profile":"kriszyp","replyTo":"SENDER","senderId":"Aqgct5-meKIa9Wn5Tf3temPclksefzIkV82Pa1SFB8wLvAM5hyJbl0N25miPc8sI3ogbXr_pIA49PHhBzNCq47dt","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] PUT/POST content type hints","postDate":"1273582030","msgId":15343,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDRCRTk1MUNFLjMwNzAzMDhAc2l0ZXBlbi5jb20+","inReplyToHeader":"PDIwMTAwNTExMDQzMTQ3LmY5NWNhZTUwLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","referencesHeader":"PEFBTkxrVGlseHpTY21NV1A4SndSclF0cTFyRHpOLU5VQzFrMjZyeUU0b2N3VUBtYWlsLmdtYWlsLmNvbT4JPDRCRTg2RjU4LjYwNjAyMDlAc2l0ZXBlbi5jb20+IDwyMDEwMDUxMTA0MzE0Ny5mOTVjYWU1MC5lcmljQGJpc29uc3lzdGVtcy5uZXQ+"},"prevInTopic":15341,"nextInTopic":15349,"prevInTime":15342,"nextInTime":15344,"topicId":15322,"numMessagesInTopic":12,"msgSnippet":"... Hash: SHA1 ... I definitely agree that this assumption can be wrong, and a 415 could be returned with directions about what media type is acceptable. Or ","rawEmail":"Return-Path: &lt;kris@...&gt;\r\nX-Sender: kris@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 27018 invoked from network); 11 May 2010 12:47:18 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m4.grp.sp2.yahoo.com with QMQP; 11 May 2010 12:47:18 -0000\r\nX-Received: from unknown (HELO rs61.luxsci.com) (65.61.166.69)\n  by mta3.grp.sp2.yahoo.com with SMTP; 11 May 2010 12:47:18 -0000\r\nX-Received: from [192.168.0.64] (97-126-200-204.slkc.qwest.net [97.126.200.204])\n\t(authenticated bits=0)\n\tby rs61.luxsci.com (8.13.8/8.13.7) with ESMTP id o4BClGnI032621\n\t(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NOT);\n\tTue, 11 May 2010 07:47:16 -0500\r\nMessage-ID: &lt;4BE951CE.3070308@...&gt;\r\nDate: Tue, 11 May 2010 06:47:10 -0600\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.9) Gecko/20100317 Thunderbird/3.0.4\r\nMIME-Version: 1.0\r\nTo: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nCc: REST-Discuss Discussion Group &lt;rest-discuss@yahoogroups.com&gt;\r\nReferences: &lt;AANLkTilxzScmMWP8JwRrQtq1rDzN-NUC1k26ryE4ocwU@...&gt;\t&lt;4BE86F58.6060209@...&gt; &lt;20100511043147.f95cae50.eric@...&gt;\r\nIn-Reply-To: &lt;20100511043147.f95cae50.eric@...&gt;\r\nX-Enigmail-Version: 1.0.1\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------020906010608020504040203&quot;\r\nFrom: Kris Zyp &lt;kris@...&gt;\r\nSubject: Re: [rest-discuss] PUT/POST content type hints\r\nX-Yahoo-Group-Post: member; u=338780200; y=X2TKLH_ZsKDmIsJI6IqB5T9KaMYpf9wKanbtJ_hSA8V1_A\r\nX-Yahoo-Profile: kriszyp\r\n\r\n\r\n--------------020906010608020504040203\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n \n\n\nOn 5/11/2010 4:31 AM, Eric J. Bowman wrote:\n&gt; \n&gt;\n&gt; Kris Zyp wrote:\n&gt; &gt;\n&gt; &gt; I believe one should be able to assume that the content type of the\n&gt; &gt; representation returned from a server from GET for URI is acceptable\n&gt; &gt; in a PUT request to that server for the same URI.\n&gt; &gt;\n&gt;\n&gt; Absolutely not. The late binding of representation to resource\n&gt; precludes this assumption. HTML is capable of providing an interface\n&gt; to an Atom system. What media type to PUT or POST to the system is\n&gt; explicitly provided in the markup, i.e. a self-documenting interface.\n&gt;\n&gt; Assuming that you can PUT or POST HTML to my system because that&#39;s the\n&gt; media type I sent on GET would not work -- I derive HTML from Atom, not\n&gt; the other way around.\n&gt;\n&gt; A PUT of an HTML document would show an intent to replace the\n&gt; self-documenting interface provided by the HTML representation, with\n&gt; some other application state. HTML is generated by my system, it is not\n&gt; subject to change via PUT to negotiated resources which happen to return\n&gt; text/html or application/xhtml+xml on GET with a Web browser, but\n&gt; happen to return Atom to a feed reader.\n&gt;\n\nI definitely agree that this assumption can be wrong, and a 415 could\nbe returned with directions about what media type is acceptable. Or\nthe client&#39;s preferred media type may override the GET&#39;s content type\n(in which case he probably wouldn&#39;t be asking this question). But\nrequiring a client to simply &quot;know&quot; what media type the server needs\n(when the client could encode in multiple media types) rather than\nattempting to use the same media type from a GET would obviously\nrequire out of band information and badly violate REST.\n\n&gt;\n&gt; &gt;\n&gt; &gt; When using JSON,\n&gt; &gt; additional information about acceptable property values can be\n&gt; &gt; determined from any JSON Schema referenced by the resource. In other\n&gt; &gt; words, if you GET some resource, and the server responds with:\n&gt; &gt;\n&gt; &gt; Content-Type: application/my-type+json; profile=my-schema\n&gt; &gt;\n&gt; &gt; One could retrieve the schema from the &quot;my-schema&quot; relative URI and do\n&gt; &gt; a PUT using the application/my-type+json content type with the schema\n&gt; &gt; information as a guide to what property values are acceptable.\n&gt; &gt;\n&gt;\n&gt; Sure you can *do* this, it just wouldn&#39;t be REST. Leaving aside that\n&gt; the media type identifier definition for JSON doesn&#39;t say anything about\n&gt; extending it using *+json, the media type definition for JSON says\n&gt; nothing about HTTP methods. Where have you provided a self-documenting\n&gt; interface giving a target URI, method and media type -- as provided by\n&gt; forms languages having no corollary in JSON, yet required by REST?\n&gt;\n&gt;\n&gt; If you &quot;just know&quot; that you can PUT or DELETE some JSON resource, it&#39;s\n&gt; no more RESTful than &quot;just knowing&quot; that you can PUT or DELETE some\n&gt; JPEG. You&#39;re resorting to unbounded creativity, rather than using\n&gt; standard media types and link relations which *do* cover HTTP methods,\n&gt; for any target media type.\n&gt;\n\nRFC 2616 is sufficient for describing the semantics of PUT and DELETE.\nI don&#39;t need to know anything besides what RFC 2616 has clearly described.\n\n&gt;\n&gt; &gt;\n&gt; &gt; Discovery of POST actions is completely different than PUT (since\n&gt; &gt; PUT&#39;s behavior is implied by a GET response). A JSON Schema can\n&gt; &gt; describe possible POST actions with submission links, including an\n&gt; &gt; acceptable content type (in the &quot;enctype&quot; property).\n&gt; &gt;\n&gt;\n&gt; I don&#39;t see how. Regardless of schema, there&#39;s simply no mention in\n&gt; the media type definition of JSON for describing URIs or methods, i.e.\n&gt; there&#39;s no forms language. The demo I posted consists of XHTML steady-\n&gt; states derived from various source representationss of other media\n&gt; types. These steady-states (will) provide a self-documenting API to\n&gt; the underlying Atom-based system.\n&gt;\n\nJSON Schema effectively provides a forms language:\nhttp://tools.ietf.org/html/draft-zyp-json-schema-02\n&gt;\n&gt;\n&gt; The user isn&#39;t trying to discover PUT vs. POST actions. The user is\n&gt; trying to drive an application to another steady-state. The user agent\n&gt; needs to translate that user goal into HTTP interactions. If the user\n&gt; is trying to add a new post, the user agent is instructed to POST to\n&gt; the domain root. If the user is trying to add a new comment, the user\n&gt; agent is instructed to POST to the appropriate comment thread. If the\n&gt; user intent is to edit an existing entry, the user agent is instructed\n&gt; to PUT to the existing URI. In each case, the user agent is instructed\n&gt; to use application/atom+xml; type=entry.\n&gt;\n&gt; There&#39;s no RESTful way to instruct any user agent that &quot;this system\n&gt; uses Atom Protocol&quot; and this may not be inferred by the fact that the\n&gt; system uses Atom. All I can do is provide a self-documenting hypertext\n&gt; API which instructs user agents how to interact with the system. This\n&gt; API may or may not conform to Atom Protocol. Whether it does or not is\n&gt; less important to REST than its presence.\n&gt;\n&gt; None of this is any different for a system based on JSON rather than\n&gt; Atom. As a REST system, I could change my Atom backend to a JSON\n&gt; backend on a whim. I&#39;m not saying it would be easy, but I am saying\n&gt; that the application states wouldn&#39;t change. The HTML would still\n&gt; present a textarea, changes to that textarea would be submitted to the\n&gt; same URI, using whatever media type the form says to use -- all HTML\n&gt; user agents automatically update to the new API.\n&gt;\n&gt; If you need to guess what media type to use then you can&#39;t possibly be\n&gt; using REST. A REST API will always tell you exactly what media type to\n&gt; use. It isn&#39;t implicit in any guessable fashion, it&#39;s explicit. If it\n&gt; isn&#39;t explicit, it isn&#39;t REST. HTML says what POST does, but only your\n&gt; hypertext can specify media type, if you lack such hypertext you lack\n&gt; a critical REST constraint.\n&gt;\n\nAbsolutely, I agree.\n\n- -- \nKris Zyp\nSitePen\n(503) 806-1841\nhttp://sitepen.com\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.9 (MingW32)\nComment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/\n \niEYEARECAAYFAkvpUc4ACgkQ9VpNnHc4zAyE7wCcCjIsRLOPR9UmAvJj50z9whT/\n5fsAn2gCtvWZto0PD4c/WeRUAGyMUZJE\n=mp4f\n-----END PGP SIGNATURE-----\n\n\r\n--------------020906010608020504040203\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta content=&quot;text/html; charset=ISO-8859-1&quot;\n http-equiv=&quot;Content-Type&quot;&gt;\n  &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;\n-----BEGIN PGP SIGNED MESSAGE----- &lt;br&gt;\nHash: SHA1 &lt;br&gt;\n&nbsp;&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\nOn 5/11/2010 4:31 AM, Eric J. Bowman wrote:&lt;br&gt;\n&lt;span style=&quot;white-space: pre;&quot;&gt;&gt;&nbsp; &lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Kris Zyp wrote:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; I believe one should be able to assume that the content\ntype of the&lt;br&gt;\n&gt; &gt; representation returned from a server from GET for URI is\nacceptable&lt;br&gt;\n&gt; &gt; in a PUT request to that server for the same URI.&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Absolutely not. The late binding of representation to resource&lt;br&gt;\n&gt; precludes this assumption. HTML is capable of providing an\ninterface&lt;br&gt;\n&gt; to an Atom system. What media type to PUT or POST to the system\nis&lt;br&gt;\n&gt; explicitly provided in the markup, i.e. a self-documenting\ninterface.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Assuming that you can PUT or POST HTML to my system because\nthat&#39;s the&lt;br&gt;\n&gt; media type I sent on GET would not work -- I derive HTML from\nAtom, not&lt;br&gt;\n&gt; the other way around.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; A PUT of an HTML document would show an intent to replace the&lt;br&gt;\n&gt; self-documenting interface provided by the HTML representation,\nwith&lt;br&gt;\n&gt; some other application state. HTML is generated by my system, it\nis not&lt;br&gt;\n&gt; subject to change via PUT to negotiated resources which happen\nto return&lt;br&gt;\n&gt; text/html or application/xhtml+xml on GET with a Web browser, but&lt;br&gt;\n&gt; happen to return Atom to a feed reader.&lt;br&gt;\n&gt;&lt;/span&gt;&lt;br&gt;\n&lt;br&gt;\nI definitely agree that this assumption can be wrong, and a 415 could&lt;br&gt;\nbe returned with directions about what media type is acceptable. Or&lt;br&gt;\nthe client&#39;s preferred media type may override the GET&#39;s content type&lt;br&gt;\n(in which case he probably wouldn&#39;t be asking this question). But&lt;br&gt;\nrequiring a client to simply &quot;know&quot; what media type the server needs&lt;br&gt;\n(when the client could encode in multiple media types) rather than&lt;br&gt;\nattempting to use the same media type from a GET would obviously&lt;br&gt;\nrequire out of band information and badly violate REST.&lt;br&gt;\n&lt;br&gt;\n&lt;span style=&quot;white-space: pre;&quot;&gt;&gt;&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; When using JSON,&lt;br&gt;\n&gt; &gt; additional information about acceptable property values can\nbe&lt;br&gt;\n&gt; &gt; determined from any JSON Schema referenced by the resource.\nIn other&lt;br&gt;\n&gt; &gt; words, if you GET some resource, and the server responds\nwith:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; Content-Type: application/my-type+json; profile=my-schema&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; One could retrieve the schema from the &quot;my-schema&quot; relative\nURI and do&lt;br&gt;\n&gt; &gt; a PUT using the application/my-type+json content type with\nthe schema&lt;br&gt;\n&gt; &gt; information as a guide to what property values are\nacceptable.&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Sure you can *do* this, it just wouldn&#39;t be REST. Leaving aside\nthat&lt;br&gt;\n&gt; the media type identifier definition for JSON doesn&#39;t say\nanything about&lt;br&gt;\n&gt; extending it using *+json, the media type definition for JSON\nsays&lt;br&gt;\n&gt; nothing about HTTP methods. Where have you provided a\nself-documenting&lt;br&gt;\n&gt; interface giving a target URI, method and media type -- as\nprovided by&lt;br&gt;\n&gt; forms languages having no corollary in JSON, yet required by\nREST?&lt;br&gt;\n&gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; If you &quot;just know&quot; that you can PUT or DELETE some JSON\nresource, it&#39;s&lt;br&gt;\n&gt; no more RESTful than &quot;just knowing&quot; that you can PUT or DELETE\nsome&lt;br&gt;\n&gt; JPEG. You&#39;re resorting to unbounded creativity, rather than using&lt;br&gt;\n&gt; standard media types and link relations which *do* cover HTTP\nmethods,&lt;br&gt;\n&gt; for any target media type.&lt;br&gt;\n&gt;&lt;/span&gt;&lt;br&gt;\n&lt;br&gt;\nRFC 2616 is sufficient for describing the semantics of PUT and DELETE.&lt;br&gt;\nI don&#39;t need to know anything besides what RFC 2616 has clearly\ndescribed.&lt;br&gt;\n&lt;br&gt;\n&lt;span style=&quot;white-space: pre;&quot;&gt;&gt;&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; Discovery of POST actions is completely different than PUT\n(since&lt;br&gt;\n&gt; &gt; PUT&#39;s behavior is implied by a GET response). A JSON Schema\ncan&lt;br&gt;\n&gt; &gt; describe possible POST actions with submission links,\nincluding an&lt;br&gt;\n&gt; &gt; acceptable content type (in the &quot;enctype&quot; property).&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; I don&#39;t see how. Regardless of schema, there&#39;s simply no mention\nin&lt;br&gt;\n&gt; the media type definition of JSON for describing URIs or\nmethods, i.e.&lt;br&gt;\n&gt; there&#39;s no forms language. The demo I posted consists of XHTML\nsteady-&lt;br&gt;\n&gt; states derived from various source representationss of other\nmedia&lt;br&gt;\n&gt; types. These steady-states (will) provide a self-documenting API\nto&lt;br&gt;\n&gt; the underlying Atom-based system.&lt;br&gt;\n&gt;&lt;/span&gt;&lt;br&gt;\n&lt;br&gt;\nJSON Schema effectively provides a forms language:&lt;br&gt;\n&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;http://tools.ietf.org/html/draft-zyp-json-schema-02&quot;&gt;http://tools.ietf.org/html/draft-zyp-json-schema-02&lt;/a&gt;&lt;br&gt;\n&lt;span style=&quot;white-space: pre;&quot;&gt;&gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; The user isn&#39;t trying to discover PUT vs. POST actions. The user\nis&lt;br&gt;\n&gt; trying to drive an application to another steady-state. The user\nagent&lt;br&gt;\n&gt; needs to translate that user goal into HTTP interactions. If the\nuser&lt;br&gt;\n&gt; is trying to add a new post, the user agent is instructed to\nPOST to&lt;br&gt;\n&gt; the domain root. If the user is trying to add a new comment, the\nuser&lt;br&gt;\n&gt; agent is instructed to POST to the appropriate comment thread.\nIf the&lt;br&gt;\n&gt; user intent is to edit an existing entry, the user agent is\ninstructed&lt;br&gt;\n&gt; to PUT to the existing URI. In each case, the user agent is\ninstructed&lt;br&gt;\n&gt; to use application/atom+xml; type=entry.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; There&#39;s no RESTful way to instruct any user agent that &quot;this\nsystem&lt;br&gt;\n&gt; uses Atom Protocol&quot; and this may not be inferred by the fact\nthat the&lt;br&gt;\n&gt; system uses Atom. All I can do is provide a self-documenting\nhypertext&lt;br&gt;\n&gt; API which instructs user agents how to interact with the system.\nThis&lt;br&gt;\n&gt; API may or may not conform to Atom Protocol. Whether it does or\nnot is&lt;br&gt;\n&gt; less important to REST than its presence.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; None of this is any different for a system based on JSON rather\nthan&lt;br&gt;\n&gt; Atom. As a REST system, I could change my Atom backend to a JSON&lt;br&gt;\n&gt; backend on a whim. I&#39;m not saying it would be easy, but I am\nsaying&lt;br&gt;\n&gt; that the application states wouldn&#39;t change. The HTML would still&lt;br&gt;\n&gt; present a textarea, changes to that textarea would be submitted\nto the&lt;br&gt;\n&gt; same URI, using whatever media type the form says to use -- all\nHTML&lt;br&gt;\n&gt; user agents automatically update to the new API.&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; If you need to guess what media type to use then you can&#39;t\npossibly be&lt;br&gt;\n&gt; using REST. A REST API will always tell you exactly what media\ntype to&lt;br&gt;\n&gt; use. It isn&#39;t implicit in any guessable fashion, it&#39;s explicit.\nIf it&lt;br&gt;\n&gt; isn&#39;t explicit, it isn&#39;t REST. HTML says what POST does, but\nonly your&lt;br&gt;\n&gt; hypertext can specify media type, if you lack such hypertext you\nlack&lt;br&gt;\n&gt; a critical REST constraint.&lt;br&gt;\n&gt;&lt;/span&gt;&lt;br&gt;\n&lt;br&gt;\nAbsolutely, I agree.&lt;br&gt;\n&lt;br&gt;\n- -- &lt;br&gt;\nKris Zyp&lt;br&gt;\nSitePen&lt;br&gt;\n(503) 806-1841&lt;br&gt;\n&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;http://sitepen.com&quot;&gt;http://sitepen.com&lt;/a&gt;&lt;br&gt;\n-----BEGIN PGP SIGNATURE-----\n&lt;br&gt;\nVersion: GnuPG v1.4.9 (MingW32)\n&lt;br&gt;\nComment: Using GnuPG with Mozilla - &lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;http://enigmail.mozdev.org/&quot;&gt;http://enigmail.mozdev.org/&lt;/a&gt;\n&lt;br&gt;\n&nbsp;&lt;br&gt;\niEYEARECAAYFAkvpUc4ACgkQ9VpNnHc4zAyE7wCcCjIsRLOPR9UmAvJj50z9whT/\n&lt;br&gt;\n5fsAn2gCtvWZto0PD4c/WeRUAGyMUZJE\n&lt;br&gt;\n=mp4f\n&lt;br&gt;\n-----END PGP SIGNATURE-----\n&lt;br&gt;\n&lt;br&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------020906010608020504040203--\r\n\n"}}