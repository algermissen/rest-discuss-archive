{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":277681928,"authorName":"Andrew S. Townley","from":"&quot;Andrew S. Townley&quot; &lt;ast@...&gt;","profile":"adz1092","replyTo":"SENDER","senderId":"cDXA1ZnH5PRdEeld_tOp0J_-0sjytLZZ_zbNdrNmoBVuLEOxXp_xqwJuVViMWGd5Xh73slePpBY9mAAP0likVbJ9zsdvbfifnBSt5_I","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] Why HATEOAS?","postDate":"1238843179","msgId":12380,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDEyMzg4NDMxNzkuOTM2MS45Ny5jYW1lbEBsaW5uYT4=","inReplyToHeader":"PGY4YjM5YWNlMDkwNDAxMTExMnQ1OWFmM2FjdThkODk0NzdjNDI3NTQwY0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PDU1YzYwZTM3MDkwMzMxMTcwMXg0YWRhYzAyZG8zNjliNWQ4NjE3MDBmNmU2QG1haWwuZ21haWwuY29tPgkgPGY4YjM5YWNlMDkwMzMxMTc1OWwzY2JjZGFmNWoyZDkwZWU5NzJhMjJmNGFiQG1haWwuZ21haWwuY29tPgkgPDEyMzg1Nzk0NzcuNjE3MS41MS5jYW1lbEBsaW5uYT4JIDxmOGIzOWFjZTA5MDQwMTExMTJ0NTlhZjNhY3U4ZDg5NDc3YzQyNzU0MGNAbWFpbC5nbWFpbC5jb20+"},"prevInTopic":12375,"nextInTopic":12384,"prevInTime":12379,"nextInTime":12381,"topicId":12357,"numMessagesInTopic":27,"msgSnippet":"Apologies for the delayed reply.  Was away from email for a bit. ... That s cool.  However, that s not exactly what I meant by verbs in the above.  To me,","rawEmail":"Return-Path: &lt;ast@...&gt;\r\nX-Sender: ast@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 18847 invoked from network); 4 Apr 2009 11:06:28 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by 98.137.34.37 with QMQP; 4 Apr 2009 11:06:28 -0000\r\nX-Received: from unknown (HELO valleyforge.networkredux.net) (64.128.80.17)\n  by mta1.grp.sp2.yahoo.com with SMTP; 4 Apr 2009 11:06:28 -0000\r\nX-Received: from [88.170.61.5] (port=57487 helo=[192.168.151.11])\n\tby valleyforge.networkredux.net with esmtpsa (SSLv3:AES256-SHA:256)\n\t(Exim 4.63)\n\t(envelope-from &lt;ast@...&gt;)\n\tid 1Lq3hV-0000PP-81; Sat, 04 Apr 2009 04:06:14 -0700\r\nTo: craigmcc@...\r\nCc: Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nIn-Reply-To: &lt;f8b39ace0904011112t59af3acu8d89477c427540c@...&gt;\r\nReferences: &lt;55c60e370903311701x4adac02do369b5d861700f6e6@...&gt;\n\t &lt;f8b39ace0903311759l3cbcdaf5j2d90ee972a22f4ab@...&gt;\n\t &lt;1238579477.6171.51.camel@linna&gt;\n\t &lt;f8b39ace0904011112t59af3acu8d89477c427540c@...&gt;\r\nContent-Type: text/plain\r\nDate: Sat, 04 Apr 2009 12:06:19 +0100\r\nMessage-Id: &lt;1238843179.9361.97.camel@linna&gt;\r\nMime-Version: 1.0\r\nX-Mailer: Evolution 2.22.3.1 \r\nContent-Transfer-Encoding: 7bit\r\nX-AntiAbuse: This header was added to track abuse, please include it with any abuse report\r\nX-AntiAbuse: Primary Hostname - valleyforge.networkredux.net\r\nX-AntiAbuse: Original Domain - yahoogroups.com\r\nX-AntiAbuse: Originator/Caller UID/GID - [47 12] / [47 12]\r\nX-AntiAbuse: Sender Address Domain - atownley.org\r\nX-Source: \r\nX-Source-Args: \r\nX-Source-Dir: \r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Andrew S. Townley&quot; &lt;ast@...&gt;\r\nSubject: Re: [rest-discuss] Why HATEOAS?\r\nX-Yahoo-Group-Post: member; u=277681928; y=HTY8yDOL7VwVHDRC45La6qbXnmYEKT3_DAaYtqZjaFGaFQ\r\nX-Yahoo-Profile: adz1092\r\n\r\nApologies for the delayed reply.  Was away from email for a bit.\n\nOn Wed, 2009-04-01 at 11:12 -0700, Craig McClanahan wrote:\n&gt; Snipping and interspersing a few comments:\n&gt; \n&gt; On Wed, Apr 1, 2009 at 2:51 AM, Andrew S. Townley &lt;ast@...&gt; wrote:\n&gt; &gt; This was a great post.  I&#39;m looking at doing something similar for an\n&gt; &gt; application as well, but, having looked at the API for the Sun Cloud, I\n&gt; &gt; was planning on taking it a bit further.\n&gt; &gt;\n&gt; &gt; One thing that I see missing is &quot;full disclosure&quot; of the operations\n&gt; &gt; (verbs) to be used as well as differentiation between actions vs.\n&gt; &gt; information.\n&gt; \n&gt; In the specification, this is described on the various pages like\n&gt; &lt;http://kenai.com/projects/suncloudapis/pages/CloudAPIVMRequests&gt;,\n&gt; which describes the set of operations that a VM representation (or,\n&gt; more properly, a URI included in a VM representation).  On the wire,\n&gt; if you use the HTTP OPTIONS command to ask the server what verbs are\n&gt; supported by that URI.  For example, the URI you get for the &quot;Attach\n&gt; VM to Public Address or VNet&quot; will tell you that it only supports a\n&gt; POST.\n\nThat&#39;s cool.  However, that&#39;s not exactly what I meant by &quot;verbs&quot; in the\nabove.  To me, what we&#39;re talking about with REST systems is that the\nrepresentations transferred between the client and the server are\npictures of the *application* state, not of the resource state.  This is\nmy understanding of Roy&#39;s thesis.\n\nIn the degenerate case, the application in question is an HTTP server,\nand what it&#39;s doing is really pretty simple and defined solely by the\nbounds of GET, POST, PUT, DELETE and friends.  What I&#39;m talking about\nare more complex hypermedia applications which are built according to\nthe REST architectural style and just happen to be using HTTP to\ntransfer these representations between the client and the server(s) in\nquestion that comprise the overall application implementation.\n\nIn this case, the representations of the application state need to be\nmore complicated, because the application is more complicated.  Of\ncourse, the difference here between browser+human user agents and\nautomated agents actually doesn&#39;t matter in the abstract.  Where it\ndiffers is in the concrete implementations of how those application\nstates are represented to the user agent.\n\nFor a browser+human user agent, you can get by with &quot;simpler&quot; (X)HTML\nrepresentations of the hypermedia aspects triggering the various state\ntransitions as well as potentially a few less complicated resource types\nlike PDFs, images, office documents, etc. that may be part of the\noverall application interaction scenarios.\n\nHowever, in the case of the automated user agent, you can&#39;t make those\nassumptions because the user agent needs to &quot;understand&quot; what each of\nthe given application state representations from the server &quot;means&quot;, so\nthat it can do the right thing to accomplish its mission.\n\nYou only have two options for doing this:\n\n1) Come up with abstraction(s) to describe these application states with\nfixed semantics and then express your application&#39;s business logic in\nterms of these abstractions, or\n\n2) Implement specific assumptions about the application into your user\nagent, and implement your business logic based on those assumptions.\n\nI&#39;m not saying that there is a one-size-fits all solution.  What I&#39;m\ntrying to define with what I outlined earlier is a way to allow you to\ndo #1 as efficiently as possible in the case where you want the same\nclient business logic to support as many server implementations as\npossible.  As you say below, all this overhead where you&#39;re primarily in\ncontrol of both ends is unnecessary complexity in most cases.\n\n&gt; What we are not including in the representations, at least right now,\n&gt; is media type related restrictions.  Partly, that is because many of\n&gt; the operations are in fact polymorphic (what happens depends on what\n&gt; media type you send in a request), and partly (at least in my view) is\n&gt; that client applications using an API are going to have *some*\n&gt; semantic understanding of what is going on, so they will be &quot;hard\n&gt; coding&quot; in a sense which representations to send already, so they\n&gt; don&#39;t necessarily need to be told.  And, just knowing the media type\n&gt; still doesn&#39;t help you understand which fields have which impacts.\n&gt; This is certainly a design principle around which people will have\n&gt; different opinions, but it&#39;s the way we have gone so far.\n\nFair enough, and as I said above, it may be the right approach for your\nparticular application.  It is much more closely conforming to option #2\nabove, but as long as you&#39;re clear (and your users are clear), then you\ncan effectively plan for the evolution of the system on both ends.\n\n&gt; &gt;\n&gt; &gt; Don&#39;t get me wrong, I think the API you have is pretty good! :)\n&gt; &gt;\n&gt; &gt; However, the only way that I could think of doing what I&#39;m talking about\n&gt; &gt; was to define some kind of envelope, or at least a series of elements\n&gt; &gt; that were influenced by or imported directly the XHTML forms (and/or\n&gt; &gt; possibly XForms) elements to identify what actions were possible for a\n&gt; &gt; given resource.  That way, you&#39;d have the full HATEOAS in the message\n&gt; &gt; and the clients wouldn&#39;t have to know anything except how to interpret\n&gt; &gt; the markup.  I guess I should also say that I&#39;m looking at XML\n&gt; &gt; representations here rather than JSON.\n&gt; \n&gt; XML versus JSON shouldn&#39;t really matter all that much.  Indeed, I&#39;ve\n&gt; seen lots of APIs that support both syntaxes (especially easy to do in\n&gt; Java if you&#39;re using JAX-RS, but not that difficult in other\n&gt; environments).\n\nI didn&#39;t figure it would, but I just wanted to be clear.\n\n&gt; &gt; I was planning on posting some thoughts on this anyway, but the timing\n&gt; &gt; of this post was too good to pass up.\n&gt; &gt;\n&gt; &gt; What I was thinking was something like:\n&gt; &gt;\n&gt; &gt; &lt;ActionEnvelope&gt;\n&gt; &gt;  &lt;Header&gt;\n&gt; &gt;  &lt;ActionList&gt;\n&gt; &gt;   &lt;Action id=&quot;action1&quot; href=&quot;uri&quot; method=&quot;POST&quot;&gt;Human readable description of the action here&lt;/Action&gt;\n&gt; &gt;   &lt;Action id=&quot;delete&quot; href=&quot;uri&quot; method=&quot;DELETE&quot;&gt;Delete this resource&lt;/Action&gt;\n&gt; &gt;   ...\n&gt; &gt;  &lt;/ActionList&gt;\n&gt; &gt;  &lt;/Header&gt;\n&gt; &gt;  &lt;Body&gt;\n&gt; &gt;  &lt;!-- any content can go here, and client processing will be based on\n&gt; &gt; either the elements or the namespace URI(s) used in the root child\n&gt; &gt; element --&gt;\n&gt; &gt;  &lt;/Body&gt;\n&gt; &gt; &lt;/ActionEnvelope&gt;\n&gt; &gt;\n&gt; &gt; Now, before everyone gets all fussy and says it&#39;s too much like SOAP, it\n&gt; &gt; truly isn&#39;t.  The only thing in common is that it uses an envelope.\n&gt; \n&gt; A couple of thoughts and questions:\n&gt; \n&gt; * Why call out DELETE as a separate action?  I&#39;d tend to accept a DELETE\n&gt;   back to the URI that got me this representation in the first place if I wanted\n&gt;   to support that semantic.\n\nBecause in the case of scenario #1 above, you&#39;re not talking about HTTP\nas the application, you&#39;re talking about something different.  Even if\nyou leverage the HTTP verbs and map those to your application as closely\nas possible, DELETE might not be supported in your particular\nenvironment.  You might have to use POST, or you might have to send the\nrequest to an entirely different URI than the one you used to request\nthe representation.\n\nThat&#39;s not pure HTTP, but I don&#39;t believe that it isn&#39;t still pure REST.\nI truly don&#39;t see a tight coupling between REST and HTTP, even though\nusing HTTP in practice to deliver REST systems makes a whole lot of\nsense.\n\nTo one of your other points about minimizing the number of invalid state\ntransition requests, it also serves to put all of the valid state\ntransition information explicitly in the hypermedia representation.  You\ncould do an HTTP OPTIONS request on the resource, but that might not\nactually tell you what *application* transitions were available in each\ncase.  It certainly SHOULD do it, but there might not be a good mapping\nbetween application state transitions and HTTP verbs.  This approach\nensures a clear separation between the two, using the hypermedia\nrepresentation.\n\n&gt; * It seems like you are focusing on an application environment where the\n&gt;   client is a browser, and therefore potentially limited to &quot;form\n&gt; like&quot; behaviors.\n&gt;   This leads you to a distinction between the &quot;edit&quot; view of a &quot;read&quot; view of\n&gt;   a resource.  My preference is to assume that the client just wants the data,\n&gt;   and is totally in charge of formatting (you can synthesize a &lt;form&gt; or an\n&gt;   XForm in javascript), so I shouldn&#39;t make model-versus-view distinctions\n&gt;   in the respresentations.\n\nAs I hope is clear now, we&#39;re talking about following an &quot;equal\nopportunity&quot; principle as far as clients are concerned.  Based on the\nthinking and research I&#39;ve done to date on REST and hypermedia-based\nsystems, I think the issues are the same, it&#39;s just that the differences\nare collapsed due to the human element in browser-based interactions.\n\nThis doesn&#39;t mean you&#39;re limited to using forms, but if it&#39;s the right\ntool for the job, there&#39;s no reason to re-invent the wheel.  That&#39;s the\nother good thing about XML-based hypermedia:  it gives you the ability\nto selectively layer in the functionality you need.\n\n&gt;From an API perspective, you call out the application state transitions\nas part of the specification and how the client/user agent is supposed\nto detect and understand the semantics of said transitions.  Then, for\neach particular state, you describe the format of the hypermedia the\nclient is likely to receive.\n\nIt still has the opportunity to either fully or partially understand\naspects of the hypermedia representations provided, with either graceful\nor un-graceful functionality degradation, depending on the complexity of\nthe user agent and the needs of the application.\n\nAlternatively, you invert the approach and implement common behavior\nbased on the clients &quot;detecting&quot; the state of the application from the\nrepresentation.  Instead of knowing ahead of time that you&#39;re supposed\nto be able to do &quot;create -&gt; view -&gt; edit | delete&quot;, it uses the\nrepresentation and an understanding of specific semantics associated\nwith particular action id&#39;s, like view, edit, delete, search, etc. and\nits &quot;understanding&quot; of particular representation content formats\ntogether to allow it to successfully interact with the system given a\nnumber of possible starting application states, based on what the\nbusiness logic of the client says it&#39;s trying to accomplish.  This would\nbe my real goal, actually.\n\n&gt;From a user agent perspective, I don&#39;t want to have to provide a\njavascript environment for every user agent.  From an application\nperspective, I see &quot;view representation&quot; and &quot;edit representation&quot; as\nbeing two separate states, potentially with two different representation\nformats and even data.  For example, you might show relationships\nbetween resources in a view representation, but if it doesn&#39;t make sense\nto edit these in an edit representation, you wouldn&#39;t include them.\nOnly the data the given user agent could actually change would be\nsupplied.\n\nThe other reason this is where my thinking is right now is that\nbrowser-based hypermedia interactions are the only ones really proven to\nfully implement the REST style to date.  Other systems implement aspects\nof it, or they follow specific semantic mappings between application\nstate transitions and HTTP state transitions or verbs, but they don&#39;t go\n&quot;whole hog&quot;.\n\nThe semweb folks are trying one approach to specifying this, but I think\nit doesn&#39;t really need to be that complicated to provide practical\nsolutions to scenario #1 above without trying to eat the whole &quot;W3C\nSemantic Web vision&quot; elephant at once.\n\nHTTP is a means to an end in my view.  It isn&#39;t (and shouldn&#39;t) be the\nlimiting design constraint for RESTful systems.  That&#39;s the role HATEOAS\nplays, not HTTP.\n\n&gt; &gt;\n&gt; &gt; The other thing to note is that the total transitions available to the\n&gt; &gt; client are the sum of any in-lined (like FORM submissions, regular\n&gt; &gt; hyperlink traversal, etc.) and then any of the other, &quot;meta&quot; actions\n&gt; &gt; possible for the system as a whole defined in the envelope&#39;s header.\n&gt; &gt;\n&gt; &gt; I went through several iterations of putting them in in the &quot;real&quot;\n&gt; &gt; resource vs. in the header, but this is where I&#39;m thinking at the\n&gt; &gt; moment, because it allows you to easily process the resource for both\n&gt; &gt; human and machine interaction (the action list becomes a menu, for\n&gt; &gt; example, if the ultimate user agent wants (X)HTML -- this can be\n&gt; &gt; accomplished a number of different ways).\n&gt; &gt;\n&gt; &gt; I was wondering if you guys went through this line of thinking with your\n&gt; &gt; API design and discarded it, or if it was deemed either unnecessary or\n&gt; &gt; too complicated.\n&gt; &gt;\n&gt; &gt; Of course, with this approach your automated user agent still needs to\n&gt; &gt; understand the semantics of the action id&#39;s, but this would be published\n&gt; &gt; as part of the API specification, separate from the specification for\n&gt; &gt; the underlying content schema(s), and the inputs required would be fully\n&gt; &gt; supplied after making the request defined by the action.\n&gt; &gt;\n&gt; &gt; This isn&#39;t terribly efficient, because an editing operation for the\n&gt; &gt; resource might look like:\n&gt; &gt;\n&gt; &gt; Step 1) Get the resource URI\n&gt; &gt;\n&gt; &gt; Step 2) Process the resource XML, recording the actions\n&gt; &gt;\n&gt; &gt; Step 3) If an action with ID &quot;edit&quot; exists in the header, but no form\n&gt; &gt; exists in the body, make request for &quot;edit&quot; resource\n&gt; &gt;\n&gt; &gt; Step 4) Process the resource XML looking for &quot;resource editing&quot; mark-up\n&gt; &gt; (defined by the API spec, probably a normal FORM in the envelope body)\n&gt; &gt;\n&gt; &gt; Step 5) Supply available form values to be changed (also prevents\n&gt; &gt; changing of read-only resource properties)\n&gt; &gt;\n&gt; &gt; Step 6) Submit FORM\n&gt; &gt;\n&gt; &gt; Step 7) Process HTTP server response\n&gt; &gt;\n&gt; &gt; Granted, this certainly not as efficient as:\n&gt; &gt;\n&gt; &gt;  PUT /vms/33333\n&gt; &gt;  Host: example.com\n&gt; &gt;  Authorization: Basic xxxxxxxxxxxxxxxxxxx\n&gt; &gt;  Accept: application/vnd.com.sun.cloud.VM+json\n&gt; &gt;  Content-Length: nnn\n&gt; &gt;  Content-Type: application/vnd.com.sun.cloud.VM+json\n&gt; &gt;  X-Cloud-Client-Specification-Version: 0.1\n&gt; &gt;\n&gt; &gt;  {\n&gt; &gt;   &quot;description&quot; : &quot;This is the new description&quot;\n&gt; &gt;  }\n&gt; &gt;\n&gt; &gt; But how does the user agent know it can do this from the original\n&gt; &gt; resource?\n&gt; \n&gt; Turn that question around.  With your approach, how does the client\n&gt; know what values are valid in any of the input fields?  Or what is\n&gt; going to happen to the state of the system when you send in a POST or\n&gt; a PUT or a DELETE?  My feeling is that the person developing the\n&gt; client application is going to have to understand this kind of\n&gt; semantics anyway, so let&#39;s skip the extra round trips, and all the\n&gt; extra server side logic to create &quot;forms&quot; -- even if the client really\n&gt; is an application that doesn&#39;t need such a thing.\n\nI&#39;m not 100% convinced that the user agent needs to fully understand\nwhat&#39;s going to happen to the state of the system for each transition.\nAll it should need to know is how to use the available state transitions\nfrom this particular state representation to accomplish what it&#39;s trying\nto do.  It is likely only concerned with a subset of the overall\napplication state and available transitions, again, depending on what\nit&#39;s trying to do and how complex the system actually is.\n\nAgain, I&#39;m not saying that what I&#39;m proposing is a one-size-fits all\nsolution.  However, at this stage, I do believe that the client only\nneeds to know:\n\na) the available state transitions (based on what it &quot;sees&quot; in the given\nrepresentation of the current application state)\n\nb) what each of those state transitions &quot;mean&quot; (their semantics) in\nterms of both generic application behavior (CRUD operations, for\nexample) as well as application-specific behavior (start/stop servers,\netc.) in the context of the job it&#39;s trying to do\n\nc) how to recognize appropriate inputs and data provided by the system\nand map those to information it holds locally\n\nb & c are the key aspects here.  If your user agent is built to\nunderstand that, in general if it sees an HTML form, then it can assume\nthat the ID values for each of the input elements corresponds to an\nobject property of an internal object it maintains corresponding to\neither the base URI (minus any query parameters) of the resource being\nedited or some other identifier present in the hypermedia, then it can\nauto-populate the form fields in much the same way that modern browsers\ndo.\n\nThey are also able to mostly do this successfully simply based on the\ninformation provided by the individual HTML elements without any\nknowledge of the particular application state.  This &quot;caveman\nmentality&quot;, e.g. &quot;me see form field id; me have data matching form field\nid; me populate field&quot;, actually seems to work reasonably well.\n\nIf your application is written in such a way that it can leverage this\nbehavior, then I think you&#39;ve greatly simplified your individual\napplication clients&#39; business logic definition.  Of course, it means\nthat you might need a more complex interaction library than just using\nHTTP, but I don&#39;t really see that an an issue.\n\nI want to get to the point where I have the ability to define &quot;simple&quot;\nclients based on an understanding of a small set of semantic actions\nthat can easily be applied across a number of different systems broadly\nperforming the same task, but with different implementation specifics.\n\nWhy, yes, this is a bit of semweb stuff, but rather than saying &quot;how do\nI understand the semantics of every possible application interface and\nnegotiate a way to interact with it,&quot; I&#39;m trying to take the approach of\n&quot;let&#39;s (try) to define a smaller set of semantics that can be broadly\napplied and push the burden of mapping to these back to the application\nrather than making the client &#39;smart enough&#39; to figure it out.&quot;\n\nI think there&#39;s a sweet spot of application types and interactions where\nthis would be immensely useful.  You can argue that you can already do\nthis kind of mapping with HTTP apis defined in terms of the HTTP verbs,\nand that&#39;s true in some cases.  However, I don&#39;t believe that HTTP was\ndesigned to support this particular scenario.  Of course, many people\nhave proven that it can work, but I think there might be a better way.\nPresently, I think that &quot;better way&quot; is based on leveraging hypermedia a\nlot more than I see in most RESTful systems for automated interaction.\n\nI also realize that there&#39;s a ton of implicit assumptions in this\napproach as well, but I am trying to make a concerted effort to keep the\ninteraction assumptions orthogonal to the application assumptions.\n\n&gt; The other thing I&#39;m doing, which is not obvious in the specification,\n&gt; is writing client language bindings for this API (Java, Ruby, Python\n&gt; to start).  You don&#39;t have to use them, but it will make life simpler\n&gt; for you.  In each language, a VM representation is described as a\n&gt; class VM with attributes/properties for all the fields, plus public\n&gt; methods like attach() and detach() that trigger the POSTs to the\n&gt; appropriate URIs, with the appropriately formatted representations.  A\n&gt; client application that leverages a binding like this gets a nice O-O\n&gt; view of the world, and all the stuff we RESTafarians love to argue\n&gt; about is hidden inside a black box :-).\n&gt; \n&gt; I&#39;ll be talking more about client bindings once we&#39;re ready to publish\n&gt; these as concrete examples ... there are some really interesting\n&gt; decisions in how to represent a REST web service programmatically.\n&gt; But I can tell you that the HATEOAS approach has made writing these\n&gt; clients quite a lot easier.\n\nI&#39;m sure that it has, and I think from a pragmatic perspective, you&#39;re\ntaking the right approach to ensure that you&#39;ve both provided convenient\ninteraction mechanisms for existing popular environments and allowed you\n(or someone else) to implement new ones as needed since you&#39;ve an open\n&#39;on-the-wire&#39; protocol and data formats that leverage functionality\npresent in just about every modern language environment (an HTTP client\nimplementation).\n\n\n&gt; &gt; I realize the propsal above isn&#39;t perfect either, but it&#39;s really still\n&gt; &gt; in the embryonic phases at the moment.  However, I plan on actually\n&gt; &gt; working through much of the detail over the next few months, so any\n&gt; &gt; feedback (good, bad or otherwise) is welcome.\n&gt; &gt;\n&gt; &gt; The Sun Cloud API is one of the more interesting ones that I&#39;ve seen\n&gt; &gt; recently, and I&#39;m sure there&#39;s lots to learn from it.\n&gt; &gt;\n&gt; &gt; Nice work.\n&gt; \n&gt; Thanks.  This API is still evolving, by the way, so feel free to\n&gt; provide any direct feedback on the related wiki (free registration\n&gt; required).\n\nIf I have anything specifically related to the API, I will certainly\ntake this approach.\n\n&gt; \n&gt; &gt;\n&gt; &gt; ast\n&gt; \n&gt; Craig\n&gt; \n\nast\n-- \nAndrew S. Townley &lt;ast@...&gt;\nhttp://atownley.org\n\n\n"}}