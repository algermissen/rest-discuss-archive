{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"Ueh0uKgLZOwtF3QzusbxkipDjCb7psJHRXKHvdV4dxNycYsA__NW9sg_lcxGdbJAej4KGmZStx4fHgdxBmWGOdrN-V0Mv05ptORb7qlYsw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Determining which Media type for post/put","postDate":"1275659396","msgId":15535,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNjA0MDc0OTU2LmM5ZTNjMWM1LmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlrTURTRG9ab3hXTzZVTHM2ZURxN0FycHZhZjFMa2RfLUVaVEYyV0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PEFBTkxrVGlsazJZWnJnY2U5M3dYcDlFSjRHZnBpckxlUVZ2bUowSnhjeFBZSEBtYWlsLmdtYWlsLmNvbT4JPEFBTkxrVGltTzROM0ZTeDg5bjR2Sm43RkpsMzJYaC1ERnNZUl93dG5Pd3VYdUBtYWlsLmdtYWlsLmNvbT4JPDNEREQwQkU2NTU4NjlENEVBNTA2NjUyQjM4MDNBRUY2MTU2RDlFNkNAUFJJU00uY2FmZmVpbmUtaXQubmV0Pgk8QUFOTGtUaW5Hc3JWaUdXSUJTWElmd3YxeTY1dDRNbTEyRW1PcXNnNTlONmUyQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExMDUxNTEuZTYzZjgyMmEuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWxIU3RDNWNpU0N5MHg5ZFFmRUJsdHluVld5ZEdLblZlbjZaYm1KQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDExNzU2NDEuZjZhY2FhMjguZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaW5kdzJsN0tDcUpkelh2OU8yLUdGMUtfamM3d1FjanBrbmhIZm5oQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDMwNTE1MDkuYjUxOWI4ZWIuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtrdmZpaGFkMWxVcVNkTmktOFozanppVy0wYjNIUTJTQXNqV2xRQG1haWwuZ21haWwuY29tPgk8MjAxMDA2MDMxNDEyMDguZTAyNjk4N2QuZXJpY0BiaXNvbnN5c3RlbXMubmV0Pgk8QUFOTGtUaWtNRFNEb1pveFdPNlVMczZlRHE3QXJwdmFmMUxrZF8tRVpURjJXQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":15534,"nextInTopic":15536,"prevInTime":15534,"nextInTime":15536,"topicId":15466,"numMessagesInTopic":82,"msgSnippet":"... So what?  We re talking about REST, right?  Which is all about anarchic scalability across organizational boundaries, right?  A smart gateway cache isn t","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 73387 invoked from network); 4 Jun 2010 13:50:23 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m3.grp.sp2.yahoo.com with QMQP; 4 Jun 2010 13:50:23 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 4 Jun 2010 13:50:23 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id E9F21509DC;\n\tFri,  4 Jun 2010 09:50:21 -0400 (EDT)\r\nDate: Fri, 4 Jun 2010 07:49:56 -0600\r\nTo: Mike Kelly &lt;mike@...&gt;\r\nCc: Sebastien Lambla &lt;seb@...&gt;, mike amundsen &lt;mamund@...&gt;,\n Glenn Block &lt;glenn.block@...&gt;, &quot;rest-discuss@yahoogroups.com&quot;\n &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20100604074956.c9e3c1c5.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTikMDSDoZoxWO6ULs6eDq7Arpvaf1Lkd_-EZTF2W@...&gt;\r\nReferences: &lt;AANLkTilk2YZrgce93wXp9EJ4GfpirLeQVvmJ0JxcxPYH@...&gt;\n\t&lt;AANLkTimO4N3FSx89n4vJn7FJl32Xh-DFsYR_wtnOwuXu@...&gt;\n\t&lt;3DDD0BE655869D4EA506652B3803AEF6156D9E6C@...-it.net&gt;\n\t&lt;AANLkTinGsrViGWIBSXIfwv1y65t4Mm12EmOqsg59N6e2@...&gt;\n\t&lt;20100601105151.e63f822a.eric@...&gt;\n\t&lt;AANLkTilHStC5ciSCy0x9dQfEBltynVWydGKnVen6ZbmJ@...&gt;\n\t&lt;20100601175641.f6acaa28.eric@...&gt;\n\t&lt;AANLkTindw2l7KCqJdzXv9O2-GF1K_jc7wQcjpknhHfnh@...&gt;\n\t&lt;20100603051509.b519b8eb.eric@...&gt;\n\t&lt;AANLkTikkvfihad1lUqSdNi-8Z3jziW-0b3HQ2SAsjWlQ@...&gt;\n\t&lt;20100603141208.e026987d.eric@...&gt;\n\t&lt;AANLkTikMDSDoZoxWO6ULs6eDq7Arpvaf1Lkd_-EZTF2W@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Determining which Media type for post/put\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nMike Kelly wrote:\n&gt;\n&gt; Eric J. Bowman wrote:\n&gt; \n&gt; &gt;\n&gt; &gt; When the origin server changes its behavior, caches change their\n&gt; &gt; behavior to match, without needing any knowledge (and definitely\n&gt; &gt; without being able to make any assertions about anything, there&#39;s no\n&gt; &gt; guarantee on the Web that you&#39;ll get fresh data) of the system the\n&gt; &gt; origin server implements to manage its resources.  This is dumb\n&gt; &gt; caching, and it&#39;s proven to scale; why replace it with smart\n&gt; &gt; caching, the coupling of which can&#39;t possibly scale?  REST is all\n&gt; &gt; about leveraging scalable, dumb caching.\n&gt; &gt;\n&gt; \n&gt; Gateway intermediaries/caches within the same organisational domain\n&gt; as the origin server do not have to be &#39;dumb&#39;.\n&gt; \n\nSo what?  We&#39;re talking about REST, right?  Which is all about anarchic\nscalability across organizational boundaries, right?  A smart gateway\ncache isn&#39;t the only architectural solution.  One which needs no\nextensions to work the same way, is a cache connector on the server\ncomponent itself, instead of relying on an external (squid) cache.\n\n&gt;\n&gt; I take it you are not a fan of, say, cache channels then?\n&gt; \n\nTo quote mnot, &quot;Itâ€™s just one more tool in the box.&quot;  This gives squid\nand other caches more kick when used as gateway caches.  Don&#39;t assume\nthat makes it more efficient than a cache connector on the server\ncomponent.  The cache benefits of cache channels don&#39;t apply beyond the\ngateway cache, do they?  It isn&#39;t widely-deployed, proven technology\nlike HTTP 1.1 caching as-is, is it?\n\nSo it has no effect on the anarchic scalability of a REST system beyond\nthe organizational boundary, does it?  If my webhost were to offer it,\nI would implement it, for more effective caching at that one point\n(which impacts my bandwidth charges).  But I would expect it to be\nseveral more years at least, before I can expect PUT to expire the way\nyou&#39;d like it to, due to cache channels, and it still won&#39;t change the\nfact that this is an optimization that only affects 1% of traffic.\n\n&gt; \n&gt; &gt;\n&gt; &gt; These dependencies you speak of aren&#39;t invisible, they&#39;re phantoms.\n&gt; &gt;\n&gt; \n&gt; Ok Eric, if you say so.\n&gt; \n\nThis has nothing to do with my say-so.  You&#39;ve failed to convince\n*anyone* here of your viewpoint, because it&#39;s just wrong.  Cognitive\ndissonance is your inability to accept that, no matter how many times\nyou&#39;re told, even by Roy, as Seb also pointed out.  Don&#39;t troll.\n\n&gt; \n&gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; What does PUT /sales-order/123 do to the html/pdf resources from a\n&gt; &gt; &gt; cache&#39;s point of view, does it invalidate them? It probably\n&gt; &gt; &gt; should, that&#39;s a pretty useful behavior to be able to rely on.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt; First, a cache invalidates only that resource involved in the PUT\n&gt; &gt; transaction -- it probably shouldn&#39;t behave any other way since that\n&gt; &gt; would defeat the entire purpose of REST and be some other, totally\n&gt; &gt; unproven, theoretical architecture bearing no resemblance to the\n&gt; &gt; real-world Web of today.\n&gt; &gt;\n&gt; \n&gt; Are you sure about that? I don&#39;t think REST has anything to say here,\n&gt; provided the mechanism is part of the system&#39;s uniform interface it\n&gt; doesn&#39;t violate any REST constraints.\n&gt; \n&gt; Don&#39;t take it from me, HTTP does this anyway:\n&gt; \n\nThe normative reference for HTTP is not draft HTTPbis.  Anyway, both say\nexactly what I said.  When encountering PUT traffic, a cache invalidates\nthe request URI -- how is this not what I said?  PUT requests don&#39;t\nhave Location or Content-Location headers pointing to other resources\nto invalidate, do they?  Draft HTTPbis adds that extra bit, which\nyou&#39;re right, says that a cache that handled a previous GET can expire\na PUT based on that knowledge, but proving that I can save 2-3% overhead\non 1% of my traffic at some point in the future when caches are upgraded\nto HTTPbis, is really stretching to make a point.\n\nWhat does REST have to say about this?  &quot;Don&#39;t violate HTTP.&quot;  If you\nthink violating HTTP to implement a REST constraint is OK, you&#39;re wrong.\n\n&gt; \n&gt; &gt;\n&gt; &gt; Second, this is one of many uses of the &#39;must-revalidate&#39;\n&gt; &gt; directive.  I serve HTML representations of Atom resources (if you\n&gt; &gt; will) to browsers, but the mechanism whereby content is posted is\n&gt; &gt; based on Atom Protocol. Obviously, updating the Atom resources\n&gt; &gt; updates the negotiated resources, but the way REST architecture\n&gt; &gt; works is that I include &#39;must-revalidate&#39; on negotiated variants\n&gt; &gt; such that they cache-validate properly.\n&gt; &gt;\n&gt; &gt; Granted, this results in overhead, but then again the overall\n&gt; &gt; bandwidth saved dwarfs the bandwidth consumed by &#39;must-revalidate&#39;\n&gt; &gt; traffic (sub- 1K/hit 304 traffic I can serve all day) and renders\n&gt; &gt; the fact that caches can&#39;t expire negotiated resources properly\n&gt; &gt; without it, moot.\n&gt; &gt;\n&gt; \n&gt; If we&#39;re talking about gateway caches, who&#39;s primary purpose is to\n&gt; *reduce demands on origin servers* - hitting the origin server to\n&gt; validate every request doesn&#39;t actually achieve much. There&#39;s\n&gt; different types and levels of caching, all aimed at solving different\n&gt; problems.\n&gt; \n\nIt achieves exactly what my demo shows that it achieves.  You&#39;re\nbitching that my 1KB/hit isn&#39;t 0.9KB/hit, and my cache-hit ratio of 70%\nisn&#39;t 71%.  The bandwidth savings comes from the server not serving\nfiles, not from the server being relieved of those dastardly 304\nresponses.  The &#39;must-revalidate&#39; directive exists, and solves the\nexact caching problem you seem to be having.  That doesn&#39;t make it the\nonly solution, but it does work with all existing caches instead of\nonly the latest version of squid, at a negligible cost compared to its\nadvantages (like being able to cache variants in the first place,\nwithout it resulting in stale responses everywhere).\n\n&gt; \n&gt; &gt;\n&gt; &gt; Optimizing PUT to begin with isn&#39;t really worthwile though, as REST\n&gt; &gt; emphasizes optimizing the hell out of GET because that&#39;s over 99%\n&gt; &gt; of a real-world system&#39;s traffic.  I care more about having those\n&gt; &gt; variants cache properly than I do about having intermediaries\n&gt; &gt; synchronously expire them when one changes -- the coupling required\n&gt; &gt; for such a system would go against fundamental REST architecture --\n&gt; &gt; for the sake of what, you have failed to explain.\n&gt; &gt;\n&gt; \n&gt; My research on gateway cache invalidation provides analysis of caching\n&gt; mechanisms by way of explanation, I&#39;ve already created a thread on\n&gt; this list about it you can contribute to if you disagree or you can\n&gt; comment on the blog post.\n&gt;\n\nThen stop making that blog post the topic of this thread, as you have.\n\n&gt;\n&gt; Given the high degree of threat you feel my\n&gt; perspective poses to the community, I think you have a duty to sort\n&gt; this out in order to prevent me poisoning any more minds with\n&gt; improper thoughts.\n&gt;\n\nNo, debunking your mythology is not incumbent upon me.  It is incumbent\nupon you to convince the REST community of your points, by showing that\nyou grasp the fundamentals, first.  You keep rejecting the fundamentals,\neven when it&#39;s Roy who puts them to you, over the years.\n\n&gt;\n&gt; Perhaps you could hold confession for anyone that\n&gt; has already moved to the dark side?\n&gt; \n\nPerhaps those of you who keep insisting, year after year, that REST is\nflawed and Roy is wrong, could get together and form your own group?\nI&#39;m still waiting for the paragraph-by-paragraph rebuttal of Chapter 5\nfrom y&#39;all.  Until then, engaging with y&#39;all consists of correcting the\nmisinformation you post on rest-discuss for others to read, or putting\ny&#39;all on &#39;ignore&#39;.  I do both, depending on mood.\n\n&gt; \n&gt; &gt;\n&gt; &gt; Some caches, certainly not widely-enough deployed to have an\n&gt; &gt; appreciable impact, will in fact use an internal identifier and\n&gt; &gt; store variants even without Content-Location headers.\n&gt; \n&gt; So what you&#39;re saying is that the HTTP does actually support it, but\n&gt; it&#39;s generally not implemented properly?\n&gt; \n\nNo, HTTP says nothing about how a cache should index its content.  I\nmerely point out that the logical, and in fact most-widely adopted,\nindexing strategy for caches is to use the URIs provided by the origin\nserver.  Some origin servers refuse to send Content-Location with Vary,\nwhich has led some high-end cache vendors to use non-URI cache-index\nstrategies to compensate.  This is why the best-practice rule-of-thumb\nhas been, and likely always will be until HTTP 1.1 is replaced, to send\nContent-Location when you&#39;re sending Vary (for reasons other than\ncompression).\n\n&gt;\n&gt; If the accept header was not intended to be context specific and only\n&gt; intended as a &#39;static&#39; description of UA preferences, why do\n&gt; browsers amend the accept header for script and style element\n&gt; hyperlinks?\n&gt;\n\nReference, please.  What browser does this?  Not that browser behavior,\ni.e. what you can make work, has ever been a measure of RESTfulness...\nsee media-type sniffing.\n\n&gt; \n&gt; If @type was changed to amend the accept header - what do\n&gt; you envisage breaking? How would this prevent your approach from\n&gt; working?\n&gt; \n\nThere exists a separation of concerns between client and server in Web\narchitecture and in REST.  Another example is URI fragments.  Your\nquestion could just as easily be, &quot;Why can&#39;t we change the Web such\nthat clients send URI fragments to servers?&quot;  Because all existing\ncontent was written based on the layered-system constraint, when it\ncomes to things like URI fragments and @type.  When you change the\nsemantics of existing markup, the existing markup (and there&#39;s an awful\nlot of it on the Web) can&#39;t be expected _not_ to break because of that\nparadigm shift, can it?\n\nAside from what would break, changing @type introduces a coupling\nbetween client and server which goes against the layered-system\nconstraint.  Solving problems by violating REST constraints is not how\nI operate.  Building coupled systems, or being forced to build coupled\nsystems if this change is forced through, is what I seek to avoid.\n\n-Eric\n\n"}}