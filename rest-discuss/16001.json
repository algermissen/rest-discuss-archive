{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"1fu8Umv3bA0N9vq1-ocESoszuPWg7fQkop6aUkzKNgYU0DcsCa0lfxfgQoxRLx1XeCnojohw4r8Fbf3FhXOn3BV53YXyBUW7tn9siAXwPA","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Role of JSON, AJAX in a RESTful system design pattern [was WADL as hypertext]","postDate":"1280224562","msgId":16001,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNzI3MDM1NjAyLmQzYmIyZDRmLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4="},"prevInTopic":0,"nextInTopic":16003,"prevInTime":16000,"nextInTime":16002,"topicId":16001,"numMessagesInTopic":4,"msgSnippet":"... I believe these shortcomings were addressed in further debate, mostly on Joe Gregorio s weblog.  For the sake of this discussion, let s assume we are","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 68617 invoked from network); 27 Jul 2010 09:56:34 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m11.grp.re1.yahoo.com with QMQP; 27 Jul 2010 09:56:34 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.sp2.yahoo.com with SMTP; 27 Jul 2010 09:56:33 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 7E2E1509DA\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Tue, 27 Jul 2010 05:56:32 -0400 (EDT)\r\nDate: Tue, 27 Jul 2010 03:56:02 -0600\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100727035602.d3bb2d4f.eric@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Role of JSON, AJAX in a RESTful system design pattern [was WADL as\n hypertext]\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nWill Hartung wrote:\n&gt;\n&gt; In that light, though I want to take Roys example you cited.\n&gt; \n&gt; While using a GIF is a clever media type to use, I think for many\n&gt; folks interested in this data it&#39;s wrong on many levels.\n&gt; \n&gt; First, it&#39;s not a sparse array, as was suggested, it&#39;s just compact.\n&gt; You&#39;re still sending all 1M bits whether it&#39;s 1 user or 10000 user\n&gt; changes. Yes, it compresses, but that&#39;s not relevant as that&#39;s only a\n&gt; transport issue.\n&gt; \n\nI believe these shortcomings were addressed in further debate, mostly\non Joe Gregorio&#39;s weblog.  For the sake of this discussion, let&#39;s assume\nwe are talking about a hierarchical set of data that *is* a sparse-bit\narray and *is* best modeled using GIF.  What the data is, is irrelevant.\n\n&gt; \n&gt; But most importantly, many systems that happen to use the GIF media\n&gt; type DON&#39;T use it at the level for which it&#39;s being suggested.\n&gt;\n\nRight.  But, any component needing to render the GIF can, if that&#39;s\neven called for.  Intermediaries could care less what any GIF represents\nconceptually, only that the bag of binary bits it&#39;s seeing is a GIF.  An\nintermediary might care, which may be a bad thing, in fact the best\nargument against GIF here is that some ISPs&#39; accelerators might convert\nto JPEG, but that&#39;s only a problem above a certain file size, and we&#39;re\navoiding that problem in my forthcoming example with a hierarchy of\nGIFs.\n\nAntivirus intermediaries don&#39;t care about GIF, at least not yet, but\nthey do care about other image formats which have been used as the\ndelivery vector for viruses.  Note that a sparse-bit array could also\nbe modeled as an HTML table, or myriad other media types.  Let&#39;s agree\nto stick with GIF for the sake of argument.  If GIF becomes susceptible,\ninstead of re-architecting the system, we can just be thankful that our\nusers who are worried can implement gateway antivirus.\n\n&gt;\n&gt; Specifically, at the bit level. I don&#39;t know PHP, but is it really\n&gt; straightforward to get the color of pixel 100,100 of a received GIF?\n&gt;\n\nPresumably, GD is being used by the producer, to convert object data\nfrom an array into a GIF (if PHP is a system requirement, then the\nmedia type selected would be PNG not GIF, but I&#39;m going to keep saying\nGIF).  A PHP consumer can determine the color of any pixel, yes.  See\nexample #1:\n\nhttp://php.net/manual/en/book.image.php\n\n&gt;\n&gt; What about Javascript in a browser. Now, perhaps, with the canvas\n&gt; element it can be done, but that&#39;s a pretty recent development. But\n&gt; either way, it sure is a lot of hoops to jump through to find out if\n&gt; bit #100100 is set. Most systems present the artifact instantiated\n&gt; from a GIF datatype as an opaque blob with very simple properties\n&gt; rather than as a list of Bits.\n&gt; \n\nWhy would the GIF images need to be displayed in a browser?  If I\ninclude some JSON in a page, do I display it as JSON?  We&#39;re talking\nabout a system that just happens to use GIF as a data format.  Whatever\ninteresting things we may want to know about that data, as well as how\nto change that data, is a job for the XHTML which describes the GIF-\nbased API to that data.\n\nTrue, there is no declarative way for a browser to generate a GIF\nrepresentation to PUT as a replacement.  But who says we need the\nbrowser to send a GIF to update a GIF?  Or use the URI of a source\ndatum as the endpoint for a change to that datum?  If 100,100 is an\nimportant resource in its own right, assign it a URI.  When that URI is\ntoggled from black to white, the client re-fetches the GIF, which GD\nhas regenerated and to which PHP has assigned a new Etag (if that&#39;s what\nfloats your boat).\n\nBut, let&#39;s bear in mind that Roy&#39;s example was specifically m2m and not\nworry about how a browser would implement GD using Javascript, or\ncanvas, or whatever. In terms of developing and maintaining such a\nsystem, the fact that when I check an interface it responds with a GIF\nI can see, is of real benefit, even if checking the accuracy and\nvalidity of the data contained in the GIF is a different problem.\n\n&gt; \n&gt; We&#39;re actually seeing the phenomenon of reusing data types, even in\n&gt; the SOAP world here in health care. Leveraging a few &quot;common&quot; data\n&gt; formats for many uses. A common data type today is the Document\n&gt; Submission Set payload. It&#39;s based on ebXML, which is used by another\n&gt; standards committee, and therefor adopted by yet another standards\n&gt; committee.\n&gt; \n\nI&#39;ve never actually claimed that SOAP is unRESTful.  OTOH, a RESTful\nSOAP system likely falls into convoluted territory, where architecture\nastronuttery has failed to consider simpler solutions.\n\n&gt; \n&gt; Ideally this is what standard formats are for. But, at the same time,\n&gt; the format is so onerous, that there is already push back from the\n&gt; &quot;simpler&quot; crowd. For a simple exchange, there is a huge amount of\n&gt; &quot;boiler plate&quot; using this format. Just like the pushback from SOAP,\n&gt; and the boiler plate it brings with it (outside of semantics of SOAP).\n&gt; &quot;Why can&#39;t I just send a PDF&quot; they say.\n&gt; \n\nRight.  But a RESTful PDF-driven system, while possible, also falls\ninto the realm of &quot;but why?&quot; since PDF can always be a variant\nrepresentation of a resource&#39;s data, sans the website template of, say,\nan XHTML variant of the same resource.  Just because most media types\nmake sense to represent data, doesn&#39;t mean they&#39;re suited to driving an\nAPI.  PDF, though capable of driving a hypertext API, is still a poor\nchoice.\n\nMaybe I should just come out and be more blunt about this -- there\nexists today only a handful of hypertext media types suitable for\ndriving a REST API.  This is a feature, not a bug!  But there is no\nlimit to the number of media types that this handful can provide a\nhypertext API *for*.  REST requires those data types be at least\nstandardizable, but does not require them to be capable of driving a\nhypertext API -- that&#39;s specifically what HTML (etc.) is (are) for.\n\n&gt; \n&gt; So, standards or no, they&#39;re not necessarily easy to use. Tooling made\n&gt; SOAP &quot;easy to use&quot;. REST is &quot;harder&quot; for many to use because of the\n&gt; lack of tooling. Throwing an XSD against some tools and getting free\n&gt; Java classes is &quot;easier&quot; than crafting and testing DOM code or Xpath\n&gt; queries.\n&gt; \n\nREST will never be easy to use, and makes a mockery of the very notion\nof tooling.  I&#39;ll get to my REST system design pattern, but for now,\nI&#39;ll say that I can build a framework and tooling around this pattern,\nbut I can&#39;t envision such a thing as a general-purpose REST framework or\ntooling.  You can do REST with RESTlet, but some of the things I do\n(without advocating, like variant cookies) with REST can&#39;t be done on\nRESTlet.\n\nMy demo includes a simple PHP httpd I&#39;m going to repurpose as a\nframework for the specific system design pattern I&#39;ve developed for the\nCMS problem space.  Simpler systems (REST&#39;s goal) are more complicated\nto develop. It&#39;s easy to have tooling and framework for &quot;architectures&quot;\nthat are merely buzzwords, where anything goes, than it will _ever_ be\nto come up with some sort of &quot;constraint validator&quot; for REST.\n\nA framework built around my design pattern, will always implement the\nsame REST constraints the same way, from one project to the next.  If I\nwere to build such framework and tooling, I would then proceed to\nspecialize in marketing it to folks whose problem it solves, but then\nI&#39;d be an expert in my framework -- just as some are experts at using\nTypo3, but not otherwise building websites.  Although, if I go this\nroute (my basic plan), REST does become simple for me to use, since all\nthe hard work that went into the framework never needs to be repeated.\n\nIf we can agree that the best way to implement a REST shopping cart is\nto use HTML, +RDFa to express the GoodRelations ontology, then it&#39;s\npossible to come up with a framework and tooling to generate an endless\nvariety of different workflows for different needs, and be able to\nvalidate the results against both schemas and REST constraints.  But,\nthat isn&#39;t the only paradigm for building a RESTful shopping cart, and\nI can&#39;t conceive of a tool or framework that would support all the\npossibilities.\n\nWhat makes WS-* tooling easy to conceive of, is the lack of constraints.\nConsider:  any WS-* standard is *defined* by its tooling -- whatever\nsomeone can actually make work, becomes the standard by which all else\nis judged.  This reliance on coding libraries instead of media types,\nis a significant difference between WS-* and REST, and is exactly what\nleads some to insist that a media type is a contract, from which code\nstubs may be generated.\n\n&gt; \n&gt; That&#39;s where the pressure for many media types are coming from, IMHO.\n&gt; They&#39;re &quot;cheap&quot; to make, and &quot;easy&quot; to use.\n&gt;\n\nWhich is designing for the short-term -- a REST antipattern.  Once one\nunderstands REST, one understands the false economy of &quot;cheap&quot; because\nlong-term maintenance requires training to a non-ubiquitous media type.\n\n&gt; \n&gt; One vision is to model the world you as you see fit, and make the\n&gt; world work with it.\n&gt;\n\naka &quot;unbounded creativity&quot;\n\n&gt;\n&gt; The other is to take the worlds models and make your software work\n&gt; with that.\n&gt; \n\naka &quot;applying constraints&quot;\n\nOr, the mistake could be called, putting your system&#39;s cart before\nthe REST horse.  REST isn&#39;t a better way to do SOA, it&#39;s an anti-\npattern of SOA, which doesn&#39;t come across when most of the chatter\nabout REST puts it in SOA terms.\n\n&gt; \n&gt; Your discussion of using HTML is a simple example. You&#39;ve always\n&gt; mentioned that before, and I never quite groked how you went about it\n&gt; until recently. Effectively what you are doing is using semantic, HTML\n&gt; markup combined with RDFa style annotations to augment the markup, and\n&gt; using that as a representation for your data.\n&gt;\n\nActually, I&#39;m using that as a *variant* representation of my data --\nspecifically, as the variant or variants (XHTML vs. HTML) which drive\nthe API.  Take another look at my demo, because that&#39;s the design\npattern I&#39;m talking about (since it applies to so much more than just a\nweblog, or even a wiki/weblog/forum, while of course not applying to\nall problem spaces or representing a definitive example of REST):\n\nhttp://charger.bisonsystems.net/xmltest/index.axm\n(that&#39;s cross-browser, if you want REST you want the index.xht variant,\nunless you&#39;re using IE)\n\nThe design pattern writ large, is to assign each application state a\nURI and an XHTML stub file containing metadata.  The XHTML calls an XSLT\nprocessor to transform a more application-specific data format into an\nXHTML API suitable for manipulating that back-end format.  I&#39;ve exposed\nmy back-end &quot;business logic&quot; (not rules) as a linked XSLT stylesheet.\nThe back-end data is hierarchical -- by date or by topic, in this\ninstantiation, but it could be anything.  Nothing about this design\npattern requires Atom, just XHTML and XSLT, and it applies to most REST\nproblems I&#39;ve ever considered.  It may be used to implement Atom\nProtocol, or whatever other protocol is needed to interact with the\nback-end data.  I like it so much I&#39;m building a framework around it.\n\nMy data format is Atom.  And yes, Atom is hypertext.  But no, Atom is\nnot the sort of hypertext needed to meet the hypertext constraint\n(unless all you&#39;re doing is GET) -- a collection of Atom entries and\nfeeds is not an engine of application state.  Atom and Atom Protocol\nare no more REST than HTML and HTTP.  REST is about combining ubiquitous\nmedia types in new and different ways.  The power isn&#39;t in any one\nmedia type, but in the combination of media types, just as the power\nisn&#39;t in any one REST constraint, but the interdependence of the\nconstraints.\n\nAny client can interact with my raw Atom in any way it wants to.\nAnyone wishing to develop a client which serendipitously re-uses my\nAtom content, discovers how to make it work by referring to the self-\ndocumenting hypertext API of my (X)HTML variant(s).  That&#39;s why it&#39;s\nthere.  REST doesn&#39;t constrain clients to interact with my system via\nhypertext, but it does constrain my system to provide such an interface.\nThe developer&#39;s manual for a REST API, _is_ the REST API.\n\n&gt; \n&gt; But it still prompted my confusion about identifying the data to the\n&gt; system, since application/xhtml+xml simply doesn&#39;t tell me, at least,\n&gt; enough about how to process the data.\n&gt;\n\nConsider that anything application/xhtml+xml doesn&#39;t tell you, belongs\nsomewhere else, most likely as domain-specific vocabulary that is not\nrelevant at the protocol layer.  At the protocol layer, we only care\nthat a GIF is a GIF -- not whether it&#39;s a picture of a dog, or even a\nsparse-bit array.  It really would help if Roy would at least publish\nhis *notes* on media type design, without that I don&#39;t feel that I or\nanyone else is capable of taking a stab at REST&#39;s missing chapter.\n\nI think the hardest thing to explain about REST, is *why* a media type\nidentifier doesn&#39;t have to say anything about the version of the media\ntype, or any of the application-specific things the &quot;contract crowd&quot;\nwants them to do.  Some guidance from Roy here, is overdue.\n\n&gt;\n&gt; But to your point, it does tell me what it is, and if it were my\n&gt; standard data type, then I would proceed to mine the payload for the\n&gt; interesting attributes.\n&gt; \n\nYou&#39;re right, mining the payload for data is one possibility.  But\nconsider another possibility, that of mining the payload for the URL of\na more application-specific media type, and mining *that* for data:\n\nGoing in, the only knowledge of my demo weblog anyone has is the link I\nposted to it, above (let&#39;s assume .xht).  REST doesn&#39;t eliminate the\nneed for a clue; going in, you also know it&#39;s a weblog which uses Atom\nas its native data format.  The media type advertises that a link is a\nlink, and some of those links may have link relations.  What those link\nrelations are, is not a protocol-layer concern.  If a component needs\nto know that, then the component needs to introspect beyond the headers.\n\nIn an ideal world, the XHTML document&#39;s @profile tells us where to look\nto find the meaning of the link relations used, and the DOCTYPE tells\nus that we&#39;re using XHTML 1.1 extended with RDFa.  In reality, my\nsystem uses the HTML 5 DOCTYPE, because a client-side XSLT system fails\non IE, as IE thinks that means &#39;download the .dtd file.&#39;  I don&#39;t know\nwhat the status is of @profile in HTML5, I just know I like it when\nused properly as a mechanism for defining link relations, i.e. it&#39;s a\ngood place to put this URL, not the sort of thing that needs to somehow\nbe machine-readable or even dereferenced, just as an identifier:\n\nhttp://www.w3.org/1999/xhtml/vocab\n\nUsers, human or machine, have known (and unknown) goals the system\nfacilitates via its REST applications.  As an example, &quot;load the most-\nrecent weblog entry, and its comments.&quot;\n\n(I&#39;ve just decided to change my model, such that links to comment\nthreads are present or absent based on comments being on or off, so\nthat if comments are allowed, there&#39;s still a link even if no comments\nexist -- a 404.  This is not reflected in the demo, where no comments\nmeans no link, for now.)\n\nFor the human, this is easy (or rather, the ease-of-use is dependent on\nvisual design).  Use eyeballs to determine ascending vs. descending post\norder, to find the newest.  Click on the link to the comment thread\n(even if there aren&#39;t any comments, this is one location of several\nsuitable for the post-new-comment form).  Human goal accomplished -- if\nthe application was &quot;load the most-recent weblog entry, and its\ncomments&quot; then that application has terminated successfully upon 200 OK.\n\n&gt; \n&gt; Apparently, that&#39;s what you&#39;re doing, correct? The XML payload that\n&gt; happens to be XHTML is not processed in total. Rather you dig your\n&gt; data out of it guided by XHTML and RDF annotations.\n&gt; \n\nFor the machine, the HTML behind the visual design needs to facilitate\nthe discovery of the most-recent post and its comment thread (if any).\nEach post will present (I&#39;m still working on the markup) a publication\ntime, marked up as both human- and machine- readable, for example &lt;abbr\ntitle=&#39;machine-readable&#39;&gt;human-readable&lt;/abbr&gt;.  RDFa allows that @title\nto be defined as equivalent to atom:published, while scoping it within\nthe &lt;li&gt; for the post.\n\n(I mark up a weblog index page semantically with an &lt;h1&gt; for each\nday, followed by an &lt;ol&gt; of the posts made that day.  The RDFa I&#39;m\ntalking about here is in a state of flux as this is work-in-progress.)\n\nThe machine user is interested in the link to the source of the first\npost, not its comment thread, because unlike the HTML where original\npost and comments may appear together, they are always different\ndatasets in Atom.  By comparing atom:published times (gleaned from\n&lt;abbr&gt; or whatever via RDFa), a machine user now needs to know which of\nthe links in-scope of the &lt;li&gt; points to the standalone weblog entry.\nA link annotated with rel=&#39;dc:source&#39; would be nice, however, this\nmarkup scopes to the page, not the &lt;li&gt; -- so the machine must traverse\na link to find the proper dc:source.\n\nIn the case of my demo, this link is marked up with property=&#39;dc:title&#39;.\nSo, the processing instructions for *which* link meets the criteria,\nare contained within domain-specific vocabulary (in which I&#39;ve re-used\nother standard vocabularies like Atom and Dublin Core).  When a machine\nfollows this link, the XHTML representation returned has a &lt;link rel=\n&#39;dc:source&#39; type=&#39;application/atom+xml&#39;/&gt;.  The machine user understands\nthat Atom has a &#39;replies&#39; link relation.  The machine user follows\ndc:source to an Atom representation containing a rel=&#39;replies&#39;.  The\nsecond 200 OK marks the successful termination of the application.\n\nIf, instead of considering how a machine might &quot;discover&quot; how to\ninteract with my system, we consider how someone unknown to me might\ndevelop their own client component for my system.  I&#39;ve given them a\nmedia type, Atom, for which plenty of standard libraries exist.\nKnowledge of Atom and Atom Protocol alone, however, is not enough to\nderive my system&#39;s API.  What URIs to POST new entries or comments to,\nhow to tag entries with categories, how to add, edit or remove\ncategories -- these unknowns only need to be discovered _once_ by the\ndeveloper, who then codes against these interfaces.  (Of course, his\napp breaks when I change my API, so it would be better to code against\nmy hypertext, so his custom client also updates.)\n\nWhat documentation does this developer refer to, in order to figure out\nhow my system works?  If I&#39;ve done my job correctly as a REST architect,\nthen I have a self-documenting API where all that knowledge is laid out\nin declarative hypertext -- the ultimate DIY handbook.  I read an\ninteresting article recently about the importance of documentation as\ndevelopment tool, instead of as afterthought.  With REST, you document\nyour system as you go, because the declarative nature of hypertext\namounts to &quot;functional documentation,&quot; provided you&#39;re using ubiquitous\nmedia types to encapsulate your out-of-band knowledge.\n\n&gt; \n&gt; Once that decision has been made, XML vs XHTML becomes a bike shed\n&gt; color, and it&#39;s easy to see the extra value XHTML provides &quot;for free&quot;\n&gt; over XML.\n&gt; \n\nI don&#39;t consider it a matter of painting the bike shed.  A vital value-\nadd from XHTML is accessibility you don&#39;t get from XML.  Why *not* make\na self-documenting hypertext API useful to as many humans as possible,\ninstead of only those without disabilities?  In fact, accessibility\nmarkup, by its very nature of being machine-readable, provides further\nstandardized attributes whose use may be included in the domain-specific\nvocabulary (which doesn&#39;t have to be restricted to RDFa).\n\n&gt; \n&gt; XHTML also (potentially) loses the value that things like Schema\n&gt; validation can bring to the table.\n&gt; \n\nI don&#39;t see how, XHTML is XML.  Maybe what you&#39;re saying, is that by\ntransforming Atom to XHTML I lose the ability to validate the Atom-\nness of the output, if I understand you.  But, any transformation of\nvalid Atom to XHTML, may be reversed back to valid Atom -- this, in\nfact, would be how to test a domain-specific vocabulary for expressing\nAtom constructs as XHTML using RDFa.  A schema may then be constructed\nfor the XHTML output, to ensure it validates against what the input\nneeds to be (correctly uses the domain-specific vocabulary for\nexpressing Atom as XHTML) for that XSLT transformation back to Atom.\n\nNot that I&#39;m saying any of that has to do with REST.\n\n&gt;\n&gt; Now, technically, you could make a &quot;sub schema&quot;, where your document\n&gt; IS XHTML, it&#39;s just a specific subset of it that you (the designer)\n&gt; have decided is enough to represent your data. You can schema this,\n&gt; potentially map this (not many mappers do well with XML attributes to\n&gt; specific object slots), etc. &quot;Cake and eat it too&quot;.\n&gt;\n\nWell, sure.  In order for my XHTML output to be not just valid but\naccessible, headings must be properly nested.  The structure of my\noutput dictates that authors be restricted to &lt;h3&gt; - &lt;h6&gt;, while\naccessibility requires authors to nest those properly.  RELAX NG +\nSchematron may be used to validate against not only the subset of\nXHTML *modules* I allow authors to use, but also the &quot;business rules&quot;\nfor using that markup.  Since content is wrapped in Atom, in order for\nthe Atom to validate, the xhtml:div&#39;s must also validate to a subset of\nXHTML (assuming @type=&#39;xhtml&#39;).\n\nIf by losing capabilities of schema, you mean those capabilities of XSD\nthat aren&#39;t duplicated using RELAX NG + Schematron, then I counter that\nthose capabilities are better lost in a REST system.  I&#39;ve never\nunderstood the point of having validation change the document being\nvalidated, and can&#39;t imagine such capability making sense in a REST\nsystem.\n\nNot that this has anything to do with REST, I&#39;m just pushing back\nagainst a perceived pragmatic shortcoming of &quot;my way.&quot;\n\n&gt;\n&gt; If the goal of XHTML is for those intermediaries (i.e. it&#39;s not for\n&gt; the clients benefit, nor the servers benefit), that can work. But if\n&gt; you go this route, you can&#39;t take &quot;arbitrary&quot; XHTML that happens to\n&gt; have your interesting data embedded within it, since the overall\n&gt; document may not match your subset schema.\n&gt; \n\nLet&#39;s not get confused here that I&#39;m only talking XHTML.  I&#39;m making a\npoint about standardized (i.e. ubiquitous) media types.  The REST design\npattern of my demo weblog could just as easily crank out an SVG\ninterface instead of an HTML interface, if that&#39;s what the system calls\nfor.  Back to Roy&#39;s example of the sparse-bit-array GIF, he mentioned\nthat it could be wrapped inside something like Atom, because having a\ncollection of images that you &quot;just know&quot; you can PUT and DELETE isn&#39;t\nthe same thing as a hypertext API.\n\nSo, re-using the system design pattern my weblog demo, the source Atom\ndocuments could be Atom Media Entries linking to sparse-bit-array GIF\nfiles, presented as a hierarchy, with XSLT transforming the Atom into\nXHTML to allow for different presentations of the data.  Or, the GIFs\nthemselves may be what&#39;s displayed, instead of an SVG graph of some set\nof data from the GIFs or somesuch derived from the GIFs.  Perhaps\nclicking on the GIF launches an external client application.  Whatever,\nthe point is that you wouldn&#39;t be re-inventing all those wheels which\nallow a browser to present a user with a selection of GIF files from\nsome server.\n\n&quot;Robert Brewer&quot; wrote:\n&gt;\n&gt; &gt; The point is that you can&#39;t know, another point is that this sort\n&gt; &gt; of thing can only work with ubiquitous media types, and another\n&gt; &gt; point is that this is why REST says to use standard media types --\n&gt; &gt; how _else_ are you going to achieve Web scale, if you go against\n&gt; &gt; how the Web scales?\n&gt; \n&gt; Not to discount your points in the least, but shipping Javascript to\n&gt; the client that then knows how to interpret the custom media-type\n&gt; seems to be a very popular approach to the &quot;how else&quot; these days. It\n&gt; certainly doesn&#39;t promote &quot;serendipitous reuse&quot; for clients that\n&gt; don&#39;t do Javascript &lt;wink&gt;, but for those that do, it leverages one\n&gt; ubiquitous media-type (javascript) to lift another, less ubiquitous\n&gt; one.\n&gt; \n\nThe simplest REST application I can describe would be a slideshow for\nimage/* media types.  Drop a bunch of images, all the same media type\nor mixed, I don&#39;t care, into a directory.  Configure an httpd to serve\nthose images with Link: headers using the standard link relations up,\nprev, next, first and last.  I don&#39;t know if Opera groks Link:, but it\ndoes grok those link relations, and will optionally present a navbar\ninterface, or optionally a fast-forward button, in their presence.\nVoila, REST slideshow with no hypertext in the entity bodies.\n\nIf you&#39;re meeting the hypertext constraint within hypertext content,\nthen you&#39;ve chosen a hypertext media type.  Not images, and not\nJavascript.  Javascript is an imperative programming language, not\ndeclarative hypertext.  There is no such thing as a &quot;link&quot; in\nJavascript, etc., IOW Javascript is a &quot;blackbox&quot; whose media type\nidentifier says nothing more than &quot;executable text/plain&quot;.\n\nThis is not a declarative hypertext link:\n\nxhr.open(&#39;GET&#39;,&#39;./xsl/csi.xsl&#39;,false);xhr.send(&#39;&#39;);\n\nThis is an imperative function.  While it&#39;s obviously a GET of an URL\nto informed eyeballs, its purpose cannot be discerned without further\nintrospection of imperative code.  Is it a link traversal?  Is it an\nasynchronous inclusion?  No fair inferring that it&#39;s an XSLT stylesheet\nto be loaded into the browser&#39;s XSLT processor, from the filename\nextension...\n\nWhen we talk about serendipitous re-use in REST, we mean the API.  We\ndo not mean mootools or Sarissa -- a reusable blackbox is still a\nblackbox.  Javascript is a ubiquitous media type for scripting any other\nmedia type which has Javascript bindings.  Those other media types tend\nto be ubiquitous hypertext types capable of driving a REST API, like\nHTML or SVG.\n\n&quot;wahbedahbe&quot; wrote:\n&gt; \n&gt; Interested to hear your argument against -- I&#39;ve puzzled over where\n&gt; Ajax fits into REST quite a bit. To make a bit of a devils advocate\n&gt; argument for it I&#39;ll say the following:\n&gt; \n\nThere&#39;s no way to assert AJAX to be either REST or NOT REST.  There are\nRESTful uses of AJAX, sure.  Examples of each coming... it&#39;s a hard\nline to draw, as it&#39;s situational.\n\n&gt;\n&gt; The point of code-on-demand is to allow the capabilities of the UA to\n&gt; be extended. Extending it to understand a data format seems like\n&gt; quite a reasonable thing to do.\n&gt;\n\nIt depends.  Modern browsers understand xml-stylesheet Processing\nInstructions.  I use @type=&#39;text/xsl&#39; in the markup, to inform clients\nthat they may process the linked document as such, despite the fact I&#39;m\nserving it as text/xml (to make IE work).  A REST solution would be to\nserve as text/xsl unless IE, ie implement conneg.  Thus, REST gracefully\ndegrading to NOT REST.\n\nI focus my use of AJAX on providing graceful degradation, when it comes\nto data formats.  First, let&#39;s start with a simple use case for RESTful\nAJAX.  My static, demo weblog&#39;s homepage&#39;s first entry says it has 2\nreplies.  If that changes to 3, I want the application steady-state to\nchange to reflect that, without changing the application state (i.e.\nreloading the page).\n\nSo I will mark that up as &lt;noscript&gt;2&lt;/noscript&gt;.  If Javascript is\nenabled, AJAX makes the &lt;noscript&gt; into a &lt;span&gt;, then calls a comet\nsubresource of the weblog entry which exposes @thr:count as JSON.  So\nas long as the homepage application state is loaded, the steady-state\nchanges dynamically to reflect the current data.  The REST application\nstate is actually an unsteady-state, as it consists of multiple open\nconnections.  See the graceful degradation, though?  The worst that can\nhappen is the user needs to re-load a page in Javascript&#39;s absence, to\nupdate thr:count.\n\nThe declarative way to implement my demo-weblog&#39;s client-side XSLT\narchitecture, is to use xml-stylesheet PIs.  These are the only\nbrowsers I intend to support.  However, if I wanted to support older\nbrowsers as well, I&#39;d call the XSLT transformation using the Sarissa\nlibrary.  That library checks for native XSLT support, if not found, it\ncan fall back to AJAXSLT.\n\nXSLT is Code-on-Demand any way you look at it.  As a declarative\nhypertext format, though, it only adds a layer of indirection instead\nof incurring the visibility penalty associated with REST&#39;s optional\nstyle.  The real penalty to visibility is calling the XSLT using\nSarissa, since that&#39;s an imperative blackbox, whether Sarissa is\ncalling an internal XSLT engine or a C-o-D XSLT engine.\n\nGraceful degradation, though.  AJAX in such a case, is being used to\nextend older browsers to understand a ubiquitous media type, and it&#39;s\nthat ubiquitous hypertext media type exposing the API, not blackbox\nJavascript (a Javascript XSLT engine isn&#39;t a blackbox any more than a\nbuilt-in XSLT processor; it&#39;s the code calling such an engine that&#39;s a\nblackbox by comparison to a declarative XML PI).\n\nIs it RESTful to only provide a hypertext interface that relies on\nJavascript to call XSLT?  No.  Will I bitch if you call it REST?  No,\nnot if you&#39;ve recognized your kludge and documented it as such, i.e.\n&quot;At such time as built-in XSLT via XML PI is ubiquitous, this method\nwill be used instead of AJAX to call XSLT transformations.&quot;  As I&#39;ve\nsaid before, REST is your long-term goal, sometimes the Web needs to\nprogress before it&#39;s realized, and sometimes your system needs to scale\nbefore implementing a constraint becomes cost-effective.\n\nIf your system is following a RESTful course that&#39;s been charted, but\nfalls short of REST&#39;s ideals for pragmatic reasons, it&#39;s still REST,\nprovided the shortcomings are documented, like Roy says in his &quot;REST\nAPIs must be hypertext driven&quot; weblog entry.\n\n&gt;\n&gt; Using a base serialization format such as XML or JSON for your data\n&gt; format (as well as the appropriate mime-type) does provide a\n&gt; reasonable amount of visibility as well.\n&gt;\n\nSure.  I&#39;m not saying anywhere *not* to use raw XML or JSON.  But in\nterms of a self-documenting hypertext API, well, you can&#39;t beat the\nvisibility of HTML semantics.  Read on...  If you&#39;ve loaded the\napplication/xml variant of my demo weblog&#39;s homepage, IE or otherwise,\nthe steady-state you&#39;re looking at consists of the following media\ntypes:\n\napplication/xml\napplication/xhtml+xml\napplication/atom+xml (as identifier)\napplication/atom+xml; type=feed\napplication/atomcat+xml\napplication/xbel+xml (coming soon for blogroll.xml)\ntext/xsl (as identifier only)\ntext/xml (as pragmatic kludge, once blogroll.xml is XBEL)\ntext/css\nimage/jpeg\nimage/png\napplication/json (not quite yet, as described above and below)\napplication/javascript (embedded, atm, in two other media types)\ntext/html (unless application/xhtml+xml is used to call XSLT, text/\nhtml is your post-xslt-transformation media type)\n\n(That&#39;s a dozen media types being passed around for REST, 14 for IE\nkludge, just for one steady-state.)\n\nWhat I&#39;ve done, see, is to combine those ubiquitous media types in a\nvery system-specific way (aka &quot;my way&quot;).  Atom Protocol isn&#39;t REST,\nbecause a REST API is more than a definition of what methods on what\none media type yield what response codes (the SOA/IDL view of REST I&#39;m\npushing back against).  OTOH, XHTML has everything I need to create a\nself-documenting hypertext API which _implements_ Atom Protocol.\n\nSo as you can see, the requirement of supporting IE forces me to kludge\naround REST for that browser by using application/xml and text/html,\nwhich otherwise aren&#39;t used in my system.  Note that all browsers, even\nIE, receive /date service payloads as application/xhtml+xml -- in IE,\nXHR treats it as application/xml instead of application/octet-stream.\n\nTake another look at that /date service payload.  Ain&#39;t it a beaut?  If\nyou can find the development doc, it uses CDATA to present what the\nJSON variant will look like.  Splitting hairs, size-wise, particularly\nonce compressed -- the headers take up more bytes than the entity.  The\nJSON is definitely ugly by comparison, and directly transcribes the text\nstrings used in the XHTML variant, for lack of any &quot;XHTML schema for\nJSON.&quot;  Opaque.\n\nThe JSON variant has no semantics.  Kinda the point of JSON.  The XHTML\nvariant&#39;s semantics are common knowledge encapsulated within the\nubiquitous media type.  The appearance of the string &quot;title&quot; in the JSON\nvariant, in no way implies that the next string is the title of the\ndocument.  Without the XHTML variant as a reference, the meaning of the\nJSON variant is opaque -- those text strings could mean anything,\nwhereas in XHTML &lt;title&gt; is unambiguously the title of the document.\nTransparent.\n\nOnce I&#39;ve added conneg back in (/conneg/ instead of /xmltest/ but\notherwise the same resources sans most file extensions), I&#39;ll post my\nexisting Xforms interface for the system.  The challenge is not so much\nin coding Xforms, as making that variant play nice with others...\nanyway, when authoring or editing content, there are places where ISO\n8601 date-string conversion falls to AJAX -- the variant JSON\nserialization on the /date service isn&#39;t REST, it&#39;s a kludge:  the\nXHTML variant could be read, it&#39;s just oh-so-much-easier to read JSON\nin the Javascript context.  Pragmatism, or not bending over backwards\nto be RESTful for the sole sake of calling it REST.\n\nEven if I was only consuming the JSON variant in my application, I\nwould still have that XHTML variant, because REST requires a self-\ndocumenting hypertext API.  With no semantics, the JSON is a bag of\nbits.  With semantics, the XHTML is a *data structure*.  Combined with\nthe Link: header, and the not-yet-built Xforms &quot;service document&quot;, the\nXHTML variants will represent a completed simple RESTful Web Service.\n\nEven with the Link: headers and an AJAX &quot;service document&quot;, the JSON\nvariant (in the absence of the XHTML variant) is NOT REST.  Notice I&#39;m\nnot saying *don&#39;t* use JSON.  Remember, updating post count reads a\nsimple number, exposed as a subresource -- typing isn&#39;t required,\nneither is anything else fancy, this could just as easily be YAML.  No\nsemantics needed.\n\n&gt;\n&gt; There is also a certain amount of native support in the UA for these\n&gt; serialization formats as well. Javascript code that understand the\n&gt; schema and semantics of your XML/JSON is not significantly unlike a\n&gt; script that understand constraints that you&#39;ve put on your HTML(...)\n&gt; \n\nBlackbox Javascript code that takes bag-of-bits JSON and converts it\ninto HTML is NOT REST.  XSLT which declaratively converts any XML\nformat (like Atom, in my demo) into XHTML is REST.  But Atom, like\nXHTML, has semantics which allow the source documents to stand on their\nown.  Same with XML, there&#39;s still a generic parent/child relationship\nthat can be traversed with XPath according to some schema.\n\nJSON lacks such capabilities, perhaps rightly so, as it isn&#39;t supposed\nto have any semantics.  Blackbox AJAX code which asynchronously loads\ncontent from another resource may or may not be REST, read on...\n\n&gt;\n&gt; Where&#39;s the violation of REST&#39;s constraints? I would say you&#39;ve gone\n&gt; too far only when you are using code-on-demand to implement something\n&gt; that the UA already does natively (with little or no gain in\n&gt; non-functional areas such as visible latencies or perhaps\n&gt; portability). Thoughts?\n&gt; \n\nFirst, I agree entirely with Mike&#39;s response to this question in the\nprevious thread.  If your JSON re-invents HTML for the purpose of being\ninserted into HTML documents, then you&#39;re violating self-descriptive\nmessaging, because HTML media types are used to identify HTML content.\nConverting it to JSON is just obfuscating what it really is.  Same with\nreserializing Atom as JSON.\n\nTypically, AJAX violates the identification of resources, self-\ndescriptive messaging, and hypertext constraints.  How many AJAX\nlibraries out there have one URI that loads the AJAX engine, then\nasynchronously loads JSON documents into HTML elements, all without\nchanging the URL when links are followed to new application states?\n\nGranted, those JSON documents have URIs, but are the important\napplication states (i.e. the HTML representations) bookmarkable?  Why\ndon&#39;t they have URIs?  If I dereference one of those JSON documents,\ndoes it link me to its required processing engine, or do I have to\n&quot;just know&quot; that I need to go to the homepage first, to download the\nAJAX engine?  Such libraries are REST anti-patterns.\n\nCompare that to my demo weblog.  The messaging is self-descriptive.\nThe base format is Atom.  The API format is XHTML.  The process of\nloading and executing a transformation from Atom to XHTML is handled by\ndeclaratively calling a document whose very media type identifier\nstates that it&#39;s purpose is to transform XML input to the XHTML of the\ncalling document.  No mystery there!\n\nThere is nothing self-evident about using the ubiquitous media types for\nJavascript and JSON to accomplish the same thing.  If you&#39;re modeling\ndata in JSON that is properly semantically modeled using Atom, then\nconverting it to HTML using ad-hoc code, then you aren&#39;t doing REST --\nif you can achieve the same goals using media types suited to the task,\nbut choose not to, you are violating the self-descriptive messaging\nconstraint, and possibly the hypertext constraint, so you can&#39;t point\nto C-o-D as some sort of loophole.\n\nWhich brings me to my favorite abuse of AJAX -- PUT.  If the forms\nlanguage you are using is HTML 4, then you lack the declarative tools\nnecessary to create a message body of any media type other than\nmultipart, which makes no sense for PUT, and you&#39;re putting PUT where\nit isn&#39;t valid.  Yeah, you can hack your way around this and make it\nwork using AJAX, sure.  But is that a RESTful approach?\n\nNo.  The XHTML media type has been extended to include any HTTP method,\nand define payloads, by Xforms.  Xforms isn&#39;t a media type, it&#39;s a\nguest language for XML host languages (XHTML, SVG).  RESTfully, you\ncode your PUT request properly, using standardized declarative\nhypertext, like Xforms.  User agent doesn&#39;t grok Xforms?  Then extend\nits capabilities using AJAX.  Multiple libraries exist to convert\nXforms code into kludgy HTML 4 forms + Javascript.  (Actually, Xforms\nplugins work better for extending the user agent to grok Xforms\nnatively.)\n\nAgain, graceful degradation.  Xforms clients can understand the native\ncode, other clients can use C-o-D to transform the native Xforms into\nbrowser-specific markup.  But the goal is to extend the client to\nunderstand something that&#39;s standardized.  The converted forms code\nlacks the visibility of the native code, since it&#39;s highly dependent on\nimperative Javascript code.  However, it&#39;s converting declarative code\nthat meets REST&#39;s constraints.  This way, C-o-D is adding a layer of\nindirection, rather than decreasing visibility -- hypertext is still\nthe engine of application state, not Javascript, if the Javascript is\nused to interpret ubiquitous hypertext.  Like with XSLT.\n\nSo it comes down to doing everything you can to avoid C-o-D, instead of\nusing it as a starting point.  If you haven&#39;t done everything you can\nto avoid C-o-D (which will be even more possible with HTML 5), then ur\ndoin&#39; it wrong.  If you&#39;re using C-o-D to avoid re-using one of the\nsubset of ubiquitous media types capable of driving a hypertext API,\nthen ur doin&#39; it wrong.  If there&#39;s a simpler, better way to achieve\nREST without using C-o-D, then your tradeoff isn&#39;t just reduced\nvisibility, you&#39;re obviously trading away constraints as well.\n\nReduced visibility should never be the first tradeoff your REST project\nmakes.\n\n-Eric\n\n"}}