{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"sEkFRtfLGFKSZri5Ro6M0LZm6HYWVWEZYcxgfDn-lbwzAOzrnusdMIlaqO0npYAwQM6SbW-I7tJ3dxptdUxeCoswf6yFMA3UtZcY8iEYuw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] REST isn&#39;t hard to learn, it&#39;s just taught wrong.","postDate":"1261457362","msgId":14321,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDkxMjIxMjE0OTIyLjExNTMwNjJjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEJBNjU3OEYxLTQ3NzgtNDY0Ri1BRUM2LTlDQTYzQzRGMEJCRkBzdWJidS5vcmc+","referencesHeader":"PDIwMDkxMjIwMjEyNjMzLjcxNWNhOTQyLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDg3aXFjMHp6aWcud2wlYmVyZW5kQHBvYm94LmNvbT4JPDIwMDkxMjIwMjI0NjEyLmI4MzVmNTAyLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIwMjI1OTQwLjc1MzdlOTMxLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIxMDAzNjA1LjdjZDkwNzBiLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPDIwMDkxMjIxMTcwNzM1LjZiMzkxOWNlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPEJBNjU3OEYxLTQ3NzgtNDY0Ri1BRUM2LTlDQTYzQzRGMEJCRkBzdWJidS5vcmc+"},"prevInTopic":14318,"nextInTopic":14322,"prevInTime":14320,"nextInTime":14322,"topicId":14255,"numMessagesInTopic":44,"msgSnippet":"... I also just wrote this:  Degrades my API to being a generic HTTP interface, as much as I may wish to call it REST. Oh, it s architecturally sound and all,","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 14018 invoked from network); 22 Dec 2009 04:49:29 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m2.grp.sp2.yahoo.com with QMQP; 22 Dec 2009 04:49:29 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.sp2.yahoo.com with SMTP; 22 Dec 2009 04:49:29 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 895B1509DC;\n\tMon, 21 Dec 2009 23:49:28 -0500 (EST)\r\nDate: Mon, 21 Dec 2009 21:49:22 -0700\r\nTo: Subbu Allamaraju &lt;subbu@...&gt;\r\nCc: berend@..., rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20091221214922.1153062c.eric@...&gt;\r\nIn-Reply-To: &lt;BA6578F1-4778-464F-AEC6-9CA63C4F0BBF@...&gt;\r\nReferences: &lt;20091220212633.715ca942.eric@...&gt;\n\t&lt;87iqc0zzig.wl%berend@...&gt;\n\t&lt;20091220224612.b835f502.eric@...&gt;\n\t&lt;20091220225940.7537e931.eric@...&gt;\n\t&lt;20091221003605.7cd9070b.eric@...&gt;\n\t&lt;20091221170735.6b3919ce.eric@...&gt;\n\t&lt;BA6578F1-4778-464F-AEC6-9CA63C4F0BBF@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.6.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] REST isn&#39;t hard to learn, it&#39;s just taught\n wrong.\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nSubbu Allamaraju wrote:\n&gt; \n&gt; On Dec 21, 2009, at 4:07 PM, Eric J. Bowman wrote:\n&gt; \n&gt; &gt; Sure, this implementation is architecturally sound, but I have to\n&gt; &gt; put up my asterisk stating that this portion of my API is not\n&gt; &gt; standardized, and is therefore not REST.  Currently, by virtue of\n&gt; &gt; Xforms 1.1 allowing\n&gt; \n\nI also just wrote this:\n\n&quot;\nDegrades my API to being a generic HTTP interface, as much as I may\nwish to call it REST. Oh, it&#39;s architecturally sound and all, but the\nREST style requires that standard media types be used for applying\nmethod semantics, so this is clearly not the REST style, even though\nPATCH is now officially part of the generic-interface-method club.\n&quot;\n\n&gt;\n&gt; I must say that this is an extreme interpretation. You are implying\n&gt; that any hint of non-standardness makes an app unRESTful. Not even\n&gt; the underlying standards of the web require such strict adherence. \n&gt; \n\nWe aren&#39;t talking about underlying standards, we&#39;re talking about an\narchitectural style that is based upon the use of an evolving set of\nstandard methods, media types and link relations.  I&#39;m drawing a very\nclear line of distinction between my 100% REST Atom Protocol system,\nand its 0% REST tagging feature.  Standard Atom Protocol clients won&#39;t\nsee anything amiss, and will interoperate with the system to the best of\ntheir abilities, but cannot see the system as a whole.  To participate\nin the tagging activity requires the use of a nonstandard client.\n\nI am harsher with my own work than I am with the work of others; I\ndon&#39;t see my overall API as RESTful because of the tagging feature, but\nif someone else were to have implemented it, I wouldn&#39;t bother\nbringing it up.  The key thing in REST is to optimize the hell out of\nGET. If some non-REST feature isn&#39;t having any effect on GET\nperformance, then it doesn&#39;t really matter that much to the style\n(although it may be critical to the goals of the system). PATCH traffic\nis insignificant compared to GET traffic, so a nonstandard PATCH-based\nfeature can safely be suboptimal.\n\n&gt;\n&gt; Besides being questionable, such an interpretation is not very\n&gt; useful. What is the end goal here? Striving to ensure that an app\n&gt; meet this interpretation, or is it to deliver something of value to\n&gt; the stakeholders? If providing value to the stakeholders requires use\n&gt; of *everything* standard, then that is what should guide an\n&gt; implementation. \n&gt; \n\n(Hypothetically speaking:) The end goal here is what differentiates the\nsystem in a crowded field, the tagging feature.  The Domain Owner wants\na top-flight weblog and believes that this feature will help attract\nAuthors (by socializing the chore of tagging), Members (folks will only\nsign up if there&#39;s something in it for them, like a new toy to play\nwith), and Nonmember Visitors (due to the quality of the content\nprovided by a community of regulars commenting on well-written\narticles, drawn in by the differentiating features like social tagging).\n\nThe Internal Developers want something that any moron who can read a\nspec can maintain, that provides a fundamentally sound platform on\nwhich differentiating features may be created and modified in response\nto user feedback.  They also understand that wide adoption by External\nDevelopers of the protocol underlying the tagging feature, is crucial\nto the success of that feature.  If a proprietary client is required to\nuse it, then it won&#39;t get very far.\n\nThe Internal Developers approach the Domain Owner and sell him on the\nnotion of a REST architecture based around Atom Protocol, due to REST&#39;s\nscalability, efficiency, maintainability and serendipitous re-use.\nWhich is brought about primarily through the decoupling of client from\nserver provided by standard methods, media types and link relations...\n\nAren&#39;t the Internal Developers morally and ethically obligated at this\npoint, to inform the Domain Owner that the tagging feature is based on\na proprietary PATCH protocol, initially only be available via an Xforms\ninterface to users who download and install the necessary browser +\nextension, unless External Developers create custom clients for it?\nThat it meets none of the goals of REST and therefore is a mismatch\nwith the style?  Isn&#39;t the success of this feature critical to the\nproject?\n\nIn order for the overall goals of the system to be met, the PATCH\nextension to Atom Protocol must be standardized.  Only once it&#39;s\navailable as part of the standard libraries, will this system meet its\ngoals, which happen to overlap the goals of a REST architecture.  Until\nthen, any client of the tagging feature is coupled to a single server\nimplementation.\n\nIn order to succeed, the PATCH protocol must gain acceptance by being\nimplemented in other systems (even if the feature is different, say\nauto-tagging instead of social tagging).  Only then will it succeed in\nattracting the developers of existing Atom Protocol clients and\nlibraries.  Only then will it be a candidate standard.  Only then will\nclient be decoupled from server, through the shared understanding of the\nevolution of an existing standard media type to encompass a new method.\n\nIt is absolutely essential that the non-RESTful nature of the PATCH\nprotocol be recognized before the implementation is even considered.\nThe Domain Owner is footing the bill, and must be able to make informed\ndecisions.  In this case, a decision to team with the Internal and\nExternal Developers to create an open proposed standard to include this\nprotocol operation under the application/atom+xml umbrella would be\nrequired for the project to succeed.  Otherwise, the nonstandard nature\nof the key differentiating feature will be the project&#39;s Achilles&#39; Heel.\n\nAnother possible decision, would be to modify existing open-source Atom\nProtocol client code for the new protocol extension, offering pre-\ncompiled clients for different OSs on the website (putting back the\ncode, of course).  The worst decision would be to ignore the REST\nmismatch and move on with a wholly proprietary API that breaks REST&#39;s\nuniform interface. Like the early attempts at manned flight -- it might\ntake off, but it will never fly.\n\nThere are ways to overcome the limitations of nonstandard\nimplementations. But let&#39;s not pretend that not using standard media\ntypes is somehow stylistically compatible with REST, when the benefits\nof that style come from the decoupling of client and server that&#39;s only\npossible _with_ standard media types.  Media types that exist for the\npurpose of interacting with a single implementation, are fundamentally\nat odds with the REST style.  My rule of thumb for creating media types\nremains:  Don&#39;t!\n\n-Eric\n\n"}}