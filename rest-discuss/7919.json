{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":184797058,"authorName":"Benjamin Carlyle","from":"Benjamin Carlyle &lt;benjamincarlyle@...&gt;","profile":"fuzzybsc","replyTo":"SENDER","senderId":"gFld9BJSqZFiVoYeawCFSMGv4H3MplXHef0MePtr4-d1f4A03lTfAGV-NriJmcQAAGZg116DAslKYiec8ze8Pym4vCEf-KpJEVw7Yh-u-tvwI2ttFNXf19w","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: POST at most once","postDate":"1171836062","msgId":7919,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDExNzE4MzYwNjIuNjkyOC42My5jYW1lbEBsb2NhbGhvc3QubG9jYWxkb21haW4+","inReplyToHeader":"PGVyYWU2aSs5Z3MwQGVHcm91cHMuY29tPg==","referencesHeader":"PGVyYWU2aSs5Z3MwQGVHcm91cHMuY29tPg=="},"prevInTopic":7916,"nextInTopic":7921,"prevInTime":7918,"nextInTime":7920,"topicId":7646,"numMessagesInTopic":40,"msgSnippet":"... I was having this thought just last night, and I can t say I disagree :) Just use a PUT and let the client pick a globally unique ID. The server can then","rawEmail":"Return-Path: &lt;benjamincarlyle@...&gt;\r\nX-Sender: benjamincarlyle@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nReceived: (qmail 74884 invoked from network); 18 Feb 2007 22:01:19 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m36.grp.scd.yahoo.com with QMQP; 18 Feb 2007 22:01:19 -0000\r\nReceived: from unknown (HELO mail01.syd.optusnet.com.au) (211.29.132.182)\n  by mta9.grp.scd.yahoo.com with SMTP; 18 Feb 2007 22:01:19 -0000\r\nReceived: from c210-49-75-64.rochd2.qld.optusnet.com.au (c210-49-75-64.rochd2.qld.optusnet.com.au [210.49.75.64])\n\tby mail01.syd.optusnet.com.au (8.13.1/8.13.1) with ESMTP id l1IM13Mj015252;\n\tMon, 19 Feb 2007 09:01:03 +1100\r\nTo: wahbedahbe &lt;andrew.wahbe@...&gt;, Mark Baker &lt;distobj@...&gt;,\n        Mark Nottingham &lt;mnot@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nIn-Reply-To: &lt;erae6i+9gs0@...&gt;\r\nReferences: &lt;erae6i+9gs0@...&gt;\r\nContent-Type: text/plain\r\nDate: Mon, 19 Feb 2007 08:01:02 +1000\r\nMessage-Id: &lt;1171836062.6928.63.camel@...&gt;\r\nMime-Version: 1.0\r\nX-Mailer: Evolution 2.6.3 \r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: Benjamin Carlyle &lt;benjamincarlyle@...&gt;\r\nSubject: Re: [rest-discuss] Re: POST at most once\r\nX-Yahoo-Group-Post: member; u=184797058; y=fPVlkWTvnMpUVu1NA_K_mfZ91zrVNtCAvcBnJAU0go7LcWI\r\nX-Yahoo-Profile: fuzzybsc\r\n\r\nOn Sun, 2007-02-18 at 20:50 +0000, wahbedahbe wrote:\n&gt; Hmmm not sure if I&#39;m over simplifying but in a nutshell these\n&gt; protocols\n&gt; are just trying to repeatedly POST/PUT to a resource identified by a\n&gt; unique id. I think you can just rely on PUT for idempotency and the\n&gt; rest\n&gt; just depends on who you want to generate the id.\n&gt; If the clients can generate unique ids, then why don&#39;t they just\n&gt; repeatedly PUT to http://example.com/&lt;myuniqueid&gt; ?\n\nI was having this thought just last night, and I can&#39;t say I disagree :)\n\nJust use a PUT and let the client pick a globally unique ID. The server\ncan then either continue using the resource the client identified in the\nfirst place for redirect the client for to the &quot;real&quot; name of the\nresource further interactions. I would lean towards the former.\n\nIt&#39;s an interesting perspective that essentially elminates the POST at\nmost once issue by eliminating POST. Do we really need our scruffy\nfourth method?\n\n&gt; If you&#39;d rather the server &quot;allocates&quot; ids then\n&gt; &gt;&gt; POST /factory\n&gt; &lt;&lt; 201 Created\n&gt; &lt;&lt; Location: /factory/&lt;auniqueid&gt;\n&gt; Then then client repeatedly PUTs to\n&gt; http://example.com/factory/&lt;auniqueid&gt;\n\nThis was one of the proposals I wrote up early in the thread, though it\nstill has its problems in terms of server resources needing to be\ncleaned up.\n\n&gt; There seems to be some worry about &quot;reclaiming&quot; an unused id after a\n&gt; period of time, but is that really a concern? You don&#39;t really\n&gt; &quot;allocate&quot; or &quot;do&quot; anything on the POST. You just make sure you never\n&gt; send back the same id twice which isn&#39;t that hard. You don&#39;t even need\n&gt; to keep track of what you&#39;ve sent. If you&#39;re worried about the client\n&gt; making an id up, you could either a) not care -- this is essentially\n&gt; back to the client-generated-id case, or b) sign your ids so you can\n&gt; detect a fraud.\n\nThis would still be an issue if you did the redirection thing, or if the\nresource was destroyed soon after creation. You would need to keep both\nurls around in case the client continued to send PUT requests to their\ndefined url. It&#39;s a horizontal scalability thing. If you need to store\ninformation based on a client request, then you need all of the servers\nin your cluster that might recieve the next request to know that\ninformation before the next request comes in. It&#39;s statelessness between\nrequests, a fuzzy but important constraint in REST. Ignore it at your\nperil, but most of us will need to bend it to varying degrees. The long\nan the short of it is whenever and however far you bend it, make sure\nyou&#39;re getting paid enough to deal with the scalability issues the\nbending introduces.\n\nLet me do the concrete proposal thing again.\n\nProblem statement: (same as before)\nI have some state that I want to append to a resource. The right method\naccording to HTTP is POST, but if I don&#39;t get a response to my POST I\ndon&#39;t know whether or not to retry.\n\nClient algorithm:\n...\nguid = generateCryptographicallySafeGloballyUniqueID();\n// Perhaps this uri template is retrieved from a GET to what would have\n// been our factory resource, or from a broader form that the user\n// filled-out.\nrequest.populateURITemplate(&quot;http://airline.example.com/ticketsales/{user}/{guid}&quot;,user,guid);\nstartOrResetTimer(reasonable resource state retention period, eg 2min);\ntry\n{\nretryPUT:\nfactory.PUT(request);\n}\ncatch (NoResponse) // aka GatewayTimeout\n{\n// One of two possibilities exist. Either,\n// * our PUT didn&#39;t arrive, or\n// * our created resource has been destroyed already\n// We try to ensure that the latter doesn&#39;t\n// happen by giving up after a reasonable\n// period, though we may have confidence that it won&#39;t\n// be destroyed quickly and just keep retrying\ngoto retryPUT;\n}\ncatch (RetentionPeriodTimeout)\n{\n// It is still possible that we could successfully\n// send the request at this point... but it could have\n// been created and destroyed again given the time we\n// have taken so far. We had better give up.\n}\ncatch (...)\n{\n// Normal error handling\n}\n\nIf we get a 201 we know that this is the first successful request. If we\nget a 200 we know that a previous request had already succeeded, but we\nhave successfully changed state. A 410 Gone might indicate that the\nresource was created and then subsequently destroyed. Some other return\ncodes might mean successful delivery, eg Not Modified might play some\npart. However we should probably keep things simple.\n\nI would suggest keeping the URI ranges user-specific for security and\ncross-pollentation reasons. We don&#39;t want one user going and blatting\nover the uri-space and preventing other valid requests from getting\nthrough. Client GUIDs should probably be cryptographically safe to avoid\ngiving away secret information.\n\nServer responsibilities:\n* Don&#39;t destroy the resource too quickly, or the client won&#39;t know for\nsure whether it was created in the first place. Consider leaving a 410\nin place for some time if the resource is destroyed quickly.\n\nBenjamin\n\n\n"}}