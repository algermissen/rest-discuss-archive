{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"NXIFGUsb7-pgARgOALSBjNE61vPSq4o0zGJ_OQA9A4uJzAzovk54Np0jutD-vZ1uAdyE_4PcbWMGzaFVTNeKRmun6VilRgEvoyIwo8i4LQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Combining HTML and XML?","postDate":"1293606058","msgId":17164,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAxMjI5MDAwMDU4LjQzNmY5ZDEyLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PEFBTkxrVGlreFdDaUFpeWM5S0RIRFlGSmdZZ1lKcmRmUU40WV9lSHN4aFF4K0BtYWlsLmdtYWlsLmNvbT4=","referencesHeader":"PDM1NTE1ODMwNUQ5OTRGODJCMkE5MEUyQTFCMDc3NUQ3QEpyblBDPgk8NEQxOUNERDMuNDA4MDVAd2VicjMub3JnPgk8NzIwMDVGQ0U0N0NENEUxQThBRTE1NzdDOURGOTZBQzVASnJuUEM+CTw0RDE5REQ3My45MDEwMjA3QHdlYnIzLm9yZz4JPEFBTkxrVGluaEJ3dW90dmhiNTdHM3gyQV9xbj10RUhLZFRIamZlRThfWVk1VEBtYWlsLmdtYWlsLmNvbT4JPDREMUEyRkQxLjcwMTA1MDJAd2VicjMub3JnPgk8QUFOTGtUaWt4V0NpQWl5YzlLREhEWUZKZ1lnWUpyZGZRTjRZX2VIc3hoUXgrQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":17163,"nextInTopic":17165,"prevInTime":17163,"nextInTime":17165,"topicId":17135,"numMessagesInTopic":57,"msgSnippet":"... No, REST is based on the principle of generality -- this generality is what Roy means by uniform .  Application-specific, or domain-specific, data types","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 77356 invoked from network); 29 Dec 2010 07:00:52 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m13.grp.re1.yahoo.com with QMQP; 29 Dec 2010 07:00:52 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta1.grp.re1.yahoo.com with SMTP; 29 Dec 2010 07:00:52 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id B6C41509D9;\n\tWed, 29 Dec 2010 02:00:50 -0500 (EST)\r\nDate: Wed, 29 Dec 2010 00:00:58 -0700\r\nTo: Peter Williams &lt;pezra@...&gt;\r\nCc: nathan@..., Rest Discussion List &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20101229000058.436f9d12.eric@...&gt;\r\nIn-Reply-To: &lt;AANLkTikxWCiAiyc9KDHDYFJgYgYJrdfQN4Y_eHsxhQx+@...&gt;\r\nReferences: &lt;355158305D994F82B2A90E2A1B0775D7@JrnPC&gt;\n\t&lt;4D19CDD3.40805@...&gt;\n\t&lt;72005FCE47CD4E1A8AE1577C9DF96AC5@JrnPC&gt;\n\t&lt;4D19DD73.9010207@...&gt;\n\t&lt;AANLkTinhBwuotvhb57G3x2A_qn=tEHKdTHjfeE8_YY5T@...&gt;\n\t&lt;4D1A2FD1.7010502@...&gt;\n\t&lt;AANLkTikxWCiAiyc9KDHDYFJgYgYJrdfQN4Y_eHsxhQx+@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.3 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Combining HTML and XML?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nPeter Williams wrote:\n&gt; \n&gt; Of course we are not forgetting uniform interfaces.  Http has that\n&gt; under control.  Even when used with novel media types the interface is\n&gt; still uniform.\n&gt;\n\nNo, REST is based on the principle of generality -- this generality is\nwhat Roy means by &#39;uniform&#39;.  Application-specific, or domain-specific,\ndata types are the opposite of generic data types which apply to any\napplication.  VoiceXML and CCXML may be used to create a uniform phone\ninterface; it would be silly to have separate data types for placing\norders by phone vs. handling customer service by phone vs. banking by\nphone.  The whole point of the style is that this specificity is traded\nfor scalability and other benefits which only accrue to generic data\ntypes.\n\nI have no idea how a generic client like a browser or a phone could\ngain the benefits of the style, if it had to be extended to grok an\nentirely new data type for every application, instead of taking a\n(almost) one-size-fits-all approach.  The Web described by REST is the\none where banking vs. ordering vs. customer service can all be executed\nwithin the same generic user-agent using the same generic media and\ndata types.  The Web where my desktop is cluttered with 100 different\napplication-specific clients (or one seriously-bloated browser) doesn&#39;t\nexist, and certainly didn&#39;t serve as the basis for REST.\n\nIt makes no sense to me that Roy set about to formalize the\narchitecture the Web had already realized, yet wound up describing an\narchitecture where each of these applications was based on its own\nprocessing model for domain-specific types.  Standardization of types\nis the basis of the Web&#39;s success, which is why it&#39;s inherent to the\nREST style derived from that success.  Had the Web been a free-for-all\nof media and data types, and Google could still index it, and Web\naccelerators somehow still worked, then an ex-post-facto description of\nits style wouldn&#39;t have been based on standardization of types as its\nfundamental concern (what other concern does REST mention more than\nonce, let alone in a dozen places).\n\n&gt;\n&gt; Resources are still identified, resources are still manipulated\n&gt; through representations...\n&gt;\n\nHow do I know what the representation means?  If the answer is that\nit&#39;s common knowledge at the IP layer (standardized), then it may be\nREST.  If I have to consult out-of-band documentation explaining a data\ntype I&#39;ve never heard of before because it isn&#39;t standardized, well,\nthat is exactly the opposite of what Roy&#39;s driving at with the style.\nRemoving the requirement for standardization from the thesis, results\nin a different style altogether.  One which is neither based on, nor\nproven by, the Web as it exists in reality.\n\nI just don&#39;t understand how anyone can read a thesis which hammers home\nstandardization as much as REST does, and come away thinking that\ncustom media types have anything to do with it.  Any remaining doubt\nshould be cleared up by the realization that Roy has never given an\nexample of using a custom media type, except to point out that such a\nsolution would need to be standardized as an absolute requirement\nbefore calling it REST.  Resources must be manipulated via\nrepresentations using *standardized* types, there&#39;s nothing invisible\nor optional about the standardization requirement; in fact it&#39;s\nrepeated ad nauseum (leading me to believe it can&#39;t simply be dismissed\nas irrelevant even if systems can be made to work regardless).\n\n&gt;\n&gt; the messages are still self-descriptive, and (assuming the\n&gt; media-type is well defined) hypermedia is still the engine of\n&gt; application state.  The uniform interface section[1] is completely\n&gt; silent on how ubiquitous support of representations needs to be.\n&gt; \n\nYou must be reading some version of the thesis which doesn&#39;t mention\nstandardization as having anything to do with the uniform interface.\nThe version I&#39;m reading is very explicit about uniform=standardized.\nREST doesn&#39;t care how well the media type is defined, REST only cares\nthat this understanding is network-based, not application-specific.  If\nit&#39;s application-specific, then the whole point of the hypertext\nconstraint is missed -- links don&#39;t do any good unless the markup is\nunderstood (like &lt;a href&gt;) at the network layer.\n\n&gt;\n&gt; I fail so see how &quot;separation of concerns, scalability and independent\n&gt; evolvability&quot; come into play regarding this particular design\n&gt; decision.\n&gt;\n\nDoes your API require a custom user-agent, or does it work with generic\nuser-agents?  If the latter, then the concern about processing the\nmedia type *is* a separate concern from your API.  When data type is\nbound to resource type, the data type must evolve with the resource,\ncoupling client to server.  When generic data types are used, client\nand server may evolve independently.\n\nScalability, in terms of REST, doesn&#39;t mean how many hits per second\nyour server can handle -- it means how many components out there can\nparticipate in the communication based on their understanding of the\ndata type.  Using &lt;a href&gt; and an HTML media type for links, achieves\nInternet scale.  Using &lt;foo fetch&gt; with a custom media type disallows\nparticipation by components which grok &lt;a href&gt;, requiring application-\nspecific knowledge to participate -- the opposite of Internet scale.\n\nThis goes for any markup -- a &lt;table&gt; is the same data structure on\nbillions of existing components (i.e. it scales).  Custom object\nserializations are understood by almost nothing by comparison (i.e.\nthey don&#39;t scale).  Standardized &lt;table&gt; markup is consistent across a\nvariety of media and data types.  The principle of generality is where\nscalability comes from -- &lt;table&gt; is generic (uniform).\n\n&gt;\n&gt; The client and server concerns are still separate;\n&gt;\n\nThese concerns are only separate if the media and data types are\nstandardized.  Otherwise they&#39;re implementation-specific, or domain-\nspecific; REST decouples client from server based on a network-layer\nunderstanding of types, stating clearly that nonstandardized types\nrequire a library-based understanding which is defined as coupling, and\nas the opposite of the uniform interface.\n\n&gt;\n&gt; custom media types are just cachable as any other media type;\n&gt;\n\nThis is debatable, and assumes that cachability is the only concern.\nWith standardized types, re-use extends beyond cachability -- as\npreviously discussed, Google does all sorts of stuff with ubiquitous\nmedia types, Web accelerators are based on ubiquitous media types, and\nso on and so forth.  None of which is possible without standardized\ntypes, which is the enabling factor.  REST targets this deployed\ninfrastructure, custom media types bypass it -- a night-and-day\ndifference in scalability.\n\n&gt; \n&gt; The problem with your argument is that custom media types *do* work\n&gt; (in reality).  They work on the corporate network.  They work on the\n&gt; public internet.  They work in a box with a fox.  I know they work\n&gt; from personal experience.\n&gt; \n\nWhat does whether the system works or not have to do with its\narchitectural style?  REST isn&#39;t a value judgment, it&#39;s a set of design\nconstraints.  These constraints aren&#39;t required for a system to work on\nthe Web or off.  They&#39;re required to achieve certain desirable\ncharacteristics, which may or may not be relevant to a given system.\nIf the goals for a system aren&#39;t the same as the goals of REST, then\nusing REST makes no sense.  If they are the same, then the goals of\nREST won&#39;t be achieved using custom media types, because that&#39;s some\nother architecture besides REST, and no evidence exists that any other\nstyle achieves the benefits of REST.\n\nCreating custom media and data types for something HTML can do, has\nabout one billionth as much scalability as following REST by re-using\nstandardized types.  REST isn&#39;t a style for extending any desired\nsemantics across network boundaries, it&#39;s a style for extending a\nlimited set of standardized semantics across network boundaries.  REST\nsays refactor into generic types; customizing types to fit the\napplication is some *other* architectural style, and the two approaches\ncouldn&#39;t be further apart.\n\nWhere in REST _doesn&#39;t_ it say that types are standardized?\n\n-Eric\n\n"}}