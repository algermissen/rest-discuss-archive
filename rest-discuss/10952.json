{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"wLO4ButojLlYdVH0mft6pRtq3mhlyq0NnYp9ZxoAvxSxJvDnl2ho-QyhJ7Roh4R2EJ3mmhyGMeJggM4oGKqo2WC3kxyjdqlS7CTpFvhbXQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] HTTP cookies as unconditional violations of REST","postDate":"1213412600","msgId":10952,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDgwNjEzMjEwMzIwLjFjYWRjNjVlLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PDIwMDgwNjExMjExMzM5LmFhOWEzZmIzNTViZDc2NzM1MjY4OGM2MjE1MDRkZjI0LjUyMjAyNGQ4NzIud2JlQGVtYWlsLnNlY3VyZXNlcnZlci5uZXQ+","referencesHeader":"PDIwMDgwNjExMjExMzM5LmFhOWEzZmIzNTViZDc2NzM1MjY4OGM2MjE1MDRkZjI0LjUyMjAyNGQ4NzIud2JlQGVtYWlsLnNlY3VyZXNlcnZlci5uZXQ+"},"prevInTopic":10951,"nextInTopic":10983,"prevInTime":10951,"nextInTime":10953,"topicId":10920,"numMessagesInTopic":14,"msgSnippet":"... The thing with cookies is, they re out there, man... so all anyone, even Dr. Fielding, can argue against are existing uses of cookies. Like for","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 60876 invoked from network); 14 Jun 2008 03:03:20 -0000\r\nX-Received: from unknown (66.218.67.95)\n  by m54.grp.scd.yahoo.com with QMQP; 14 Jun 2008 03:03:20 -0000\r\nX-Received: from unknown (HELO mxout-03.mxes.net) (216.86.168.178)\n  by mta16.grp.scd.yahoo.com with SMTP; 14 Jun 2008 03:03:20 -0000\r\nX-Received: from BigBison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTP id 479D523E4DA\n\tfor &lt;rest-discuss@yahoogroups.com&gt;; Fri, 13 Jun 2008 23:03:18 -0400 (EDT)\r\nDate: Fri, 13 Jun 2008 21:03:20 -0600\r\nTo: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20080613210320.1cadc65e.eric@...&gt;\r\nIn-Reply-To: &lt;20080611211339.aa9a3fb355bd767352688c621504df24.522024d872.wbe@...&gt;\r\nReferences: &lt;20080611211339.aa9a3fb355bd767352688c621504df24.522024d872.wbe@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 2.4.5 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] HTTP cookies as unconditional violations of REST\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nEtan Wexler wrote:\n&gt;\n&gt; I (Etan Wexler) wrote:\n&gt; \n&gt; &gt; &gt; Maybe my premise is wrong and cookies are not a mechanism for\n&gt; &gt; &gt; associating requests with a session maintained on an origin\n&gt; &gt; &gt; server. Maybe cookies pass arbitrary information from origin\n&gt; &gt; &gt; server to user agent and back. If that is so, then the use of\n&gt; &gt; &gt; cookies still violates the constraint of self-descriptive\n&gt; &gt; &gt; messages, because cookies are not self-descriptive at all.\n&gt; \n&gt; Aristotle Pagaltzis responded (in\n&gt; &lt;http://tech.groups.yahoo.com/group/rest-discuss/message/10925&gt;):\n&gt; \n&gt; &gt; So cookies violate they constraint because they violate the\n&gt; &gt; constraint? You have begged the question but not actually given\n&gt; &gt; any reason for your claim.\n&gt; \n&gt; If cookies are vehicles for passing arbitrary information, as you tell\n&gt; me that they are, then it is the arbitrary nature that prevents\n&gt; self-description. User agents and intermediaries are unable to\n&gt; determine whether a cookie carries authentication credentials, a\n&gt; reference to session state, a directive to override the method, or\n&gt; something else. In terms of desirable properties, the effect is to\n&gt; reduce visibility, thus reducing cacheability, thus reducing network\n&gt; performance.\n&gt; \n&gt; I truly struggle to explain my point because, to me, it seems\n&gt; extremely obvious. Yeah, if an application fails to conform to a\n&gt; constraint, then it has violated the constraint. I don&#39;t see\n&gt; self-descriptiveness as a default for data. On the contrary, I see\n&gt; that it takes nontrivial effort on the part of designers to craft\n&gt; self-descriptive data. If you agree that self-descriptiveness is not\n&gt; a default for data, then the onus is on the people who find cookies\n&gt; in harmony with REST to show how cookies are self-descriptive. If you\n&gt; disagree and posit that self-descriptiveness is the default for data,\n&gt; then I would ask that you provide some evidence for your claim.\n&gt; \n\nThe thing with cookies is, they&#39;re out there, man... so all anyone,\neven Dr. Fielding, can argue against are existing uses of cookies.\nLike for authentication.  But once again, absolute law isn&#39;t the order\nof the day around here, we prefer the jury system (or as some would say,\nREST is the Pirate Code).  In that spirit, we recognize that basing\nopposition to cookies in general, based on shortcomings in the realm of\nauthentication (i.e. security and privacy) or any other singular\nevidence, would be to commit a logical fallacy by stating that any use\nof cookies is a risk to security and privacy.  Or, as the case may be\nin section 6.3.4.2, that any use for cookies will ever be devised which\ndoesn&#39;t break the &#39;back&#39; button.\n\nREST does provide architectural guidelines a Web system may be compared \nagainst, for the purposes of identifying and avoiding scaling issues\nthrough judicious use of caching, avoiding stateful connections, and the\nlate binding of representations to resources (Content Negotiation).  But\nhere&#39;s the flaw in conneg... this is my local IE 6 install&#39;s User-Agent\nheader -- this week, bound to change every time Windows Update runs:\n\nMozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; formsPlayer\n1.5; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET\nCLR 3.0.04506.648)\n\nEvery Web cache I&#39;m familiar with, when encountering Vary: User-Agent, \nwill create separate entries for every User-Agent string it encounters, \nfor IE alone the possibilities are almost endless.  But the only reason \nI&#39;m sniffing the User-Agent string in the first place, is to detect\nIE. Beyond that I don&#39;t particularly care about version, or extensions,\nor the user&#39;s .NET version (if any, but caching is flawed without it).\nSo, in terms of REST my application&#39;s negotiated content is already\nlimited to HTTP 1.1 caches, with this &quot;cache alias&quot; problem I&#39;ve\ndescribed... not good!  But there is a solution, using cookies...\n\nBy storing the coarse-grained result of content negotiation in a\ncookie, and responding to requests with this cookie by sending &#39;Vary:\nCookie&#39; instead of &#39;Vary: User-Agent&#39;, the cache alias problem is\ncleaned up and the application benefits exponentially in terms of\nscale -- because all visitors&#39; IE installations are assigned the same\ncookie, and cache-control is Public.  This is storing the results of\nconneg, which is not application state.  All variant representations\nreflect the same application state, regardless of cookie values.\n\nOnce a user-agent has obtained a cookie (which expires after a time\ninterval), it knows how to directly request its desired variant,\nbypassing content negotiation (less CPU cycles on the server) -- if\nthe request even *gets* to the origin server.  Intermediaries, unless\ncookied content is configured as uncacheable, know which variant to\nserve, without needing to know the conneg algorithm.  Less CPU, less\nbandwidth, a fraction of the usual penalties for implementing very\nRESTful Content Negotiation, with none of the downsides Roy talks about\nin 6.3.4.2...\n\nYet I should shun this contraption for purely stigmatic reasons?  ;-)\nYou&#39;ll have to do better than that!  Your point about self-descriptive \nmessages is a good one, and in fact all the arguments against cookies\ncite examples where cookies are used to maintain state. However, my\noverloading (hijacking?) of cookie headers to function as cache-\ncontrol headers violates nothing in section 5.2.2, specifically:\n\n&quot;All REST interactions are stateless. That is, each request contains\nall of the information necessary for a connector to understand the\nrequest, independent of any requests that may have preceded it. This\nrestriction accomplishes four functions: 1) it removes any need for the\nconnectors to retain application state between requests, thus reducing\nconsumption of physical resources and improving scalability; 2) it\nallows interactions to be processed in parallel without requiring that\nthe processing mechanism understand the interaction semantics; 3) it\nallows an intermediary to view and understand a request in isolation,\nwhich may be necessary when services are dynamically rearranged; and,\n4) it forces all of the information that might factor into the\nreusability of a cached response to be present in each request.&quot;\n\nThe point is, stateless uses of cookies (and I&#39;ve seen a few) shouldn&#39;t\nbe shunned for using cookies, when the reason cookies aren&#39;t normally\nthought of as RESTful comes with the assumption that all uses of\ncookies result in stateful connections.  My method has no cookie-\nderived security concerns, as they are stateless, nor does it have\nprivacy concerns, as &#39;view=html&#39; is opaque and at most reflects what\nsort of browser a visitor is using.\n\nWhat if cookies are disabled on the client?  Well, since the response\nis public and cacheable anyway, such a client will always have to hit\nthe origin server to renegotiate, even when actual content is delivered\nby an intermediary (with a far lower probability for a match based on\nVary: User-Agent).  So the worst-case scenario in my case, is the\nstatus quo scenario for using conneg to do browser detection.\n\nIf cookies are disallowed on an intermediary, that intermediary won&#39;t\nbe caching my negotiated content based on the cookie header.  It should\nfunction exactly as it would if no cookies were involved, i.e. cache\nbased on User-Agent string, which is far less efficient as time goes on\ndue to the proliferation of little differences between installations in\ncertain products.  Again, the worst-case scenario is the status quo.\n\nOh, and it took some tinkering with cache-control settings, but the\n&#39;back&#39; button now functions properly in my setup and pulls content\ndirect from browser cache without &#39;pinging&#39; the origin server (the user\ncan always reload the cached page).  Before, there was considerable\nlatency involved with the &#39;back&#39; button, which I considered broken.\n\nSorry, the example links I&#39;ve posted previously aren&#39;t working, there\nwere several regression errors in the final update of the alpha.  At\nsome point there will be a beta, until then we don&#39;t have the resources\nto bother fixing the somewhat-broken alpha, or the /date web service.\n\nEtan Wexler wrote:\n&gt;\n&gt; Peter Keane wrote (in\n&gt; &lt;http://tech.groups.yahoo.com/group/rest-discuss/message/10935&gt;):\n&gt; \n&gt; &gt; There is\n&gt; &gt; no significant distinction (in this specific case) between the\n&gt; &gt; server giving the client a form or a uri template or a cookie that\n&gt; &gt; the client can then use to create a request.\n&gt; \n&gt; I&#39;ll presume that you mean that the form or the URI template would be\n&gt; in a representation with a media type that identifies the form or URI\n&gt; template as such. And therein is the significant distinction. A\n&gt; REST-conformant user agent would process the form or URI template and\n&gt; present it decently to the user only because the media type dictates a\n&gt; set of shared conventions. (For example, HTML documents in the World\n&gt; Wide Web are HTML documents because their media-type label is\n&gt; &quot;text/html&quot;. If one changes the label to &quot;text/plain&quot;, the entity body\n&gt; has lost most of its meaning and is no longer HTML.) The cookie is\n&gt; opaque to the user agent (and to connectors and to intermediary\n&gt; components).\n&gt; \n\nI&#39;m not sure what you&#39;re saying, here.  The URI is opaque to all of the\nabove, just like cookies.  In REST, the server delivers algorithms to\nuser-agents, which derive state changes (links, form submissions) which \nare presented to the user, from said algorithm.  Header fields are not\noff-limits.  If a response header has no meaning to the user-agent,\nfine, but this doesn&#39;t mean a script can&#39;t refer to it to build a URI.\n\n&quot;The important bit is that the algorithm is defined by the server\nand the resource remains accessible regardless of how the URI\nwas calculated (i.e., the result of the algorithm is bookmarkable).&quot;\n\nhttp://tech.groups.yahoo.com/group/rest-discuss/message/10027\n\nIn my system, the cookie expires quickly, but any page bookmarked after\nthe cookie was assigned will be valid long after the cookie has\nexpired, the only consequence is that the client must re-negotiate with\nthe origin server.  I don&#39;t understand why the natural behavior of\ncookies is a bad thing to exploit for RESTful purposes, IOW there&#39;s no\nreason I can see why cookies being opaque to the client is a Bad Thing.\n\nMy cookie headers would normally be ignored by intermediaries, except\nby sending &#39;Vary: Cookie&#39;, which explicitly makes them cache headers.\nJust like sending &#39;Vary: User-Agent&#39;, which is also normally ignored by\nintermediaries, makes it a cache header.  So this is typical behavior in\na RESTful system, even if my choice of headers to Vary is atypical...\nunless it breaks an actual REST constraint, implementing anything in\nHTTP goes, IMHO.\n\n-Eric\n\n"}}