{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":272793929,"authorName":"Kevin Duffey","from":"Kevin Duffey &lt;andjarnic@...&gt;","profile":"andjarnic","replyTo":"SENDER","senderId":"HGJap_EOZidCdbJakwKc5INtoO77CfOyoEk49JYn0R6CjzA2ZYH4Jpg-ii-SRZJ_UsvZ0X5O2VNz9gWugBy_uhcIQZeXRl1OGQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Link relations [was: A media type for case files, dossiers and documents]","postDate":"1291390020","msgId":17017,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDkyMDI1NC43NDQ2Ni5xbUB3ZWI1NTkwNi5tYWlsLnJlMy55YWhvby5jb20+","inReplyToHeader":"PEFBTkxrVGltSGZXUVBzVURNLTUtOWt5RzhtRkNXPXM4S3R1Zzk5dnNNMHdhZUBtYWlsLmdtYWlsLmNvbT4="},"prevInTopic":17016,"nextInTopic":17018,"prevInTime":17016,"nextInTime":17018,"topicId":16947,"numMessagesInTopic":88,"msgSnippet":"Mike, a most excellent response.. very well said, again I have a better understanding of all this thanks to you and Eric. Here I thought I was implementing","rawEmail":"Return-Path: &lt;andjarnic@...&gt;\r\nX-Sender: andjarnic@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 22091 invoked from network); 3 Dec 2010 15:27:01 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m11.grp.re1.yahoo.com with QMQP; 3 Dec 2010 15:27:01 -0000\r\nX-Received: from unknown (HELO nm25.bullet.mail.ac4.yahoo.com) (98.139.52.222)\n  by mta2.grp.re1.yahoo.com with SMTP; 3 Dec 2010 15:27:01 -0000\r\nX-Received: from [98.139.52.191] by nm25.bullet.mail.ac4.yahoo.com with NNFMP; 03 Dec 2010 15:27:01 -0000\r\nX-Received: from [98.139.52.147] by tm4.bullet.mail.ac4.yahoo.com with NNFMP; 03 Dec 2010 15:27:01 -0000\r\nX-Received: from [127.0.0.1] by omp1030.mail.ac4.yahoo.com with NNFMP; 03 Dec 2010 15:27:01 -0000\r\nX-Yahoo-Newman-Property: ymail-3\r\nX-Yahoo-Newman-Id: 67556.87530.bm@...\r\nX-Received: (qmail 94472 invoked by uid 60001); 3 Dec 2010 15:27:01 -0000\r\nMessage-ID: &lt;920254.74466.qm@...&gt;\r\nX-YMail-OSG: LbNFGdUVM1kx0VA9F0syh1nwW_LYxKtczQwA9EnSH9.rMjH\n Sdvp_pfPo6rDRly7mXiiF0fv1axC4molluzr11kIeLvu.yhPTlWn1iAgmnEE\n f0UL2Fqnp6DfefskrCD6mp5Kt2QDvLvqKZNom7iyUZTFGr5qwlUa41pjCyzl\n WNls_KKM.xMYTFHUJl05gpmSCwBC_4oIxZaxAevTPycIJm6C1nFifDs7wb3P\n PuoW1FI7xAtkE.3p6Y_xaHcnhcUJC72bJmlFbvIvxCovFynnIXHxNIgdbZcb\n 2HmXCA211tyQbp6VzrEBlE3xg2qPDv0rLQmpbN_iBUhdto1yJXeZhp2.0ZQ-\n -\r\nX-Received: from [99.22.138.61] by web55906.mail.re3.yahoo.com via HTTP; Fri, 03 Dec 2010 07:27:00 PST\r\nX-Mailer: YahooMailClassic/11.4.20 YahooMailWebService/0.8.107.285259\r\nDate: Fri, 3 Dec 2010 07:27:00 -0800 (PST)\r\nTo: Rest Discussion List &lt;rest-discuss@yahoogroups.com&gt;\r\nIn-Reply-To: &lt;AANLkTimHfWQPsUDM-5-9kyG8mFCW=s8Ktug99vsM0wae@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative; boundary=&quot;0-677474689-1291390020=:74466&quot;\r\nFrom: Kevin Duffey &lt;andjarnic@...&gt;\r\nSubject: Re: [rest-discuss] Link relations [was: A media type for case files, dossiers and documents]\r\nX-Yahoo-Group-Post: member; u=272793929; y=oX9Q4scmX_uBvdunqoRqLDEomaDoXQlPY6iaicVn4id3-j0I\r\nX-Yahoo-Profile: andjarnic\r\n\r\n\r\n--0-677474689-1291390020=:74466\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nMike, a most excellent response.. very well said, again I have a better und=\r\nerstanding of all this thanks to you and Eric.\n\nHere I thought I was implem=\r\nenting HATEOAS by providing links back in my response and a single entry po=\r\nint for all consumers to initiate their communication with my api. \n\nI tota=\r\nlly get the concept of an evolving api breaking clients. Because of that, i=\r\nt was my impression that providing versions of your api prevent that, at le=\r\nast to some degree. Clients using v1, continue to use v1 until they are rea=\r\ndy to be written to use v2, or..they just stay on v1. Like most software th=\r\nat adheres to major version changes as major feature changes, a v2 would be=\r\n something probably quite a bit different.. different response formats, per=\r\nhaps... but by using links in the responses, I can, from my api, direct cli=\r\nents to new resources if need be. Perhaps the old /orders is no longer vali=\r\nd.. we have a /neworders to handle all kinds of new data. Since all the cli=\r\nents use the links elements to navigate based on the rel=3D&quot;&quot; value, they s=\r\nhouldn&#39;t break, that I know of. Well.. to be fair, if the response format c=\r\nhanges, then yes, they would break.. but if you keep the response format th=\r\ne same but modify the resources called via the links, then the\n clients wil=\r\nl &quot;evolve&quot; with the api automatically. \n\nWhat I am having a hard time swall=\r\nowing is providing an API that returns data as HTML. I think it&#39;s going to =\r\nbe hard to go out there and tell consumers, &quot;here is my api, which returns =\r\nHTML, but not for visual use.. you have to parse the HTML yourself, even th=\r\nough your not a browser.. you&#39;re going to become a browser basically, in or=\r\nder to use my api&quot;. This just seems hard to get acceptance or by in by pote=\r\nntial consumers. I would imagine most consumers of apis are expecting xml o=\r\nr json, and to get back html, and have to actually parse it at least to me =\r\nI&#39;d be questioning why html, which as far as I knew was used to display dat=\r\na in a visual manner, is being sent back for me to parse to use the data in=\r\n it.\n\n\n\n--- On Fri, 12/3/10, mike amundsen &lt;mamund@...&gt; wrote:\n\nFrom:=\r\n mike amundsen &lt;mamund@...&gt;\nSubject: Re: [rest-discuss] Link relation=\r\ns [was: A media type for case files, dossiers and documents]\nTo: &quot;Kevin Duf=\r\nfey&quot; &lt;andjarnic@...&gt;\nCc: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;, &quot;R=\r\nest Discussion List&quot; &lt;rest-discuss@yahoogroups.com&gt;, juergen.brendel@muleso=\r\nft.com\nDate: Friday, December 3, 2010, 2:08 AM\n\nKevin:\nI&#39;ve been doing quit=\r\ne a bit of work in the area of making decisions on how to code clients for =\r\nInternet apps. Your comments about how XHTML seems inappropriate remind me =\r\nof a set of decisions we all make (consciously=A0or not) about implementing=\r\n solutions for Internet apps. Here&#39;s a peek into one aspect of my current t=\r\nhinking on this. Hopefully it hits some of teh points to raise and provides=\r\n some ideas on how you can approach your decision-making.\n\nNOTE: I cover so=\r\nme of this in a talk and the slides (and C# code) for that talk are here:ht=\r\ntp://amundsen.com/talks/#beyond-web20=A0=A0\n\nCONSIDERATIONSWhen coding clie=\r\nnts for application-level protocols (HTTP) over distributed networks (i.e. =\r\nthe &quot;Web&quot;), these things (among others) must be taken into account:\n1 - how=\r\n does the client know all the addresses (URIs) that will be needed to execu=\r\nte operations? =A02 - how does the client know how to properly construct sp=\r\necific requests (searches, filters, etc.) to send to the addresses?\n\n3 - ho=\r\nw does the client &quot;understand&quot; the responses returned from those requests?4=\r\n - how does the client know the order in which these actions (requests/resp=\r\nonses) must take place (you can&#39;t create a new order until you create a new=\r\n customer, you can&#39;t register more than ten pending orders per day, etc.).\n=\r\n\n\nYou have two general approaches:=A0- code these details into the client (=\r\nnon-hypermedia) and re-code the client when the details change or;\n- code t=\r\nhese details into the message (hypermedia) and reformat the message when th=\r\ne details change.\nA NON-HYPERMEDIA APPROACH:1 - When coding the client appl=\r\nication programmers will get a long list of URIs (from documentation) and h=\r\nard-code them into the client application or encode the URI list in some st=\r\natic config file, etc. and make that available to the client code. It&#39;s pos=\r\nsible that some URI construction rules can be used instead of a static list=\r\n. Then programmers write code that knows how to execute the construction ru=\r\nles at runtime based on the state of the client, etc. The client applicatio=\r\nn will also have some rules in code in order to associate each fixed/constr=\r\nucted URI w/ some &quot;action&quot; (get a user record, search for users added last =\r\nweek, add a new user, etc.) and the client code will select the proper addr=\r\ness at runtime based on the state of the client, etc.\n\n\n2 - When sending re=\r\nquests from the client to the server (the &quot;actions&quot; mentioned in #1 above),=\r\n programmers will write code that knows the format details of the message (=\r\nXML, JSON, CSV, etc), the layout details (XML elements named &quot;email&quot;, &quot;hat-=\r\nsize&quot;, etc.), which elements are required, optional, etc. Programmers will =\r\nwrite code that, at runtime, associates client state with each of these &quot;fi=\r\nelds&quot;, populates the structures and sends them to the proper URI (from #1).=\r\n\n\n\n3 - When=A0receiving=A0responses, client applications know, ahead of tim=\r\ne, what to format expect (XML, JSON, etc.), the exact layout of each respon=\r\nse (elements and attributes, etc.), and how to render them visually for hum=\r\nans (or arrange the data returned in the proper memory &quot;slots&quot; for M2M apps=\r\n).=A0\n\n\n4 - The client application will have all the rules for application =\r\nflow hard coded. It will &quot;know&quot; that customers cannot have more than ten pe=\r\nnding orders or that order detail lines can&#39;t be sent to the server before =\r\nan order document is created, etc.\n\n\nWhen using the this approach, changing=\r\n any of those items over time (new addresses for new requests that return n=\r\new responses in a new=A0application-flow order) will require re-coding the =\r\nclient and re-deploying that new code to replace all the existing &quot;old&quot; cli=\r\nent code.\n\n=A0A HYPERMEDIA-DRIVEN APPROACHUsing Fielding&#39;s REST style as a =\r\nguide (&quot;hypermedia as the engine of application state&quot;):1 - The goal is to =\r\nreduce the number of addresses to the fewest reasonably possible. One pre-e=\r\nstablished address is a nice goal - the &quot;starting&quot; address. After that, all=\r\n other addresses are expected to come in the responses. XHTML has a built-i=\r\nn element for this data - the anchor (&lt;a ... /&gt;) tag.=A0\n\n\n2 - The informat=\r\nion about what fields to use when crafting a request are contained in the r=\r\nesponses to requests, not hard-coded in the client application. XHTML has b=\r\nuilt-in elements for this, too. FORMs w/ INPUT, SELECT, and TEXTAREA elemen=\r\nts. Clients know ahead of time how to handle each of these elements; they a=\r\nre universal for all types of requests (for users, customers, stores, order=\r\ns, etc.). Also, the FORM element has the associated URI for this action whe=\r\nn the client=A0receives=A0the response so there is no need to hard-code any=\r\n other URIs in the client, either.\n\n\n3 - The information about what fields =\r\n& layouts to expect in responses and how to &quot;render&quot; them is also included =\r\nin XHTML. Like the FORM elements, response elements are generic and of a li=\r\nmited set. Clients to do not need to know a set of specific data elements (=\r\n&lt;email /&gt;, &lt;hat-size /&gt;, etc.) and when to expect them and how to render th=\r\nem. Instead, client code is written to know how to render the generic set o=\r\nf elements (DL, DT, DD, DIV, SPAN, TABLE, etc) in a response.\n\n=A04 - The r=\r\nesponses carry the &quot;next possible steps&quot; for the application flow. XHTML el=\r\nements such as &lt;a /&gt; and &lt;form /&gt; will appear when it&#39;s appropriate (the re=\r\nsponse to create order will have links/controls to create order lines, once=\r\n ten pending orders are created for a customer, the response will no longer=\r\n in include a &quot;create pending order&quot; link, etc.).\n\n\nWhen using the second a=\r\npproach, new addresses for new requests that return new responses w/ new ap=\r\np-flow=A0details=A0will not require changing the client code. Because all t=\r\nhat information is included in the responses; the media type (XHTML) has &quot;a=\r\nffordances&quot; for carrying that application control information (&lt;a /&gt;, &lt;form=\r\n /&gt;, etc.) within the responses. =A0XHTML has an advantage due to it&#39;s buil=\r\nt-in hypermedia controls. XML and JSON do not have these.=A0\n\n\nCHOOSING WHI=\r\nCH APPROACH TO USENow, it may turn out that you are creating an=A0applicati=\r\non=A0that:1) has only one address2) has only one request format3) has only =\r\none response format\n4) has only one possible application flow\n\nIf that&#39;s th=\r\ne case, you don&#39;t need the advantages that a hypermedia-driven implementati=\r\non affords; all that work may be overkill and waste. Using a non-hypermedia=\r\n format (e.g. CSV, XML, JSON, etc.) and hard-coding the details in the clie=\r\nnt will work much better with less overall effort.\n\n\nOr, you may have a sma=\r\nll set of addresses, or a small set of request formats, or a small set of r=\r\nesponse formats, or a small set of app-flows. Now you need to think a bit m=\r\nore on whether your varying set of addresses, request and response formats,=\r\n and app-flows are numerous enough to make it worth while to adopt a hyperm=\r\nedia-driven implementation or stick to hard-coding clients.\n\n\nOr you may ha=\r\nve an application where, even w/ a wide range of address, requests, respons=\r\nes, and app-flows, these values hardly change over the life of the applicat=\r\nion (days, weeks, years, etc.). Does it make sense to use a hypermedia-driv=\r\nen implementation if the formats never change?\n\n\nOr you may be the only one=\r\n writing the client. Just like it&#39;s often more effort to document a simple =\r\napp than build it, using a hypermedia-driven implementation in order to nev=\r\ner change the code that you yourself could write more quickly and efficient=\r\nly anyway may be too much effort for the return.\n\nSo,,,_When_ you choose on=\r\ne approach over the other is entirely up to you based on your particular co=\r\nnstraints (time, money, complexity of the app, variance of the app over tim=\r\ne, etc.). But if you _do_ choose a hypermedia-driven approach,you&#39;ll want t=\r\no use an existing hypermedia type (XHTML) or design and implement your own =\r\ncustom hypermedia type.\n=A0=A0=A0Hope that ramble helps.\n\nmcahttp://amundse=\r\nn.com/blog/\nhttp://twitter.com@mamund\nhttp://mamund.com/foaf.rdf#me\n\n\n\n\n#RE=\r\nSTFest 2010 \nhttp://rest-fest.googlecode.com\n\n\n\n\nOn Fri, Dec 3, 2010 at 02:=\r\n54, Kevin Duffey &lt;andjarnic@...&gt; wrote:\n\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n=\r\n\n\n\n\n\n\nI get everything you are saying..finally thanks to a few of you that =\r\nset me clear on this whole media-type issue. \n\n\n\nI am however having a hard=\r\n time thinking about telling clients that they basically need to parse html=\r\n to use my API. I much rather say &quot;for /orders, you get this chunk of xml b=\r\nack with these potential elements.. parse it to get the data you need&quot;. Or =\r\nin JSON. As I use Java/JAX-RS with Jersey, it handles automatically turning=\r\n my objects into either xml or json, whatever the Accept header specifies. =\r\nAnyway, for my own learning, it is good to know what you said, and it does =\r\nmake sense. However, it seems odd to me to return things in HTML as opposed=\r\n to xml or json, when it&#39;s just chunks.. that is, a user places 100 orders =\r\nover 3 months, then comes in and asks to see a history of orders. I return =\r\nan xml chunk with their 100 orders and related\n info. That seems perfectly =\r\nfine to provide in xml or json, allowing any client to parse the response a=\r\ns they see fit. I would obviously have some sort of api doc that would expl=\r\nain the response. \n\nI guess what I am grappling with is that for the most p=\r\nart, I would suspect most services like the one I am messing around with to=\r\n learn, would be used by specific clients, not anyone and everyone out on t=\r\nhe web. More so, I don&#39;t see anyone needing to use my particular bits of da=\r\nta I return for their own use.. that is, if I were to register a media type=\r\n that represents a generic ordering document, that might make sense, but in=\r\n my case, if I am building up a REST api for my specific little service, it=\r\n doesn&#39;t seem like returning HTML would make any more sense than returning =\r\nxml or json. I certainly can see if I was building my own web site, where I=\r\n have some javascript make ajax requests and I return a chunk of HTML inste=\r\nad of XML or JSON, so that my own\n site consuming my API can benefit from h=\r\naving HTML directly, rather than xml or json then have to build up the html=\r\n on the fly in the browser. But for say a mobile app that had a native clie=\r\nnt that allowed a user to log in and pull up their recent orders, a chunk o=\r\nf XML would fit well. HTML seems more difficult to have to parse and deal w=\r\nith.. at least the way I think. Again, if I were going to display it in a b=\r\nrowser..maybe it&#39;s fine, but if I wanted to do something with the data befo=\r\nre displaying it or maybe it&#39;s not a web browser at all, html seems out of =\r\nplace. That&#39;s just my opinion tho from the bits I&#39;ve learned the past few d=\r\nays.\n\n\n\n\n--- On Thu, 12/2/10, Eric J. Bowman &lt;eric@...&gt; wrote:=\r\n\n\n\n\nFrom: Eric J. Bowman &lt;eric@...&gt;\nSubject: Re: [rest-discuss=\r\n] Link relations [was: A media type for\n case files, dossiers and documents=\r\n]\nTo: &quot;Kevin Duffey&quot; &lt;andjarnic@...&gt;\nCc: &quot;Rest Discussion List&quot; &lt;rest=\r\n-discuss@yahoogroups.com&gt;, juergen.brendel@...\n\n\nDate: Thursday, D=\r\necember 2, 2010, 10:32 PM\n\n\n\n\n\n\n\n=A0\n\n\n\n    \n      \n      \n      Kevin Duff=\r\ney wrote:\n\n&gt; \n\n&gt; Valid point. I am not sure what media type would fit then.=\r\n I am\n\n&gt; trying to follow the HATEOS design, I have an entry point that\n\n&gt; =\r\nreturns some links based on credentials, from there a client would\n\n&gt; use t=\r\nhose to make calls to any of my resources, and each response\n\n&gt; would retur=\r\nn a relevant chunk of XML or JSON with links for each\n\n&gt; resource accessibl=\r\ne at that point (for example GET /orders/id would\n\n&gt; return a specific orde=\r\nr along with one or more links that can be used\n\n&gt; to operate on the order)=\r\n. \n\n&gt;\n\n\n\nI&#39;ve never seen an order-processing system that couldn&#39;t be modele=\r\nd as\n\nHTML.  In fact, I&#39;ve rarely seen an order-processing system that wasn=\r\n&#39;t\n\nHTML.  In OOP terminology, the goal is to distribute not your objects,\n=\r\n\nbut your object interfaces.  REST says, make those object interfaces\n\nunif=\r\norm.  Which means participants have a network-based shared\n\nunderstanding o=\r\nf your state transitions (links, forms), IOW, a self-\n\ndocumenting API.\n\n\n\n=\r\nIt&#39;s perfectly acceptable to model your data as JSON or as XML (bearing\n\nin=\r\n mind that schemas are an orthogonal concern).  The trick is to\n\ncreate an =\r\nHTML interface for either JSON or XML data, which instructs\n\nuser-agents ho=\r\nw to interact with that data.  I&#39;d choose either JSON or\n\nXML, instead of t=\r\nrying to do both, depending on whether you&#39;re more\n\ncomfortable transformin=\r\ng that data into HTML using Javascript or XSLT.\n\n\n\n&gt; \n\n&gt; So if I use applic=\r\nation/xml, my API would not be considered truly\n\n&gt; RESTful? \n\n&gt; \n\n\n\nNo, not=\r\n if you&#39;re using application/xml as the hypertext engine driving\n\napplicati=\r\non state.  If it&#39;s just a snippet of XML which gets read by,\n\nsay, an HTML =\r\nfront-end driving application state, then it&#39;s OK because\n\nthe processing m=\r\nodel (parse as XML, handling XInclude/XLink/rdf:about)\n\nis adequate to the =\r\ntask.  If that XML snippet contains URIs the user is\n\nsupposed to click on =\r\nto transition the application to the next steady-\n\nstate (which aren&#39;t XLin=\r\nks), well, that&#39;s what &lt;a&gt; and atom:link are\n\nfor, there&#39;s no corollary in =\r\napplication/xml (besides XLink).\n\n\n\nAlso, most order forms are simply tabul=\r\nar data, the semantics of which\n\ndon&#39;t exist in application/xml like they d=\r\no in application/xhtml+xml or\n\ntext/html with &lt;table&gt;.  Same with lists, sa=\r\nme with forms.\n\n\n\n&gt;\n\n&gt; So now I&#39;ll ask, what media type I could possibly us=\r\ne with my own\n\n&gt; xml/json structure? It almost sounds like you&#39;re saying I =\r\nshouldn&#39;t\n\n&gt; be returning my own made up structure, that I should instead u=\r\nse an\n\n&gt; existing media type, like one with xhtml or something. Is there a\n=\r\n\n&gt; media type that allows for any sort of specific format to a domain to\n\n&gt;=\r\n be returned? Or does that now fall into a case where I should create\n\n&gt; my=\r\n own media type and register it with IANA?\n\n&gt; \n\n\n\nIt falls into a case wher=\r\ne you should refactor.  You have tabular data,\n\nso you need to choose a dat=\r\na type which expresses such semantics (i.e.\n\nHTML, or DocBook).  The whole =\r\npoint of media types is that they are\n\n_not_ domain-specific, but rather, r=\r\nepresent a shared understanding of\n\na processing model at the network (IP) =\r\nlayer.  This is the fundamental\n\ntradeoff of the style:\n\n\n\n&quot;[A] uniform int=\r\nerface degrades efficiency, since information is\n\ntransferred in a standard=\r\nized form rather than one which is specific to\n\nan application&#39;s needs.&quot;\n\n\n=\r\n\nAn order consists of item numbers, descriptions, quantity, unit price\n\nand=\r\n total price.  You *could* re-invent the &lt;table&gt; wheel and register\n\nit as =\r\na new media type, but it&#39;s more scalable (maintainable, portable)\n\nto re-us=\r\ne HTML even if it isn&#39;t a precise fit.  If you create a new\n\nmedia type, th=\r\nen you need to distribute a custom user-agent.  When you\n\nupgrade your API,=\r\n you must simultaneously update that user-agent.\n\n\n\nThe success of the Web =\r\nis due to the common user-agent.  What I really\n\ndon&#39;t want, is for any sys=\r\ntem I interact with to require me to install\n\nyet another piece of software=\r\n, and keep it up-to-date.  That&#39;s coupling.\n\nSo much easier for everyone co=\r\nncerned, to target the browser.  That way,\n\nI only need to install and main=\r\ntain one user-agent regardless of how\n\nmany different systems I interact wi=\r\nth.  Such decoupling allows clients\n\nand servers to evolve independently.  =\r\nSo there is a cost associated\n\nwith the minting of new media types -- coupl=\r\ning -- unless and until the\n\nnew media type achieves significant uptake.\n\n\n=\r\n\n-Eric\n\n\n\n    \n     \n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n      \n\n\n\n\n\n\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n=\r\n\n\n      \r\n--0-677474689-1291390020=:74466\r\nContent-Type: text/html; charset=iso-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;table cellspacing=3D&quot;0&quot; cellpadding=3D&quot;0&quot; border=3D&quot;0&quot; &gt;&lt;tr&gt;&lt;td valign=3D&quot;=\r\ntop&quot; style=3D&quot;font: inherit;&quot;&gt;Mike, a most excellent response.. very well s=\r\naid, again I have a better understanding of all this thanks to you and Eric=\r\n.&lt;br&gt;&lt;br&gt;Here I thought I was implementing HATEOAS by providing links back =\r\nin my response and a single entry point for all consumers to initiate their=\r\n communication with my api. &lt;br&gt;&lt;br&gt;I totally get the concept of an evolvin=\r\ng api breaking clients. Because of that, it was my impression that providin=\r\ng versions of your api prevent that, at least to some degree. Clients using=\r\n v1, continue to use v1 until they are ready to be written to use v2, or..t=\r\nhey just stay on v1. Like most software that adheres to major version chang=\r\nes as major feature changes, a v2 would be something probably quite a bit d=\r\nifferent.. different response formats, perhaps... but by using links in the=\r\n responses, I can, from my api, direct clients to new resources if need be.=\r\n\n Perhaps the old /orders is no longer valid.. we have a /neworders to hand=\r\nle all kinds of new data. Since all the clients use the links elements to n=\r\navigate based on the rel=3D&quot;&quot; value, they shouldn&#39;t break, that I know of. =\r\nWell.. to be fair, if the response format changes, then yes, they would bre=\r\nak.. but if you keep the response format the same but modify the resources =\r\ncalled via the links, then the clients will &quot;evolve&quot; with the api automatic=\r\nally. &lt;br&gt;&lt;br&gt;What I am having a hard time swallowing is providing an API t=\r\nhat returns data as HTML. I think it&#39;s going to be hard to go out there and=\r\n tell consumers, &quot;here is my api, which returns HTML, but not for visual us=\r\ne.. you have to parse the HTML yourself, even though your not a browser.. y=\r\nou&#39;re going to become a browser basically, in order to use my api&quot;. This ju=\r\nst seems hard to get acceptance or by in by potential consumers. I would im=\r\nagine most consumers of apis are expecting xml or json, and to get back\n ht=\r\nml, and have to actually parse it at least to me I&#39;d be questioning why htm=\r\nl, which as far as I knew was used to display data in a visual manner, is b=\r\neing sent back for me to parse to use the data in it.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;--- On=\r\n &lt;b&gt;Fri, 12/3/10, mike amundsen &lt;i&gt;&lt;mamund@...&gt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;=\r\nbr&gt;&lt;blockquote style=3D&quot;border-left: 2px solid rgb(16, 16, 255); margin-lef=\r\nt: 5px; padding-left: 5px;&quot;&gt;&lt;br&gt;From: mike amundsen &lt;mamund@...&gt=\r\n;&lt;br&gt;Subject: Re: [rest-discuss] Link relations [was: A media type for case=\r\n files, dossiers and documents]&lt;br&gt;To: &quot;Kevin Duffey&quot; &lt;andjarnic@yahoo.c=\r\nom&gt;&lt;br&gt;Cc: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;, &quot;Rest Discuss=\r\nion List&quot; &lt;rest-discuss@yahoogroups.com&gt;, juergen.brendel@...=\r\nm&lt;br&gt;Date: Friday, December 3, 2010, 2:08 AM&lt;br&gt;&lt;br&gt;&lt;div id=3D&quot;yiv443856726=\r\n&quot;&gt;&lt;div&gt;Kevin:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I&#39;ve been doing quite a bit of work =\r\nin the area of making decisions on how to code clients for Internet\n apps. =\r\nYour comments about how XHTML seems inappropriate remind me of a set of dec=\r\nisions we all make (consciously&nbsp;or not) about implementing solutions f=\r\nor Internet apps. Here&#39;s a peek into one aspect of my current thinking on t=\r\nhis. Hopefully it hits some of teh points to raise and provides some ideas =\r\non how you can approach your decision-making.&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;NOT=\r\nE: I cover some of this in a talk and the slides (and C# code) for that tal=\r\nk are here:&lt;a rel=3D&quot;nofollow&quot; target=3D&quot;_blank&quot; href=3D&quot;http://amundsen.co=\r\nm/talks/#beyond-web20&quot;&gt;http://amundsen.com/talks/#beyond-web20&lt;/a&gt;&nbsp;&nb=\r\nsp;&lt;/div&gt;&lt;div&gt;\n&lt;br&gt;&lt;/div&gt;&lt;div&gt;CONSIDERATIONS&lt;/div&gt;&lt;div&gt;When coding clients =\r\nfor application-level protocols (HTTP) over distributed networks (i.e. the =\r\n&quot;Web&quot;), these things (among others) must be taken into account:&lt;/div&gt;\n&lt;div&gt;=\r\n1 - how does the client know all the addresses (URIs) that will be needed t=\r\no execute operations? &nbsp;&lt;/div&gt;&lt;div&gt;2 - how does the client know how to =\r\nproperly construct specific requests (searches, filters, etc.) to send to t=\r\nhe addresses?&lt;/div&gt;\n\n&lt;div&gt;3 - how does the client &quot;understand&quot; the response=\r\ns returned from those requests?&lt;/div&gt;&lt;div&gt;4 - how does the client know the =\r\norder in which these actions (requests/responses) must take place (you can&#39;=\r\nt create a new order until you create a new customer, you can&#39;t register mo=\r\nre than ten pending orders per day, etc.).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;=\r\nYou have two general approaches:&nbsp;&lt;/div&gt;&lt;div&gt;- code these details into =\r\nthe client (non-hypermedia) and re-code the client when the details change =\r\nor;&lt;/div&gt;\n&lt;div&gt;- code these details into the message (hypermedia) and refor=\r\nmat the message when the details change.&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;A N=\r\nON-HYPERMEDIA APPROACH:&lt;/div&gt;&lt;div&gt;1 - When coding the client application pr=\r\nogrammers will get a long list of URIs (from documentation) and hard-code t=\r\nhem into the client application or encode the URI list in some static confi=\r\ng file, etc. and make that available to the client code. It&#39;s possible that=\r\n some URI construction rules can be used instead of a static list. Then pro=\r\ngrammers write code that knows how to execute the construction rules at run=\r\ntime based on the state of the client, etc. The client application will als=\r\no have some rules in code in order to associate each fixed/constructed URI =\r\nw/ some &quot;action&quot; (get a user record, search for users added last week, add =\r\na new user, etc.) and the client code will select the proper address at run=\r\ntime based on the state of the client, etc.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - =\r\nWhen sending requests from the client to the server (the &quot;actions&quot; mentione=\r\nd in #1 above), programmers will write code that knows the format details o=\r\nf the message (XML, JSON, CSV, etc), the layout details (XML elements named=\r\n &quot;email&quot;, &quot;hat-size&quot;, etc.), which elements are required, optional, etc. Pr=\r\nogrammers will write code that, at runtime, associates client state with ea=\r\nch of these &quot;fields&quot;, populates the structures and sends them to the proper=\r\n URI (from #1).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3 - When&nbsp;receiving&nbsp;res=\r\nponses, client applications know, ahead of time, what to format expect (XML=\r\n, JSON, etc.), the exact layout of each response (elements and attributes, =\r\netc.), and how to render them visually for humans (or arrange the data retu=\r\nrned in the proper memory &quot;slots&quot; for M2M apps).&nbsp;&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/di=\r\nv&gt;&lt;div&gt;4 - The client application will have all the rules for application f=\r\nlow hard coded. It will &quot;know&quot; that customers cannot have more than ten pen=\r\nding orders or that order detail lines can&#39;t be sent to the server before a=\r\nn order document is created, etc.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;When using the=\r\n this approach, changing any of those items over time (new addresses for ne=\r\nw requests that return new responses in a new&nbsp;application-flow order) =\r\nwill require re-coding the client and re-deploying that new code to replace=\r\n all the existing &quot;old&quot; client code.&lt;/div&gt;\n\n&lt;div&gt;&nbsp;&lt;/div&gt;&lt;div&gt;A HYPERME=\r\nDIA-DRIVEN APPROACH&lt;/div&gt;&lt;div&gt;Using Fielding&#39;s REST style as a guide (&quot;hype=\r\nrmedia as the engine of application state&quot;):&lt;/div&gt;&lt;div&gt;1 - The goal is to r=\r\neduce the number of addresses to the fewest reasonably possible. One pre-es=\r\ntablished address is a nice goal - the &quot;starting&quot; address. After that, all =\r\nother addresses are expected to come in the responses. XHTML has a built-in=\r\n element for this data - the anchor (&lt;a ... /&gt;) tag.&nbsp;&lt;/div&gt;\n\n&lt;di=\r\nv&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2 - The information about what fields to use when crafting=\r\n a request are contained in the responses to requests, not hard-coded in th=\r\ne client application. XHTML has built-in elements for this, too. FORMs w/ I=\r\nNPUT, SELECT, and TEXTAREA elements. Clients know ahead of time how to hand=\r\nle each of these elements; they are universal for all types of requests (fo=\r\nr users, customers, stores, orders, etc.). Also, the FORM element has the a=\r\nssociated URI for this action when the client&nbsp;receives&nbsp;the respon=\r\nse so there is no need to hard-code any other URIs in the client, either.&lt;/=\r\ndiv&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3 - The information about what fields &amp; layou=\r\nts to expect in responses and how to &quot;render&quot; them is also included in XHTM=\r\nL. Like the FORM elements, response elements are generic and of a limited s=\r\net. Clients to do not need to know a set of specific data elements (&lt;ema=\r\nil /&gt;, &lt;hat-size /&gt;, etc.) and when to expect them and how to rend=\r\ner them. Instead, client code is written to know how to render the generic =\r\nset of elements (DL, DT, DD, DIV, SPAN, TABLE, etc) in a response.&lt;/div&gt;\n\n&lt;=\r\ndiv&gt;&nbsp;&lt;/div&gt;&lt;div&gt;4 - The responses carry the &quot;next possible steps&quot; for =\r\nthe application flow. XHTML elements such as &lt;a /&gt; and &lt;form /&gt;=\r\n will appear when it&#39;s appropriate (the response to create order will have =\r\nlinks/controls to create order lines, once ten pending orders are created f=\r\nor a customer, the response will no longer in include a &quot;create pending ord=\r\ner&quot; link, etc.).&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;When using the second approach,=\r\n new addresses for new requests that return new responses w/ new app-flow&n=\r\nbsp;details&nbsp;will not require changing the client code. Because all tha=\r\nt information is included in the responses; the media type (XHTML) has &quot;aff=\r\nordances&quot; for carrying that application control information (&lt;a /&gt;, &=\r\nlt;form /&gt;, etc.) within the responses. &nbsp;XHTML has an advantage due=\r\n to it&#39;s built-in hypermedia controls. XML and JSON do not have these.&nbsp=\r\n;&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CHOOSING WHICH APPROACH TO USE&lt;/div&gt;&lt;div&gt;Now, =\r\nit may turn out that you are creating an&nbsp;application&nbsp;that:&lt;/div&gt;&lt;=\r\ndiv&gt;1) has only one address&lt;/div&gt;&lt;div&gt;2) has only one request format&lt;/div&gt;&lt;=\r\ndiv&gt;3) has only one response format&lt;/div&gt;\n&lt;div&gt;4) has only one possible app=\r\nlication flow&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If that&#39;s the case, you don&#39;t need =\r\nthe advantages that a hypermedia-driven implementation affords; all that wo=\r\nrk may be overkill and waste. Using a non-hypermedia format (e.g. CSV, XML,=\r\n JSON, etc.) and hard-coding the details in the client will work much bette=\r\nr with less overall effort.&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or, you may have a s=\r\nmall set of addresses, or a small set of request formats, or a small set of=\r\n response formats, or a small set of app-flows. Now you need to think a bit=\r\n more on whether your varying set of addresses, request and response format=\r\ns, and app-flows are numerous enough to make it worth while to adopt a hype=\r\nrmedia-driven implementation or stick to hard-coding clients.&lt;/div&gt;\n\n&lt;div&gt;&lt;=\r\nbr&gt;&lt;/div&gt;&lt;div&gt;Or you may have an application where, even w/ a wide range of=\r\n address, requests, responses, and app-flows, these values hardly change ov=\r\ner the life of the application (days, weeks, years, etc.). Does it make sen=\r\nse to use a hypermedia-driven implementation if the formats never change?&lt;/=\r\ndiv&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Or you may be the only one writing the client. Ju=\r\nst like it&#39;s often more effort to document a simple app than build it, usin=\r\ng a hypermedia-driven implementation in order to never change the code that=\r\n you yourself could write more quickly and efficiently anyway may be too mu=\r\nch effort for the return.&lt;/div&gt;\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;So,,,&lt;/div&gt;&lt;div&gt;_When_ =\r\nyou choose one approach over the other is entirely up to you based on your =\r\nparticular constraints (time, money, complexity of the app, variance of the=\r\n app over time, etc.). But if you _do_ choose a hypermedia-driven approach,=\r\nyou&#39;ll want to use an existing hypermedia type (XHTML) or design and implem=\r\nent your own custom hypermedia type.&lt;/div&gt;\n&lt;div&gt;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&lt;di=\r\nv&gt;Hope that ramble helps.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;\nmca&lt;/div&gt;&lt;div&gt;&lt;a rel=3D=\r\n&quot;nofollow&quot; target=3D&quot;_blank&quot; href=3D&quot;http://amundsen.com/blog/&quot;&gt;http://amun=\r\ndsen.com/blog/&lt;/a&gt;&lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; target=3D&quot;_blank&quot; href=3D&quot;http://=\r\ntwitter.com&quot;&gt;http://twitter.com&lt;/a&gt;@mamund&lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; target=3D=\r\n&quot;_blank&quot; href=3D&quot;http://mamund.com/foaf.rdf#me&quot;&gt;http://mamund.com/foaf.rdf#=\r\nme&lt;/a&gt;&lt;br&gt;\n\n&lt;br&gt;&lt;br&gt;#RESTFest 2010 &lt;br&gt;&lt;a rel=3D&quot;nofollow&quot; target=3D&quot;_blank=\r\n&quot; href=3D&quot;http://rest-fest.googlecode.com&quot;&gt;http://rest-fest.googlecode.com&lt;=\r\n/a&gt;&lt;br&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;&lt;div class=3D&quot;yiv443856726gmail_quote&quot;&gt;On Fri, Dec 3, 2=\r\n010 at 02:54, Kevin Duffey &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a rel=3D&quot;nofollow&quot; ymailt=\r\no=3D&quot;mailto:andjarnic@...&quot; target=3D&quot;_blank&quot; href=3D&quot;/mc/compose?to=\r\n=3Dandjarnic@...&quot;&gt;andjarnic@...&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;block=\r\nquote class=3D&quot;yiv443856726gmail_quote&quot; style=3D&quot;margin: 0pt 0pt 0pt 0.8ex;=\r\n border-left: 1px solid rgb(204, 204, 204); padding-left: 1ex;&quot;&gt;\n\n\n\n\n\n\n\n\n  =\r\n      \n\n\n\n\n&lt;div&gt;\n\n\n\n\n\n&lt;br&gt;&lt;br&gt;\n\n\n\n\n&lt;table border=3D&quot;0&quot; cellpadding=3D&quot;0&quot; ce=\r\nllspacing=3D&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=3D&quot;font: inherit;&quot; valign=3D&quot;top&quot;&gt;I ge=\r\nt everything you are saying..finally thanks to a few of you that set me cle=\r\nar on this whole media-type issue. &lt;br&gt;&lt;br&gt;\n\nI am however having a hard tim=\r\ne thinking about telling clients that they basically need to parse html to =\r\nuse my API. I much rather say &quot;for /orders, you get this chunk of xml back =\r\nwith these potential elements.. parse it to get the data you need&quot;. Or in J=\r\nSON. As I use Java/JAX-RS with Jersey, it handles automatically turning my =\r\nobjects into either xml or json, whatever the Accept header specifies. Anyw=\r\nay, for my own learning, it is good to know what you said, and it does make=\r\n sense. However, it seems odd to me to return things in HTML as opposed to =\r\nxml or json, when it&#39;s just chunks.. that is, a user places 100 orders over=\r\n 3 months, then comes in and asks to see a history of orders. I return an x=\r\nml chunk with their 100 orders and related\n info. That seems perfectly fine=\r\n to provide in xml or json, allowing any client to parse the response as th=\r\ney see fit. I would obviously have some sort of api doc that would explain =\r\nthe response. &lt;br&gt;&lt;br&gt;I guess what I am grappling with is that for the most=\r\n part, I would suspect most services like the one I am messing around with =\r\nto learn, would be used by specific clients, not anyone and everyone out on=\r\n the web. More so, I don&#39;t see anyone needing to use my particular bits of =\r\ndata I return for their own use.. that is, if I were to register a media ty=\r\npe that represents a generic ordering document, that might make sense, but =\r\nin my case, if I am building up a REST api for my specific little service, =\r\nit doesn&#39;t seem like returning HTML would make any more sense than returnin=\r\ng xml or json. I certainly can see if I was building my own web site, where=\r\n I have some javascript make ajax requests and I return a chunk of HTML ins=\r\ntead of XML or JSON, so that my own\n site consuming my API can benefit from=\r\n having HTML directly, rather than xml or json then have to build up the ht=\r\nml on the fly in the browser. But for say a mobile app that had a native cl=\r\nient that allowed a user to log in and pull up their recent orders, a chunk=\r\n of XML would fit well. HTML seems more difficult to have to parse and deal=\r\n with.. at least the way I think. Again, if I were going to display it in a=\r\n browser..maybe it&#39;s fine, but if I wanted to do something with the data be=\r\nfore displaying it or maybe it&#39;s not a web browser at all, html seems out o=\r\nf place. That&#39;s just my opinion tho from the bits I&#39;ve learned the past few=\r\n days.&lt;div&gt;\n\n&lt;br&gt;&lt;br&gt;&lt;br&gt;--- On &lt;b&gt;Thu, 12/2/10, Eric J. Bowman &lt;i&gt;&lt;&lt;a r=\r\nel=3D&quot;nofollow&quot; ymailto=3D&quot;mailto:eric@...&quot; target=3D&quot;_blank&quot; =\r\nhref=3D&quot;/mc/compose?to=3Deric@...&quot;&gt;eric@...&lt;/a&gt;&g=\r\nt;&lt;/i&gt;&lt;/b&gt; wrote:&lt;br&gt;&lt;/div&gt;&lt;blockquote style=3D&quot;border-left: 2px solid rgb(=\r\n16, 16, 255); margin-left: 5px; padding-left: 5px;&quot;&gt;\n\n&lt;div&gt;&lt;br&gt;From: Eric J=\r\n. Bowman &lt;&lt;a rel=3D&quot;nofollow&quot; ymailto=3D&quot;mailto:eric@...&quot; t=\r\narget=3D&quot;_blank&quot; href=3D&quot;/mc/compose?to=3Deric@...&quot;&gt;eric@bison=\r\nsystems.net&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Subject: Re: [rest-discuss] Link relation=\r\ns [was: A media type for\n case files, dossiers and documents]&lt;br&gt;&lt;/div&gt;&lt;div=\r\n&gt;To: &quot;Kevin Duffey&quot; &lt;&lt;a rel=3D&quot;nofollow&quot; ymailto=3D&quot;mailto:andjarnic@yah=\r\noo.com&quot; target=3D&quot;_blank&quot; href=3D&quot;/mc/compose?to=3Dandjarnic@...&quot;&gt;and=\r\njarnic@...&lt;/a&gt;&gt;&lt;br&gt;&lt;/div&gt;Cc: &quot;Rest Discussion List&quot; &lt;&lt;a rel=3D&quot;=\r\nnofollow&quot; ymailto=3D&quot;mailto:rest-discuss@yahoogroups.com&quot; target=3D&quot;_blank&quot;=\r\n href=3D&quot;/mc/compose?to=3Drest-discuss@yahoogroups.com&quot;&gt;rest-discuss@yahoog=\r\nroups.com&lt;/a&gt;&gt;, &lt;a rel=3D&quot;nofollow&quot; ymailto=3D&quot;mailto:juergen.brendel@mu=\r\nlesoft.com&quot; target=3D&quot;_blank&quot; href=3D&quot;/mc/compose?to=3Djuergen.brendel@mule=\r\nsoft.com&quot;&gt;juergen.brendel@...&lt;/a&gt;&lt;br&gt;\n\nDate: Thursday, December 2,=\r\n 2010, 10:32 PM&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;\n\n\n\n\n\n&lt;span&gt;&nbsp;&lt;/span&gt;\n=\r\n\n\n\n    &lt;div&gt;\n      \n      \n      &lt;p&gt;Kevin Duffey wrote:&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; =\r\nValid point. I am not sure what media type would fit then. I am&lt;br&gt;\n&gt; tr=\r\nying to follow the HATEOS design, I have an entry point that&lt;br&gt;\n&gt; retur=\r\nns some links based on credentials, from there a client would&lt;br&gt;\n&gt; use =\r\nthose to make calls to any of my resources, and each response&lt;br&gt;\n&gt; woul=\r\nd return a relevant chunk of XML or JSON with links for each&lt;br&gt;\n&gt; resou=\r\nrce accessible at that point (for example GET /orders/id would&lt;br&gt;\n&gt; ret=\r\nurn a specific order along with one or more links that can be used&lt;br&gt;\n&gt;=\r\n to operate on the order). &lt;br&gt;\n&gt;&lt;br&gt;\n&lt;br&gt;\nI&#39;ve never seen an order-proc=\r\nessing system that couldn&#39;t be modeled as&lt;br&gt;\nHTML.  In fact, I&#39;ve rarely s=\r\neen an order-processing system that wasn&#39;t&lt;br&gt;\nHTML.  In OOP terminology, t=\r\nhe goal is to distribute not your objects,&lt;br&gt;\nbut your object interfaces. =\r\n REST says, make those object interfaces&lt;br&gt;\nuniform.  Which means particip=\r\nants have a network-based shared&lt;br&gt;\nunderstanding of your state transition=\r\ns (links, forms), IOW, a self-&lt;br&gt;\ndocumenting API.&lt;br&gt;\n&lt;br&gt;\nIt&#39;s perfectly=\r\n acceptable to model your data as JSON or as XML (bearing&lt;br&gt;\nin mind that =\r\nschemas are an orthogonal concern).  The trick is to&lt;br&gt;\ncreate an HTML int=\r\nerface for either JSON or XML data, which instructs&lt;br&gt;\nuser-agents how to =\r\ninteract with that data.  I&#39;d choose either JSON or&lt;br&gt;\nXML, instead of try=\r\ning to do both, depending on whether you&#39;re more&lt;br&gt;\ncomfortable transformi=\r\nng that data into HTML using Javascript or XSLT.&lt;br&gt;\n&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; So=\r\n if I use application/xml, my API would not be considered truly&lt;br&gt;\n&gt; RE=\r\nSTful? &lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nNo, not if you&#39;re using application/xml as the h=\r\nypertext engine driving&lt;br&gt;\napplication state.  If it&#39;s just a snippet of X=\r\nML which gets read by,&lt;br&gt;\nsay, an HTML front-end driving application state=\r\n, then it&#39;s OK because&lt;br&gt;\nthe processing model (parse as XML, handling XIn=\r\nclude/XLink/rdf:about)&lt;br&gt;\nis adequate to the task.  If that XML snippet co=\r\nntains URIs the user is&lt;br&gt;\nsupposed to click on to transition the applicat=\r\nion to the next steady-&lt;br&gt;\nstate (which aren&#39;t XLinks), well, that&#39;s what =\r\n&lt;a&gt; and atom:link are&lt;br&gt;\nfor, there&#39;s no corollary in application/xm=\r\nl (besides XLink).&lt;br&gt;\n&lt;br&gt;\nAlso, most order forms are simply tabular data,=\r\n the semantics of which&lt;br&gt;\ndon&#39;t exist in application/xml like they do in =\r\napplication/xhtml+xml or&lt;br&gt;\ntext/html with &lt;table&gt;.  Same with lists=\r\n, same with forms.&lt;br&gt;\n&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; So now I&#39;ll ask, what media type =\r\nI could possibly use with my own&lt;br&gt;\n&gt; xml/json structure? It almost sou=\r\nnds like you&#39;re saying I shouldn&#39;t&lt;br&gt;\n&gt; be returning my own made up str=\r\nucture, that I should instead use an&lt;br&gt;\n&gt; existing media type, like one=\r\n with xhtml or something. Is there a&lt;br&gt;\n&gt; media type that allows for an=\r\ny sort of specific format to a domain to&lt;br&gt;\n&gt; be returned? Or does that=\r\n now fall into a case where I should create&lt;br&gt;\n&gt; my own media type and =\r\nregister it with IANA?&lt;br&gt;\n&gt; &lt;br&gt;\n&lt;br&gt;\nIt falls into a case where you sh=\r\nould refactor.  You have tabular data,&lt;br&gt;\nso you need to choose a data typ=\r\ne which expresses such semantics (i.e.&lt;br&gt;\nHTML, or DocBook).  The whole po=\r\nint of media types is that they are&lt;br&gt;\n_not_ domain-specific, but rather, =\r\nrepresent a shared understanding of&lt;br&gt;\na processing model at the network (=\r\nIP) layer.  This is the fundamental&lt;br&gt;\ntradeoff of the style:&lt;br&gt;\n&lt;br&gt;\n&quot;[A=\r\n] uniform interface degrades efficiency, since information is&lt;br&gt;\ntransferr=\r\ned in a standardized form rather than one which is specific to&lt;br&gt;\nan appli=\r\ncation&#39;s needs.&quot;&lt;br&gt;\n&lt;br&gt;\nAn order consists of item numbers, descriptions, =\r\nquantity, unit price&lt;br&gt;\nand total price.  You *could* re-invent the &lt;ta=\r\nble&gt; wheel and register&lt;br&gt;\nit as a new media type, but it&#39;s more scalab=\r\nle (maintainable, portable)&lt;br&gt;\nto re-use HTML even if it isn&#39;t a precise f=\r\nit.  If you create a new&lt;br&gt;\nmedia type, then you need to distribute a cust=\r\nom user-agent.  When you&lt;br&gt;\nupgrade your API, you must simultaneously upda=\r\nte that user-agent.&lt;br&gt;\n&lt;br&gt;\nThe success of the Web is due to the common us=\r\ner-agent.  What I really&lt;br&gt;\ndon&#39;t want, is for any system I interact with =\r\nto require me to install&lt;br&gt;\nyet another piece of software, and keep it up-=\r\nto-date.  That&#39;s coupling.&lt;br&gt;\nSo much easier for everyone concerned, to ta=\r\nrget the browser.  That way,&lt;br&gt;\nI only need to install and maintain one us=\r\ner-agent regardless of how&lt;br&gt;\nmany different systems I interact with.  Suc=\r\nh decoupling allows clients&lt;br&gt;\nand servers to evolve independently.  So th=\r\nere is a cost associated&lt;br&gt;\nwith the minting of new media types -- couplin=\r\ng -- unless and until the&lt;br&gt;\nnew media type achieves significant uptake.&lt;b=\r\nr&gt;\n&lt;br&gt;\n-Eric&lt;br&gt;\n&lt;/p&gt;\n\n    &lt;/div&gt;\n     \n\n\n\n \n\n\n&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/blockqu=\r\note&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;\n\n\n\n\n\n\n\n      \n\n\n\n\n\n&lt;br&gt;\n\n    \n    \n&lt;br&gt;\n=\r\n\n\n\n\n&lt;div style=3D&quot;color: white; clear: both;&quot;&gt;&lt;/div&gt;\n\n\n\n&lt;/blockquote&gt;&lt;/div&gt;=\r\n&lt;br&gt;&lt;/div&gt;\n&lt;/div&gt;&lt;/blockquote&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;\n\n\n\n\n\n\n\n      \r\n--0-677474689-1291390020=:74466--\r\n\n"}}