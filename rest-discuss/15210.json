{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"3Am5y3OWAwgZ1M66Hb0fEfIxgZqHuphmldvrBksfI2GIKfPYd2b03BAil8FTHcuKPrPr5Za_fxKOwH39PWYhW8yAl5dbpgqW5pZAmm4tnQ","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the sense of  Roy&#39;s dissertation?","postDate":"1270958282","msgId":15210,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTAwNDEwMjE1ODAyLmY2MDZjZmZkLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PGhwcjM3MCtrbTdnQGVHcm91cHMuY29tPg==","referencesHeader":"PDIwMTAwNDEwMDgyODAzLjQzMzQxMDFhLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4JPGhwcjM3MCtrbTdnQGVHcm91cHMuY29tPg=="},"prevInTopic":15207,"nextInTopic":15211,"prevInTime":15209,"nextInTime":15211,"topicId":15152,"numMessagesInTopic":30,"msgSnippet":"... I don t know in what sense you mean the term client of the system . REST encompasses the constraints of the client-server style, so the client connectors","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 49526 invoked from network); 11 Apr 2010 03:58:49 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m4.grp.sp2.yahoo.com with QMQP; 11 Apr 2010 03:58:49 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta2.grp.re1.yahoo.com with SMTP; 11 Apr 2010 03:58:49 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 1516B509B4;\n\tSat, 10 Apr 2010 23:58:38 -0400 (EDT)\r\nDate: Sat, 10 Apr 2010 21:58:02 -0600\r\nTo: &quot;William Martinez Pomares&quot; &lt;wmartinez@...&gt;\r\nCc: rest-discuss@yahoogroups.com\r\nMessage-Id: &lt;20100410215802.f606cffd.eric@...&gt;\r\nIn-Reply-To: &lt;hpr370+km7g@...&gt;\r\nReferences: &lt;20100410082803.4334101a.eric@...&gt;\n\t&lt;hpr370+km7g@...&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.0.0 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: How comes to life an &quot;Application&quot; in the\n sense of  Roy&#39;s dissertation?\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\n&quot;William Martinez Pomares&quot; wrote:\n&gt; \n&gt; 2. To me, any interface is in the limits of a system. What is outside\n&gt; the limits is the client of the system. And here is a confusion many\n&gt; engineering students have when we look at client-server style. They\n&gt; assume the server is a system and the client the one that uses it,\n&gt; but in that style both elements are part of the system!\n&gt; \n\nI don&#39;t know in what sense you mean the term &quot;client of the system&quot;.\nREST encompasses the constraints of the client-server style, so the\nclient connectors of all the components &quot;in-circuit&quot; for the request/\nresponse (and their corresponding client and intermediary components)\ninteraction with the origin server&#39;s cache or server connector are\nindeed part of the system, for whatever application is executing.\n\nSince a discussion of what components are &quot;in-circuit&quot; really serves\nabsolutely no purpose (other than facilitating philosophical debates),\nit may be safely avoided (taken for granted) by shorthanding the REST\nsystem as the REST API or using these terms interchangeably.  For all\nintents and purposes.\n\n&gt;\n&gt; Same in REST. When I mention client of an API, I mean the client that\n&gt; will use the system (and thus, not part of it) through an interface.\n&gt; REST uses the client-server style, in which the client is part of the\n&gt; system, not outside or it. It may need an interface to communicate\n&gt; with the server, but this interface is not an external one. \n&gt; \n\nI don&#39;t know what a &quot;client of an API&quot; is, either.  The user agent\nactually serves the API to the user as a series of steady-states.  The\nuser component&#39;s client connector to the user agent may be a human&#39;s\neyes, ears and fingers, and the user agent&#39;s server connector to the\nclient component may be KVM/audio.  On VOIP, the user component&#39;s client\nconnector and the user agent&#39;s server connector are both acoustic\ncouplers which implement a generic telephonic interface which sounds a\ntone for each key on the pad, plus natural language.\n\nWhat natural-language description corresponds to what key on the pad I\nshould press is conveyed to me by my user agent (telephone) as a choice\nof state transitions.  That domain-specific vocabulary could be a\nself-documenting REST API, as it does the same thing -- instructs the\nuser agent *how* to use the generic telephonic connector interface to\ncarry out the user&#39;s instructions via hypertext (CCXML + VoiceXML):\nPress &#39;1&#39; for English, &#39;2&#39; for Spanish on one domain may be Press &#39;1&#39;\nfor Spanish, &#39;2&#39; for English on another domain -- the API carries\ndomain-specific instructions on how to use the generic connector\ninterface to transition to the next steady-state (no HTTP required, but\nI can say &#39;1 for English&#39; is equivalent to GET, and entering an Rx# is \nequivalent to POST, &#39;press # when finished&#39; is a submit button).\n\nAny VOIP telephone executing my application is, at that time, a part of\nmy system while other telephones are not.  It doesn&#39;t matter if that\ntelephone is on a public or private exchange, landline or IP, the API\n(press &#39;1&#39; for English, &#39;#&#39; when finished) isn&#39;t affected at all -- it\ndoesn&#39;t make sense to make any distinction between API and system,\nbecause the only parts of the system the developer cares about are the\nuser agent executing the application, and the server component.\n\n&gt;\n&gt; This is a little hard to explain. We have a REST system, which\n&gt; includes the clients in the terms of the client-server style. The BIG\n&gt; REST system is the web, as a whole. Clients are part of that system,\n&gt; and the particular thing about the API those In-system client use, is\n&gt; that API is a network based API (as opposed as a library based one).\n&gt; \n\nThe Web, as a whole, is not a REST system in any way (otherwise there&#39;d\nbe no such thing as a not-REST API).  The thesis clearly describes the\nnative architecture of the Web as the client-cache-stateless-server\nstyle.  All REST constraints build from here, i.e. REST constrains the\nWeb architecture as a whole (while first requiring that the constraints\nof client-cache-stateless-server be adhered to -- plenty of APIs don&#39;t\nmeet the constraints of the Web&#39;s native architectural style either),\ndown to a set of best practices for systems desiring the benefits of\nREST, i.e. a sweet spot.\n\nYou&#39;re correct that a REST API is distributed -- my application\nsteady-states are derived from a variety of sources which aren&#39;t\nconstrained to being from a single domain or server (although in\nreality, user agents frown on cross-site architectures, so I use\nmultiple gateway components on a single domain, just not by choice, and\npray for the day I can dismantle them as the relics they are).\n\n&gt;\n&gt; 3. So... All you say is totally correct for the clients (user agents)\n&gt; in the REST system (your REST system, not the Web). Now, on the web,\n&gt; you also have clients of your REST system, that is also on the web\n&gt; (we assume you can have a private REST system in your own cloud, that\n&gt; is not a sin). YOur system maybe is not a REST system (as you mention\n&gt; of WP), and you made that REST wrapper (an API) so it can be used in\n&gt; the web (the big system) so other people in the web can use your\n&gt; system. You are building an API, that starts as an adapter and (if\n&gt; you change WP to become RESTfull) ends up as a facade. \n&gt; \n\nThe only user agents I consider as part of my system, are those\nexecuting applications against it, RESTfully or not.  I promise you I\nam developing a REST system which has a REST API, and these system vs.\nwrapper vs. facade distinctions just don&#39;t exist or matter.  They&#39;re\nnothing but implementation details, hidden behind the generic connector\ninterface.  The API is public, and does not vary based on the topology\nof my backend system.  The topology of my backend is *irrelevant* to\nREST, as it&#39;s part of the system but not the API.\n\nThe distinction of where the user is located, inside or outside a\nfirewall, is likewise irrelevant to REST.  What&#39;s relevant are their\nauthentication headers, and perhaps IP address (or incoming phone #),\nbut the nature of that IP address (public or private) has no bearing on\nanything.  Most intranets allow authorized access over the Web, REST\nAPI or not.  That certain requests are only allowed from certain IPs is\nan aspect of my system that has nothing to do with its API -- I publish\nno list of (un)allowable IP ranges to the world as part of the API, I\nleave it to my response codes to inform the user agent why a request\nfailed (operation not allowed from your location, unauthorized user).\n\nI use REST API and REST system interchangeably, because the only place\nit matters is philosophical discussions about the difference between\nthe two, like we&#39;re having here.  Any user agent executing an\napplication against my API is in-circuit with my system.  For all\nintents and purposes this makes no difference to anything, since REST\ndevelopers are concerned with how their system responds to requests,\ni.e. how it implements the generic connector interface -- not how it\nimplements resources behind the generic connector interface.\n\nAs I said before, we take so many system components (caches) for\ngranted when discussing what the system entails for any given request/\nresponse that going into detail isn&#39;t really of much use... it amounts\nto obscuring the system&#39;s design.  This debate is going into exactly\nthat sort of detail to prove that API and system aren&#39;t technically\ninterchangeable, which I agree with, but for any discussion but this\none there&#39;s really no point making the distinction, because such\ndistinction only obscures what&#39;s being discussed.  For all intents and\npurposes.\n\n&gt;\n&gt; You are building then and API. For you WP system. Two things. That\n&gt; was my point: what I actually see is people having a non-REST system\n&gt; that want to build a REST API. An adapter.   \n&gt; \n\nNo, I&#39;m not making a REST API for WordPress, bearing in mind that\nimplementation detail has nothing to do with REST and I could just as\neasily be modifying WordPress to achieve my objective as encapsulating\nit with a REST layer.  It wouldn&#39;t appear any different to the world\nI&#39;m exposing the API to.  Implementation details are hidden behind the\ngeneric connector interface, REST APIs are only concerned with\ninstructing user agents how to manipulate representations of resource\nor application state over the generic connector interface.\n\nI&#39;m not creating two things, I&#39;m creating one gateway layer.  It has\nclient and server connectors, but only the server connector is part of\nthe API.\n\nWhat I&#39;m making is a REST API for my overall system, made up of\nseparate wiki, weblog, forum, blogroll and tagging APIs plus the /date\nservice.  The API I&#39;m developing is a frontend to whatever totally\nobscured implementation details make up the backend.  Could be WP,\ncould be Drupal, could be my native Atom Store, could be a combination\nof any of the above, and can change at my whim without affecting the\nAPI I&#39;ve exposed to the world.  Only the client connector of the\ngateway layer needs changing, in the form of adding a module for each\nsource generator, but the purpose of the layer is to provide the REST\nAPI and it does that without skipping a beat, because implementation\ndetails are hidden behind the generic connector interface.\n\n&gt;\n&gt; So, I guess we are on the same page, only that you use the term API\n&gt; and System as similar/the same thing (blurring the limit between the\n&gt; API and the encompassed system, as if they were parts of a whole,\n&gt; which is not bad), while I actually want to state the difference.\n&gt; When a client comes to me saying: &quot;We want to move on and become\n&gt; REST&quot;, I ask : Do you want your old system to be re-architected using\n&gt; REST, or do you want to build an API around it? When a client comes\n&gt; saying they want an API, I surely know there is a system (certainly\n&gt; not REST) on the back, that wants to be exposed to the web. \n&gt; \n\nNot quite on the same page, but some of what we&#39;re debating we do agree\non, so when you see a response that looks contradictory to what you&#39;re\nsaying, it&#39;s more likely to mean &quot;your terminology is imprecise&quot; rather\nthan &quot;you&#39;re wrong&quot;.\n\nWhen a client comes to you for REST development, you should start by\nmodeling resources.  Once that&#39;s done and you&#39;ve gotten a feel for the\nexisting system, it&#39;s up to you as the architect to present your client\nwith implementation options on the backend, i.e. encapsulate or replace\nthe existing system?  That isn&#39;t the sort of up-front question you can\nexpect someone who&#39;s not a REST expert to be capable of answering, in\nfact they&#39;re probably coming to you for *your* answer to that question,\nor at least your input.\n\nBut it isn&#39;t a starting point, and the distinction you&#39;re trying to make\nhas nothing to do with the REST API you&#39;re developing for your client,\nit&#39;s an implementation detail hidden behind the generic connector\ninterface having no bearing on REST.  Make your backend generate your\nREST resources&#39; representations however you see fit, using REST behind\nthe firewall or not.  The generated representations are part of the REST\nAPI, how they are generated is not, so how they are generated is out-of-\nscope to any discussion of the REST API, meaning we can go ahead and\ncall it a REST system without causing any harm because we just don&#39;t\ncare about implementation details.\n\nSorry for all the repetition, I just think these are important points.\n\n-Eric\n\n"}}