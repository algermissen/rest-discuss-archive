{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":364579677,"authorName":"Mike","from":"Mike &lt;mike@...&gt;","profile":"pleb1985","replyTo":"SENDER","senderId":"Grv7orvqg9dlS5s46AsNlo1b1BgrEwvgYdY9YcAW-F21yl4ETlYR4kkjfehs85yRXhc_4mH5wGehhscWicJLig","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [rest-discuss] HTML5 and RESTful HTTP in browsers","postDate":"1227535021","msgId":11602,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ5MkFCMkFELjEwMTAxMDhAbXlrYW5qby5jby51az4=","inReplyToHeader":"PDQ5MkFBMDZGLjgwMjAxMDdAaGFja2NyYWZ0Lm5ldD4=","referencesHeader":"PDIwMTUxMDEwLjIzNjg3MTIyNjkxOTk1NDUzMi5KYXZhTWFpbC5zZXJ2bGV0QGt1bmRlbnNlcnZlcj4JPDQ5MjJCMzZBLjMwOTA4MDRAbXlrYW5qby5jby51az4JPFAtSVJDLUVYQkUwMjc3YmllTFkwMDAwMTYwMUBFWC5VQ09QLkVEVT4JPDQ5MjVDMjAzLjgwNzA0MDFAbXlrYW5qby5jby51az4JPFAtSVJDLUVYQkUwMmEycjhnUEEwMDAwMTdmN0BFWC5VQ09QLkVEVT4JPDQ5MjYwNjI5LjgwNjA4MDVAbXlrYW5qby5jby51az4JPFAtSVJDLUVYQkUwMnhUanRScGUwMDAwMTk5NUBFWC5VQ09QLkVEVT4JPDQ5MjY4MkU4LjgwNjA2MDRAbXlrYW5qby5jby51az4JPFAtSVJDLUVYQkUwMmFOZ0VwVFgwMDAwMWJjZEBFWC5VQ09QLkVEVT4JPDQ5MjZGMzQ3LjUwNTA4MDBAbXlrYW5qby5jby51az4JPGVjZjM1YTFiMDgxMTIxMTAwMHExZTMxMzM3Y3VhMGQ3YWRhMmIyMDI3NjJhQG1haWwuZ21haWwuY29tPgk8NDkyNzA2MDEuNjA4MDcwNEBteWthbmpvLmNvLnVrPiA8MjAwODExMjIwNzA4MjAuZDkxMWU5NjQuZXJpY0BiaXNvbnN5c3RlbXMubmV0PiA8NDkyQThDMzguOTA3MDFAaGFja2NyYWZ0Lm5ldD4gPDQ5MkE5MURCLjcwMTA0MDdAbXlrYW5qby5jby51az4gPDQ5MkFBMDZGLjgwMjAxMDdAaGFja2NyYWZ0Lm5ldD4="},"prevInTopic":11601,"nextInTopic":11603,"prevInTime":11601,"nextInTime":11603,"topicId":11508,"numMessagesInTopic":82,"msgSnippet":"... How is making context-specific changes to a UA s Accept header, creating a new type of identifier ? Why on earth does the Accept header exist if it s not","rawEmail":"Return-Path: &lt;mike@...&gt;\r\nX-Sender: mike@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 85826 invoked from network); 24 Nov 2008 13:57:02 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m46.grp.scd.yahoo.com with QMQP; 24 Nov 2008 13:57:02 -0000\r\nX-Received: from unknown (HELO moutng.kundenserver.de) (212.227.126.188)\n  by mta18.grp.scd.yahoo.com with SMTP; 24 Nov 2008 13:57:02 -0000\r\nX-Received: from [192.168.10.13] (evojsyfw02.evolve-online.com [213.133.221.98])\n\tby mrelayeu.kundenserver.de (node=mrelayeu6) with ESMTP (Nemesis)\n\tid 0ML29c-1L4bvx0LD5-0002zE; Mon, 24 Nov 2008 14:57:01 +0100\r\nMessage-ID: &lt;492AB2AD.1010108@...&gt;\r\nDate: Mon, 24 Nov 2008 13:57:01 +0000\r\nUser-Agent: Thunderbird 2.0.0.17 (X11/20080925)\r\nMIME-Version: 1.0\r\nTo: Jon Hanna &lt;jon@...&gt;\r\nCc: Rest List &lt;rest-discuss@yahoogroups.com&gt;\r\nReferences: &lt;20151010.236871226919954532.JavaMail.servlet@kundenserver&gt;\t&lt;4922B36A.3090804@...&gt;\t&lt;P-IRC-EXBE0277bieLY00001601@...&gt;\t&lt;4925C203.8070401@...&gt;\t&lt;P-IRC-EXBE02a2r8gPA000017f7@...&gt;\t&lt;49260629.8060805@...&gt;\t&lt;P-IRC-EXBE02xTjtRpe00001995@...&gt;\t&lt;492682E8.8060604@...&gt;\t&lt;P-IRC-EXBE02aNgEpTX00001bcd@...&gt;\t&lt;4926F347.5050800@...&gt;\t&lt;ecf35a1b0811211000q1e31337cua0d7ada2b202762a@...&gt;\t&lt;49270601.6080704@...&gt; &lt;20081122070820.d911e964.eric@...&gt; &lt;492A8C38.90701@...&gt; &lt;492A91DB.7010407@...&gt; &lt;492AA06F.8020107@...&gt;\r\nIn-Reply-To: &lt;492AA06F.8020107@...&gt;\r\nContent-Type: text/plain; charset=UTF-8; format=flowed\r\nContent-Transfer-Encoding: 8bit\r\nX-Provags-ID: V01U2FsdGVkX1+FKCuT7UUAicnzis58jntnZDywEB7DtGUxoTn\n 6dSRACSSkgPxQHwpr+pY9xB1XlLHnSDSm60T6LQhKdSbyhoHoy\n yj8XRxwnsU5kKj1F3T6khAxX+QcVtBq\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Mike &lt;mike@...&gt;\r\nSubject: Re: [rest-discuss] HTML5 and RESTful HTTP in browsers\r\nX-Yahoo-Group-Post: member; u=364579677; y=fOPolzoVoZZzczMb-O-0vgGzTn9w_yrBALjAw0pkwnbNltE\r\nX-Yahoo-Profile: pleb1985\r\n\r\nJon Hanna wrote:\n&gt; Mike wrote:\n&gt;  \n&gt;&gt; One single accept header can indicate all of the appropriate \n&gt;&gt; content-types and their preferences for a given link. I would not use \n&gt;&gt; the markup to achieve a complete listing of the types available at a \n&gt;&gt; given URI, just the appropriate types for a given link in that \n&gt;&gt; particular state of the application.\n&gt;&gt;     \n&gt;\n&gt; If we put this into links it becomes an identifier. We now have a sort \n&gt; of resource (though different to a HTTP resource, as currently \n&gt; defined) identified by an identifier (though not a URI as in HTTP as \n&gt; currently defined, but rather a tuple containing a URI and a [possibly \n&gt; null] mime-type).\n&gt;\n&gt; Now, lets say we want to build a RESTful system out of this new design \n&gt; style. It&#39;s likely that some people here would, since we&#39;re all \n&gt; subscribed to a list called &quot;Rest-Discuss&quot;.\n&gt;\n&gt; In order to do this we will want to have a way to distinguish \n&gt; different representations of the new types of resources identified by \n&gt; the new types of identifiers.\n&gt;   \n\nHow is making context-specific changes to a UA&#39;s Accept header, creating \na &#39;new type of identifier&#39; ?\n\nWhy on earth does the Accept header exist if it&#39;s not to indicate \nappropriate content types?\n&gt; However. Since the proposal here is to replace REST with an un-RESTful \n&gt; system in which the accept header becomes part of the identifier\n\nNo - the Accept header *remains* part of the request; it&#39;s significance \nto the server is increased. Applications that do not wish to make use of \nthe Accept header this way can continue not doing so - both solutions \ncan co-exist peacefully on the web and in HTML provided this Accept \nattribute is optional.\n\n&gt; we can assume that once we&#39;ve managed to fix it to be RESTful HTML6 \n&gt; will make that part of the identifier too. Anyone wanting to build a \n&gt; RESTful system that is fully compatible with HTML6 will need to add a \n&gt; further level of representation identification.\n&gt;\n&gt; A mechanism for an infinite number of accept identifiers will \n&gt; presumably arrive sometime between HTML7 and HTMLâˆž.\n&gt;\n&gt;   \n\nThe Accept attribute (and header) can contain whatever the developer \nwants, I&#39;m not sure why you believe this would be limited to certain \ncontent types.\n\n&lt;a href=&quot;/document&quot; Accept=&quot;foo/bar&quot;&gt;\n\n&gt;&gt; Being able to query a URI for a list of available content-types would \n&gt;&gt; be nice;\n&gt;&gt;     \n&gt;\n&gt; It is nice. That&#39;s why its already possible.\n&gt;\n&gt;  \n&gt;&gt; but this would be better at the protocol level, I think.\n&gt;&gt;     \n&gt;\n&gt; Yes, it&#39;s in HTTP/1.1.\n&gt;\n&gt;  \n&gt;&gt; That way if someone sends me an email with a link to \n&gt;&gt; example.com/report - I can right click the link and be provided with \n&gt;&gt; a resource-specific &#39;Open As..&#39; menu with a list of all the UAs on my \n&gt;&gt; OS that can be served with an appropriate content-type.\n&gt;&gt;     \n&gt;\n&gt; This is perfectly possible with existing technology.\n&gt;   \n\nGood; then I guess that&#39;s even more reason to keep all representations \nof a resource within one URI, rather than creating unnecessary URIs for \neach representation.\n&gt;  \n&gt;&gt; For now, it is most likely that the link will be opened in a web \n&gt;&gt; browser; so the practical solution in the short term would be HTML \n&gt;&gt; representations which provide links to all the other content-types \n&gt;&gt; available.\n&gt;&gt;     \n&gt;\n&gt; That is a good way of implementing the representation sent with 406, yes.\n&gt;\n&gt;  \n&gt;&gt; Unfortunately, unless you have separate URI&#39;s for each representation \n&gt;&gt; this is not possible with HTML as it stands\n&gt;&gt;     \n&gt;\n&gt; And?\n&gt;\n&gt; If you are pushing the choice of representations above the protocol \n&gt; level (which you are if you are letting the user choose)\n\nHow sure are you, that is &#39;pushing it above the protocol level&#39;?\n\n\n&gt; then those representations have become resources*.\n\n...?\n\n&gt; In a RESTful system there is a uniform way of identifying all \n&gt; resources. In HTTP this is URIs.\n&gt;   \n\nNeat! :)\n\n&gt; Any proposal to have a means of identifying resources beyond URIs is a \n&gt; proposal to make HTTP no longer RESTful.\n\nTrue. What about using URIs to identify beyond resources? (i.e. to \nspecify the representation)\n\n&gt; Means to say things about resources could certainly be useful parts of \n&gt; hypermedia formats, and hence the type attribute on the &lt;a&gt; element in \n&gt; HTML4.0 and later can be useful, but moving from describing resources \n&gt; to partially identifying them is not just unRESTful but anti-RESTful.\n\nModifying the Accept header has *nothing to do* with identifying the \nresource.\n\nI think you may have misunderstood the implications of this proposal.\n\n&gt; You are proposing that we make HTML violate one of the core \n&gt; constraints of REST.\n&gt;   \n\nNo, I&#39;m not.\n\n&gt; Your proposal solves a &quot;problem&quot; that does not exist. If a client \n&gt; wishes to deal with the scenario you describe, the solution is as \n&gt; follows:\n&gt;\n&gt; 1. Client sends GET to URI with empty Accept header.\n&gt; 2a. Server ignores empty get and sends default (possibly sole) \n&gt; representation, as it is not willing to assist content negotiation on \n&gt; the basis of content-types.\n&gt; 2b. Server sends 406 Not Acceptable response with entity being a \n&gt; hypertext document linking to resources which are representations of \n&gt; that resource.\n&gt; 3a. Client handles download and/or display of representation based on \n&gt; content-type and other metadata.\n&gt; 3b. Client handles choice of representations either computationally or \n&gt; by offering choice to user.\n&gt; 4b. Client handles download and/or display of representation based on \n&gt; content-type and other metadata.\n&gt;   \nTo me, that&#39;s a horrible solution.\n&gt; * There is nothing to say a representation of a given resource cannot \n&gt; itself be a resource. The two rival definitions of just what a web \n&gt; resource are that they can be anything at all, or (the W3C TAG \n&gt; finding) that they are &quot;informational resources&quot;. A representation of \n&gt; a resource is clearly an informational resource in its own right, and \n&gt; is also clearly within a subset of &quot;anything at all&quot;. There are \n&gt; further cases where a resource really is one and the same as its \n&gt; representation; the most obvious case being a software batch, since in \n&gt; such cases it really is the bunch of 1s and 0s that we care about.\n&gt;   \n\nIt should be reasonably apparent from the preceding conversation that I \nam well aware representations can be *treated* as resources, and that \ncontent types can be treated as their own URIs (this is common practice \nright now). My point here is that I see no value in doing content type \nnegotiation in the URI if the representation is negotiable (Accept \nheader) via the protocol (HTTP). Lack of support? That&#39;s why I am \nproposing this additional attribute.\n\nYour tone seems a little hostile; I&#39;ll give the benefit of the doubt and \njust assume you&#39;re socially inept!\n\nThanks for your feedback though :)\n\nRegards,\nMike\n\n\n"}}