{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":266460716,"authorName":"Eric J. Bowman","from":"&quot;Eric J. Bowman&quot; &lt;eric@...&gt;","replyTo":"SENDER","senderId":"ONfgtOLjtPHahfBW2Z8E8FIP579z3vYPON44x6f_bwF44gx-gGl5XnUDfzOwzbpaz0dRN1YuEAxTF0KsNqT2rc6l8sQBsLP55NbPX6P7PA","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: [rest-discuss] Re: REST is not about domain models","postDate":"1324601802","msgId":18156,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMTExMjIyMTc1NjQyLmJkNTRmYzBjLmVyaWNAYmlzb25zeXN0ZW1zLm5ldD4=","inReplyToHeader":"PENDN0IxMTZERDA0NTRFQkM4ODAyNUU2OTJFQjQwRjk2QEpyblBDPg==","referencesHeader":"PDZGOUE0QkIxLTVFNjktNDQ3My1CQzM4LTQ0OEUyRTU1REQ1OUBub3Jkc2MuY29tPgk8amN1dTU5K3IzdjZAZUdyb3Vwcy5jb20+CTwyMDExMTIyMjE0MjMzNC5iMjMxMDZkZS5lcmljQGJpc29uc3lzdGVtcy5uZXQ+CTxDQzdCMTE2REQwNDU0RUJDODgwMjVFNjkyRUI0MEY5NkBKcm5QQz4="},"prevInTopic":18155,"nextInTopic":18157,"prevInTime":18155,"nextInTime":18157,"topicId":18135,"numMessagesInTopic":20,"msgSnippet":"... Well, yeah, there s that. ... Me in a nutshell, is if an m2m process is dealing with data which amounts to a purchase order, why not make its interface","rawEmail":"Return-Path: &lt;eric@...&gt;\r\nX-Sender: eric@...\r\nX-Apparently-To: rest-discuss@yahoogroups.com\r\nX-Received: (qmail 52295 invoked from network); 23 Dec 2011 00:57:06 -0000\r\nX-Received: from unknown (98.137.35.161)\n  by m15.grp.sp2.yahoo.com with QMQP; 23 Dec 2011 00:57:06 -0000\r\nX-Received: from unknown (HELO mxout-08.mxes.net) (216.86.168.183)\n  by mta5.grp.sp2.yahoo.com with SMTP; 23 Dec 2011 00:57:06 -0000\r\nX-Received: from bigbison (unknown [65.117.211.162])\n\t(using TLSv1 with cipher DHE-RSA-AES256-SHA (256/256 bits))\n\t(No client certificate requested)\n\tby smtp.mxes.net (Postfix) with ESMTPSA id 41B2D50A5D;\n\tThu, 22 Dec 2011 19:57:04 -0500 (EST)\r\nDate: Thu, 22 Dec 2011 17:56:42 -0700\r\nTo: =?UTF-8?B?SsO4cm4=?= Wildt &lt;jw@...&gt;\r\nCc: &lt;rest-discuss@yahoogroups.com&gt;\r\nMessage-Id: &lt;20111222175642.bd54fc0c.eric@...&gt;\r\nIn-Reply-To: &lt;CC7B116DD0454EBC88025E692EB40F96@JrnPC&gt;\r\nReferences: &lt;6F9A4BB1-5E69-4473-BC38-448E2E55DD59@...&gt;\n\t&lt;jcuu59+r3v6@...&gt;\n\t&lt;20111222142334.b23106de.eric@...&gt;\n\t&lt;CC7B116DD0454EBC88025E692EB40F96@JrnPC&gt;\r\nOrganization: Bison Systems Corporation\r\nX-Mailer: Sylpheed 3.1.1 (GTK+ 2.10.14; i686-pc-mingw32)\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Eric J. Bowman&quot; &lt;eric@...&gt;\r\nSubject: Re: [rest-discuss] Re: REST is not about domain models\r\nX-Yahoo-Group-Post: member; u=266460716\r\n\r\nJørn Wildt wrote:\n&gt; \n&gt; So application/xml could be just as good as text/html since it\n&gt; doesn&#39;t expose the domain vocabulary at the protocol layer? Let me\n&gt; answer that question myself: yes, but there is something missing - in\n&gt; HTML you get hypermedia semantics (links, forms) for free whereas in\n&gt; XML you have to reinvent it for every vocabulary.\n&gt; \n\nWell, yeah, there&#39;s that.\n\n&gt;\n&gt; So the dilema is: By leveraging HTML you get full hypermedia\n&gt; semantics but have to embed domain data in it using tricks like RDFa.\n&gt; On the other hand, by using plain XML you have a straight forward way\n&gt; to encode domain data but have no predefined hypermedia semantics.\n&gt; Right?\n&gt; \n\nMe in a nutshell, is if an m2m process is dealing with data which\namounts to a purchase order, why not make its interface *look* like a\npurchase order?  The extra overhead is rendered moot in REST if you&#39;re\nusing compression, caching, and a progressively-renderable media type.\nDon&#39;t un-solve the problem of network latency when transferring data\nfrom point A to point B for the sake of saving a few bytes, it&#39;s a\nfalse economy with cumulative consequences over the long term.\n\nBy my definition, hypertext semantics doesn&#39;t just apply to ‌linking and\nforms, but to semantic structure.  IOW, hypertext includes not just\nmaking an abbreviation a link to a definition, but &lt;abbr title=\n&#39;etcetera&#39;&gt;etc.&lt;/abbr&gt; as well.  More importantly, various list markup\nfor describing lists of whatever, plus table markup for describing\ntabular data; and the ability to nest these within one another, allows\nthe structure of the object interface to convey the relationship between\nlinked/embedded objects even if those objects have complex structures.\n\nWhat I&#39;m saying is, the structure of a purchase-order object is tabular,\nso its interface may be modeled as a &lt;table&gt;.  This &lt;table&gt; can be\nmanipulated via XForms and PUT in whole, or the &lt;table&gt; can contain a\n&lt;form&gt; or two to POST partial data.  Following the accessibility\nguidelines makes such documents both human and machine readable.  In\nthe m2m case, there&#39;s more work to do.  If this work builds on human-\nreadable code, there&#39;s no need to then go back and make an m2m format\nhuman-readable and accessible so it can be understood by those charged\nwith maintaining or interoperating with it.  Or worry about making it\nstream processable.\n\nI can infer the meaning of a purchase order presented as a table easily\nenough, column B x column C = column D while the sum of column D is the\ntotal cost.  Describing this to a machine user is the challenge, but\nthere&#39;s an ontology for that -- which applies to application/xml too.\nThe difference is that the same data structure presented as semantic\nHTML is readily apparent to anyone who needs to understand that data\nstructure (for interoperability or maintenance), plus its progressive\nrendering rules are well-known so it&#39;s stream processable.  Not to\nmention browser-based test/debug.\n\nI don&#39;t have to learn some new, undocumented media type by reverse-\nengineering a system&#39;s functionality.  In 20 years, if I&#39;m reverse-\nengineering a system written in obscured code in a dead language, the\njob is much easier if I can understand the data format just by looking\nat it.  HTML is a great language not just for presenting a purchase-\norder interface, but also for inlining the documentation for that\ninterface within the data-exchange format.  Interoperability is easier\nif external organizations don&#39;t even need to know about your internal\nobjects; they&#39;re free to come up with their own provided they comply\nwith your API.  You get to change your objects that way, too.  None of\nthis is possible when data formats are object serializations rather\nthan object interfaces.\n\nHypertext also includes vector-based images, or in HTML the ability to\nembed an image, where the domain-specific definition of the image has a\nspecific meaning (using a GIF as an array).  Anyway, my point is that\nthere&#39;s an awful lot of meaning which can be conveyed by the structure\nof the markup, instead of by overloading link relations or any RDF\nimplementation (embedded/RDFa or linked, or microdata).  Such meaning is\nstandardized, how you&#39;re using it is what you document about your API.\nYou can usually do this in-line, for human and machine users.\n\nHTML wrapped with Atom may be used to define most REST APIs I can think\nof, and if I go that route, many of the benefits of REST immediately\naccrue.  Ubiquitous media types provide stream-processable, massively-\ncacheable, widely-interoperable, long-term-stable data modeling for\nobject interfaces.  Why _wouldn&#39;t_ I want all that, from the start,\noff-the-shelf, re-usable from one project to the next -- absolutely\nfree?  Creating new media types seems like work, I prefer to REST...\n\n-Eric\n\n"}}